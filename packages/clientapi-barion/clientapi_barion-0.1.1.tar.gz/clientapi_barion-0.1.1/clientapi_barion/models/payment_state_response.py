# coding: utf-8

"""
    Barion API

    Integrate with ease and get unbeatable fees and data that helps you grow your business.

    The version of the OpenAPI document: 0.1.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from clientapi_barion.models.detailed_payment_transaction import DetailedPaymentTransaction
from clientapi_barion.models.funding_information import FundingInformation
from typing import Optional, Set
from typing_extensions import Self

class PaymentStateResponse(BaseModel):
    """
    PaymentStateResponse
    """ # noqa: E501
    payment_id: Optional[StrictStr] = Field(default=None, description="The identifier of the payment in the Barion system.", alias="PaymentId")
    payment_request_id: Optional[StrictStr] = Field(default=None, description="The identifier of the payment in the shop's system.", alias="PaymentRequestId")
    posid: Optional[StrictStr] = Field(default=None, description="The public identifier of the shop that created the payment.", alias="POSId")
    pos_name: Optional[StrictStr] = Field(default=None, description="The name of the shop that created the payment.", alias="POSName")
    pos_owner_email: Optional[StrictStr] = Field(default=None, description="The e-mail address of the owner of the shop that created the payment.", alias="POSOwnerEmail")
    pos_owner_country: Optional[StrictStr] = Field(default=None, description="ISO2 country code of the owner of the shop that created the payment.", alias="POSOwnerCountry")
    status: Optional[StrictStr] = Field(default=None, description="The status of the payment in the Barion system.", alias="Status")
    payment_type: Optional[StrictStr] = Field(default=None, description="The type of the payment.", alias="PaymentType")
    allowed_funding_sources: Optional[List[StrictStr]] = Field(default=None, description="The allowed funding sources that were defined when creating the payment. **⚠️ Note ⚠️:** Barion's documentation is contradictory, as it refers to the bankcard as a `Card` in some places and as a `BankCard` in others, and does not mention it in others. Therefore we do not use `FundingResource` here.", alias="AllowedFundingSources")
    funding_source: Optional[StrictStr] = Field(default=None, description="The funding source that was used to complete the payment. **⚠️ Note ⚠️:** Barion's documentation is contradictory as it should be of the `FundingSource` type.", alias="FundingSource")
    funding_information: Optional[FundingInformation] = Field(default=None, description="Detailed information about the funding source that was used to complete the payment.", alias="FundingInformation")
    recurrence_type: Optional[StrictStr] = Field(default=None, description="This enum indicates the type of recurrence that the payment represents.", alias="RecurrenceType")
    trace_id: Optional[StrictStr] = Field(default=None, description="The Trace Id that identifies that recurring scenario.", alias="TraceId")
    guest_checkout: Optional[StrictBool] = Field(default=None, description="Indicates whether the payment allows guest checkout.", alias="GuestCheckout")
    created_at: Optional[datetime] = Field(default=None, description="The locale-specific payment creation timestamp.", alias="CreatedAt")
    completed_at: Optional[datetime] = Field(default=None, description="The locale-specific payment completion timestamp. If the payment is not yet completed, this is empty.", alias="CompletedAt")
    valid_until: Optional[datetime] = Field(default=None, description="The payment must be completed before this locale-specific payment expiration timestamp.", alias="ValidUntil")
    reserved_until: Optional[datetime] = Field(default=None, description="If the payment is a reservation, the shop's owner has until this locale-specific expiration timestamp to finish it. If the payment isn't a reservation, this is empty.", alias="ReservedUntil")
    delayed_capture_until: Optional[datetime] = Field(default=None, description="If the payment is a delayed capture, the shop owner has until this locale-specific expiration timestamp to capture it. If the payment isn't a delayed capture, this is empty.", alias="DelayedCaptureUntil")
    transactions: Optional[List[DetailedPaymentTransaction]] = Field(default=None, alias="Transactions")
    total: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The total amount of the payment at the time of the request to the endpoint.", alias="Total")
    currency: Optional[Annotated[str, Field(min_length=3, strict=True, max_length=3)]] = Field(default=None, description="The currency of the payment. Must be supplied in ISO 4217 format. This affects all transactions included in the payment; it is not possible to define multiple transactions in different currencies.", alias="Currency")
    suggested_locale: Optional[StrictStr] = Field(default=None, description="Indicates the language that the Barion Smart Gateway should be displayed to the payer.", alias="SuggestedLocale")
    fraud_risk_score: Optional[StrictInt] = Field(default=None, description="A risk score computed by the anti-fraud analysis, ranging from 0 (completely legit) to 100 (certain fraud).", alias="FraudRiskScore")
    callback_url: Optional[StrictStr] = Field(default=None, description="The URL (including the payment identifier) where the Barion system will send (or has already sent) a request to whenever there is a change in the state of the payment.", alias="CallbackUrl")
    redirect_url: Optional[StrictStr] = Field(default=None, description="The URL (including the payment identifier) where the payer gets (or has already got) redirected to after the payment is, or was completed, or cancelled.", alias="RedirectUrl")
    payment_method: Optional[StrictStr] = Field(default=None, description="Enumerates the completion method of a payment transaction. ", alias="PaymentMethod")
    __properties: ClassVar[List[str]] = ["PaymentId", "PaymentRequestId", "POSId", "POSName", "POSOwnerEmail", "POSOwnerCountry", "Status", "PaymentType", "AllowedFundingSources", "FundingSource", "FundingInformation", "RecurrenceType", "TraceId", "GuestCheckout", "CreatedAt", "CompletedAt", "ValidUntil", "ReservedUntil", "DelayedCaptureUntil", "Transactions", "Total", "Currency", "SuggestedLocale", "FraudRiskScore", "CallbackUrl", "RedirectUrl", "PaymentMethod"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentStateResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of funding_information
        if self.funding_information:
            _dict['FundingInformation'] = self.funding_information.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in transactions (list)
        _items = []
        if self.transactions:
            for _item_transactions in self.transactions:
                if _item_transactions:
                    _items.append(_item_transactions.to_dict())
            _dict['Transactions'] = _items
        # set to None if payment_type (nullable) is None
        # and model_fields_set contains the field
        if self.payment_type is None and "payment_type" in self.model_fields_set:
            _dict['PaymentType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentStateResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "PaymentId": obj.get("PaymentId"),
            "PaymentRequestId": obj.get("PaymentRequestId"),
            "POSId": obj.get("POSId"),
            "POSName": obj.get("POSName"),
            "POSOwnerEmail": obj.get("POSOwnerEmail"),
            "POSOwnerCountry": obj.get("POSOwnerCountry"),
            "Status": obj.get("Status"),
            "PaymentType": obj.get("PaymentType"),
            "AllowedFundingSources": obj.get("AllowedFundingSources"),
            "FundingSource": obj.get("FundingSource"),
            "FundingInformation": FundingInformation.from_dict(obj["FundingInformation"]) if obj.get("FundingInformation") is not None else None,
            "RecurrenceType": obj.get("RecurrenceType"),
            "TraceId": obj.get("TraceId"),
            "GuestCheckout": obj.get("GuestCheckout"),
            "CreatedAt": obj.get("CreatedAt"),
            "CompletedAt": obj.get("CompletedAt"),
            "ValidUntil": obj.get("ValidUntil"),
            "ReservedUntil": obj.get("ReservedUntil"),
            "DelayedCaptureUntil": obj.get("DelayedCaptureUntil"),
            "Transactions": [DetailedPaymentTransaction.from_dict(_item) for _item in obj["Transactions"]] if obj.get("Transactions") is not None else None,
            "Total": obj.get("Total"),
            "Currency": obj.get("Currency"),
            "SuggestedLocale": obj.get("SuggestedLocale"),
            "FraudRiskScore": obj.get("FraudRiskScore"),
            "CallbackUrl": obj.get("CallbackUrl"),
            "RedirectUrl": obj.get("RedirectUrl"),
            "PaymentMethod": obj.get("PaymentMethod")
        })
        return _obj


