# coding: utf-8

"""
    Barion API

    Integrate with ease and get unbeatable fees and data that helps you grow your business.

    The version of the OpenAPI document: 0.1.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from clientapi_barion.models.billing_address import BillingAddress
from clientapi_barion.models.payer_account_information import PayerAccountInformation
from clientapi_barion.models.payment_transaction import PaymentTransaction
from clientapi_barion.models.payment_type import PaymentType
from clientapi_barion.models.purchase_information import PurchaseInformation
from clientapi_barion.models.shipping_address import ShippingAddress
from typing import Optional, Set
from typing_extensions import Self

class PaymentStartRequestWithGoogleToken(BaseModel):
    """
    PaymentStartRequestWithGoogleToken
    """ # noqa: E501
    payer_email_address: Annotated[str, Field(strict=True, max_length=256)] = Field(description="The e-mail address of the Google Pay user. This is provided by Google.", alias="PayerEmailAddress")
    google_pay_token: StrictStr = Field(description="The Google Pay token. The encrypted Google Pay token that contains the card information.", alias="GooglePayToken")
    payment_type: Optional[StrictStr] = Field(description="The type of payment, which can be either immediate or a money reservation. Reservation means that the shop has a time window to finish the payment (even though the money transaction still takes place immediately). Reservation amounts can be modified during this time window unless the new amount is lower than the original.", alias="PaymentType")
    reservation_period: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Only makes sense at reservation payments. This is the time window that allows the shop to finish (finalize) the payment. If this does not happen within the time window, the system refunds the payment amount to the payer.", alias="ReservationPeriod")
    delayed_capture_period: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="This is the time window that allows the shop to complete (finalize) the payment. If this does not happen within the time window, the system releases the payment amount.", alias="DelayedCapturePeriod")
    payment_window: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Time window for the payment to be completed. The payer must execute the payment before this elapses, or else the payment will expire and can no longer be completed.", alias="PaymentWindow")
    guest_check_out: StrictBool = Field(description="Flag indicating whether the payment can be completed without a registered Barion wallet. Guest checkout can only be done with bank cards, and the payer must supply a valid e-mail address - this is necessary for fraud control.", alias="GuestCheckOut")
    initiate_recurrence: Optional[StrictBool] = Field(default=None, description="This flag indicates that the shop would like to initialize a token payment. This means that the shop is authorized to charge the funding source of the payer in the future without redirecting her/him to the Barion Smart Gateway. It can be used for one-click and subscription payment scenarios.", alias="InitiateRecurrence")
    recurrence_id: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(default=None, description="A string used to identify a given token payment. Its purpose is determined by the value of the InitiateRecurrence property.", alias="RecurrenceId")
    funding_sources: List[StrictStr] = Field(description="An array of strings containing the allowed funding sources that can be used to complete the payment.", alias="FundingSources")
    payment_request_id: Annotated[str, Field(strict=True, max_length=100)] = Field(description="The unique identifier for the payment generated by the shop. This is so the shop can track its own payment identifiers. It is also useful for bookkeeping purposes since this shows up in the monthly account statement and the transaction history export, making identification of payments easier for the shop.", alias="PaymentRequestId")
    payer_hint: Optional[Annotated[str, Field(strict=True, max_length=256)]] = Field(default=None, description="Required for `3DS`. The shop can supply an e-mail address as a hint on who should complete the payment. This can be used if the shop is certain about that the payer has an active Barion wallet or the shop would like to help the guest payer with filling in the email field for her/him. If provided, the Barion Smart Gateway automatically fills out the e-mail address field in the Barion wallet login form and the guest payer form, speeding up the payment process.", alias="PayerHint")
    card_holder_name_hint: Optional[Annotated[str, Field(min_length=2, strict=True, max_length=45)]] = Field(default=None, description="Required for `3DS`. The shop can provide a hint for the customer's name on the card to speed up the payment flow. If a value is provided, the cardholder name input will be pre-filled with it and the customer can use the pre-filled value instead of typing it out on its own, which speeds up the payment process.", alias="CardHolderNameHint")
    recurrence_type: Optional[StrictStr] = Field(default=None, description="This enum indicates the type of recurrence that the payment represents.", alias="RecurrenceType")
    trace_id: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(default=None, description="Required for `3DS`, when executing token payments. Identifies the nature of the token payment.", alias="TraceId")
    redirect_url: Annotated[str, Field(strict=True, max_length=2000)] = Field(description="The URL where the payer should be redirected after the payment is completed or canceled. The payment identifier is added to the query string part of this URL in the `paymentId` parameter. If not provided, the system will use the redirect URL assigned to the shop that started the payment.", alias="RedirectUrl")
    callback_url: Optional[Annotated[str, Field(strict=True, max_length=2000)]] = Field(default=None, description="The URL where the Barion system sends a request whenever there is a change in the state of the payment. The payment identifier is added to the query string part of this URL in the `paymentId` parameter.", alias="CallbackUrl")
    transactions: List[PaymentTransaction] = Field(description="An array of payment transactions contained in the payment. A payment must contain at least one such transaction.", alias="Transactions")
    order_number: Optional[Annotated[str, Field(strict=True, max_length=100)]] = Field(default=None, description="The order number generated by the shop. This is to aid the shop in identifying a given payment in its own system. This also shows up in generated monthly account statements and transaction history exports, so it also helps with bookkeeping.", alias="OrderNumber")
    shipping_address: Optional[ShippingAddress] = Field(default=None, description="Required for `3DS`. The shipping address associated with the payment, if applicable. Providing this is recommended because it helps the automatic anti-fraud analysis get more accurate results.", alias="ShippingAddress")
    locale: Annotated[str, Field(strict=True, max_length=10)] = Field(description="This indicates in which language the Barion Smart Gateway should display for the payer upon redirect.", alias="Locale")
    currency: Annotated[str, Field(min_length=3, strict=True, max_length=3)] = Field(description="The currency of the payment. Must be supplied in ISO 4217 format. This affects all transactions included in the payment; it is not possible to define multiple transactions in different currencies.", alias="Currency")
    payer_phone_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(default=None, description="Required for `3DS`. The number must be sent in the expected format, without + sign or leading zero(s).", alias="PayerPhoneNumber")
    payer_work_phone_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(default=None, description="Required for `3DS`. The work phone of the payer. The number must be sent in the expected format, without + sign or leading zero(s).", alias="PayerWorkPhoneNumber")
    payer_home_number: Optional[Annotated[str, Field(strict=True, max_length=30)]] = Field(default=None, description="Required for `3DS`. The home phone number of the payer. The number must be sent in the expected format, without + sign or leading zero(s).", alias="PayerHomeNumber")
    billing_address: Optional[BillingAddress] = Field(default=None, description="Required for `3DS`. The billing address associated with the payment, if applicable.", alias="BillingAddress")
    payer_account_information: Optional[PayerAccountInformation] = Field(default=None, description="Required for `3DS`. Information about the account of the payer in the merchant's system.", alias="PayerAccountInformation")
    purchase_information: Optional[PurchaseInformation] = Field(default=None, description="Required for `3DS`. Information about current purchase.", alias="PurchaseInformation")
    challenge_preference: Optional[StrictStr] = Field(default=None, alias="ChallengePreference")
    __properties: ClassVar[List[str]] = ["PayerEmailAddress", "GooglePayToken", "PaymentType", "ReservationPeriod", "DelayedCapturePeriod", "PaymentWindow", "GuestCheckOut", "InitiateRecurrence", "RecurrenceId", "FundingSources", "PaymentRequestId", "PayerHint", "CardHolderNameHint", "RecurrenceType", "TraceId", "RedirectUrl", "CallbackUrl", "Transactions", "OrderNumber", "ShippingAddress", "Locale", "Currency", "PayerPhoneNumber", "PayerWorkPhoneNumber", "PayerHomeNumber", "BillingAddress", "PayerAccountInformation", "PurchaseInformation", "ChallengePreference"]

    @field_validator('reservation_period')
    def reservation_period_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(\d{1,2}\.\d{2}:\d{2}:\d{2})$", value):
            raise ValueError(r"must validate the regular expression /^(\d{1,2}\.\d{2}:\d{2}:\d{2})$/")
        return value

    @field_validator('delayed_capture_period')
    def delayed_capture_period_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(\d{1,2}\.\d{2}:\d{2}:\d{2})$", value):
            raise ValueError(r"must validate the regular expression /^(\d{1,2}\.\d{2}:\d{2}:\d{2})$/")
        return value

    @field_validator('payment_window')
    def payment_window_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^(\d{1,2}\.\d{2}:\d{2}:\d{2})$", value):
            raise ValueError(r"must validate the regular expression /^(\d{1,2}\.\d{2}:\d{2}:\d{2})$/")
        return value

    @field_validator('payer_phone_number')
    def payer_phone_number_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('payer_work_phone_number')
    def payer_work_phone_number_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    @field_validator('payer_home_number')
    def payer_home_number_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^\d+$", value):
            raise ValueError(r"must validate the regular expression /^\d+$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentStartRequestWithGoogleToken from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in transactions (list)
        _items = []
        if self.transactions:
            for _item_transactions in self.transactions:
                if _item_transactions:
                    _items.append(_item_transactions.to_dict())
            _dict['Transactions'] = _items
        # override the default output from pydantic by calling `to_dict()` of shipping_address
        if self.shipping_address:
            _dict['ShippingAddress'] = self.shipping_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of billing_address
        if self.billing_address:
            _dict['BillingAddress'] = self.billing_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payer_account_information
        if self.payer_account_information:
            _dict['PayerAccountInformation'] = self.payer_account_information.to_dict()
        # override the default output from pydantic by calling `to_dict()` of purchase_information
        if self.purchase_information:
            _dict['PurchaseInformation'] = self.purchase_information.to_dict()
        # set to None if payment_type (nullable) is None
        # and model_fields_set contains the field
        if self.payment_type is None and "payment_type" in self.model_fields_set:
            _dict['PaymentType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentStartRequestWithGoogleToken from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "PayerEmailAddress": obj.get("PayerEmailAddress"),
            "GooglePayToken": obj.get("GooglePayToken"),
            "PaymentType": obj.get("PaymentType"),
            "ReservationPeriod": obj.get("ReservationPeriod"),
            "DelayedCapturePeriod": obj.get("DelayedCapturePeriod"),
            "PaymentWindow": obj.get("PaymentWindow"),
            "GuestCheckOut": obj.get("GuestCheckOut"),
            "InitiateRecurrence": obj.get("InitiateRecurrence"),
            "RecurrenceId": obj.get("RecurrenceId"),
            "FundingSources": obj.get("FundingSources"),
            "PaymentRequestId": obj.get("PaymentRequestId"),
            "PayerHint": obj.get("PayerHint"),
            "CardHolderNameHint": obj.get("CardHolderNameHint"),
            "RecurrenceType": obj.get("RecurrenceType"),
            "TraceId": obj.get("TraceId"),
            "RedirectUrl": obj.get("RedirectUrl"),
            "CallbackUrl": obj.get("CallbackUrl"),
            "Transactions": [PaymentTransaction.from_dict(_item) for _item in obj["Transactions"]] if obj.get("Transactions") is not None else None,
            "OrderNumber": obj.get("OrderNumber"),
            "ShippingAddress": ShippingAddress.from_dict(obj["ShippingAddress"]) if obj.get("ShippingAddress") is not None else None,
            "Locale": obj.get("Locale"),
            "Currency": obj.get("Currency"),
            "PayerPhoneNumber": obj.get("PayerPhoneNumber"),
            "PayerWorkPhoneNumber": obj.get("PayerWorkPhoneNumber"),
            "PayerHomeNumber": obj.get("PayerHomeNumber"),
            "BillingAddress": BillingAddress.from_dict(obj["BillingAddress"]) if obj.get("BillingAddress") is not None else None,
            "PayerAccountInformation": PayerAccountInformation.from_dict(obj["PayerAccountInformation"]) if obj.get("PayerAccountInformation") is not None else None,
            "PurchaseInformation": PurchaseInformation.from_dict(obj["PurchaseInformation"]) if obj.get("PurchaseInformation") is not None else None,
            "ChallengePreference": obj.get("ChallengePreference")
        })
        return _obj


