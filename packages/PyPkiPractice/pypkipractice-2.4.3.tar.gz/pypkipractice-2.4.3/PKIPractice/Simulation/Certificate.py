"""
Module used for defining the certificate class and it's functionality.
"""

import random
import string
from copy import deepcopy
from datetime import datetime, timedelta
from typing import Union
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives.asymmetric.padding import PSS, MGF1
from cryptography.hazmat.primitives import serialization
from cryptography import x509
from cryptography.exceptions import UnsupportedAlgorithm
from .SimUtils import hash_info, get_hash_func

import sys
from os.path import abspath, dirname, join
script_dir = dirname(abspath(__file__))
if script_dir in ['PKI_Practice', 'PKI Practice', 'app']:
    sys.path.append(abspath(script_dir))
elif script_dir == 'PKIPractice':
    sys.path.append(abspath(join(script_dir, '..')))
else:
    sys.path.append(abspath(join(script_dir, '../..')))

from PKIPractice.Utilities.DataclassUtils import *


class PKICertificate:
    """
    The PKICertificate class represents a given certificate that can be sent and held by holders.

    Attributes:
        name (str): The name of the certificate, derived from the `subject_name` parameter.
        subject_info (SUBJECT_INFO): Information about the subject, including common name, country,
            state, organization, and contact details.
        issuer_info (ISSUER_INFO): Information about the certificate issuer, such as common name,
            country, state, and organization details.
        serial_number (str): A unique 16-character hexadecimal string generated for the certificate.
        x509_version (int): The X.509 version of the certificate, defaulting to version 3.
        signature_alg (str): The signature algorithm used for signing the certificate, derived from
            `subject_env_info.sig_hash`.
        valid_start (datetime): The datetime when the certificate becomes valid, initialized to the
            current time.
        valid_end (Union[datetime, None]): The datetime when the certificate expires. If
            `subject_env_info.cert_valid_dur` is `'none'`, this is `None`. Otherwise, it is computed
            based on the duration string (formatted as `HH:MM:SS`).
        encryption_alg (dict): Details of the encryption algorithm used in the certificate, derived
            from `subject_env_info.encrypt_alg`.
        subject_pub_key (Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey]): The subject's public key,
            which can be either an RSA or elliptic curve public key.
        signature (bytes): The certificate's digital signature, generated by hashing the certificate
            content using the specified `signature_alg`.
        issuer_chain: (list): A list of certificates that make up the chain of certificate authority.
        crypto_cert (x509.Certificate): An X.509 certificate object just because.
        error (Union[str, None]): An error message if the x509 certificate could not be generated, otherwise `None`.

    Methods:
        hash_content() -> str:
            Returns the core attributes of the certificate as a string.
    """
    def __init__(self, name: str, subject_info: HOLDER_INFO, issuer_info: HOLDER_INFO,
                 subject_env_info: HOLDER_ENV_INFO, subject_pub_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey],
                 issuer_priv_key: Union[rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey],
                 issuer_chain: Union[list, None] = None):

        # Name
        self.name = name

        # Subject info
        self.subject_info: SUBJECT_INFO = SUBJECT_INFO(
            common_name=subject_info.common_name, country=subject_info.country, state=subject_info.state,
            local=subject_info.local, org=subject_info.org, org_unit=subject_info.org_unit, email=subject_info.email,
            url=subject_info.url
        )

        # Issuer info
        self.issuer_info: ISSUER_INFO = ISSUER_INFO(
            common_name=issuer_info.common_name, country=issuer_info.country, state=issuer_info.state,
            local=issuer_info.local, org=issuer_info.org, url=issuer_info.url
        )

        # Certificate information
        self.serial_number: str = ''.join(random.choices(string.hexdigits[:16], k=16)).upper()
        self.x509_version: int = 3
        self.signature_alg: str = subject_env_info.sig_hash

        # Time information
        self.valid_start: datetime = datetime.now()

        if subject_env_info.cert_valid_dur == timedelta.max:
            self.valid_end = datetime.max
        else:
            self.valid_end: datetime = self.valid_start + subject_env_info.cert_valid_dur

        # Asymmetric Key information
        self.encryption_alg: dict = subject_env_info.encrypt_alg
        self.subject_pub_key: Union[rsa.RSAPublicKey, ec.EllipticCurvePublicKey] = subject_pub_key

        # Signature of all information
        hashed_content: str = hash_info(self.hash_content, self.signature_alg)
        if isinstance(issuer_priv_key, rsa.RSAPrivateKey):
            self.signature: bytes = issuer_priv_key.sign(
                hashed_content.encode('utf-8'), PSS(MGF1(get_hash_func(subject_env_info.sig_hash)), PSS.DIGEST_LENGTH),
                get_hash_func(subject_env_info.sig_hash)
            )
        elif isinstance(issuer_priv_key, ec.EllipticCurvePrivateKey):
            self.signature: bytes = issuer_priv_key.sign(
                hashed_content.encode('utf-8'), ec.ECDSA(get_hash_func(subject_env_info.sig_hash))
            )

        # TODO: Update docuscript
        # Create an issuer chain and add self here
        if issuer_chain is None:
            self.issuer_chain = [self]
        else:
            self.issuer_chain = deepcopy(issuer_chain).append(self)

        # Create an actual certificate object here for the heck of it
        subject = x509.Name([
            x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, subject_info.common_name),
            x509.NameAttribute(x509.oid.NameOID.COUNTRY_NAME, subject_info.country),
            x509.NameAttribute(x509.oid.NameOID.STATE_OR_PROVINCE_NAME, subject_info.state),
            x509.NameAttribute(x509.oid.NameOID.LOCALITY_NAME, subject_info.local),
            x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, subject_info.org),
            x509.NameAttribute(x509.oid.NameOID.ORGANIZATIONAL_UNIT_NAME, subject_info.org_unit),
            x509.NameAttribute(x509.oid.NameOID.EMAIL_ADDRESS, subject_info.email),
        ])

        issuer = x509.Name([
            x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, issuer_info.common_name),
            x509.NameAttribute(x509.oid.NameOID.COUNTRY_NAME, issuer_info.country),
            x509.NameAttribute(x509.oid.NameOID.STATE_OR_PROVINCE_NAME, issuer_info.state),
            x509.NameAttribute(x509.oid.NameOID.LOCALITY_NAME, issuer_info.local),
            x509.NameAttribute(x509.oid.NameOID.ORGANIZATION_NAME, issuer_info.org),
            x509.NameAttribute(x509.oid.NameOID.ORGANIZATIONAL_UNIT_NAME, issuer_info.org_unit),
            x509.NameAttribute(x509.oid.NameOID.EMAIL_ADDRESS, issuer_info.email),
        ])

        self.crypto_cert = x509.CertificateBuilder()
        self.crypto_cert = self.crypto_cert.subject_name(subject)
        self.crypto_cert = self.crypto_cert.issuer_name(issuer)
        self.crypto_cert = self.crypto_cert.public_key(self.subject_pub_key)
        self.crypto_cert = self.crypto_cert.serial_number(int(self.serial_number, 16))
        self.crypto_cert = self.crypto_cert.not_valid_before(self.valid_start)
        self.crypto_cert = self.crypto_cert.not_valid_after(self.valid_end)
        self.crypto_cert = self.crypto_cert.add_extension(
            x509.SubjectAlternativeName([x509.DNSName(subject_info.url)]),
            critical=False
        )
        self.crypto_cert = self.crypto_cert.add_extension(
            x509.SubjectKeyIdentifier.from_public_key(self.subject_pub_key),
            critical=False
        )
        if issuer_chain is not None:
            self.crypto_cert = self.crypto_cert.add_extension(
                x509.AuthorityKeyIdentifier.from_issuer_public_key(self.issuer_chain[-2].subject_pub_key),
                critical=False
            )

        try:
            self.crypto_cert = self.crypto_cert.sign(issuer_priv_key, get_hash_func(subject_env_info.sig_hash))
            self.error = None
        except UnsupportedAlgorithm as e:
            print(f'Could not sign the certificate with {subject_env_info.sig_hash}. Defaulting to SHA256...')
            self.crypto_cert = self.crypto_cert.sign(issuer_priv_key, get_hash_func('sha256'))
            self.error = e

    @property
    def hash_content(self) -> str:
        """
        Returns the core attributes of the certificate as a hashable string.

        Returns:
            str: The core attributes turned into string and lined up.
        """

        subject_pub_pem = self.subject_pub_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        return f'{self.name}{self.subject_info}{self.issuer_info}' \
               f'{self.serial_number}{self.x509_version}{self.signature_alg}' \
               f'{self.valid_start}{self.valid_end}{self.encryption_alg}{subject_pub_pem}'
