# autogenerated by ssc-gen DO NOT_EDIT
"""universal parser for kodik.info/serial entrypoint"""

from __future__ import annotations
import re
import json
from typing import List, Dict, TypedDict, Union
import sys

if sys.version_info >= (3, 10):
    from types import NoneType
else:
    NoneType = type(None)

from parsel import Selector, SelectorList
from parsel.selector import _SelectorType  # noqa

J_UrlParams = TypedDict(
    "J_UrlParams",
    {
        "d": str,
        "d_sign": str,
        "pd": str,
        "pd_sign": str,
        "ref": str,
        "ref_sign": str,
        "advert_debug": bool,
        "min_age": int,
        "first_url": bool,
    },
)
T_KodikAPIPayload = TypedDict(
    "T_KodikAPIPayload",
    {
        "d": str,
        "d_sign": str,
        "pd": str,
        "pd_sign": str,
        "ref": str,
        "ref_sign": str,
        "type": str,
        "hash": str,
        "id": str,
    },
)
T_SeasonBox = TypedDict(
    "T_SeasonBox",
    {
        "value": str,
        "data_serial_id": str,
        "data_serial_hash": str,
        "data_title": str,
        "data_translation_title": str,
    },
)
T_SeriesBox = TypedDict(
    "T_SeriesBox",
    {
        "value": str,
        "data_id": str,
        "data_hash": str,
        "data_title": str,
    },
)
T_SeriesOptionItem = TypedDict(
    "T_SeriesOptionItem",
    {
        "value": str,
        "data_id": str,
        "data_hash": str,
        "data_title": str,
    },
)
T_SeriesOptions = Dict[str, List[T_SeriesOptionItem]]
T_TranslationsBox = TypedDict(
    "T_TranslationsBox",
    {
        "value": str,
        "data_id": str,
        "data_translation_type": str,
        "data_media_id": str,
        "data_media_hash": str,
        "data_media_type": str,
        "data_title": str,
        "data_episode_count": str,
    },
)
T_MainKodikMin = TypedDict(
    "T_MainKodikMin",
    {
        "url_params": J_UrlParams,
        "api_payload": T_KodikAPIPayload,
        "player_js_path": str,
    },
)
T_MainKodikSerialPage = TypedDict(
    "T_MainKodikSerialPage",
    {
        "thumbnails": List[str],
        "season_box": List[T_SeasonBox],
        "series_box": List[T_SeriesBox],
        "series_options": T_SeriesOptions,
        "translations_box": List[T_TranslationsBox],
        "url_params": J_UrlParams,
        "api_payload": T_KodikAPIPayload,
        "player_js_path": str,
    },
)
T_MovieTranslationBox = TypedDict(
    "T_MovieTranslationBox",
    {
        "value": str,
        "data_id": str,
        "data_translation_type": str,
        "data_media_id": str,
        "data_media_hash": str,
        "data_media_type": str,
        "data_title": str,
    },
)
T_MainKodikVideoPage = TypedDict(
    "T_MainKodikVideoPage",
    {
        "thumbnails": List[str],
        "translation_box": List[T_MovieTranslationBox],
        "url_params": J_UrlParams,
        "api_payload": T_KodikAPIPayload,
        "player_js_path": str,
    },
)
T_MainKodikAPIPath = TypedDict(
    "T_MainKodikAPIPath",
    {
        "api_path": str,
    },
)


class KodikAPIPayload:
    """payload for Kodik API request

    {
        "d": "String",
        "d_sign": "String",
        "pd": "String",
        "pd_sign": "String",
        "ref": "String",
        "ref_sign": "String",
        "type": "String",
        "hash": "String",
        "id": "String"
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_d(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*domain\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_d_sign(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*d_sign\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_pd(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*pd\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_pd_sign(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*pd_sign\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_ref(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*ref\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_ref_sign(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("var\s*ref_sign\s+=\s+['\"](.*?)['\"];", value1)[1]

    def _parse_type(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("videoInfo\.type\s*=\s*['\"](.*?)['\"];", value1)[1]

    def _parse_hash(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("videoInfo\.hash\s*=\s*['\"](.*?)['\"];", value1)[1]

    def _parse_id(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("videoInfo\.id\s*=\s*['\"](.*?)['\"];", value1)[1]

    def parse(self) -> T_KodikAPIPayload:
        return {
            "d": self._parse_d(self._doc),
            "d_sign": self._parse_d_sign(self._doc),
            "pd": self._parse_pd(self._doc),
            "pd_sign": self._parse_pd_sign(self._doc),
            "ref": self._parse_ref(self._doc),
            "ref_sign": self._parse_ref_sign(self._doc),
            "type": self._parse_type(self._doc),
            "hash": self._parse_hash(self._doc),
            "id": self._parse_id(self._doc),
        }


class SeasonBox:
    """represent season select

    [
        {
            "value": "String",
            "data_serial_id": "String",
            "data_serial_hash": "String",
            "data_title": "String",
            "data_translation_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("option")

    def _parse_value(self, value: Selector) -> str:
        return value.attrib["value"]

    def _parse_data_serial_id(self, value: Selector) -> str:
        return value.attrib["data-serial-id"]

    def _parse_data_serial_hash(self, value: Selector) -> str:
        return value.attrib["data-serial-hash"]

    def _parse_data_title(self, value: Selector) -> str:
        return value.attrib["data-title"]

    def _parse_data_translation_title(self, value: Selector) -> str:
        return value.attrib["data-translation-title"]

    def parse(self) -> List[T_SeasonBox]:
        return [
            {
                "value": self._parse_value(e),
                "data_serial_id": self._parse_data_serial_id(e),
                "data_serial_hash": self._parse_data_serial_hash(e),
                "data_title": self._parse_data_title(e),
                "data_translation_title": self._parse_data_translation_title(e),
            }
            for e in self._split_doc(self._doc)
        ]


class SeriesBox:
    """represent selected series in current page

    [
        {
            "value": "String",
            "data_id": "String",
            "data_hash": "String",
            "data_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("option")

    def _parse_value(self, value: Selector) -> str:
        return value.attrib["value"]

    def _parse_data_id(self, value: Selector) -> str:
        return value.attrib["data-id"]

    def _parse_data_hash(self, value: Selector) -> str:
        return value.attrib["data-hash"]

    def _parse_data_title(self, value: Selector) -> str:
        return value.attrib["data-title"]

    def parse(self) -> List[T_SeriesBox]:
        return [
            {
                "value": self._parse_value(e),
                "data_id": self._parse_data_id(e),
                "data_hash": self._parse_data_hash(e),
                "data_title": self._parse_data_title(e),
            }
            for e in self._split_doc(self._doc)
        ]


class SeriesOptionItem:
    """

    [
        {
            "value": "String",
            "data_id": "String",
            "data_hash": "String",
            "data_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("option")

    def _parse_value(self, value: Selector) -> str:
        return value.attrib["value"]

    def _parse_data_id(self, value: Selector) -> str:
        return value.attrib["data-id"]

    def _parse_data_hash(self, value: Selector) -> str:
        return value.attrib["data-hash"]

    def _parse_data_title(self, value: Selector) -> str:
        return value.attrib["data-title"]

    def parse(self) -> List[T_SeriesOptionItem]:
        return [
            {
                "value": self._parse_value(e),
                "data_id": self._parse_data_id(e),
                "data_hash": self._parse_data_hash(e),
                "data_title": self._parse_data_title(e),
            }
            for e in self._split_doc(self._doc)
        ]


class SeriesOptions:
    """

    {
        "<K>": [
            {
                "value": "String",
                "data_id": "String",
                "data_hash": "String",
                "data_title": "String"
            },
            "..."
        ],
        "<KN>": "..."
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("div")

    def _parse_key(self, value: Selector) -> str:
        return value.attrib["class"]

    def _parse_value(self, value: Selector) -> List[T_SeriesOptionItem]:
        return SeriesOptionItem(value).parse()

    def parse(self) -> T_SeriesOptions:
        return {self._parse_key(e): self._parse_value(e) for e in self._split_doc(self._doc)}


class TranslationsBox:
    """

    [
        {
            "value": "String",
            "data_id": "String",
            "data_translation_type": "String",
            "data_media_id": "String",
            "data_media_hash": "String",
            "data_media_type": "String",
            "data_title": "String",
            "data_episode_count": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("option")

    def _parse_value(self, value: Selector) -> str:
        return value.attrib["value"]

    def _parse_data_id(self, value: Selector) -> str:
        return value.attrib["data-id"]

    def _parse_data_translation_type(self, value: Selector) -> str:
        return value.attrib["data-translation-type"]

    def _parse_data_media_id(self, value: Selector) -> str:
        return value.attrib["data-media-id"]

    def _parse_data_media_hash(self, value: Selector) -> str:
        return value.attrib["data-media-hash"]

    def _parse_data_media_type(self, value: Selector) -> str:
        return value.attrib["data-media-type"]

    def _parse_data_title(self, value: Selector) -> str:
        return value.attrib["data-title"]

    def _parse_data_episode_count(self, value: Selector) -> str:
        value1 = value.attrib["data-episode-count"]
        return re.search("(\d+)$", value1)[1]

    def parse(self) -> List[T_TranslationsBox]:
        return [
            {
                "value": self._parse_value(e),
                "data_id": self._parse_data_id(e),
                "data_translation_type": self._parse_data_translation_type(e),
                "data_media_id": self._parse_data_media_id(e),
                "data_media_hash": self._parse_data_media_hash(e),
                "data_media_type": self._parse_data_media_type(e),
                "data_title": self._parse_data_title(e),
                "data_episode_count": self._parse_data_episode_count(e),
            }
            for e in self._split_doc(self._doc)
        ]


class MainKodikMin:
    """parser for extract only minimal data for next API reuqest

        for extract full detailed information use MainKodikSerialPage and MainKodikVideoPage

        USAGE:

            1. GET <kodik-page-player>
            2. add base_url to <player_js_path>
            3. extract API (<API_PATH>) path from javascript file (use MainKodikAPIPath)
            3.1 decode <API_PATH> path (base64 cipher)
            4. <api_payload> required extra constant keys
                - bad_user = (true or false)
                - cdn_is_working = true
                - info "{}"
            4.1 required headers:
                - origin="https://<NETLOC>" // player page
                - referer=<PLAYER_LINK> // FIRST URL player entrypoint
                - accept= "application/json, text/javascript, */*; q=0.01"
            4.2 POST <kodik-base-url> + /<API_PATH>
               data=<api_payload> (<JSON>) + headers
            5. extract urls from ['links'] key
            6. video urls encoded in ROT_13 + BASE64 ciphers

        EXAMPLE:

            - GET https://kodik.info/serial/64218/890744b309ec026d43742995d0d49cd7/720p?season=1&episode=1
            - GET https://aniqit.com/video/72755/dc966c03a7cb719dac577d8004a9b091/720p
            - GET https://kodik.info/seria/1133512/04d5f7824ba3563bd78e44a22451bb45/720p

         ISSUES:
            - kodik maybe have another netloc (e.g.: anivod)
            - 403 Forbidden if request sent not from CIS region
            - 404 DELETED: eg: https://kodik.info/seria/310427/09985563d891b56b1e9b01142ae11872/720p
            - 500 Internal server error: eg: https://kodik.info/seria/1051016/af405efc5e061f5ac344d4811de3bc16/720p ('Cyberpunk: Edgerunners' ep5 Anilibria dub)




    {
        "url_params": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "advert_debug": "Bool",
            "min_age": "Int",
            "first_url": "Bool"
        },
        "api_payload": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "type": "String",
            "hash": "String",
            "id": "String"
        },
        "player_js_path": "String"
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_url_params(self, value: Selector) -> J_UrlParams:
        value1 = value.get()
        value2 = re.search("var\\s*urlParams\\s*=\\s*['\\\"](\\{.*\\})['\\\"]", value1)[1]
        return json.loads(value2)

    def _parse_api_payload(self, value: Selector) -> T_KodikAPIPayload:
        return KodikAPIPayload(value).parse()

    def _parse_player_js_path(self, value: Selector) -> str:
        value1 = value.get()
        return re.search('<script\s*type="text/javascript"\s*src="(/assets/js/app\..*?)">', value1)[1]

    def parse(self) -> T_MainKodikMin:
        return {
            "url_params": self._parse_url_params(self._doc),
            "api_payload": self._parse_api_payload(self._doc),
            "player_js_path": self._parse_player_js_path(self._doc),
        }


class MainKodikSerialPage:
    """first extract data entrypoint for kodik.../serial/ entrypoint path

    {
        "thumbnails": "Array<String>",
        "season_box": [
            {
                "value": "String",
                "data_serial_id": "String",
                "data_serial_hash": "String",
                "data_title": "String",
                "data_translation_title": "String"
            },
            "..."
        ],
        "series_box": [
            {
                "value": "String",
                "data_id": "String",
                "data_hash": "String",
                "data_title": "String"
            },
            "..."
        ],
        "series_options": {
            "<K>": [
                {
                    "value": "String",
                    "data_id": "String",
                    "data_hash": "String",
                    "data_title": "String"
                },
                "..."
            ],
            "<KN>": "..."
        },
        "translations_box": [
            {
                "value": "String",
                "data_id": "String",
                "data_translation_type": "String",
                "data_media_id": "String",
                "data_media_hash": "String",
                "data_media_type": "String",
                "data_title": "String",
                "data_episode_count": "String"
            },
            "..."
        ],
        "url_params": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "advert_debug": "Bool",
            "min_age": "Int",
            "first_url": "Bool"
        },
        "api_payload": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "type": "String",
            "hash": "String",
            "id": "String"
        },
        "player_js_path": "String"
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_thumbnails(self, value: Selector) -> List[str]:
        value1 = value.get()
        value2 = re.search("var\\s*thumbnails\\s*=\\s*\\[(.*?)\\];", value1)[1]
        value3 = value2.replace('"', "")
        value4 = value3.split(",")
        value5 = [e.strip(" ") for e in value4]
        return [f"https:{e}" for e in value5 if e]

    def _parse_season_box(self, value: Selector) -> List[T_SeasonBox]:
        value1 = value.css(".serial-panel > .serial-seasons-box")
        return SeasonBox(value1).parse()

    def _parse_series_box(self, value: Selector) -> List[T_SeriesBox]:
        value1 = value.css(".serial-panel > .serial-series-box")
        return SeriesBox(value1).parse()

    def _parse_series_options(self, value: Selector) -> T_SeriesOptions:
        value1 = value.css(".serial-panel > .series-options")
        return SeriesOptions(value1).parse()

    def _parse_translations_box(self, value: Selector) -> List[T_TranslationsBox]:
        value1 = value.css(".serial-panel > .serial-translations-box")
        return TranslationsBox(value1).parse()

    def _parse_url_params(self, value: Selector) -> J_UrlParams:
        value1 = value.get()
        value2 = re.search("var\\s*urlParams\\s*=\\s*['\\\"](\\{.*\\})['\\\"]", value1)[1]
        return json.loads(value2)

    def _parse_api_payload(self, value: Selector) -> T_KodikAPIPayload:
        return KodikAPIPayload(value).parse()

    def _parse_player_js_path(self, value: Selector) -> str:
        value1 = value.get()
        return re.search('<script\s*type="text/javascript"\s*src="(/assets/js/app\..*?)">', value1)[1]

    def parse(self) -> T_MainKodikSerialPage:
        return {
            "thumbnails": self._parse_thumbnails(self._doc),
            "season_box": self._parse_season_box(self._doc),
            "series_box": self._parse_series_box(self._doc),
            "series_options": self._parse_series_options(self._doc),
            "translations_box": self._parse_translations_box(self._doc),
            "url_params": self._parse_url_params(self._doc),
            "api_payload": self._parse_api_payload(self._doc),
            "player_js_path": self._parse_player_js_path(self._doc),
        }


class MovieTranslationBox:
    """

    [
        {
            "value": "String",
            "data_id": "String",
            "data_translation_type": "String",
            "data_media_id": "String",
            "data_media_hash": "String",
            "data_media_type": "String",
            "data_title": "String"
        },
        "..."
    ]"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _split_doc(self, value: _SelectorType) -> SelectorList:
        return value.css("option")

    def _parse_value(self, value: Selector) -> str:
        return value.attrib["value"]

    def _parse_data_id(self, value: Selector) -> str:
        return value.attrib["data-id"]

    def _parse_data_translation_type(self, value: Selector) -> str:
        return value.attrib["data-translation-type"]

    def _parse_data_media_id(self, value: Selector) -> str:
        return value.attrib["data-media-id"]

    def _parse_data_media_hash(self, value: Selector) -> str:
        return value.attrib["data-media-hash"]

    def _parse_data_media_type(self, value: Selector) -> str:
        return value.attrib["data-media-type"]

    def _parse_data_title(self, value: Selector) -> str:
        return value.attrib["data-title"]

    def parse(self) -> List[T_MovieTranslationBox]:
        return [
            {
                "value": self._parse_value(e),
                "data_id": self._parse_data_id(e),
                "data_translation_type": self._parse_data_translation_type(e),
                "data_media_id": self._parse_data_media_id(e),
                "data_media_hash": self._parse_data_media_hash(e),
                "data_media_type": self._parse_data_media_type(e),
                "data_title": self._parse_data_title(e),
            }
            for e in self._split_doc(self._doc)
        ]


class MainKodikVideoPage:
    """first extract data entrypoint for kodik.../video/ entrypoint path

        required for extract videos via kodik API


    {
        "thumbnails": "Array<String>",
        "translation_box": [
            {
                "value": "String",
                "data_id": "String",
                "data_translation_type": "String",
                "data_media_id": "String",
                "data_media_hash": "String",
                "data_media_type": "String",
                "data_title": "String"
            },
            "..."
        ],
        "url_params": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "advert_debug": "Bool",
            "min_age": "Int",
            "first_url": "Bool"
        },
        "api_payload": {
            "d": "String",
            "d_sign": "String",
            "pd": "String",
            "pd_sign": "String",
            "ref": "String",
            "ref_sign": "String",
            "type": "String",
            "hash": "String",
            "id": "String"
        },
        "player_js_path": "String"
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_thumbnails(self, value: Selector) -> List[str]:
        value1 = value.get()
        value2 = re.search("var\\s*thumbnails\\s*=\\s*\\[(.*?)\\];", value1)[1]
        value3 = value2.replace('"', "")
        value4 = value3.split(",")
        value5 = [e.strip(" ") for e in value4]
        return [f"https:{e}" for e in value5 if e]

    def _parse_translation_box(self, value: Selector) -> List[T_MovieTranslationBox]:
        value1 = value.css(".movie-panel > .movie-translations-box")
        return MovieTranslationBox(value1).parse()

    def _parse_url_params(self, value: Selector) -> J_UrlParams:
        value1 = value.get()
        value2 = re.search("var\\s*urlParams\\s*=\\s*['\\\"](\\{.*\\})['\\\"]", value1)[1]
        return json.loads(value2)

    def _parse_api_payload(self, value: Selector) -> T_KodikAPIPayload:
        return KodikAPIPayload(value).parse()

    def _parse_player_js_path(self, value: Selector) -> str:
        value1 = value.get()
        return re.search('<script\s*type="text/javascript"\s*src="(/assets/js/app\..*?)">', value1)[1]

    def parse(self) -> T_MainKodikVideoPage:
        return {
            "thumbnails": self._parse_thumbnails(self._doc),
            "translation_box": self._parse_translation_box(self._doc),
            "url_params": self._parse_url_params(self._doc),
            "api_payload": self._parse_api_payload(self._doc),
            "player_js_path": self._parse_player_js_path(self._doc),
        }


class MainKodikAPIPath:
    """extract actual API path from kodik js script

        USAGE:

            GET MainKodikPage.player_js_path, MainKodikSerialPage.player_js_path

        EXAMPLE:

            - GET https://kodik.info/assets/js/app.serial.6721f2dd68501a625a518ea935006bd8f5cf5f4d037f2648a97a02dfd0fe5b85.js
            - GET https://aniqit.com/assets/js/app.player_single.3e2f9f0ae45d18b06cfd8b01181f85bab47fb9867cd1e73568c84dbe44ba7a44.js



    {
        "api_path": "String"
    }"""

    def __init__(self, document: Union[str, _SelectorType]) -> None:
        self._doc = Selector(document) if isinstance(document, str) else document

    def _parse_api_path(self, value: Selector) -> str:
        value1 = value.get()
        return re.search("\$\.ajax\([^>]+,url:\s*atob\([\"']([\w=]+)[\"']\)", value1)[1]

    def parse(self) -> T_MainKodikAPIPath:
        return {"api_path": self._parse_api_path(self._doc)}
