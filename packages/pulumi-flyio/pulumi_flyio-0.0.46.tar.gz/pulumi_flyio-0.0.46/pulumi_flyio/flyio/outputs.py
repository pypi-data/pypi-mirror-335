# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'CheckStatus',
    'FlyContainerConfig',
    'FlyContainerDependency',
    'FlyContainerHealthcheck',
    'FlyContainerMount',
    'FlyDNSConfig',
    'FlyDnsForwardRule',
    'FlyDnsOption',
    'FlyEnvFrom',
    'FlyExecHealthcheck',
    'FlyFile',
    'FlyHTTPHealthcheck',
    'FlyHTTPOptions',
    'FlyHTTPResponseOptions',
    'FlyMachineCheck',
    'FlyMachineConfig',
    'FlyMachineGuest',
    'FlyMachineHTTPHeader',
    'FlyMachineInit',
    'FlyMachineMetrics',
    'FlyMachineMount',
    'FlyMachinePort',
    'FlyMachineProcess',
    'FlyMachineRestart',
    'FlyMachineSecret',
    'FlyMachineService',
    'FlyMachineServiceConcurrency',
    'FlyProxyProtoOptions',
    'FlyStatic',
    'FlyStopConfig',
    'FlyTCPHealthcheck',
    'FlyTLSOptions',
    'FlyTempDirVolume',
    'FlyVolumeConfig',
    'ImageRef',
    'MachineEvent',
]

@pulumi.output_type
class CheckStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CheckStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CheckStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CheckStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 output: Optional[str] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if output is not None:
            pulumi.set(__self__, "output", output)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def output(self) -> Optional[str]:
        return pulumi.get(self, "output")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class FlyContainerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependsOn":
            suggest = "depends_on"
        elif key == "envFrom":
            suggest = "env_from"
        elif key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyContainerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyContainerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyContainerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cmd: Optional[Sequence[str]] = None,
                 depends_on: Optional[Sequence['outputs.FlyContainerDependency']] = None,
                 entrypoint: Optional[Sequence[str]] = None,
                 env: Optional[Mapping[str, str]] = None,
                 env_from: Optional[Sequence['outputs.FlyEnvFrom']] = None,
                 exec_: Optional[Sequence[str]] = None,
                 files: Optional[Sequence['outputs.FlyFile']] = None,
                 healthchecks: Optional[Sequence['outputs.FlyContainerHealthcheck']] = None,
                 image: Optional[str] = None,
                 mounts: Optional[Sequence['outputs.FlyContainerMount']] = None,
                 name: Optional[str] = None,
                 restart: Optional['outputs.FlyMachineRestart'] = None,
                 secrets: Optional[Sequence['outputs.FlyMachineSecret']] = None,
                 stop: Optional['outputs.FlyStopConfig'] = None,
                 user: Optional[str] = None):
        if cmd is not None:
            pulumi.set(__self__, "cmd", cmd)
        if depends_on is not None:
            pulumi.set(__self__, "depends_on", depends_on)
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if env_from is not None:
            pulumi.set(__self__, "env_from", env_from)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if healthchecks is not None:
            pulumi.set(__self__, "healthchecks", healthchecks)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if mounts is not None:
            pulumi.set(__self__, "mounts", mounts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if restart is not None:
            pulumi.set(__self__, "restart", restart)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if stop is not None:
            pulumi.set(__self__, "stop", stop)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cmd(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cmd")

    @property
    @pulumi.getter(name="dependsOn")
    def depends_on(self) -> Optional[Sequence['outputs.FlyContainerDependency']]:
        return pulumi.get(self, "depends_on")

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="envFrom")
    def env_from(self) -> Optional[Sequence['outputs.FlyEnvFrom']]:
        return pulumi.get(self, "env_from")

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.FlyFile']]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def healthchecks(self) -> Optional[Sequence['outputs.FlyContainerHealthcheck']]:
        return pulumi.get(self, "healthchecks")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def mounts(self) -> Optional[Sequence['outputs.FlyContainerMount']]:
        return pulumi.get(self, "mounts")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def restart(self) -> Optional['outputs.FlyMachineRestart']:
        return pulumi.get(self, "restart")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.FlyMachineSecret']]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter
    def stop(self) -> Optional['outputs.FlyStopConfig']:
        return pulumi.get(self, "stop")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class FlyContainerDependency(dict):
    def __init__(__self__, *,
                 condition: Optional[str] = None,
                 name: Optional[str] = None):
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class FlyContainerHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "successThreshold":
            suggest = "success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyContainerHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyContainerHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyContainerHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.FlyExecHealthcheck'] = None,
                 failure_threshold: Optional[int] = None,
                 grace_period: Optional[int] = None,
                 http: Optional['outputs.FlyHTTPHealthcheck'] = None,
                 interval: Optional[int] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 success_threshold: Optional[int] = None,
                 tcp: Optional['outputs.FlyTCPHealthcheck'] = None,
                 timeout: Optional[int] = None,
                 unhealthy: Optional[str] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if unhealthy is not None:
            pulumi.set(__self__, "unhealthy", unhealthy)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.FlyExecHealthcheck']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[int]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.FlyHTTPHealthcheck']:
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.FlyTCPHealthcheck']:
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def unhealthy(self) -> Optional[str]:
        return pulumi.get(self, "unhealthy")


@pulumi.output_type
class FlyContainerMount(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 path: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class FlyDNSConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsForwardRules":
            suggest = "dns_forward_rules"
        elif key == "hostnameFqdn":
            suggest = "hostname_fqdn"
        elif key == "skipRegistration":
            suggest = "skip_registration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyDNSConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyDNSConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyDNSConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_forward_rules: Optional[Sequence['outputs.FlyDnsForwardRule']] = None,
                 hostname: Optional[str] = None,
                 hostname_fqdn: Optional[str] = None,
                 nameservers: Optional[Sequence[str]] = None,
                 options: Optional[Sequence['outputs.FlyDnsOption']] = None,
                 searches: Optional[Sequence[str]] = None,
                 skip_registration: Optional[bool] = None):
        if dns_forward_rules is not None:
            pulumi.set(__self__, "dns_forward_rules", dns_forward_rules)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if hostname_fqdn is not None:
            pulumi.set(__self__, "hostname_fqdn", hostname_fqdn)
        if nameservers is not None:
            pulumi.set(__self__, "nameservers", nameservers)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if searches is not None:
            pulumi.set(__self__, "searches", searches)
        if skip_registration is not None:
            pulumi.set(__self__, "skip_registration", skip_registration)

    @property
    @pulumi.getter(name="dnsForwardRules")
    def dns_forward_rules(self) -> Optional[Sequence['outputs.FlyDnsForwardRule']]:
        return pulumi.get(self, "dns_forward_rules")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter(name="hostnameFqdn")
    def hostname_fqdn(self) -> Optional[str]:
        return pulumi.get(self, "hostname_fqdn")

    @property
    @pulumi.getter
    def nameservers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "nameservers")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence['outputs.FlyDnsOption']]:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def searches(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "searches")

    @property
    @pulumi.getter(name="skipRegistration")
    def skip_registration(self) -> Optional[bool]:
        return pulumi.get(self, "skip_registration")


@pulumi.output_type
class FlyDnsForwardRule(dict):
    def __init__(__self__, *,
                 addr: Optional[str] = None,
                 basename: Optional[str] = None):
        if addr is not None:
            pulumi.set(__self__, "addr", addr)
        if basename is not None:
            pulumi.set(__self__, "basename", basename)

    @property
    @pulumi.getter
    def addr(self) -> Optional[str]:
        return pulumi.get(self, "addr")

    @property
    @pulumi.getter
    def basename(self) -> Optional[str]:
        return pulumi.get(self, "basename")


@pulumi.output_type
class FlyDnsOption(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class FlyEnvFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envVar":
            suggest = "env_var"
        elif key == "fieldRef":
            suggest = "field_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyEnvFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyEnvFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyEnvFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env_var: Optional[str] = None,
                 field_ref: Optional[str] = None):
        if env_var is not None:
            pulumi.set(__self__, "env_var", env_var)
        if field_ref is not None:
            pulumi.set(__self__, "field_ref", field_ref)

    @property
    @pulumi.getter(name="envVar")
    def env_var(self) -> Optional[str]:
        return pulumi.get(self, "env_var")

    @property
    @pulumi.getter(name="fieldRef")
    def field_ref(self) -> Optional[str]:
        return pulumi.get(self, "field_ref")


@pulumi.output_type
class FlyExecHealthcheck(dict):
    def __init__(__self__, *,
                 command: Optional[Sequence[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "command")


@pulumi.output_type
class FlyFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestPath":
            suggest = "guest_path"
        elif key == "rawValue":
            suggest = "raw_value"
        elif key == "secretName":
            suggest = "secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_path: Optional[str] = None,
                 mode: Optional[int] = None,
                 raw_value: Optional[str] = None,
                 secret_name: Optional[str] = None):
        if guest_path is not None:
            pulumi.set(__self__, "guest_path", guest_path)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if raw_value is not None:
            pulumi.set(__self__, "raw_value", raw_value)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @property
    @pulumi.getter(name="guestPath")
    def guest_path(self) -> Optional[str]:
        return pulumi.get(self, "guest_path")

    @property
    @pulumi.getter
    def mode(self) -> Optional[int]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="rawValue")
    def raw_value(self) -> Optional[str]:
        return pulumi.get(self, "raw_value")

    @property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[str]:
        return pulumi.get(self, "secret_name")


@pulumi.output_type
class FlyHTTPHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tlsServerName":
            suggest = "tls_server_name"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyHTTPHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyHTTPHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyHTTPHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.FlyMachineHTTPHeader']] = None,
                 method: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None,
                 tls_server_name: Optional[str] = None,
                 tls_skip_verify: Optional[bool] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.FlyMachineHTTPHeader']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[str]:
        return pulumi.get(self, "tls_server_name")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "tls_skip_verify")


@pulumi.output_type
class FlyHTTPOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2Backend":
            suggest = "h2_backend"
        elif key == "headersReadTimeout":
            suggest = "headers_read_timeout"
        elif key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyHTTPOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyHTTPOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyHTTPOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compress: Optional[bool] = None,
                 h2_backend: Optional[bool] = None,
                 headers_read_timeout: Optional[int] = None,
                 idle_timeout: Optional[int] = None,
                 response: Optional['outputs.FlyHTTPResponseOptions'] = None):
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if h2_backend is not None:
            pulumi.set(__self__, "h2_backend", h2_backend)
        if headers_read_timeout is not None:
            pulumi.set(__self__, "headers_read_timeout", headers_read_timeout)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="h2Backend")
    def h2_backend(self) -> Optional[bool]:
        return pulumi.get(self, "h2_backend")

    @property
    @pulumi.getter(name="headersReadTimeout")
    def headers_read_timeout(self) -> Optional[int]:
        return pulumi.get(self, "headers_read_timeout")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.FlyHTTPResponseOptions']:
        return pulumi.get(self, "response")


@pulumi.output_type
class FlyHTTPResponseOptions(dict):
    def __init__(__self__, *,
                 headers: Optional[Mapping[str, Mapping[str, Any]]] = None,
                 pristine: Optional[bool] = None):
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if pristine is not None:
            pulumi.set(__self__, "pristine", pristine)

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Mapping[str, Any]]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def pristine(self) -> Optional[bool]:
        return pulumi.get(self, "pristine")


@pulumi.output_type
class FlyMachineCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriod":
            suggest = "grace_period"
        elif key == "tlsServerName":
            suggest = "tls_server_name"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period: Optional[str] = None,
                 headers: Optional[Sequence['outputs.FlyMachineHTTPHeader']] = None,
                 interval: Optional[str] = None,
                 kind: Optional[str] = None,
                 method: Optional[str] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 timeout: Optional[str] = None,
                 tls_server_name: Optional[str] = None,
                 tls_skip_verify: Optional[bool] = None,
                 type: Optional[str] = None):
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[str]:
        return pulumi.get(self, "grace_period")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.FlyMachineHTTPHeader']]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[str]:
        return pulumi.get(self, "tls_server_name")

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "tls_skip_verify")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class FlyMachineConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoDestroy":
            suggest = "auto_destroy"
        elif key == "stopConfig":
            suggest = "stop_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 auto_destroy: Optional[bool] = None,
                 checks: Optional[Mapping[str, 'outputs.FlyMachineCheck']] = None,
                 containers: Optional[Sequence['outputs.FlyContainerConfig']] = None,
                 dns: Optional['outputs.FlyDNSConfig'] = None,
                 env: Optional[Mapping[str, str]] = None,
                 files: Optional[Sequence['outputs.FlyFile']] = None,
                 guest: Optional['outputs.FlyMachineGuest'] = None,
                 init: Optional['outputs.FlyMachineInit'] = None,
                 metadata: Optional[Mapping[str, str]] = None,
                 metrics: Optional['outputs.FlyMachineMetrics'] = None,
                 mounts: Optional[Sequence['outputs.FlyMachineMount']] = None,
                 processes: Optional[Sequence['outputs.FlyMachineProcess']] = None,
                 restart: Optional['outputs.FlyMachineRestart'] = None,
                 schedule: Optional[str] = None,
                 services: Optional[Sequence['outputs.FlyMachineService']] = None,
                 standbys: Optional[Sequence[str]] = None,
                 statics: Optional[Sequence['outputs.FlyStatic']] = None,
                 stop_config: Optional['outputs.FlyStopConfig'] = None,
                 volumes: Optional[Sequence['outputs.FlyVolumeConfig']] = None):
        pulumi.set(__self__, "image", image)
        if auto_destroy is not None:
            pulumi.set(__self__, "auto_destroy", auto_destroy)
        if checks is not None:
            pulumi.set(__self__, "checks", checks)
        if containers is not None:
            pulumi.set(__self__, "containers", containers)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if guest is not None:
            pulumi.set(__self__, "guest", guest)
        if init is not None:
            pulumi.set(__self__, "init", init)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if mounts is not None:
            pulumi.set(__self__, "mounts", mounts)
        if processes is not None:
            pulumi.set(__self__, "processes", processes)
        if restart is not None:
            pulumi.set(__self__, "restart", restart)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if standbys is not None:
            pulumi.set(__self__, "standbys", standbys)
        if statics is not None:
            pulumi.set(__self__, "statics", statics)
        if stop_config is not None:
            pulumi.set(__self__, "stop_config", stop_config)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="autoDestroy")
    def auto_destroy(self) -> Optional[bool]:
        return pulumi.get(self, "auto_destroy")

    @property
    @pulumi.getter
    def checks(self) -> Optional[Mapping[str, 'outputs.FlyMachineCheck']]:
        return pulumi.get(self, "checks")

    @property
    @pulumi.getter
    def containers(self) -> Optional[Sequence['outputs.FlyContainerConfig']]:
        return pulumi.get(self, "containers")

    @property
    @pulumi.getter
    def dns(self) -> Optional['outputs.FlyDNSConfig']:
        return pulumi.get(self, "dns")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def files(self) -> Optional[Sequence['outputs.FlyFile']]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def guest(self) -> Optional['outputs.FlyMachineGuest']:
        return pulumi.get(self, "guest")

    @property
    @pulumi.getter
    def init(self) -> Optional['outputs.FlyMachineInit']:
        return pulumi.get(self, "init")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.FlyMachineMetrics']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def mounts(self) -> Optional[Sequence['outputs.FlyMachineMount']]:
        return pulumi.get(self, "mounts")

    @property
    @pulumi.getter
    def processes(self) -> Optional[Sequence['outputs.FlyMachineProcess']]:
        return pulumi.get(self, "processes")

    @property
    @pulumi.getter
    def restart(self) -> Optional['outputs.FlyMachineRestart']:
        return pulumi.get(self, "restart")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.FlyMachineService']]:
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def standbys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "standbys")

    @property
    @pulumi.getter
    def statics(self) -> Optional[Sequence['outputs.FlyStatic']]:
        return pulumi.get(self, "statics")

    @property
    @pulumi.getter(name="stopConfig")
    def stop_config(self) -> Optional['outputs.FlyStopConfig']:
        return pulumi.get(self, "stop_config")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.FlyVolumeConfig']]:
        return pulumi.get(self, "volumes")


@pulumi.output_type
class FlyMachineGuest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuKind":
            suggest = "cpu_kind"
        elif key == "memoryMb":
            suggest = "memory_mb"
        elif key == "gpuKind":
            suggest = "gpu_kind"
        elif key == "hostDedicationId":
            suggest = "host_dedication_id"
        elif key == "kernelArgs":
            suggest = "kernel_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineGuest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineGuest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineGuest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_kind: str,
                 cpus: int,
                 memory_mb: int,
                 gpu_kind: Optional[str] = None,
                 gpus: Optional[int] = None,
                 host_dedication_id: Optional[str] = None,
                 kernel_args: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "cpu_kind", cpu_kind)
        pulumi.set(__self__, "cpus", cpus)
        pulumi.set(__self__, "memory_mb", memory_mb)
        if gpu_kind is not None:
            pulumi.set(__self__, "gpu_kind", gpu_kind)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if host_dedication_id is not None:
            pulumi.set(__self__, "host_dedication_id", host_dedication_id)
        if kernel_args is not None:
            pulumi.set(__self__, "kernel_args", kernel_args)

    @property
    @pulumi.getter(name="cpuKind")
    def cpu_kind(self) -> str:
        return pulumi.get(self, "cpu_kind")

    @property
    @pulumi.getter
    def cpus(self) -> int:
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> int:
        return pulumi.get(self, "memory_mb")

    @property
    @pulumi.getter(name="gpuKind")
    def gpu_kind(self) -> Optional[str]:
        return pulumi.get(self, "gpu_kind")

    @property
    @pulumi.getter
    def gpus(self) -> Optional[int]:
        return pulumi.get(self, "gpus")

    @property
    @pulumi.getter(name="hostDedicationId")
    def host_dedication_id(self) -> Optional[str]:
        return pulumi.get(self, "host_dedication_id")

    @property
    @pulumi.getter(name="kernelArgs")
    def kernel_args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "kernel_args")


@pulumi.output_type
class FlyMachineHTTPHeader(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class FlyMachineInit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "kernelArgs":
            suggest = "kernel_args"
        elif key == "swapSizeMb":
            suggest = "swap_size_mb"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineInit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineInit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineInit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cmd: Optional[Sequence[str]] = None,
                 entrypoint: Optional[Sequence[str]] = None,
                 exec_: Optional[Sequence[str]] = None,
                 kernel_args: Optional[Sequence[str]] = None,
                 swap_size_mb: Optional[int] = None,
                 tty: Optional[bool] = None):
        if cmd is not None:
            pulumi.set(__self__, "cmd", cmd)
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if kernel_args is not None:
            pulumi.set(__self__, "kernel_args", kernel_args)
        if swap_size_mb is not None:
            pulumi.set(__self__, "swap_size_mb", swap_size_mb)
        if tty is not None:
            pulumi.set(__self__, "tty", tty)

    @property
    @pulumi.getter
    def cmd(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cmd")

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="kernelArgs")
    def kernel_args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "kernel_args")

    @property
    @pulumi.getter(name="swapSizeMb")
    def swap_size_mb(self) -> Optional[int]:
        return pulumi.get(self, "swap_size_mb")

    @property
    @pulumi.getter
    def tty(self) -> Optional[bool]:
        return pulumi.get(self, "tty")


@pulumi.output_type
class FlyMachineMetrics(dict):
    def __init__(__self__, *,
                 https: Optional[bool] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None):
        if https is not None:
            pulumi.set(__self__, "https", https)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def https(self) -> Optional[bool]:
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class FlyMachineMount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addSizeGb":
            suggest = "add_size_gb"
        elif key == "extendThresholdPercent":
            suggest = "extend_threshold_percent"
        elif key == "sizeGb":
            suggest = "size_gb"
        elif key == "sizeGbLimit":
            suggest = "size_gb_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineMount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineMount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineMount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_size_gb: Optional[int] = None,
                 encrypted: Optional[bool] = None,
                 extend_threshold_percent: Optional[int] = None,
                 name: Optional[str] = None,
                 path: Optional[str] = None,
                 size_gb: Optional[int] = None,
                 size_gb_limit: Optional[int] = None,
                 volume: Optional[str] = None):
        if add_size_gb is not None:
            pulumi.set(__self__, "add_size_gb", add_size_gb)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if extend_threshold_percent is not None:
            pulumi.set(__self__, "extend_threshold_percent", extend_threshold_percent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)
        if size_gb_limit is not None:
            pulumi.set(__self__, "size_gb_limit", size_gb_limit)
        if volume is not None:
            pulumi.set(__self__, "volume", volume)

    @property
    @pulumi.getter(name="addSizeGb")
    def add_size_gb(self) -> Optional[int]:
        return pulumi.get(self, "add_size_gb")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter(name="extendThresholdPercent")
    def extend_threshold_percent(self) -> Optional[int]:
        return pulumi.get(self, "extend_threshold_percent")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[int]:
        return pulumi.get(self, "size_gb")

    @property
    @pulumi.getter(name="sizeGbLimit")
    def size_gb_limit(self) -> Optional[int]:
        return pulumi.get(self, "size_gb_limit")

    @property
    @pulumi.getter
    def volume(self) -> Optional[str]:
        return pulumi.get(self, "volume")


@pulumi.output_type
class FlyMachinePort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "forceHttps":
            suggest = "force_https"
        elif key == "httpOptions":
            suggest = "http_options"
        elif key == "proxyProtoOptions":
            suggest = "proxy_proto_options"
        elif key == "startPort":
            suggest = "start_port"
        elif key == "tlsOptions":
            suggest = "tls_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachinePort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachinePort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachinePort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 force_https: Optional[bool] = None,
                 handlers: Optional[Sequence[str]] = None,
                 http_options: Optional['outputs.FlyHTTPOptions'] = None,
                 port: Optional[int] = None,
                 proxy_proto_options: Optional['outputs.FlyProxyProtoOptions'] = None,
                 start_port: Optional[int] = None,
                 tls_options: Optional['outputs.FlyTLSOptions'] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if force_https is not None:
            pulumi.set(__self__, "force_https", force_https)
        if handlers is not None:
            pulumi.set(__self__, "handlers", handlers)
        if http_options is not None:
            pulumi.set(__self__, "http_options", http_options)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proxy_proto_options is not None:
            pulumi.set(__self__, "proxy_proto_options", proxy_proto_options)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)
        if tls_options is not None:
            pulumi.set(__self__, "tls_options", tls_options)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter(name="forceHttps")
    def force_https(self) -> Optional[bool]:
        return pulumi.get(self, "force_https")

    @property
    @pulumi.getter
    def handlers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "handlers")

    @property
    @pulumi.getter(name="httpOptions")
    def http_options(self) -> Optional['outputs.FlyHTTPOptions']:
        return pulumi.get(self, "http_options")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="proxyProtoOptions")
    def proxy_proto_options(self) -> Optional['outputs.FlyProxyProtoOptions']:
        return pulumi.get(self, "proxy_proto_options")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        return pulumi.get(self, "start_port")

    @property
    @pulumi.getter(name="tlsOptions")
    def tls_options(self) -> Optional['outputs.FlyTLSOptions']:
        return pulumi.get(self, "tls_options")


@pulumi.output_type
class FlyMachineProcess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envFrom":
            suggest = "env_from"
        elif key == "exec":
            suggest = "exec_"
        elif key == "ignoreAppSecrets":
            suggest = "ignore_app_secrets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineProcess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineProcess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineProcess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cmd: Optional[Sequence[str]] = None,
                 entrypoint: Optional[Sequence[str]] = None,
                 env: Optional[Mapping[str, str]] = None,
                 env_from: Optional[Sequence['outputs.FlyEnvFrom']] = None,
                 exec_: Optional[Sequence[str]] = None,
                 ignore_app_secrets: Optional[bool] = None,
                 secrets: Optional[Sequence['outputs.FlyMachineSecret']] = None,
                 user: Optional[str] = None):
        if cmd is not None:
            pulumi.set(__self__, "cmd", cmd)
        if entrypoint is not None:
            pulumi.set(__self__, "entrypoint", entrypoint)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if env_from is not None:
            pulumi.set(__self__, "env_from", env_from)
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if ignore_app_secrets is not None:
            pulumi.set(__self__, "ignore_app_secrets", ignore_app_secrets)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def cmd(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cmd")

    @property
    @pulumi.getter
    def entrypoint(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "entrypoint")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="envFrom")
    def env_from(self) -> Optional[Sequence['outputs.FlyEnvFrom']]:
        return pulumi.get(self, "env_from")

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="ignoreAppSecrets")
    def ignore_app_secrets(self) -> Optional[bool]:
        return pulumi.get(self, "ignore_app_secrets")

    @property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence['outputs.FlyMachineSecret']]:
        return pulumi.get(self, "secrets")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class FlyMachineRestart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuBidPrice":
            suggest = "gpu_bid_price"
        elif key == "maxRetries":
            suggest = "max_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineRestart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineRestart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineRestart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gpu_bid_price: Optional[float] = None,
                 max_retries: Optional[int] = None,
                 policy: Optional[str] = None):
        if gpu_bid_price is not None:
            pulumi.set(__self__, "gpu_bid_price", gpu_bid_price)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter(name="gpuBidPrice")
    def gpu_bid_price(self) -> Optional[float]:
        return pulumi.get(self, "gpu_bid_price")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        return pulumi.get(self, "policy")


@pulumi.output_type
class FlyMachineSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "envVar":
            suggest = "env_var"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env_var: Optional[str] = None,
                 name: Optional[str] = None):
        if env_var is not None:
            pulumi.set(__self__, "env_var", env_var)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="envVar")
    def env_var(self) -> Optional[str]:
        return pulumi.get(self, "env_var")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class FlyMachineService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceInstanceDescription":
            suggest = "force_instance_description"
        elif key == "forceInstanceKey":
            suggest = "force_instance_key"
        elif key == "internalPort":
            suggest = "internal_port"
        elif key == "minMachinesRunning":
            suggest = "min_machines_running"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autostart: Optional[bool] = None,
                 autostop: Optional[str] = None,
                 checks: Optional[Sequence['outputs.FlyMachineCheck']] = None,
                 concurrency: Optional['outputs.FlyMachineServiceConcurrency'] = None,
                 force_instance_description: Optional[str] = None,
                 force_instance_key: Optional[str] = None,
                 internal_port: Optional[int] = None,
                 min_machines_running: Optional[int] = None,
                 ports: Optional[Sequence['outputs.FlyMachinePort']] = None,
                 protocol: Optional[str] = None):
        if autostart is not None:
            pulumi.set(__self__, "autostart", autostart)
        if autostop is not None:
            pulumi.set(__self__, "autostop", autostop)
        if checks is not None:
            pulumi.set(__self__, "checks", checks)
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if force_instance_description is not None:
            pulumi.set(__self__, "force_instance_description", force_instance_description)
        if force_instance_key is not None:
            pulumi.set(__self__, "force_instance_key", force_instance_key)
        if internal_port is not None:
            pulumi.set(__self__, "internal_port", internal_port)
        if min_machines_running is not None:
            pulumi.set(__self__, "min_machines_running", min_machines_running)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def autostart(self) -> Optional[bool]:
        return pulumi.get(self, "autostart")

    @property
    @pulumi.getter
    def autostop(self) -> Optional[str]:
        return pulumi.get(self, "autostop")

    @property
    @pulumi.getter
    def checks(self) -> Optional[Sequence['outputs.FlyMachineCheck']]:
        return pulumi.get(self, "checks")

    @property
    @pulumi.getter
    def concurrency(self) -> Optional['outputs.FlyMachineServiceConcurrency']:
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter(name="forceInstanceDescription")
    def force_instance_description(self) -> Optional[str]:
        return pulumi.get(self, "force_instance_description")

    @property
    @pulumi.getter(name="forceInstanceKey")
    def force_instance_key(self) -> Optional[str]:
        return pulumi.get(self, "force_instance_key")

    @property
    @pulumi.getter(name="internalPort")
    def internal_port(self) -> Optional[int]:
        return pulumi.get(self, "internal_port")

    @property
    @pulumi.getter(name="minMachinesRunning")
    def min_machines_running(self) -> Optional[int]:
        return pulumi.get(self, "min_machines_running")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.FlyMachinePort']]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class FlyMachineServiceConcurrency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hardLimit":
            suggest = "hard_limit"
        elif key == "softLimit":
            suggest = "soft_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyMachineServiceConcurrency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyMachineServiceConcurrency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyMachineServiceConcurrency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hard_limit: Optional[int] = None,
                 soft_limit: Optional[int] = None,
                 type: Optional[str] = None):
        if hard_limit is not None:
            pulumi.set(__self__, "hard_limit", hard_limit)
        if soft_limit is not None:
            pulumi.set(__self__, "soft_limit", soft_limit)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="hardLimit")
    def hard_limit(self) -> Optional[int]:
        return pulumi.get(self, "hard_limit")

    @property
    @pulumi.getter(name="softLimit")
    def soft_limit(self) -> Optional[int]:
        return pulumi.get(self, "soft_limit")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class FlyProxyProtoOptions(dict):
    def __init__(__self__, *,
                 version: Optional[str] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class FlyStatic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guestPath":
            suggest = "guest_path"
        elif key == "urlPrefix":
            suggest = "url_prefix"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "tigrisBucket":
            suggest = "tigris_bucket"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyStatic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyStatic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyStatic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guest_path: str,
                 url_prefix: str,
                 index_document: Optional[str] = None,
                 tigris_bucket: Optional[str] = None):
        pulumi.set(__self__, "guest_path", guest_path)
        pulumi.set(__self__, "url_prefix", url_prefix)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if tigris_bucket is not None:
            pulumi.set(__self__, "tigris_bucket", tigris_bucket)

    @property
    @pulumi.getter(name="guestPath")
    def guest_path(self) -> str:
        return pulumi.get(self, "guest_path")

    @property
    @pulumi.getter(name="urlPrefix")
    def url_prefix(self) -> str:
        return pulumi.get(self, "url_prefix")

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[str]:
        return pulumi.get(self, "index_document")

    @property
    @pulumi.getter(name="tigrisBucket")
    def tigris_bucket(self) -> Optional[str]:
        return pulumi.get(self, "tigris_bucket")


@pulumi.output_type
class FlyStopConfig(dict):
    def __init__(__self__, *,
                 signal: Optional[str] = None,
                 timeout: Optional[str] = None):
        if signal is not None:
            pulumi.set(__self__, "signal", signal)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def signal(self) -> Optional[str]:
        return pulumi.get(self, "signal")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class FlyTCPHealthcheck(dict):
    def __init__(__self__, *,
                 port: Optional[int] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class FlyTLSOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultSelfSigned":
            suggest = "default_self_signed"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyTLSOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyTLSOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyTLSOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alpn: Optional[Sequence[str]] = None,
                 default_self_signed: Optional[bool] = None,
                 versions: Optional[Sequence[str]] = None):
        if alpn is not None:
            pulumi.set(__self__, "alpn", alpn)
        if default_self_signed is not None:
            pulumi.set(__self__, "default_self_signed", default_self_signed)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def alpn(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "alpn")

    @property
    @pulumi.getter(name="defaultSelfSigned")
    def default_self_signed(self) -> Optional[bool]:
        return pulumi.get(self, "default_self_signed")

    @property
    @pulumi.getter
    def versions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "versions")


@pulumi.output_type
class FlyTempDirVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeMb":
            suggest = "size_mb"
        elif key == "storageType":
            suggest = "storage_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyTempDirVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyTempDirVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyTempDirVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_mb: Optional[int] = None,
                 storage_type: Optional[str] = None):
        if size_mb is not None:
            pulumi.set(__self__, "size_mb", size_mb)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)

    @property
    @pulumi.getter(name="sizeMb")
    def size_mb(self) -> Optional[int]:
        return pulumi.get(self, "size_mb")

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[str]:
        return pulumi.get(self, "storage_type")


@pulumi.output_type
class FlyVolumeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tempDir":
            suggest = "temp_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlyVolumeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlyVolumeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlyVolumeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 temp_dir: Optional['outputs.FlyTempDirVolume'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temp_dir is not None:
            pulumi.set(__self__, "temp_dir", temp_dir)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="tempDir")
    def temp_dir(self) -> Optional['outputs.FlyTempDirVolume']:
        return pulumi.get(self, "temp_dir")


@pulumi.output_type
class ImageRef(dict):
    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 registry: Optional[str] = None,
                 repository: Optional[str] = None,
                 tag: Optional[str] = None):
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def registry(self) -> Optional[str]:
        return pulumi.get(self, "registry")

    @property
    @pulumi.getter
    def repository(self) -> Optional[str]:
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")


@pulumi.output_type
class MachineEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flyId":
            suggest = "fly_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fly_id: str,
                 request: Optional[Mapping[str, Any]] = None,
                 source: Optional[str] = None,
                 status: Optional[str] = None,
                 timestamp: Optional[int] = None,
                 type: Optional[str] = None):
        pulumi.set(__self__, "fly_id", fly_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="flyId")
    def fly_id(self) -> str:
        return pulumi.get(self, "fly_id")

    @property
    @pulumi.getter
    def request(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[int]:
        return pulumi.get(self, "timestamp")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


