"""
Copyright (c) 2025 ayeteadoe <ayeteadoe@gmail.com>

SPDX-License-Identifier: MIT
"""
import os
import sys
import subprocess
from pathlib import Path
from abc import ABC, abstractmethod
from iprm.load.load import Loader
from iprm.util.env import Env
from iprm.util.vcvarsall import vcvarsall_script
from iprm.core.object import Object
from iprm.api.obj.project import Project
from iprm.api.obj.subdirectories import SubDirectories
from iprm.api.obj.target import Target
from iprm.api.obj.cxx import CppTarget
from iprm.api.obj.rust import RustTarget

iprm_gen_dir_path = os.path.dirname(__file__)
src_dir_path = os.path.abspath(os.path.join(iprm_gen_dir_path, '..', '..'))
sys.path.append(src_dir_path)


class Backend(ABC):
    def __init__(self, loader: Loader, **kwargs):
        self._loader = loader
        # TODO: Use this for something
        self._config = kwargs

    @property
    def loader(self):
        return self._loader

    @property
    def project_dir_str(self):
        return str(self.loader.project_dir)

    def generate_project(self):
        project_objects = self.loader.load_project()
        num_files_to_generate = len(project_objects.keys()) if project_objects is not None else 0
        if num_files_to_generate == 0:
            self.loader.log_sink.log_message(
                f"{self.loader.file_name()}: no '{self.generated_file_name}' files to generate")
            return

        num_files_generated = 1
        for native_file_path, objects in project_objects.items():
            def gen_log():
                self.loader.log_sink.log_message(
                    f"[{num_files_generated}/{num_files_to_generate}] Generating '{self.generated_file_name}' from "
                    f"'{native_file_path}'", end='\r')

            gen_log()

            from iprm import __version__
            from datetime import datetime, timezone
            generated_content = [
                '# =========================================================',
                '# WARNING: This file is auto-generated. DO NOT EDIT MANUALLY',
                f'# Generated by: iprm (v{__version__})',
                f'# Generated on: {datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z")}',
                f'# Platform: {Env.platform.display_name()}',
                '# =========================================================',
            ]
            for obj in objects:
                # NOTE: Generators are state-less, it assumes validation on the native objects has happened by this
                # point and just spits out what the object tells it to. Actual validation on the generated files can
                # be tested by running the various configure, build, test, and install commands to target project model
                # supports and independently verifying the results are what one expects
                generated_obj_content = self._generate_object(obj)
                if generated_obj_content:
                    generated_content.extend(generated_obj_content)
                else:
                    # TODO: log saying no content for the object was generated
                    pass

            generated_file_path = Path(str(native_file_path)).parent / self.generated_file_name
            with open(generated_file_path, 'w') as file:
                file.write('\n'.join(generated_content))
                num_files_generated += 1
        self.loader.log_sink.log_message('')

    @classmethod
    def _generate_object(cls, obj: Object) -> list[str]:
        from typing import cast
        if obj.is_project:
            project = cast(Project, obj)
            return cls._generate_project(project)
        elif obj.is_subdirs:
            subdirs = cast(SubDirectories, obj)
            return cls._generate_subdirectories(subdirs)
        elif obj.is_cxx:
            cxx = cast(CppTarget, obj)
            return cls._generate_cxx(cxx)
        elif obj.is_rust:
            rust = cast(RustTarget, obj)
            return cls._generate_rust(rust)
        return []

    @classmethod
    @abstractmethod
    def _generate_project(cls, project: Project) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_subdirectories(cls, subdirs: SubDirectories) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_target(cls, target: Target) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_cxx(cls, cxx: CppTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_rust(cls, rust: RustTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def name(cls):
        pass

    @classmethod
    @abstractmethod
    def current_src_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def current_bin_dir(cls):
        pass

    @classmethod
    def _run_command(cls, cmd):
        cmd_str = ' '.join(cmd)
        return subprocess.run(
            vcvarsall_script(cmd_str) if Env.platform.windows else cmd_str, shell=True).returncode

    @classmethod
    @abstractmethod
    def configure(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def build(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def test(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def install(cls, **kwargs):
        pass

    @property
    @abstractmethod
    def generated_file_name(self):
        pass

    @classmethod
    def num_procs(cls, **kwargs):
        numproc = kwargs.get('numproc', None)
        if numproc:
            return numproc
        if Env.platform.windows:
            return '%NUMBER_OF_PROCESSORS%'
        elif Env.platform.macos:
            return '$(sysctl -n hw.ncpu)'
        elif Env.platform.linux:
            return '$(nproc)'
        return None

    @classmethod
    def build_type(cls, **kwargs):
        release = kwargs.get('release', None)
        bld_type = cls._default_build_type() if release is None else cls._release_build_type()
        debug = kwargs.get('debug', None)
        if debug:
            bld_type = cls._debug_build_type()
        return bld_type

    @classmethod
    @abstractmethod
    def _default_build_type(cls):
        pass

    @classmethod
    @abstractmethod
    def _release_build_type(cls):
        pass

    @classmethod
    @abstractmethod
    def _debug_build_type(cls):
        pass


class BuildSystem(Backend):
    def __init__(self, loader: Loader, **kwargs):
        super().__init__(loader, **kwargs)

    @classmethod
    @abstractmethod
    def _generate_project(cls, project: Project) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_subdirectories(cls, subdirs: SubDirectories) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_cxx(cls, cxx: CppTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_rust(cls, rust: RustTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def current_src_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def current_bin_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def configure(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def build(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def test(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def install(cls, **kwargs):
        pass


class ProjectModel(Backend):
    @classmethod
    @abstractmethod
    def generator_ninja(cls):
        pass

    @classmethod
    @abstractmethod
    def generator_xcode(cls):
        pass

    @classmethod
    @abstractmethod
    def generator_visual_studio(cls):
        pass

    @classmethod
    @abstractmethod
    def generator_unix_makefile(cls):
        pass

    @classmethod
    @abstractmethod
    def _generate_project(cls, project: Project) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_subdirectories(cls, subdirs: SubDirectories) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_cxx(cls, cxx: CppTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def _generate_rust(cls, rust: RustTarget) -> list[str]:
        pass

    @classmethod
    @abstractmethod
    def current_src_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def current_bin_dir(cls):
        pass

    @classmethod
    @abstractmethod
    def configure(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def build(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def test(cls, **kwargs):
        pass

    @classmethod
    @abstractmethod
    def install(cls, **kwargs):
        pass
