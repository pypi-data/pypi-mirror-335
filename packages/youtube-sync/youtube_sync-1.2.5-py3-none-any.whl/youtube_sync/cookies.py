import logging
import pickle
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Iterator

from filelock import FileLock
from open_webdriver import open_webdriver  # type: ignore

from .types import Source

_COOKIE_REFRESH_HOURS = 2

# Set up module logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.WARNING)


def _convert_cookies_to_txt(cookies: list[dict]) -> str:
    """
    Convert a list of cookie dictionaries to the cookies.txt (Netscape format).

    Each cookie dictionary may contain the following keys:
      - domain: The domain for the cookie.
      - expiry: Unix timestamp for expiration. If missing, treated as a session cookie (0).
      - httpOnly: (Ignored in this format)
      - name: The name of the cookie.
      - path: The URL path for which the cookie is valid.
      - sameSite: (Ignored in this format)
      - secure: Boolean indicating if the cookie is secure.
      - value: The cookie's value.

    Returns:
      A string formatted as a cookies.txt file.
    """
    # Header lines for the cookies.txt file
    lines: list[str] = [
        "# Netscape HTTP Cookie File",
        "# http://curl.haxx.se/rfc/cookie_spec.html",
        "# This file was generated by a Python script.\n",
    ]

    # Iterate over each cookie dictionary and convert to the correct format.
    for cookie in cookies:
        domain: str = cookie.get("domain", "")
        # If the domain starts with a dot, it applies to subdomains.
        flag: str = "TRUE" if domain.startswith(".") else "FALSE"
        path: str = cookie.get("path", "/")
        # Secure field: 'TRUE' if cookie is secure, otherwise 'FALSE'
        secure: str = "TRUE" if cookie.get("secure", False) else "FALSE"
        # Use expiry if provided; otherwise, set to 0 for a session cookie.
        expiry: str = str(cookie.get("expiry", 0))
        name: str = cookie.get("name", "")
        value: str = cookie.get("value", "")

        # Create a tab-separated line in the cookies.txt format.
        line: str = f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
        lines.append(line)

    # Join all lines with newline characters.
    return "\n".join(lines)


def _get_cookies_from_browser(url: str) -> list[dict]:
    with open_webdriver() as driver:
        # clear cookies
        driver.delete_all_cookies()
        driver.get(url)
        return driver.get_cookies()


def _get_cookie_paths(source: Source) -> tuple[Path, Path, Path]:
    assert source == Source.YOUTUBE, f"Only YouTube is supported, got {source}"
    cookies_pkl = Path("cookies") / "youtube" / "cookies.pkl"
    cookie_txt = Path("cookies") / "youtube" / "cookies.txt"
    cookies_lock = Path("cookies") / "youtube" / "cookies.lock"
    return cookies_pkl, cookie_txt, cookies_lock


def _get_platform_homepage_url(source: Source) -> str:
    if source == Source.YOUTUBE:
        return "https://www.youtube.com"
    if source == Source.RUMBLE:
        return "https://rumble.com"
    if source == Source.BRIGHTEON:
        return "https://www.brighteon.com"
    raise ValueError(f"Unknown source: {source}")


@dataclass
class CookiePaths:
    pkl: Path
    txt: Path
    lck: Path

    @staticmethod
    def create(source: Source) -> "CookiePaths":
        base_path = Path("cookies") / source.value
        out = CookiePaths(
            pkl=base_path / "cookies.pkl",
            txt=base_path / "cookies.txt",
            lck=base_path / "cookies.lock",
        )
        return out


_COOKIE_PATHS: dict[Source, CookiePaths] = {
    Source.YOUTUBE: CookiePaths.create(Source.YOUTUBE),
    Source.RUMBLE: CookiePaths.create(Source.RUMBLE),
    Source.BRIGHTEON: CookiePaths.create(Source.BRIGHTEON),
}


def get_cookie_paths(source: Source) -> CookiePaths:
    return _COOKIE_PATHS[source]


def get_or_refresh_cookies(
    source: Source,
    cookies: "Cookies | None",
) -> "Cookies":

    paths = get_cookie_paths(source)

    with FileLock(paths.lck):
        now = datetime.now()
        cookies_pkl = paths.pkl
        cookies_txt = paths.txt
        # case 1: we have cookies
        if cookies is not None:
            # and they are not expired
            expire_time = cookies.creation_time + timedelta(hours=_COOKIE_REFRESH_HOURS)
            if now < expire_time:
                return cookies
        # case 2: we have cookies on disk, but we must check to see that they are the right type.
        if cookies_pkl.exists() and cookies_txt.exists():
            yt_cookies = Cookies.from_pickle(cookies_pkl)
            if isinstance(yt_cookies, Cookies):
                hours_old = (now - yt_cookies.creation_time).seconds / 3600
                if hours_old < _COOKIE_REFRESH_HOURS:
                    return yt_cookies
            else:
                logger.warning("Invalid cookies found at %s", cookies_pkl)
        # case 3: we have no cookies, or they are expired, or they are the wrong type
        yt_cookies = Cookies.from_browser(source)
        yt_cookies.save(cookies_pkl)
        yt_cookies.save(cookies_txt)
        return yt_cookies


class Cookies:

    @staticmethod
    def get_or_refresh(source: Source, cookies: "Cookies | None") -> "Cookies":

        return get_or_refresh_cookies(source=source, cookies=cookies)

    @staticmethod
    def from_browser(source: Source) -> "Cookies":
        url: str = _get_platform_homepage_url(source)
        data = _get_cookies_from_browser(url=url)
        return Cookies(source=source, data=data)

    def __init__(self, source: Source, data: list[dict]) -> None:
        self.version = "1"
        self.data = data
        self.source = source
        pkl, txt, lock = _get_cookie_paths(source)
        self.path_pkl = pkl
        self.path_txt = txt
        self.path_lock = lock
        self.creation_time = datetime.now()

    @property
    def cookies_txt(self) -> str:
        return _convert_cookies_to_txt(self.data)

    def write_cookies_txt(self, file_path: Path):
        file_path.write_text(self.cookies_txt, encoding="utf-8")

    @staticmethod
    def load(source: Source) -> "Cookies":
        cookies = Cookies.get_or_refresh(source=source, cookies=None)
        return cookies

    def save(self, out_file: Path) -> None:
        # assert out_pickle_file.suffix == ".pkl"
        # self.to_pickle(out_pickle_file)
        suffix = out_file.suffix
        if suffix not in {".pkl", ".txt"}:
            raise ValueError(
                f"Unsupported file extension: {suffix}, options are: '.pkl', '.txt'"
            )
        parent = out_file.parent
        parent.mkdir(parents=True, exist_ok=True)
        if suffix == ".pkl":
            self.to_pickle(out_file)
        elif suffix == ".txt":
            self.write_cookies_txt(out_file)
        else:
            raise ValueError(f"Unsupported file extension: {suffix}")

    def __len__(self) -> int:
        return len(self.data)

    def __iter__(self) -> Iterator[dict]:
        return iter(self.data)

    def __repr__(self) -> str:
        return f"Cookies({self.data})"

    def __str__(self) -> str:
        return self.cookies_txt

    def to_pickle(self, file_path: Path) -> None:
        """
        Serialize the Cookies object to a pickle file.

        Args:
            file_path: Path where the pickle file will be saved
        """
        with open(file_path, "wb") as f:
            pickle.dump(self, f)

    @staticmethod
    def from_pickle(file_path: Path) -> "Cookies":
        """
        Create a Cookies object from a pickle file.

        Args:
            file_path: Path to the pickle file

        Returns:
            A Cookies object with data loaded from the pickle file

        Raises:
            FileNotFoundError: If the pickle file doesn't exist
            pickle.UnpicklingError: If the file contains invalid pickle data
        """
        with open(file_path, "rb") as f:
            return pickle.load(f)
