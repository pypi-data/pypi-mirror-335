import pickle
from datetime import datetime
from pathlib import Path
from typing import Iterator

from open_webdriver import open_webdriver  # type: ignore


def _convert_cookies_to_txt(cookies: list[dict]) -> str:
    """
    Convert a list of cookie dictionaries to the cookies.txt (Netscape format).

    Each cookie dictionary may contain the following keys:
      - domain: The domain for the cookie.
      - expiry: Unix timestamp for expiration. If missing, treated as a session cookie (0).
      - httpOnly: (Ignored in this format)
      - name: The name of the cookie.
      - path: The URL path for which the cookie is valid.
      - sameSite: (Ignored in this format)
      - secure: Boolean indicating if the cookie is secure.
      - value: The cookie's value.

    Returns:
      A string formatted as a cookies.txt file.
    """
    # Header lines for the cookies.txt file
    lines: list[str] = [
        "# Netscape HTTP Cookie File",
        "# http://curl.haxx.se/rfc/cookie_spec.html",
        "# This file was generated by a Python script.\n",
    ]

    # Iterate over each cookie dictionary and convert to the correct format.
    for cookie in cookies:
        domain: str = cookie.get("domain", "")
        # If the domain starts with a dot, it applies to subdomains.
        flag: str = "TRUE" if domain.startswith(".") else "FALSE"
        path: str = cookie.get("path", "/")
        # Secure field: 'TRUE' if cookie is secure, otherwise 'FALSE'
        secure: str = "TRUE" if cookie.get("secure", False) else "FALSE"
        # Use expiry if provided; otherwise, set to 0 for a session cookie.
        expiry: str = str(cookie.get("expiry", 0))
        name: str = cookie.get("name", "")
        value: str = cookie.get("value", "")

        # Create a tab-separated line in the cookies.txt format.
        line: str = f"{domain}\t{flag}\t{path}\t{secure}\t{expiry}\t{name}\t{value}"
        lines.append(line)

    # Join all lines with newline characters.
    return "\n".join(lines)


def _get_cookies_from_browser(url: str) -> "Cookies":
    with open_webdriver() as driver:
        # clear cookies
        driver.delete_all_cookies()
        driver.get(url)
        return Cookies(driver.get_cookies())


class Cookies:

    @staticmethod
    def from_browser(url: str) -> "Cookies":
        return _get_cookies_from_browser(url)

    def __init__(self, data: list[dict]) -> None:
        self.data = data
        self.creation_time = datetime.now()

    @property
    def cookies_txt(self) -> str:
        return _convert_cookies_to_txt(self.data)

    def write_cookies_txt(self, file_path: Path):
        file_path.write_text(self.cookies_txt, encoding="utf-8")

    @staticmethod
    def load(file_path: Path) -> "Cookies":
        assert file_path.suffix == ".pkl"
        return Cookies.from_pickle(file_path)

    def save(self, out_file: Path) -> None:
        # assert out_pickle_file.suffix == ".pkl"
        # self.to_pickle(out_pickle_file)
        suffix = out_file.suffix
        if suffix not in {".pkl", ".txt"}:
            raise ValueError(
                f"Unsupported file extension: {suffix}, options are: '.pkl', '.txt'"
            )
        parent = out_file.parent
        parent.mkdir(parents=True, exist_ok=True)
        if suffix == ".pkl":
            self.to_pickle(out_file)
        elif suffix == ".txt":
            self.write_cookies_txt(out_file)
        else:
            raise ValueError(f"Unsupported file extension: {suffix}")

    def __len__(self) -> int:
        return len(self.data)

    def __iter__(self) -> Iterator[dict]:
        return iter(self.data)

    def __repr__(self) -> str:
        return f"Cookies({self.data})"

    def __str__(self) -> str:
        return self.cookies_txt

    def to_pickle(self, file_path: Path) -> None:
        """
        Serialize the Cookies object to a pickle file.

        Args:
            file_path: Path where the pickle file will be saved
        """
        with open(file_path, "wb") as f:
            pickle.dump(self.data, f)

    @staticmethod
    def from_pickle(file_path: Path) -> "Cookies":
        """
        Create a Cookies object from a pickle file.

        Args:
            file_path: Path to the pickle file

        Returns:
            A Cookies object with data loaded from the pickle file

        Raises:
            FileNotFoundError: If the pickle file doesn't exist
            pickle.UnpicklingError: If the file contains invalid pickle data
        """
        with open(file_path, "rb") as f:
            data = pickle.load(f)
        return Cookies(data)
