.\" Automatically generated by Pandoc 3.6.2
.\"
.TH "sphinx" "1" "" "" "command\-line client for the SPHINX password manager"
.SH NAME
sphinx \- command\-line client for the SPHINX password manager
.SH SYNOPSIS
\f[CR]sphinx\f[R] init
.PP
echo \[lq]password\[rq] | \f[CR]sphinx\f[R] create <user> <site>
[<u><l><d><s>] [<size>] [<symbols>] [<target password>]
.PP
echo \[lq]password\[rq] | \f[CR]sphinx\f[R] get <user> <site>
.PP
echo \-e \[lq]oldpassword\[rq] | \f[CR]sphinx\f[R] change <user> <site>
[<u><l><d><s>] [<size>] [<symbols>] [<target password>]
.PP
[ echo \[lq]password\[rq] | ] \f[CR]sphinx\f[R] commit <user> <site>
.PP
[ echo \[lq]password\[rq] | ] \f[CR]sphinx\f[R] undo <user> <site>
.PP
[ echo \[lq]password\[rq] | ] \f[CR]sphinx\f[R] delete <user> <site>
.PP
\f[CR]sphinx\f[R] list <site>
.PP
\f[CR]sphinx\f[R] healthcheck
.PP
\f[CR]sphinx\f[R] qr [<svg>] [<key>]
.PP
In general if any operation requires a master(input) password, it is
expected on standard input, and any resulting account (output) password
is printed to standard output.
In the examples we use \f[CR]echo\f[R] but it is recommended to use
\f[CR]getpwd(1)\f[R] or similar tools to query and pass the input
password.
.SH DESCRIPTION
SPHINX \[en] password Store that Perfectly Hides from Itself (No
Xaggeration) \[en] is an information\-theoretically secure cryptographic
password storage protocol with strong security guarantees, as described
in the 2015 paper \[lq]Device\-Enhanced Password Protocols with Optimal
Online\-Offline Protection\[rq] by Jarecki, Krawczyk, Shirvanian, and
Saxena (https://ia.cr/2015/1099).
.PP
\f[CR]sphinx\f[R] is the command\-line client for the SPHINX protocol,
it provides access to all operations over the life\-cycle of a password:
init, create, get, change, undo, commit, delete.
Additionally it provides also operations that make this more
user\-friendly: listing of users associated with a host and export of
the configuration using a qr code.
.PP
\f[CR]sphinx\f[R] not only handles passwords, it is also able to handle
(T)OTP 2FA and age keys.
Additionally \- if installed \- \f[CR]sphinx\f[R] also provides access
to \f[CR]opaquestore(1)\f[R], a simple tool that allows one to store
secrets that need encrypted storage (like keys, phrases, or other data).
.SS INITIALIZING A CLIENT
.IP
.EX
sphinx init
.EE
.PP
This creates a new master key for the client, which is used to address
records on the sphinx server and authorize management operations on
those records.
.PP
You \f[B]SHOULD\f[R] back up and encrypt this master key.
.PP
If you want to use sphinx on a different device you want to copy this
master key also there.
For copying this (and other settings) to the android client
\f[CR]androsphinx\f[R] we have the \f[CR]qr\f[R] operation, see below.
.PP
This operation also creates a fixed healthcheck record on the server(s).
.SS CREATE PASSWORD
Creating a new password for a site is easy, pass your \[lq]master\[rq]
password on standard input to the client, and provide parameters like in
this example:
.IP
.EX
echo \-n \[aq]my input password\[aq] | sphinx create username example.com ulsd 0 \[aq] !\[dq]#$%&\[rs]\[aq]()*+,\-./:;<=>?\[at][\[rs]\[rs]]\[ha]_\[ga]{|}\[ti]\[aq]
.EE
.PP
The parameters to the client are
.IP \[bu] 2
Your input password on standard input.
Since the input password is not used to input anything, you can actually
use different input passwords for different user/site combinations.
(Unlike with traditional password managers which have one master
password that encrypts the whole database)
.IP \[bu] 2
\f[CR]create\f[R] for the operation, then
.IP \[bu] 2
\f[CR]username\f[R] for the username on
.IP \[bu] 2
the site \f[CR]example.com\f[R] then
.IP \[bu] 2
the password constraints, see sections \f[CR]PASSWORD RULES\f[R] and
\f[CR]PREDETERMINED PASSWORDS\f[R] for more info
.PP
If the command runs successfully \- the resulting new high\-entropy
output password according to the given rules is printed to the console.
.SS GET PASSWORD
Getting a password from the sphinx oracle works by running the following
command:
.IP
.EX
echo \-n \[aq]my master password\[aq] | sphinx get username example.com
.EE
.PP
You supply your master password on standard input, provide the
\f[CR]get\f[R] operation as the first parameter, your
\f[CR]username\f[R] as the 2nd and the \f[CR]site\f[R] as the 3rd
parameter.
The resulting password is returned on standard output.
.SS CHANGE PASSWORD
You might want to (or are forced to regularly) change your password,
this is easy while you can keep your master password unchanged (or you
can change it too, if you want).
The command is this:
.IP
.EX
echo \-en \[aq]my master password\[rs]nnew masterpassword\[aq] | sphinx change username example.com \[aq]ulsd\[aq] 0 \[aq] !\[dq]#$%&\[rs]\[aq]()*+,\-./:;<=>?\[at][\[rs]\[rs]]\[ha]_\[ga]{|}\[ti]\[aq]
.EE
.PP
You supply your current master password on standard input, and separated
by a new\-line you also provide the new master password.
The new master password can be the same as the old, but can also be a
new password if you want to change also the master password.
.PP
You provide the \f[CR]change\f[R] operation as the first parameter to
the client, your \f[CR]username\f[R] as the 2nd and the \f[CR]site\f[R]
as the 3rd parameter.
You also can provide similar password generation rule parameters that
were also used to create the original password, in case your account has
new password rules and you want/have to accommodate them.
For more information see the \f[CR]PASSWORD RULES\f[R] and
\f[CR]PREDETERMINED PASSWORDS\f[R] sections below.
.PP
Your new new password is returned on standard output.
\f[B]IMPORTANT\f[R] this only creates a new output password, but does
not activate it.
Running a \f[CR]get\f[R] operation will still respond with the previous
password, to activate the new password, you need to run a
\f[CR]commit\f[R] operation, see the next section:
.SS COMMITTING A CHANGED PASSWORD
After changing the password, you will still get the old password when
running the \f[CR]get\f[R] operation.
To switch to use the new password you have to commit the changes with
.IP
.EX
echo \-n \[aq]my master password\[aq] | sphinx commit username example.com
.EE
.PP
Depending on your \f[CR]rwd_keys\f[R] configuration setting, you might
have to provide your input password on standard input to this operation.
.PP
If all goes well, there is no output expected.
If anything goes wrong, there is going to be an error message and a
non\-zero exit\-code.
.SS UNDOING A PASSWORD COMMIT
If you somehow messed up and have to go back to use the old password,
you can undo committing your password using:
.IP
.EX
echo \-n \[aq]my master password\[aq] | sphinx undo username example.com
.EE
.PP
Depending on your \f[CR]rwd_keys\f[R] configuration setting, you might
have to provide your master password on standard input to this
operation.
.PP
If all goes well, there is no output expected, otherwise there will be
an error message and non\-zero exit\-code.
.SS DELETING PASSWORDS
In case you want to delete a password, you can do using the following
command:
.IP
.EX
echo \-n \[dq]my master password\[dq] | sphinx delete username example.com
.EE
.PP
You provide the \f[CR]delete\f[R] operation as the first parameter to
the client, your \f[CR]username\f[R] as the 2nd and the \f[CR]site\f[R]
as the 3rd parameter.
This command does not provide any output on the console in case
everything goes well, otherwise an error message and an non\-zero exit
code will signal a problem.
.PP
Depending on your \f[CR]rwd_keys\f[R] configuration setting, you might
have to provide your master password on standard input to this
operation.
.SS QR CODE CONFIG
In case you want to use phone with the same sphinx server, you need to
export your config to the phone via a QR code.
.IP
.EX
sphinx qr
.EE
.PP
Will display a QR code containing only public information \- like the
server host and port, and whether you use rwd_keys.
This is mostly useful if you want to share your setup with a friend or
family.
.PP
If you want to connect your own phone to the setup used with pwdsphinx,
you also need to export your client secret in the QR code:
.IP
.EX
sphinx qr key
.EE
.PP
This contains your client secret, and you should keep this QR code
confidential.
Make sure there is no cameras making copies of this while this QR code
is displayed on your screen.
.PP
If for whatever reason you want to display the QR code as an SVG, just
append the \f[CR]svg\f[R] keyword to the end of the \f[CR]sphinx qr\f[R]
command.
.SS HEALTHCHECK
If you have run the \f[CR]sphinx init\f[R] command, then this also has
created a fixed healthcheck record.
You can simply check if your setup is ok, by running a
\f[CR]sphinx healthcheck\f[R] operation.
You can also try doing the same by running a \f[CR]get\f[R] operation
like this:
.IP
.EX
echo \-n \[aq]all ok?\[aq] |  env/bin/sphinx get healthcheck \[dq]sphinx servers\[dq]
.EE
.PP
It should output \[lq]everything works fine\[rq].
The difference is, that the health check only fetches the ratelimiting
challenges from all servers and then aborts.
While the get request will affect your ratelimiting difficulty if done
to frequently.
.SS PASSWORD RULES
When creating or changing passwords you can specify rules limiting the
size and characters allowed in the output password.
This is specified as follows:
.PP
The letters \f[CR]ulsd\f[R] stand in order for the following character
classes: \- \f[CR]u\f[R] upper\-case letters, \- \f[CR]l\f[R]
lower\-case letters, \- \f[CR]s\f[R] symbols and \- \f[CR]d\f[R] for
digits.
.PP
The \f[CR]s\f[R] is a short\-cut to allow all of the symbols, if you are
limited by the server which symbols to use, you can specify the allowed
symbols explicitly.
Currently these are the symbols supported (note the leading space char):
.IP
.EX
 !\[dq]#$%&\[aq]()*+,\-./:;<=>?\[at][\[rs]]\[ha]_\[ga]{|}\[ti]
.EE
.PP
Be careful, if you specify these on the command\-line you\[cq]ll have to
escape the quotes you use for enclosing this list and possibly the
backslash char that is also part of this list.
In the \f[CR]create username\f[R] example above the symbols are
correctly escaped, in case you need to copy/paste them.
.PP
For examples how to use these see the section \[lq]CREATE PASSWORD\[rq]
or \[lq]CHANGE PASSWORD\[rq].
.SS DEFAULT RULES
If you do not provide password rules, they will be defaulting to `ulsd'
and length as long as possible, which means 77 characters long passwords
using all four character classes, providing 507 bits of entropy, way too
much.
.SS RECOMMENDED OUTPUT PASSWORD LENGTH
It is recommended to set the output password size to maximum 12 chars in
case of \f[CR]ulsd\f[R] classes enabled.
If you ever have to type in this output password on a TV remote, or in
other stressful situations this will be a big relief.
12 character long passwords with full entropy and consisting of all
possible printable ASCII chars are computationally impossible to
bruteforce on current password cracking hardware, as they provide almost
80 bits of entropy, and 15 characters almost 99 bits of entropy.
.SS PREDETERMINED OUTPUT PASSWORDS
In case for some reason you cannot use random passwords with your
account, or you want to store a \[lq]password\[rq] that you cannot
change, like a PIN code for example, or a passphrase shared with your
colleagues, you can specify a maximum 77 character long password, that
will be generated by the SPHINX client for you.
In that case the command line looks like this (note the same syntax also
works for the \f[CR]change\f[R] operation)
.IP
.EX
echo \-n \[aq]my master password\[aq] | sphinx create username example.com \[dq]correct_battery\-horse#staple\[dq]
.EE
.PP
In this case you cannot specify neither the accepted character classes,
nor the size, nor symbols, these will be deducted from the predetermined
password itself.
.SS Backward compatibility with v1 SPHINX servers/records
If you still have SPHINX records on the server that were generated using
v1, \- and you want to use them \-, you have to specify this server also
in the client section like you had to in v1.
If there is no record found with v2 get operations sphinx will attempt a
get request for a v1 style record.
If a v1 style record is found, a new v2 style record is created
automatically, so no need to check for v1 style records in this
particular case anymore.
.PP
Unless you use also other clients that are v1 onl (like androsphinx) v1
records that are upgraded to v2 can be automatically deleted after a
successful upgrade, for this set \f[CR]delete_upgraded\f[R] to true in
the \f[CR][client]\f[R] section of your sphinx configuration.
This helps server administrators by keeping their \[lq]DB\[rq] clean,
and having a means to see how many v1 records are still not upgraded.
.SS OUTPUT PLUGINS (TOTP & AGE)
It is possible to \[lq]store\[rq] TOTP secrets and age secret keys using
\f[CR]sphinx\f[R].
To store such a secret and have it automatically handled correctly
(e.g.\ TOTP verification code output instead of the secret) just prefix
your username with \f[CR]otp://\f[R] for TOTP support and with
\f[CR]age://\f[R] for age key support.
The latter, when queried will output a correctly formatted age private
key.
.PP
Currently the following converters are supported:
.SS TOTP
Import a TOTP secret
.IP
.EX
% getpwd \f[B]|\f[R] sphinx create otp://username example.com ABCDEF1234567890
.EE
.PP
Get a TOTP PIN:
.IP
.EX
% getpwd | sphinx get otp://username example.com
.EE
.SS minisign
Create a new key and store the public key at /tmp/minisig.pub:
.IP
.EX
% getpwd \[rs]
    \f[B]|\f[R] sphinx create minisig://user example.com >/tmp/minisig.pub
.EE
.PP
\f[CR]Create\f[R] and \f[CR]Change\f[R] SPHINX operations automatically
return a public key.
.PP
Sign a file \f[CR]filetosign\f[R]:
.IP
.EX
% getpwd \[rs]
    \f[B]|\f[R] sphinx get minisig://user example.com \[rs]
    \f[B]|\f[R] pipe2tmpfile minisign \-S \-s \[at]\[at]keyfile\[at]\[at] \-m filetosign
.EE
.PP
The \f[CR]Get\f[R] SPHINX operation returns a private key.
.SS Age
Generate an AGE key and store the public key:
.IP
.EX
% getpwd \[rs]
    \f[B]|\f[R] sphinx create age://user example.com >/tmp/age.pub
.EE
.PP
\f[CR]Create\f[R] and \f[CR]Change\f[R] SPHINX operations automatically
return a public key.
.PP
Decrypt a file using an AKE key from SPHINX:
.IP
.EX
% getpwd \[rs]
    \f[B]|\f[R] sphinx get age://user localhost \[rs]
    \f[B]|\f[R] pipe2tmpfile age \-\-decrypt \-i \[at]\[at]keyfile\[at]\[at] encryptedfile
.EE
.PP
The \f[CR]Get\f[R] SPHINX operation returns a private key.
.SS SSH\-ED25519
Create key and save public key:
.IP
.EX
% getpwd \[rs]
   \f[B]|\f[R] sphinx create ssh\-ed25519://test asdf >pubkey
.EE
.PP
\f[CR]Create\f[R] and \f[CR]Change\f[R] SPHINX operations automatically
return a public key.
.PP
Sign a file:
.IP
.EX
% getpwd \[rs]
   \f[B]|\f[R] sphinx get ssh\-ed25519://test asdf \[rs]
   \f[B]|\f[R] pipe2tmpfile ssh\-keygen \-Y sign \-n file \-f \[at]\[at]keyfile\[at]\[at] content.txt > content.txt.sig
.EE
.PP
The \f[CR]Get\f[R] SPHINX operation returns a private key.
.PP
Verify file with public key:
.IP
.EX
% ssh\-keygen \-Y check\-novalidate \-n file \-f /tmp/ssh\-ed.pubkey \-s /tmp/content.txt.sig </tmp/content.txt
.EE
.SS OPAQUE\-Store INTEGRATION
If you have opaque\-store (see https://github.com/stef/opaque\-store/)
installed and configured (see \f[CR]opaque\-stored.cfg(5)\f[R])
correctly you get a number of additional operations, which allow you to
store traditionally encrypted blobs of information.
The following operations will be available if opaque\-store is setup
correctly:
.IP
.EX
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx store <keyid> file\-to\-store
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx read <keyid>
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx replace [force] <keyid> file\-to\-store
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx edit [force] <keyid>
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx changepwd [force] <keyid>
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx erase [force] <keyid>
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx recovery\-tokens <keyid>
echo \-n \[aq]password\[aq] \f[B]|\f[R] sphinx unlock <keyid> <recovery\-token>
.EE
.SS How does OPAQUE\-Store SPHINX integration work
In all OPAQUE\-Store operations we first execute a SPHINX get operation,
that calculates the password which is used with OPAQUE.
This means that the input passwords for OPAQUE will be the strongest
possible and essentially un\-bruteforcable on their own (without
SPHINX).
Of course online bruteforce attacks are still possible going through
SPHINX.
But OPAQUE is able to detect wrong passwords and thus can lock your
record after a pre\-configured amount of failed attempts.
Of course this does not apply to the operator of an OPAQUE server, who
can circumvent the locking of records.
And thus:
.SS A WARNING: don\[cq]t let one entity control enough of your SPHINX and OPAQUE\-Store servers
As you can see every opaque\-store op needs a password on standard
input.
This password is run through SPHINX, and the output password is used in
the OPAQUE protocol as the input password.
This also means, that if you use a single server setup for both SPHINX
and OPAQUE\-Store, the two servers should not be controlled by the same
3rd party entity, otherwise this entity is able to offline\-bruteforce
your SPHINX master password.
If you use either of these services in a threshold setup, and these
threshold servers are controlled by different entities, you should be
ok, as long as no one controls a threshold number of oracles/servers.
.SS OPAQUE\-Store CLI Parameters
.SS KeyId
Every operation provided by the OPAQUE\-Storage (O\-S) integration needs
a \[lq]keyid\[rq] parameter, this references your record stored by O\-S.
Internally the client uses the configuration value \f[CR]id_salt\f[R],
together with the name of the O\-S server to hash the keyid parameter
into a record id for the O\-S Server.
This means, that if you lose or change your \f[CR]id_salt\f[R] parameter
or the name of the O\-S server, all your record ids will be different
and inaccessible.
So it is a good idea to make a backup of your configuration file
containing these.
Note this \f[CR]id_salt\f[R] doesn\[cq]t really have to be secret,
although it does provide another layer of security\-by\-obscurity if you
do so.
.SS Forced operations
In the case that you are using a threshold setup, some operations
(\f[CR]replace\f[R], \f[CR]edit\f[R], \f[CR]changepwd\f[R] and
\f[CR]erase\f[R]) require that all servers successfully participate in
the operation.
This is to avoid, that the records on temporarily unavailable servers
remain unchanged and lead later possibly to corruption.
If you are sure however that this is ok, you can provide a
\f[CR]force\f[R] parameter on the CLI which reduces the number of
servers successfully participating to the value of your
\f[CR]threshold\f[R] configuration setting.
.SS Store an encrypted blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx store <keyid> file\-to\-store
.EE
.PP
This simply does what it promises, stores the \f[CR]file\-to\-store\f[R]
encrypted on the OPAQUE\-Store server, using a password derived from
SPHINX.
Note that this command outputs also a recovery\-token, which you should
keep safe in case your record gets locked.
.SS Retrieving an encrypted opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx read <keyid>
.EE
.PP
Straightforward, no surprise.
This gets your previously stored record and displays it on standard
output.
.SS Overwrite an encrypted opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx replace [force] <keyid> file\-to\-store
.EE
.PP
Whatever has been stored at \f[CR]keyid\f[R] is now overwritten by an
encrypted \f[CR]file\-to\-store\f[R].
This only works, if there is already something stored at
\f[CR]keyid\f[R].
All servers must cooperate in this, if one or more are unavailable this
will fail, unless \f[CR]force\f[R] is specified and the threshold is
matched, in which case the servers unavailable will be corrupted from
this point on.
.SS Edit a opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx edit [force] <keyid>
.EE
.PP
This operation fetches the file stored at \f[CR]keyid\f[R] loads it into
your editor (specified by the \f[CR]EDITOR\f[R] environment variable)
and stores the changes and saved file back on the same \f[CR]keyid\f[R]
overwriting the original.
.SS Change your password on an opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx changepwd [force] <keyid>
.EE
.PP
This operation does a full change of passwords and keys.
Even if you don\[cq]t change your own password that you provide to
getpwd, SPHINX will change it\[cq]s own key, and thus change the output
password which will be used for the password in OPAQUE\-store finally
resulting in a whole new and fresh encryption key for your file which
gets re\-encrypted with that.
.SS Delete a stored opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx erase [force] <keyid>
.EE
.PP
Nothing surprising here, does what it promises, deletes the stored blob
referenced by the keyid.
.SS Get a recovery token
.IP
.EX
getpwd \f[B]|\f[R] sphinx recovery\-tokens <keyid>
.EE
.PP
If your record is not locked, this operation gets you an additional
recovery token.
.SS Unlock a locked opaquestore blob
.IP
.EX
getpwd \f[B]|\f[R] sphinx unlock <keyid> <recovery\-token>
.EE
.PP
If for some reason (someone online\-bruteforcing your record, or you
forgetting your master password) your record becomes locked by the
servers, you can unlock it using a recovery token.
This will also automatically retrieve the record \- unless you supply
the wrong password again.
.SH SPHINX CONFIGURATION
The client can be configured by any of the following files:
.IP \[bu] 2
\f[CR]/etc/sphinx/config\f[R]
.IP \[bu] 2
\f[CR]\[ti]/.sphinxrc\f[R]
.IP \[bu] 2
\f[CR]\[ti]/.config/sphinx/config\f[R]
.IP \[bu] 2
\f[CR]./sphinx.cfg\f[R]
.PP
Files are parsed in this order, this means global settings can be
overridden by per\-user and per\-directory settings.
.PP
The client can be configured changing the settings in the
\f[CR][client]\f[R] and the \f[CR][servers]\f[R] sections of the config
file.
.PP
The \f[CR]datadir\f[R] (default: \f[CR]\[ti]/.sphinx\f[R]) variable
holds the location for your client parameters.
Particularly it contains a masterkey which is used to derive secrets.
The master key \- if not available \- is generated by issuing an
\f[CR]init\f[R] command.
You \f[B]SHOULD\f[R] back up and encrypt this master key.
.PP
\f[CR]rwd_keys\f[R] toggles if the master password is required for
authentication of management operations.
.PP
The oracle is oblivious to this setting, this is purely a client\-side
toggle, in theory it is possible to have different settings for
different \[lq]records\[rq] on the oracle.
.PP
\f[CR]validate_password\f[R] Stores a check digit of 5 bits in on the
oracle, this helps to notice most typos of the master password, while
decreasing security slightly.
.PP
The \f[CR]userlist\f[R] option (default: True) can disable the usage of
userlists.
This prohibits the server to correlate all the records that belong to
the same sphinx user relating to the same host.
The cost of this, is that the user has to remember themselves which
usernames they have at which host.
.PP
Specify \f[CR]address\f[R] and \f[CR]port\f[R] for backward
compatibility with an old v1 server.
If there is no record found with v2 get operations sphinx will attempt a
v1 style get request and see if the record is available from \[lq]old
times\[rq].
If a v1 record is found a new v2 style record is created, so no need to
send a v1 get request for this particular record anymore.
.PP
\f[CR]delete_upgraded\f[R] enables automatic deletion of v1 records
after automatically upgrading them to v2 records.
Unless you use also other clients that are v1 only (like androsphinx)
this is the recommended setting, it removes crust and enables server
operators to see if their users are finally completely v2, and can
disable v1 support.
.PP
The \f[CR]threshold\f[R] option must specify the number of servers
necessary to operate sphinx.
If the \f[CR][servers]\f[R] section contains more than two entries, this
value must be greater than 1 and less than the number of servers listed
in the \f[CR][servers]\f[R] section: 1 < threshold < len(servers).
.PP
The \[ga][servers]\[cq] section contains subsections for each server
like this:
.IP
.EX
[servers]
[servers.zero]
host=\[dq]localhost\[dq]
port=10000
ltsigkey = \[dq]32byteBase64EncodedValue==\[dq]
.EE
.PP
The subsections all have the the format [server.\f[CR]name\f[R]].
This \f[CR]name\f[R] can be freely chosen and can be a public value.
it is \f[B]important\f[R] to never change it, as long as you want to
access your passwords on this server.
This name value is used together with other values to create unique
record IDs.
If you change the name the record IDs change, and you will not be able
to access your old records.
.PP
The \f[CR]host\f[R] and \f[CR]port\f[R] should match what you set (or
its admin publishes) in the \f[CR]oracle(1)\f[R] server.
The \f[CR]ltsigkey\f[R] is the servers long\-term signing key for
threshold operations this should be a base64 encoded value.
Alternatively you can also store the raw binary key in a file, which you
then specify using the \f[CR]ltsigkey_path\f[R] value instead.
This key only needed for threshold operation, if you use SPHINX in a
single\-server setting you don\[cq]t need this.
.SH SECURITY CONSIDERATIONS
You \f[B]SHOULD\f[R] back up and encrypt your master key.
Hint you could do this using the \f[CR]qr key\f[R] operation, recording
all the other important details as well.
Backing up your \f[CR]webauthn_data_dir\f[R] from the
\f[CR][websphinx]\f[R] section is also a good idea, in case you use the
webextension and webauthn.
.PP
The \f[CR]rwd_keys\f[R] configuration setting, if set to False protects
against offline master password bruteforce attacks \- which is also a
security guarantee of the original SPHINX protocol.
.PP
The drawback is that for known (host,username) pairs the according
record can be changed/deleted by an attacker if the clients masterkey is
available to them.
However neither the master nor the account password can leak this way.
This is merely a denial\-of\-service attack vector.
If \f[CR]rwd_keys\f[R] is set to True, then this eliminates the
denial\-of\-service vector, but also negates the offline\-bruteforce
guarantee of the SPHINX protocol.
This setting is really a compromise between availability of account
passwords versus the confidentiality of your master password.
.PP
The \f[CR]validate_password\f[R] configuration setting if enabled,
decreases security slightly (by 5 bits).
In general it should be safe to enable.
.PP
The \f[CR]userlist\f[R] configuration setting is by default enabled, and
allows a server operator to correlate records that belong to the same
SPHINX user on the same online service.
If you have multiple accounts on an online service and all of them are
handled by the same SPHINX server, the server operator can take note
when a userlist record is updated and which SPHINX record belongs to
this operation.
This leaks some information, that can be used by an adversarial server
operator to correlate records.
.PP
In this man page we are using echo only for demonstration, you should
use something like this instead (or even directly \f[CR]getpwd(1)\f[R]
from the contrib directory if you are not interested in customizing):
.IP
.EX
echo GETPIN | pinentry | grep \[aq]\[ha]D\[aq] | cut \-c3\- | sphinx create username example.com ulsd 0
.EE
.PP
Using pinentry you can go fancy and do double password input, and even
have something checking password quality for you, check it out, it\[cq]s
quite versatile.
.SH REPORTING BUGS
https://github.com/stef/pwdsphinx/issues/
.SH AUTHOR
Written by Stefan Marsiske.
.SH COPYRIGHT
Copyright © 2024 Stefan Marsiske.
License GPLv3+: GNU GPL version 3 or later \c
.UR https://gnu.org/licenses/gpl.html
.UE \c
\&.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
.SH SEE ALSO
https://www.ctrlc.hu/\[ti]stef/blog/posts/sphinx.html
.PP
https://www.ctrlc.hu/\[ti]stef/blog/posts/oprf.html
.PP
https://github.com/stef/opaque\-store/
.PP
\f[CR]oracle(1)\f[R], \f[CR]getpwd(1)\f[R], \f[CR]opaquestore(1)\f[R]
