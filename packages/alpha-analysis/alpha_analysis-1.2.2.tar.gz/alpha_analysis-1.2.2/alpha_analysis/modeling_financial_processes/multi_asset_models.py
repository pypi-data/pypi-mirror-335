import numpy as np


class MultiAssetGBM:
    def __init__(self, mu, sigma, rho, S0):
        """
        Инициализация модели для нескольких активов с использованием геометрического Брауновского процесса.

        :param mu: Список дрейфов (средняя доходность) для каждого актива
        :param sigma: Список волатильностей для каждого актива
        :param rho: Матрица корреляций между активами
        :param S0: Начальные цены активов (список)
        """
        self.mu = np.array(mu)  # Средняя доходность для каждого актива
        self.sigma = np.array(sigma)  # Волатильности для каждого актива
        self.rho = np.array(rho)  # Матрица корреляций между активами
        self.S0 = np.array(S0)  # Начальные цены активов

    def simulate(self, T, dt, n_steps):
        """
        Симуляция траектории цен нескольких активов с использованием геометрического Брауновского процесса.

        :param T: Время (например, 1 год)
        :param dt: Шаг по времени
        :param n_steps: Количество шагов (например, 252 для ежедневных шагов)

        :return: Массив с симулированными ценами активов
        """
        n_assets = len(self.mu)
        n = int(T / dt)  # Количество шагов по времени

        # Массив для хранения цен активов на каждом шаге
        S = np.zeros((n_assets, n_steps))
        S[:, 0] = self.S0  # Начальные значения для всех активов

        # Генерация случайных величин для винеровских процессов с учетом корреляции
        # Для этого используем хирархию независимых случайных величин
        L = np.linalg.cholesky(self.rho)  # Разложение матрицы корреляций

        for i in range(1, n_steps):
            # Генерация случайных величин для каждого актива
            z = np.random.normal(0, 1, n_assets)
            correlated_z = L @ z  # Перемножаем с матрицей Лупа (корреляция)

            # Обновление цен активов на каждом шаге
            for j in range(n_assets):
                dW = correlated_z[j] * np.sqrt(dt)  # Случайная величина для актива j
                dS = self.mu[j] * S[j, i - 1] * dt + self.sigma[j] * S[j, i - 1] * dW
                S[j, i] = S[j, i - 1] + dS

        return S


# Пример использования

if __name__ == "__main__":
    # Параметры для модели с несколькими активами
    mu = [0.05, 0.03]  # Средняя доходность для двух активов
    sigma = [0.2, 0.15]  # Волатильности для двух активов
    rho = [[1.0, 0.5],  # Матрица корреляций между активами
           [0.5, 1.0]]
    S0 = [100, 50]  # Начальные цены активов

    # Создание объекта модели для нескольких активов
    multi_asset_gbm = MultiAssetGBM(mu, sigma, rho, S0)

    # Симуляция траектории
    T = 1  # Время до окончания (1 год)
    dt = 1 / 252  # Шаг по времени (252 торговых дня в году)
    n_steps = 252  # Количество шагов (252 для ежедневных шагов)

    # Генерация симулированных траекторий
    S_sim = multi_asset_gbm.simulate(T, dt, n_steps)

    # Результаты симуляции
    print(S_sim)
