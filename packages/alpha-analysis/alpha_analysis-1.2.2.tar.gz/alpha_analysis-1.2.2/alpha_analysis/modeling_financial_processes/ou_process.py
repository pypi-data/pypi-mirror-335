import numpy as np


class OUProcess:
    def __init__(self, mu, theta, sigma, X0):
        """
        Инициализация модели процесса Ора-Улма (OU-процесс).

        :param mu: Долгосрочное среднее значение процесса
        :param theta: Скорость возвращения к среднему
        :param sigma: Волатильность процесса
        :param X0: Начальное значение процесса
        """
        self.mu = mu  # Долгосрочное среднее значение
        self.theta = theta  # Скорость возвращения
        self.sigma = sigma  # Волатильность
        self.X0 = X0  # Начальное значение процесса

    def simulate(self, T, dt, n_steps):
        """
        Симуляция траектории процесса Ора-Улма.

        :param T: Время (например, 1 год)
        :param dt: Шаг по времени
        :param n_steps: Количество шагов (например, 252 для ежедневных шагов)

        :return: Массив с симулированными значениями процесса
        """
        n = int(T / dt)  # Число шагов по времени

        # Массив для хранения значений процесса
        X = np.zeros(n_steps)
        X[0] = self.X0  # Начальное значение

        # Генерация случайных величин для винеров процесса
        for i in range(1, n_steps):
            dW = np.random.normal(0, np.sqrt(dt))  # Генерация случайной величины dW_t
            dX = self.theta * (self.mu - X[i - 1]) * dt + self.sigma * dW  # Изменение процесса
            X[i] = X[i - 1] + dX  # Обновление значения процесса

        return X


# Пример использования

if __name__ == "__main__":
    # Параметры для модели OU-процесса
    mu = 0.05  # Долгосрочное среднее значение
    theta = 0.1  # Скорость возвращения к среднему
    sigma = 0.2  # Волатильность
    X0 = 0.03  # Начальное значение процесса

    # Создание объекта OU-процесса
    ou_process = OUProcess(mu, theta, sigma, X0)

    # Симуляция траектории
    T = 1  # Время до окончания (1 год)
    dt = 1 / 252  # Шаг по времени (252 торговых дня в году)
    n_steps = 252  # Количество шагов (252 для ежедневных шагов)

    # Генерация симулированной траектории
    X_sim = ou_process.simulate(T, dt, n_steps)

    # Результат можно вывести или использовать далее для анализа
    print(X_sim)
