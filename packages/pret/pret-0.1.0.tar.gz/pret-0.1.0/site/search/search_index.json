{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#getting-started-with-pret","title":"Getting started with Pret","text":"<p>Pret is a library for building full-stack reactive user interfaces in Python, using React as a rendering engine.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install \"pret[joy]\"  --user\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Python, only Python: pret is written in Python: you can write your both your UI and server actions Python. No need to learn a new language, or to use a transpiler.</li> <li>Client-side rendering: unlike other Python UI frameworks, pret runs primarily in the browser. This enables a fast response time to user actions (like hover events), and a better user experience under degraded network conditions.</li> <li>Built on React: pret uses React as a rendering engine, and benefits from its ecosystem.</li> <li>Reactive: unlike other solutions like ipywidgets, pret is reactive. Only the parts of the UI that need to be updated are re-rendered.</li> <li>State management: in addition to React's local state management (i.e. <code>use_state</code>), pret provides a global and modular state management solution that is synchronized both between components, and between the client and the server.</li> <li>Modular: pret is designed to be modular. You can easily create your own components, and reuse them in other pret-based projects.</li> <li>Integrated with Jupyter: pret components can be used in Jupyter notebooks, as well as in standalone web applications.</li> <li>Remote execution: pret can call and use the result of Python functions on the server from the browser</li> </ul>"},{"location":"#use-it-in-a-notebook","title":"Use it in a notebook","text":"<p>Let's write a simple todo app that should:</p> <ul> <li>display a list of todos, that can be checked as done</li> <li>display the number remaining todos</li> <li>change the font to bold as a todo is hovered</li> <li>allow editing the todo list directly in Python</li> </ul> <p>Copy and paste the following code in a notebook:</p> <pre><code>from pret import component, proxy, run, use_state, use_tracked\nfrom pret.ui.joy import Checkbox, Input, Stack, Typography\n\nstate = proxy(\n    {\n        \"faire \u00e0 manger\": True,\n        \"faire la vaisselle\": False,\n    },\n    remote_sync=True,\n)\n\n\n@component\ndef TodoApp():\n    todos = use_tracked(state)\n    typed, set_typed = use_state(\"\")\n    num_remaining = sum(not ok for ok in todos.values())\n    plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n    def on_key_down(event):\n        if event.key == \"Enter\":\n            todos[typed] = False\n            set_typed(\"\")\n\n    return Stack(\n        *(\n            Checkbox(\n                label=todo,\n                checked=ok,\n                on_change=lambda e, t=todo: todos.update({t: e.target.checked}),\n            )\n            for todo, ok in todos.items()\n        ),\n        Input(\n            value=typed,\n            on_change=lambda event: set_typed(event.target.value),\n            on_key_down=on_key_down,\n            placeholder=\"Add a todo\",\n        ),\n        Typography(\n            f\"Number of unfinished todo{plural}: {num_remaining}\",\n            sx={\"minWidth\": \"230px\"},  # just to avoid jittering when it's centered\n        ),\n        spacing=2,\n        sx={\"m\": 1},\n    )\n\n\nTodoApp()\n</code></pre> <p>In comparison, the closest alternative using ipywidgets looks like the following snippet:</p> IPyWidget's implementation <pre><code>import ipywidgets as widgets\n\nstate = {\n    \"faire \u00e0 manger\": True,\n    \"faire la vaisselle\": False,\n}\n\n\nclass IPWTodoApp:\n    def __init__(self):\n        self.box = widgets.VBox()\n        self.render()\n\n    def _repr_mimebundle_(self, *args, **kwargs):\n        return self.box._repr_mimebundle_(*args, **kwargs)\n\n    def render(self, *args, **kwargs):\n        num_remaining = sum([not checked for _, checked in state.items()])\n        plural = \"s\" if num_remaining &gt; 1 else \"\"\n\n        def on_input_submit(sender):\n            state[input_widget.value] = False\n            self.render()\n\n        def create_todo_item(todo, checked):\n            def update_todo_status(*args, **kwargs):\n                state[todo] = checkbox.value\n                self.render()\n\n            checkbox = widgets.Checkbox(\n                value=checked,\n                description=todo,\n                disabled=False,\n                indent=False,\n            )\n            checkbox.observe(update_todo_status, names=\"value\")\n            return checkbox\n\n        input_widget = widgets.Text(\n            placeholder=\"Add a todo\",\n            description=\"\",\n            disabled=False,\n        )\n        input_widget.on_submit(on_input_submit)\n\n        self.box.children = [\n            *(create_todo_item(todo, checked) for todo, checked in state.items()),\n            input_widget,\n            widgets.Label(value=f\"Number of unfinished todo{plural}: {num_remaining}\"),\n        ]\n\n\nIPWTodoApp()\n</code></pre> <p>You also lose some features:</p> <ul> <li>the app stops working if the server shuts down</li> <li>hover events cannot be listened to</li> <li>no React dom diffing: the app must either be re-rendered entirely (as in the example),   or you must determine specifically which field of which widget to update</li> </ul>"},{"location":"#use-it-in-a-standalone-app","title":"Use it in a standalone app","text":"<p>You can also use pret to build standalone web applications. Copy the above code in a file named <code>app.py</code>, and change the last line to</p> <pre><code>if __name__ == \"__main__\":\n    run(TodoApp)\n</code></pre> <p>Then, run the following command, and voil\u00e0 !</p> <pre><code>python app.py\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>Here are step-by-step guides to get you started.</p> <p> Your first component</p><p>Learn the basics of composing a UI component with Pret.</p><p> Sharing state</p><p>Learn how to manage the state of your app and share it between multiple components.</p><p> Tic Tac Toe</p><p>Building what we have learned in the previous tutorials, let's build a Tic Tac Toe game.</p><p> Interacting with the server</p><p>Learn how to run server-side code and interact with the server from the client, and vice-versa.</p>"},{"location":"tutorials/create-your-first-component/","title":"Your first component","text":""},{"location":"tutorials/create-your-first-component/#your-first-component","title":"Your first component","text":"<p>Let's create a first UI component with Pret. We will start simple, with the \"Hello World\" of UI components: a Todo list.</p> <p>Pret is a declarative UI library, which means that you describe the UI you want, and Pret takes care of rendering it for you. Under the hood, we use React and React libraries to render the UI.</p>"},{"location":"tutorials/create-your-first-component/#composing-components","title":"Composing components","text":"<p>Our app should be able to display a list of todos, where each todo is described by a text and a boolean indicating whether it is done or not. Let's use Joy's Checkbox for this:</p> <pre><code>from pret.ui.joy import Checkbox\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n)\n</code></pre> <p>Great ! We successfully declared and rendered our first component. Let's make it a list. We will use the Stack component to stack multiple components vertically. To compose components, we pass checkboxes as positional arguments (or a list) to the Stack component, and Pret will render them as children of the Stack component.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\n\nStack(\n    Checkbox(label=\"My first todo\", checked=True),\n    Checkbox(label=\"My second todo\", checked=False),\n)\n</code></pre> <p>Instead of hardcoding the todos, we can use a list of todos and a loop to render them:</p> <pre><code>from pret.ui.joy import Checkbox, Stack\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\nStack(\n    [\n        Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n        for todo in todos\n    ],\n    spacing=2,\n)\n</code></pre> <p>We can turn this into a TodoList component, so that we can reuse it later:</p> <pre><code>from pret import component\n\n\n@component\ndef TodoList(todos):\n    return Stack(\n        [\n            Checkbox(label=todo[\"text\"], checked=todo[\"done\"])\n            for todo in todos\n        ],\n        spacing=2,\n    )\n\n\nTodoList(todos=todos)  # (1)!\n</code></pre> <ol> <li>Here, <code>todos</code> are not children components but parameters of the <code>TodoList</code> component, also known as <code>props</code> in React, so we pass them as keyword arguments. In fact, passing them as positional arguments would raise an error.</li> </ol>"},{"location":"tutorials/create-your-first-component/#reacting-to-events","title":"Reacting to events","text":"<p>Now that we have a list of todos, we want to be able to mark them as done or not. We can use the <code>on_change</code> event of the Checkbox component to react to changes. For now, let's just make a popup appear when a todo is checked or unchecked.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\nfrom pret.bridge import js  # (1)!\n\n\ndef on_change(event):\n    checked = event.target.checked\n    js.alert(f\"Todo {'checked' if checked else 'unchecked'}\")\n\n\nCheckbox(\n    label=\"My first todo\",\n    checked=True,\n    on_change=on_change,\n)\n</code></pre> <ol> <li>We import the <code>js</code> object from the <code>pret.bridge</code> module. This object allows us to interact with the browser's JavaScript global variables, such as <code>alert</code>.</li> </ol>"},{"location":"tutorials/create-your-first-component/#adding-state","title":"Adding state","text":"<p>Our app is still a bit static : you may have noticed that you cannot change the value of the checboxes. We need to add state to our app to keep track of the todos' state. Let's start simple by making a Counter component that increments a counter each time a button is clicked. We can use the <code>use_state</code> hook, which allows us to create a state variable that will persist across renders (calls of our component) and trigger a re-render when its value changes.</p> <pre><code>from pret.ui.joy import Button, Typography, Stack\nfrom pret import component, use_state\n\n\n@component\ndef Counter():\n    count, set_count = use_state(0)\n\n    def increment(event):\n        set_count(count + 1)\n\n    return Stack(\n        [\n            Button(\"Increment\", on_click=increment),\n            Typography(f\"Count: {count}\"),\n        ],\n        spacing=2,\n    )\n\nCounter()\n</code></pre> <p>As you can see, every time you click the button, the state changes which triggers a re-render of the component. This is how we can make our TodoList component interactive. We will use the <code>use_state</code> hook to keep track of the todos' state.</p> <pre><code>from pret.ui.joy import Checkbox, Stack\nfrom pret import use_state, component\n\ntodos = [\n    {\"text\": \"My first todo\", \"done\": True},\n    {\"text\": \"My second todo\", \"done\": False},\n]\n\n@component\ndef TodoList(todos):\n    todos, set_todos = use_state(todos)\n\n    def on_change(event, index):\n        new_todos = list(todos)\n        new_todos[index] = {**todos[index], \"done\": event.target.checked}\n        set_todos(new_todos)\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=(lambda index: lambda event: on_change(event, index))(index),\n            )\n            for index, todo in enumerate(todos)\n        ],\n        spacing=2,\n    )\n\nTodoList(todos=todos)\n</code></pre>"},{"location":"tutorials/interacting-with-the-server/","title":"Interacting with the server","text":""},{"location":"tutorials/interacting-with-the-server/#interacting-with-the-server","title":"Interacting with the server","text":"<p>In this tutorial, we'll see the difference between server-side and client-side code in Pret, and how to interact with the server from your app.</p>"},{"location":"tutorials/interacting-with-the-server/#client-side-environment","title":"Client-side environment","text":"<p>When you build a Pret app, you are building a web application that will run in the browser. By default, in Pret, any function used in a rendered component will be sent to the browser and executed with Pyodide. While this is a powerful feature, this means that this function doesn't have access to your server-side environment, such as your database, filesystem or computing resources.</p> <p>For instance, let's take a look at the following component:</p> <pre><code>from pret import component\nfrom pret.ui.react import br\nimport os\n\nstatic_cwd = os.getcwd()\n\ndef dynamic_cwd():\n    return os.getcwd()\n\n@component\ndef ShowCurrentWorkingDirectory():\n    return [\n        f\"Current working dir when this App was built: {static_cwd}\",\n        br(),\n        f\"Current working dir when this App is rendered: {dynamic_cwd()}\",\n    ]\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>The \"dynamic\" displayed path will be the one from the browser's pyodide environment. In fact, these docs are hosted as a static website on GitHub Pages, so there is no server-side environment to access during the rendering process. The \"static\" path will be the one from the server-side environment, computed when the component is built and sent as a constant to the browser.</p>"},{"location":"tutorials/interacting-with-the-server/#running-server-side-code","title":"Running server-side code","text":"<p>To tell Pret to run a function on the server-side, you can decorate a function with <code>@server_only</code>. In this case, any call to this function from a client-side function will actually trigger a call to the server, and the result will be sent back to the client asynchronously.</p> <p>Async functions</p> <p>Any function decorated with <code>@server_only</code> becomes an async function from the client's perspective. This means that you must use <code>await</code> on the result of this function to get the actual return value.</p> <p>At the moment, it is not possible to directly await the result of the server function in the rendering function. Therefore, in the example below, we combine <code>@server_only</code> with <code>use_effect</code> to update the displayed current server working directory once it has been fetched from the server.</p> <pre><code>from pret import server_only, use_effect, use_memo, use_state\nfrom pret import component\nfrom pret.ui.react import br\nimport os\nfrom asyncio import sleep\n\n@server_only\ndef dynamic_server_cwd():\n    return os.getcwd()\n\ndef dynamic_client_cwd():\n    return os.getcwd()\n\nstatic_cwd = os.getcwd()\n\n@component\ndef ShowCurrentWorkingDirectory():\n    server_cwd, set_server_cwd = use_state(\"undefined\")\n\n    async def on_load():\n        set_server_cwd(await dynamic_server_cwd())\n\n    use_effect(on_load, [])\n\n    return [\n        f\"Current working dir when this App was built: {static_cwd}\",\n        br(),\n        f\"Current CLIENT working dir when this App is rendered: {dynamic_client_cwd()}\",\n        br(),\n        f\"Current SERVER working dir when this App is rendered: {server_cwd}\",\n    ]\n\nShowCurrentWorkingDirectory()\n</code></pre> <p>Since this app is hosted on GitHub Pages, there is no server-side environment to access. However, you can run this code in a notebook to see the difference between the client and server working directories.</p>"},{"location":"tutorials/interacting-with-the-server/#synchronizing-client-and-server-side-states","title":"Synchronizing client and server-side states","text":"<p>In the last Sharing state tutorial, we saw how to create a shared state between components with <code>state = proxy(...)</code>. This shared state is stored in the browser's memory, and is not accessible from the server. This means that once you have executed your app, the <code>state</code> variable in your notebook will not be updated when the state in the browser is updated.</p> <p>Pret offers a simple way to synchronize the state between the client and the server, by using the <code>remote_sync</code> option in the <code>proxy</code> function. This option will keep both server and client states in sync whenever one of them is updated.</p> <pre><code>from pret.ui.joy import Button, Typography, Stack\nfrom pret import component, proxy\nfrom pret.hooks import use_tracked\n\nstate = proxy({\n    \"count\": 0,\n}, remote_sync=True)\n\n@component\ndef Counter():\n    tracked = use_tracked(state)\n\n    def increment(event):\n        state[\"count\"] += 1\n\n    return Button(f\"Count: {tracked['count']}. Click to increment\", on_click=increment)\n\nCounter()\n</code></pre> <p>In your notebook, you can now change the <code>state[\"count\"]</code> variable in another cell, and observe the change in the browser. Conversely, you can click the \"Increment\" button in the browser, and print the <code>state[\"count\"]</code> variable in your notebook to see the change.</p> <pre><code># Show the current count, synchronized with the browser\nprint(state[\"count\"])\n\n# Change the count from the notebook\nstate[\"count\"] = 42\n</code></pre>"},{"location":"tutorials/metanno/","title":"Metanno","text":""},{"location":"tutorials/metanno/#metanno","title":"Metanno","text":"<p>Metanno is a library for building annotation tools. It is built on top of Pret library, and provides a set of components for viewing and editing annotations in tables, texts and images.</p> <p>Let's use Metanno to view a small list of objects in a table.</p> <pre><code>from pret.ui.metanno import TableComponent\n\nTableComponent(\n    rows=[\n        {\"name\": \"Alice\", \"age\": 25, \"fries_liker\": True, \"city\": \"Paris\"},\n        {\"name\": \"Bob\", \"age\": 30, \"fries_liker\": False, \"city\": \"London\"},\n        {\"name\": \"Charlie\", \"age\": 35, \"fries_liker\": True, \"city\": \"New York\"},\n        {\"name\": \"David\", \"age\": 40, \"fries_liker\": False, \"city\": \"Paris\"},\n        {\"name\": \"Eve\", \"age\": 45, \"fries_liker\": True, \"city\": \"London\"},\n        {\"name\": \"Frank\", \"age\": 50, \"fries_liker\": False, \"city\": \"New York\"},\n        {\"name\": \"Grace\", \"age\": 55, \"fries_liker\": True, \"city\": \"Paris\"},\n        {\"name\": \"Helen\", \"age\": 60, \"fries_liker\": False, \"city\": \"London\"},\n        {\"name\": \"Ivan\", \"age\": 65, \"fries_liker\": True, \"city\": \"New York\"},\n    ],\n    columns=[\n        {\"key\": \"name\", \"name\": \"Name\", \"kind\": \"text\"},\n        {\"key\": \"age\", \"name\": \"Age\", \"kind\": \"number\"},\n        {\"key\": \"fries_liker\", \"name\": \"Likes fries\", \"kind\": \"boolean\", \"editable\": True},\n        {\"key\": \"city\", \"name\": \"City\", \"kind\": \"text\", \"choices\": [\"Paris\", \"London\", \"New York\"], \"editable\": True},\n    ],\n    row_key=\"name\",\n)\n</code></pre>"},{"location":"tutorials/sharing-state/","title":"Sharing state","text":""},{"location":"tutorials/sharing-state/#sharing-state","title":"Sharing state","text":"<p>In the previous tutorial, we have seen how to compose a simple component from other components, how to render it, and detect user events. In this tutorial, we will see how to share state between components.</p>"},{"location":"tutorials/sharing-state/#proxy-state","title":"Proxy state","text":"<p>Why is state management hard in web development? The dynamic nature of user interfaces means multiple components must reflect and react to shared, constantly changing data without falling into the pitfalls of inefficient re-renders (e.g, you recompute the whole app UI whenever a single state variable changes), or convoluted data flows (e.g., state being passed through many layers of components that don\u2019t even use it). Traditional approaches, like Redux, often introduce layers of boilerplate and require careful architecture to avoid performance issues and maintain clarity.</p> <p>There is another issue of immutability: we cannot mutate the state directly (e.g., <code>state.todos[0][\"done\"] = True</code>), since React, and thus Pret, relies on shallow comparison to detect changes in the state. For instance, if <code>todos</code> is the same object, even though its content has changed, React will consider that the state has not changed and will not trigger a re-render.</p> <p>And if we take care of preventing direct mutations, changing the state can be cumbersome. For instance, if we want to change the <code>done</code> field of the first todo, we would have to do something like this:</p> <pre><code>new_todos = list(todos)\nnew_todos[0] = {**todos[0], \"done\": True}\n\n# We now have todos != new_todos and\n# todos[i] == new_todos[i] for all i except 0\n</code></pre> <p>Pret takes inspiration from valtio and provides a simple way to manage state in your components. A state object can be created an shared between components. Access to the states and mutations are recorded, such that the app knows which component should be re-rendered when a given part of the state changes.</p> <p>To create a state object, we use the <code>proxy</code> wrapper:</p> <pre><code>from pret import proxy\nfrom pret.state import subscribe\n\nstate = proxy(\n    {\n        \"todos\": [\n            {\"text\": \"My first todo\", \"done\": True},\n            {\"text\": \"My second todo\", \"done\": False},\n        ],\n    }\n)\n\nsubscribe(state, callback=lambda ops: print(ops))\nstate[\"todos\"][1][\"done\"] = True\n# prints: [['__setitem__', ['todos', 1, 'done'], True]]\n</code></pre> <p>Supported types</p> <p>At the moment, not all types can be used in a Pret proxy state. We focus on supporting the most common container types, such as lists and dictionaries, in addition to the basic types (int, float, str, bool, None).</p>"},{"location":"tutorials/sharing-state/#using-state-in-components","title":"Using state in components","text":"<p>Now that we have a state object, we can use it in our components. To let Pret know that a component should re-render when a part of the state changes, we use the <code>use_tracked</code> hook, which returns a snapshot of the state. This hook tracks access made on the state, and if a mutation on a part of the state that was accessed is detected :</p> <ul> <li>the component will re-render</li> <li>the snapshot will be different from the previous one (meaning, we don't have the <code>new_todos is todos</code> issue mentioned earlier)</li> </ul> <pre><code>from pret import component, use_tracked, proxy\nfrom pret.ui.joy import Checkbox, Stack\n\nstate = proxy({\n    \"todos\": [\n        {\"text\": \"My first todo\", \"done\": True},\n        {\"text\": \"My second todo\", \"done\": False},\n    ],\n})\n\n\n@component\ndef TodoList():  # (1)!\n    todos = use_tracked(state[\"todos\"])\n\n    def on_change(event, todo):\n        todo[\"done\"] = event.target.checked\n\n    return Stack(\n        [\n            Checkbox(\n                label=todo[\"text\"],\n                checked=todo[\"done\"],\n                on_change=lambda event, todo=todo: on_change(event, todo),\n            )\n            for todo in todos\n        ],\n        spacing=2,\n    )\n\n\nTodoList()\n</code></pre> <ol> <li>Note that we don't pass the <code>todos</code> as an argument to the <code>TodoList</code> component anymore. Instead, we use the <code>use_tracked</code> hook to directly subscribe to the global <code>state</code> object.</li> </ol>"},{"location":"tutorials/sharing-state/#sharing-state-between-components","title":"Sharing state between components","text":"<p>Sharing state between components is now straightforward. Let's display the number of remaining todos in the list. We will use the same <code>state</code> object as the component above.</p> <pre><code>from pret.ui.joy import Typography\nfrom pret.ui.react import br\n\n@component\ndef RemainingTodoCounter():\n    todos = use_tracked(state[\"todos\"])\n    num_remaining = sum(not todo[\"done\"] for todo in todos)\n\n    return Typography(\n        f\"Number of unfinished todos: {num_remaining}.\",\n        br(),\n        \"Click todos in the previous component to change the count.\",\n    )\n\nRemainingTodoCounter()\n</code></pre>"},{"location":"tutorials/tictactoe/","title":"TicTacToe","text":""},{"location":"tutorials/tictactoe/#tictactoe","title":"TicTacToe","text":"<p>Let's build a simple TicTacToe game using Pret. We will build a simple game where two players can play against each other.</p> <pre><code>from pret import proxy, component\nfrom pret.ui.react import button, div\nfrom pret.hooks import use_tracked\n\nstate = proxy({\n    \"board\": [0] * 9,\n    \"turn\": 1,\n    \"winning_pattern\": [],\n})\n\nwinning_patterns = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [6, 4, 2],\n]\n\nSQUARE_STYLE = {\n    \"display\": \"flex\",\n    \"justifyContent\": \"center\",\n    \"alignItems\": \"center\",\n    \"width\": \"60px\",\n    \"height\": \"60px\",\n    \"margin\": \"2px\",\n    \"fontSize\": \"24px\",\n    \"padding\": \"0\",\n    \"appearance\": \"none\",\n    \"border\": \"1px solid grey\",\n}\n\nWINNING_SQUARE_STYLE = {\n    **SQUARE_STYLE,\n    \"background\": \"lightGreen\",\n}\n\nGRID_STYLE = {\n    \"display\": \"grid\",\n    \"gridTemplateColumns\": \"repeat(3, 66px)\",\n    \"gridGap\": \"2px\",\n}\n\n\n@component\ndef TicTacToe():\n    tracked = use_tracked(state)\n    winning_pattern = tracked[\"winning_pattern\"]\n\n    def on_click_square(idx):\n        # if the game is over, clean everything on click\n        if state[\"winning_pattern\"] or 0 not in state[\"board\"]:\n            print(\"winning\", state[\"winning_pattern\"], \"no zero\", 0 not in state[\"board\"])\n            state[\"board\"][:] = [0] * 9\n            state[\"winning_pattern\"] = []\n            return\n\n        # place a piece on the board\n        value = state[\"board\"][idx]\n        if value == 0:\n            state[\"board\"][idx] = state[\"turn\"]\n        state[\"turn\"] = 2 if state[\"turn\"] == 1 else 1\n\n        # check for victory\n        for pattern in winning_patterns:\n            players = set(state[\"board\"][i] for i in pattern)\n            if len(players) == 1 and 0 not in players:\n                state[\"winning_pattern\"] = pattern\n\n    return div(\n        [\n            button(\n                \"X\" if square == 2 else \"O\" if square == 1 else \"\",\n                on_click=lambda event, idx=idx: on_click_square(idx),\n                style=(\n                    WINNING_SQUARE_STYLE\n                    if idx in winning_pattern else\n                    SQUARE_STYLE\n                ),\n            )\n            for idx, square in enumerate(tracked[\"board\"])\n        ],\n        style=GRID_STYLE,\n    )\n\n\nTicTacToe()\n</code></pre>"},{"location":"reference/pret/","title":"Overview","text":""},{"location":"reference/pret/#pret","title":"<code>pret</code>","text":""},{"location":"reference/pret/#pret.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/#pret.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/#pret.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>CallbackType</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/#pret.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/#pret.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], FunctionReturnType]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/#pret.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p>"},{"location":"reference/pret/#pret.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>RefValueType</code> </p> RETURNS DESCRIPTION <code>RefType[RefValueType]</code> <p>The ref object</p>"},{"location":"reference/pret/#pret.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/#pret.use_state--examples","title":"Examples","text":"<pre><code>from pret.ui.react import div, button, p\nfrom pret import component, use_state\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/#pret.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>StateValueType</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/#pret.use_tracked","title":"<code>use_tracked</code>","text":"<p>This hook is used to track the access made on a proxy object. You can also use the returned object to change the proxy object.</p>"},{"location":"reference/pret/#pret.use_tracked--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A proxy object, like the one returned by <code>proxy({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked proxy object</p>"},{"location":"reference/pret/#pret.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/#pret.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>CallbackType</code> </p> RETURNS DESCRIPTION <code>CallbackType</code> <p>The wrapped callback function</p>"},{"location":"reference/pret/bridge/","title":"<code>pret.bridge</code>","text":""},{"location":"reference/pret/cli/","title":"<code>pret.cli</code>","text":""},{"location":"reference/pret/cli/prepack_command/","title":"<code>pret.cli.prepack_command</code>","text":""},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack","title":"<code>prepack</code>","text":"<p>Pre-packs a stub module into a single javascript file.</p>"},{"location":"reference/pret/cli/prepack_command/#pret.cli.prepack_command.prepack--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>stub_module</code> <p>The name of the stub module to prepack.</p> <p> TYPE: <code>str</code> </p> <code>output_path</code> <p>The path to the output file.</p> <p> TYPE: <code>str</code> </p> <code>cwd</code> <p>Whether to add the current working directory to the python path.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p>"},{"location":"reference/pret/cli/stub_command/","title":"<code>pret.cli.stub_command</code>","text":""},{"location":"reference/pret/hooks/","title":"hooks","text":""},{"location":"reference/pret/hooks/#prethooks","title":"<code>pret.hooks</code>","text":""},{"location":"reference/pret/hooks/#pret.hooks.use_state","title":"<code>use_state</code>","text":"<p>Returns a stateful value, and a function to update it.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--examples","title":"Examples","text":"<pre><code>from pret.ui.react import div, button, p\nfrom pret import component, use_state\n\n\n@component\ndef CounterApp():\n    count, set_count = use_state(0)\n\n    def increment():\n        set_count(count + 1)\n\n    return div(p(count), button({\"onClick\": increment}, \"Increment\"))\n</code></pre>"},{"location":"reference/pret/hooks/#pret.hooks.use_state--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the state</p> <p> TYPE: <code>StateValueType</code> </p> RETURNS DESCRIPTION <code>Tuple[StateValueType, Callable[[StateValueType], None]]</code> <ul> <li>The current value of the state</li> <li>A function to update the state</li> </ul>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo","title":"<code>use_memo</code>","text":"<p>Returns a memoized value, computed from the provided function. The function will only be re-executed if any of the dependencies change.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_memo--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The function to run to compute the memoized value</p> <p> TYPE: <code>Callable[[], FunctionReturnType]</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the function</p> <p> TYPE: <code>List</code> </p> RETURNS DESCRIPTION <code>FunctionReturnType</code> <p>The value</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref","title":"<code>use_ref</code>","text":"<p>Returns a mutable ref object whose <code>.current</code> property is initialized to the passed argument.</p> <p>The returned object will persist for the full lifetime of the component.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_ref--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>initial_value</code> <p>The initial value of the ref</p> <p> TYPE: <code>RefValueType</code> </p> RETURNS DESCRIPTION <code>RefType[RefValueType]</code> <p>The ref object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback","title":"<code>use_callback</code>","text":"<p>Returns a memoized callback function. The callback will be stable across re-renders, as long as the dependencies don't change, meaning the last callback function passed to this function will be used between two re-renders.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>CallbackType</code> </p> <code>dependencies</code> <p>The dependencies that will trigger a re-execution of the callback.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect","title":"<code>use_effect</code>","text":"<p>The <code>useEffect</code> hook allows you to perform side effects in function components. Side effects can include data fetching, subscriptions, manually changing the DOM, and more.</p> <p>The effect runs after every render by default. If <code>dependencies</code> are provided, the effect runs whenever those values change. Therefore, if <code>dependencies</code> is an empty array, the effect runs only once after the initial render.</p> <p>Note</p> <p>Ensure that dependencies are simple values like int, str, bool to avoid unnecessary re-executions, as these values are converted to javascript objects, and converting complex objects may not ensure referential equality.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_effect--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>effect</code> <p>A function containing the side effect logic. It can optionally return a cleanup function.</p> <p> TYPE: <code>Callable</code> </p> <code>dependencies</code> <p>An optional array of dependencies that determines when the effect runs.</p> <p> TYPE: <code>Optional[List]</code> DEFAULT: <code>None</code> </p>"},{"location":"reference/pret/hooks/#pret.hooks.use_tracked","title":"<code>use_tracked</code>","text":"<p>This hook is used to track the access made on a proxy object. You can also use the returned object to change the proxy object.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_tracked--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>proxy_object</code> <p>A proxy object, like the one returned by <code>proxy({...})</code></p> <p> </p> RETURNS DESCRIPTION <code>TrackedProxyType</code> <p>A tracked proxy object</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback","title":"<code>use_event_callback</code>","text":"<p>This hook is used to store a callback function that will be called when an event is triggered. The callback function can be changed without triggering a re-render of the component. The function returns a wrapped callback function that will in turn call the stored callback function.</p> <p>Warning</p> <p>Do not use this hook if the rendering of the component depends on the callback function.</p>"},{"location":"reference/pret/hooks/#pret.hooks.use_event_callback--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>callback</code> <p>The callback function</p> <p> TYPE: <code>CallbackType</code> </p> RETURNS DESCRIPTION <code>CallbackType</code> <p>The wrapped callback function</p>"},{"location":"reference/pret/ipython_var_cleaner/","title":"<code>pret.ipython_var_cleaner</code>","text":""},{"location":"reference/pret/main/","title":"<code>pret.main</code>","text":""},{"location":"reference/pret/main/#pret.main.extract_js_dependencies","title":"<code>extract_js_dependencies</code>","text":"<p>Create a js file that will import all the globals that were accessed during pickling and assign them to the global scope.</p>"},{"location":"reference/pret/main/#pret.main.extract_js_dependencies--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>refs</code> <p>List of Ref objects that were accessed during pickling</p> <p> </p> <code>exclude</code> <p>List of module patterns to exclude from the js globals file</p> <p> DEFAULT: <code>('js.React.*', 'js.ReactDOM.*')</code> </p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets","title":"<code>extract_prebuilt_extension_assets</code>","text":"<p>Extracts entry javascript files from the static directory of each package as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_extension_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>packages</code> <p> TYPE: <code>List[str]</code> </p> RETURNS DESCRIPTION <code>Tuple[Dict[str, Path], List[Tuple[str, str]]]</code>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets","title":"<code>extract_prebuilt_base_assets</code>","text":"<p>Extracts the base index.html file as well as a mapping entry -&gt; file to know where to look for whenever the app asks for a chunk or an asset.</p>"},{"location":"reference/pret/main/#pret.main.extract_prebuilt_base_assets--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>Returns</code> <code>Tuple</code>"},{"location":"reference/pret/manager/","title":"<code>pret.manager</code>","text":""},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager","title":"<code>JupyterServerManager</code>","text":"<p>           Bases: <code>Manager</code></p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.open","title":"<code>open</code>","text":"<p>Open a comm to the frontend if one isn't already open.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.close","title":"<code>close</code>","text":"<p>Close method. Closes the underlying comm. When the comm is closed, all the view views are automatically removed from the front-end.</p>"},{"location":"reference/pret/manager/#pret.manager.JupyterServerManager.handle_comm_msg","title":"<code>handle_comm_msg</code>","text":"<p>Called when a message is received from the front-end</p>"},{"location":"reference/pret/render/","title":"<code>pret.render</code>","text":""},{"location":"reference/pret/render/#pret.render.make_create_element_from_function","title":"<code>make_create_element_from_function</code>","text":"<p>Turn a Python Pret function into function that creates a React element.</p>"},{"location":"reference/pret/render/#pret.render.make_create_element_from_function--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p>The Python function to turn into a React element creator, ie a function that when invoked by React, will call the Python function with the correct arguments.</p> <p> </p> RETURNS DESCRIPTION <code>(**props) -&gt; ReactElement&lt;fn</code>"},{"location":"reference/pret/render/#pret.render.component","title":"<code>component</code>","text":"<p>Decorator to turn a Python function into a Pret component, that will be rendered by React.</p>"},{"location":"reference/pret/render/#pret.render.component--parameters","title":"Parameters","text":"PARAMETER DESCRIPTION <code>fn</code> <p> TYPE: <code>Callable</code> </p>"},{"location":"reference/pret/serialize/","title":"<code>pret.serialize</code>","text":""},{"location":"reference/pret/serialize/#pret.serialize.globalvars","title":"<code>globalvars</code>","text":"<p>Adapted from dill._dill._globalvars</p> <p>get objects defined in global scope that are referred to by func</p> <p>return a dict of {name:object}</p>"},{"location":"reference/pret/serialize/#pret.serialize.save_function","title":"<code>save_function</code>","text":"<p>Adapted from dill._dill.save_function</p>"},{"location":"reference/pret/serialize/#pret.serialize.save_module_dict","title":"<code>save_module_dict</code>","text":"<p>Adapted from dill._dill._save_module_dict</p>"},{"location":"reference/pret/serialize/#pret.serialize.create_module_with_dict","title":"<code>create_module_with_dict</code>","text":"<p>Create a module with the given name, docstring, and optional file name</p>"},{"location":"reference/pret/serialize/#pret.serialize.save_type","title":"<code>save_type</code>","text":"<p>Adapted from dill._dill._save_type</p>"},{"location":"reference/pret/serialize/#pret.serialize.save_module","title":"<code>save_module</code>","text":"<p>Adapted from dill._dill.save_module</p>"},{"location":"reference/pret/serialize/#pret.serialize.create_module","title":"<code>create_module</code>","text":"<p>Create a module object from a name</p>"},{"location":"reference/pret/serve/","title":"<code>pret.serve</code>","text":""},{"location":"reference/pret/settings/","title":"<code>pret.settings</code>","text":""},{"location":"reference/pret/state/","title":"<code>pret.state</code>","text":"<p>Tracked state management for Python to enable reactive programming in Python, both in the browser and in the kernel. Inspired by the amazing valtio library (https://github.com/pmndrs/valtio).</p>"},{"location":"reference/pret/ui/react/","title":"<code>pret.ui.react</code>","text":""},{"location":"changelog/","title":"Changelog","text":""}]}