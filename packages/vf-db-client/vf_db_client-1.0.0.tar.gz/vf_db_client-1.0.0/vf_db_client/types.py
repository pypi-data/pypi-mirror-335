# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _ProductEnumListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.ProductEnum']]


class _ProductEnumListFilterHasInput(TypedDict):
    has: 'enums.ProductEnum'


class _ProductEnumListFilterHasEveryInput(TypedDict):
    has_every: List['enums.ProductEnum']


class _ProductEnumListFilterHasSomeInput(TypedDict):
    has_some: List['enums.ProductEnum']


class _ProductEnumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


ProductEnumListFilter = Union[
    _ProductEnumListFilterHasInput,
    _ProductEnumListFilterEqualsInput,
    _ProductEnumListFilterHasSomeInput,
    _ProductEnumListFilterIsEmptyInput,
    _ProductEnumListFilterHasEveryInput,
]


class _ProductEnumListUpdateSet(TypedDict):
    set: List['enums.ProductEnum']


class _ProductEnumListUpdatePush(TypedDict):
    push: List['enums.ProductEnum']


ProductEnumListUpdate = Union[
    List['enums.ProductEnum'],
    _ProductEnumListUpdateSet,
    _ProductEnumListUpdatePush,
]

class _StateEnumListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.StateEnum']]


class _StateEnumListFilterHasInput(TypedDict):
    has: 'enums.StateEnum'


class _StateEnumListFilterHasEveryInput(TypedDict):
    has_every: List['enums.StateEnum']


class _StateEnumListFilterHasSomeInput(TypedDict):
    has_some: List['enums.StateEnum']


class _StateEnumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StateEnumListFilter = Union[
    _StateEnumListFilterHasInput,
    _StateEnumListFilterEqualsInput,
    _StateEnumListFilterHasSomeInput,
    _StateEnumListFilterIsEmptyInput,
    _StateEnumListFilterHasEveryInput,
]


class _StateEnumListUpdateSet(TypedDict):
    set: List['enums.StateEnum']


class _StateEnumListUpdatePush(TypedDict):
    push: List['enums.StateEnum']


StateEnumListUpdate = Union[
    List['enums.StateEnum'],
    _StateEnumListUpdateSet,
    _StateEnumListUpdatePush,
]

class _StatusEnumListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.StatusEnum']]


class _StatusEnumListFilterHasInput(TypedDict):
    has: 'enums.StatusEnum'


class _StatusEnumListFilterHasEveryInput(TypedDict):
    has_every: List['enums.StatusEnum']


class _StatusEnumListFilterHasSomeInput(TypedDict):
    has_some: List['enums.StatusEnum']


class _StatusEnumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StatusEnumListFilter = Union[
    _StatusEnumListFilterHasInput,
    _StatusEnumListFilterEqualsInput,
    _StatusEnumListFilterHasSomeInput,
    _StatusEnumListFilterIsEmptyInput,
    _StatusEnumListFilterHasEveryInput,
]


class _StatusEnumListUpdateSet(TypedDict):
    set: List['enums.StatusEnum']


class _StatusEnumListUpdatePush(TypedDict):
    push: List['enums.StatusEnum']


StatusEnumListUpdate = Union[
    List['enums.StatusEnum'],
    _StatusEnumListUpdateSet,
    _StatusEnumListUpdatePush,
]

class _PlanTypeEnumListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.PlanTypeEnum']]


class _PlanTypeEnumListFilterHasInput(TypedDict):
    has: 'enums.PlanTypeEnum'


class _PlanTypeEnumListFilterHasEveryInput(TypedDict):
    has_every: List['enums.PlanTypeEnum']


class _PlanTypeEnumListFilterHasSomeInput(TypedDict):
    has_some: List['enums.PlanTypeEnum']


class _PlanTypeEnumListFilterIsEmptyInput(TypedDict):
    is_empty: bool


PlanTypeEnumListFilter = Union[
    _PlanTypeEnumListFilterHasInput,
    _PlanTypeEnumListFilterEqualsInput,
    _PlanTypeEnumListFilterHasSomeInput,
    _PlanTypeEnumListFilterIsEmptyInput,
    _PlanTypeEnumListFilterHasEveryInput,
]


class _PlanTypeEnumListUpdateSet(TypedDict):
    set: List['enums.PlanTypeEnum']


class _PlanTypeEnumListUpdatePush(TypedDict):
    push: List['enums.PlanTypeEnum']


PlanTypeEnumListUpdate = Union[
    List['enums.PlanTypeEnum'],
    _PlanTypeEnumListUpdateSet,
    _PlanTypeEnumListUpdatePush,
]


# Filing types

class FilingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Filing create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    stateTrackingNumber: Optional[_str]
    companyTrackingNumber: Optional[_str]
    product: Optional[_str]
    subTypeOfInsurance: Optional[_str]
    filingType: Optional[_str]
    submissionDate: Optional[datetime.datetime]
    filingStatus: Optional[_str]
    serffStatus: Optional[_str]
    dispositionDate: Optional[datetime.datetime]
    dispositionStatus: Optional[_str]
    stateStatusLastChanged: Optional[datetime.datetime]
    metadataJson: Optional['fields.Json']
    filingDescription: Optional[_str]
    filingSummary: Optional[_str]
    documents: 'DocumentCreateManyNestedWithoutRelationsInput'
    companies: 'FilingToCompanyCreateManyNestedWithoutRelationsInput'


class FilingCreateInput(FilingOptionalCreateInput):
    """Required arguments to the Filing create method"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    typeOfInsurance: 'enums.ProductEnum'
    state: 'enums.StateEnum'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class FilingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Filing create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    stateTrackingNumber: Optional[_str]
    companyTrackingNumber: Optional[_str]
    product: Optional[_str]
    subTypeOfInsurance: Optional[_str]
    filingType: Optional[_str]
    submissionDate: Optional[datetime.datetime]
    filingStatus: Optional[_str]
    serffStatus: Optional[_str]
    dispositionDate: Optional[datetime.datetime]
    dispositionStatus: Optional[_str]
    stateStatusLastChanged: Optional[datetime.datetime]
    metadataJson: Optional['fields.Json']
    filingDescription: Optional[_str]
    filingSummary: Optional[_str]


class FilingCreateWithoutRelationsInput(FilingOptionalCreateWithoutRelationsInput):
    """Required arguments to the Filing create method, without relations"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    typeOfInsurance: 'enums.ProductEnum'
    state: 'enums.StateEnum'

class FilingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'FilingCreateWithoutRelationsInput'
    where: 'FilingWhereUniqueInput'

class FilingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingCreateWithoutRelationsInput'
    connect: 'FilingWhereUniqueInput'
    connect_or_create: 'FilingConnectOrCreateWithoutRelationsInput'


class FilingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['FilingCreateWithoutRelationsInput', List['FilingCreateWithoutRelationsInput']]
    connect: Union['FilingWhereUniqueInput', List['FilingWhereUniqueInput']]
    connect_or_create: Union['FilingConnectOrCreateWithoutRelationsInput', List['FilingConnectOrCreateWithoutRelationsInput']]

_FilingWhereUnique_id_Input = TypedDict(
    '_FilingWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_FilingWhereUnique_serffTrackingNumber_Input = TypedDict(
    '_FilingWhereUnique_serffTrackingNumber_Input',
    {
        'serffTrackingNumber': '_str',
    },
    total=True
)

FilingWhereUniqueInput = Union[
    '_FilingWhereUnique_id_Input',
    '_FilingWhereUnique_serffTrackingNumber_Input',
]


class FilingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    stateTrackingNumber: Optional[_str]
    companyTrackingNumber: Optional[_str]
    product: Optional[_str]
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: Optional[_str]
    filingType: Optional[_str]
    submissionDate: Optional[datetime.datetime]
    filingStatus: Optional[_str]
    serffStatus: Optional[_str]
    dispositionDate: Optional[datetime.datetime]
    dispositionStatus: Optional[_str]
    stateStatusLastChanged: Optional[datetime.datetime]
    state: 'enums.StateEnum'
    metadataJson: Optional['fields.Json']
    filingDescription: Optional[_str]
    filingSummary: Optional[_str]
    documents: 'DocumentUpdateManyWithoutRelationsInput'
    companies: 'FilingToCompanyUpdateManyWithoutRelationsInput'


class FilingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    stateTrackingNumber: Optional[_str]
    companyTrackingNumber: Optional[_str]
    product: Optional[_str]
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: Optional[_str]
    filingType: Optional[_str]
    submissionDate: Optional[datetime.datetime]
    filingStatus: Optional[_str]
    serffStatus: Optional[_str]
    dispositionDate: Optional[datetime.datetime]
    dispositionStatus: Optional[_str]
    stateStatusLastChanged: Optional[datetime.datetime]
    state: 'enums.StateEnum'
    metadataJson: Optional['fields.Json']
    filingDescription: Optional[_str]
    filingSummary: Optional[_str]


class FilingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['FilingCreateWithoutRelationsInput']
    connect: List['FilingWhereUniqueInput']
    connect_or_create: List['FilingConnectOrCreateWithoutRelationsInput']
    set: List['FilingWhereUniqueInput']
    disconnect: List['FilingWhereUniqueInput']
    delete: List['FilingWhereUniqueInput']

    # TODO
    # update: List['FilingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['FilingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['FilingScalarWhereInput']
    # upsert: List['FilingUpserteWithWhereUniqueWithoutRelationsInput']


class FilingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingCreateWithoutRelationsInput'
    connect: 'FilingWhereUniqueInput'
    connect_or_create: 'FilingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'FilingUpdateInput'
    # upsert: 'FilingUpsertWithoutRelationsInput'


class FilingUpsertInput(TypedDict):
    create: 'FilingCreateInput'
    update: 'FilingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Filing_id_OrderByInput = TypedDict(
    '_Filing_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Filing_createdAt_OrderByInput = TypedDict(
    '_Filing_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Filing_updatedAt_OrderByInput = TypedDict(
    '_Filing_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Filing_status_OrderByInput = TypedDict(
    '_Filing_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Filing_serffTrackingNumber_OrderByInput = TypedDict(
    '_Filing_serffTrackingNumber_OrderByInput',
    {
        'serffTrackingNumber': 'SortOrder',
    },
    total=True
)

_Filing_stateTrackingNumber_OrderByInput = TypedDict(
    '_Filing_stateTrackingNumber_OrderByInput',
    {
        'stateTrackingNumber': 'SortOrder',
    },
    total=True
)

_Filing_companyTrackingNumber_OrderByInput = TypedDict(
    '_Filing_companyTrackingNumber_OrderByInput',
    {
        'companyTrackingNumber': 'SortOrder',
    },
    total=True
)

_Filing_product_OrderByInput = TypedDict(
    '_Filing_product_OrderByInput',
    {
        'product': 'SortOrder',
    },
    total=True
)

_Filing_typeOfInsurance_OrderByInput = TypedDict(
    '_Filing_typeOfInsurance_OrderByInput',
    {
        'typeOfInsurance': 'SortOrder',
    },
    total=True
)

_Filing_subTypeOfInsurance_OrderByInput = TypedDict(
    '_Filing_subTypeOfInsurance_OrderByInput',
    {
        'subTypeOfInsurance': 'SortOrder',
    },
    total=True
)

_Filing_filingType_OrderByInput = TypedDict(
    '_Filing_filingType_OrderByInput',
    {
        'filingType': 'SortOrder',
    },
    total=True
)

_Filing_submissionDate_OrderByInput = TypedDict(
    '_Filing_submissionDate_OrderByInput',
    {
        'submissionDate': 'SortOrder',
    },
    total=True
)

_Filing_filingStatus_OrderByInput = TypedDict(
    '_Filing_filingStatus_OrderByInput',
    {
        'filingStatus': 'SortOrder',
    },
    total=True
)

_Filing_serffStatus_OrderByInput = TypedDict(
    '_Filing_serffStatus_OrderByInput',
    {
        'serffStatus': 'SortOrder',
    },
    total=True
)

_Filing_dispositionDate_OrderByInput = TypedDict(
    '_Filing_dispositionDate_OrderByInput',
    {
        'dispositionDate': 'SortOrder',
    },
    total=True
)

_Filing_dispositionStatus_OrderByInput = TypedDict(
    '_Filing_dispositionStatus_OrderByInput',
    {
        'dispositionStatus': 'SortOrder',
    },
    total=True
)

_Filing_stateStatusLastChanged_OrderByInput = TypedDict(
    '_Filing_stateStatusLastChanged_OrderByInput',
    {
        'stateStatusLastChanged': 'SortOrder',
    },
    total=True
)

_Filing_state_OrderByInput = TypedDict(
    '_Filing_state_OrderByInput',
    {
        'state': 'SortOrder',
    },
    total=True
)

_Filing_metadataJson_OrderByInput = TypedDict(
    '_Filing_metadataJson_OrderByInput',
    {
        'metadataJson': 'SortOrder',
    },
    total=True
)

_Filing_filingDescription_OrderByInput = TypedDict(
    '_Filing_filingDescription_OrderByInput',
    {
        'filingDescription': 'SortOrder',
    },
    total=True
)

_Filing_filingSummary_OrderByInput = TypedDict(
    '_Filing_filingSummary_OrderByInput',
    {
        'filingSummary': 'SortOrder',
    },
    total=True
)

_Filing_RelevanceInner = TypedDict(
    '_Filing_RelevanceInner',
    {
        'fields': 'List[FilingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Filing_RelevanceOrderByInput = TypedDict(
    '_Filing_RelevanceOrderByInput',
    {
        '_relevance': '_Filing_RelevanceInner',
    },
    total=True
)

FilingOrderByInput = Union[
    '_Filing_id_OrderByInput',
    '_Filing_createdAt_OrderByInput',
    '_Filing_updatedAt_OrderByInput',
    '_Filing_status_OrderByInput',
    '_Filing_serffTrackingNumber_OrderByInput',
    '_Filing_stateTrackingNumber_OrderByInput',
    '_Filing_companyTrackingNumber_OrderByInput',
    '_Filing_product_OrderByInput',
    '_Filing_typeOfInsurance_OrderByInput',
    '_Filing_subTypeOfInsurance_OrderByInput',
    '_Filing_filingType_OrderByInput',
    '_Filing_submissionDate_OrderByInput',
    '_Filing_filingStatus_OrderByInput',
    '_Filing_serffStatus_OrderByInput',
    '_Filing_dispositionDate_OrderByInput',
    '_Filing_dispositionStatus_OrderByInput',
    '_Filing_stateStatusLastChanged_OrderByInput',
    '_Filing_state_OrderByInput',
    '_Filing_metadataJson_OrderByInput',
    '_Filing_filingDescription_OrderByInput',
    '_Filing_filingSummary_OrderByInput',
    '_Filing_RelevanceOrderByInput',
]



# recursive Filing types
# TODO: cleanup these types



FilingRelationFilter = TypedDict(
    'FilingRelationFilter',
    {
        'is': 'FilingWhereInput',
        'is_not': 'FilingWhereInput',
    },
    total=False,
)


class FilingListRelationFilter(TypedDict, total=False):
    some: 'FilingWhereInput'
    none: 'FilingWhereInput'
    every: 'FilingWhereInput'


class FilingInclude(TypedDict, total=False):
    """Filing relational arguments"""
    documents: Union[bool, 'FindManyDocumentArgsFromFiling']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromFiling']


class FilingIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    documents: Union[bool, 'FindManyDocumentArgsFromFiling']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromFiling']


class FilingArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromFiling']


class FilingCompanyArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    Filing: Union[bool, 'FilingArgsFromFiling']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromFiling']


class FilingToCompanyArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    Filing: Union[bool, 'FilingArgsFromFiling']
    pages: Union[bool, 'FindManyPageArgsFromFiling']
    chunks: Union[bool, 'FindManyChunkArgsFromFiling']
    blocks: Union[bool, 'FindManyBlockArgsFromFiling']


class DocumentArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    Document: Union[bool, 'DocumentArgsFromFiling']
    chunks: Union[bool, 'FindManyChunkArgsFromFiling']
    blocks: Union[bool, 'FindManyBlockArgsFromFiling']


class PageArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    Document: Union[bool, 'DocumentArgsFromFiling']
    pages: Union[bool, 'FindManyPageArgsFromFiling']
    blocks: Union[bool, 'FindManyBlockArgsFromFiling']


class ChunkArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    Chunk: Union[bool, 'ChunkArgsFromFiling']
    Document: Union[bool, 'DocumentArgsFromFiling']
    Page: Union[bool, 'PageArgsFromFiling']


class BlockArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    users: Union[bool, 'FindManyUserArgsFromFiling']
    plan: Union[bool, 'PlanArgsFromFiling']


class TenantArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    tenants: Union[bool, 'FindManyTenantArgsFromFiling']


class PlanArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    chats: Union[bool, 'FindManyChatArgsFromFiling']
    tenant: Union[bool, 'TenantArgsFromFiling']


class UserArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    chats: Union[bool, 'ChatArgsFromFiling']


class MessageArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromFiling(TypedDict, total=False):
    """Relational arguments for Filing"""
    user: Union[bool, 'UserArgsFromFiling']
    messages: Union[bool, 'FindManyMessageArgsFromFiling']


class ChatArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromFiling(TypedDict, total=False):
    """Arguments for Filing"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyFilingArgs = FindManyFilingArgsFromFiling
FindFirstFilingArgs = FindManyFilingArgsFromFiling


class FilingWhereInput(TypedDict, total=False):
    """Filing arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringFilter']
    stateTrackingNumber: Union[None, _str, 'types.StringFilter']
    companyTrackingNumber: Union[None, _str, 'types.StringFilter']
    product: Union[None, _str, 'types.StringFilter']
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: Union[None, _str, 'types.StringFilter']
    filingType: Union[None, _str, 'types.StringFilter']
    submissionDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    filingStatus: Union[None, _str, 'types.StringFilter']
    serffStatus: Union[None, _str, 'types.StringFilter']
    dispositionDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    dispositionStatus: Union[None, _str, 'types.StringFilter']
    stateStatusLastChanged: Union[None, datetime.datetime, 'types.DateTimeFilter']
    state: 'enums.StateEnum'
    metadataJson: Union[None, 'fields.Json', 'types.JsonFilter']
    filingDescription: Union[None, _str, 'types.StringFilter']
    filingSummary: Union[None, _str, 'types.StringFilter']
    documents: 'DocumentListRelationFilter'
    companies: 'FilingToCompanyListRelationFilter'

    # should be noted that AND and NOT should be Union['FilingWhereInput', List['FilingWhereInput']]
    # but this causes mypy to hang :/
    AND: List['FilingWhereInput']
    OR: List['FilingWhereInput']
    NOT: List['FilingWhereInput']



# aggregate Filing types


class FilingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Filing arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    stateTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    companyTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    product: Union[_str, 'types.StringWithAggregatesFilter']
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: Union[_str, 'types.StringWithAggregatesFilter']
    filingType: Union[_str, 'types.StringWithAggregatesFilter']
    submissionDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    filingStatus: Union[_str, 'types.StringWithAggregatesFilter']
    serffStatus: Union[_str, 'types.StringWithAggregatesFilter']
    dispositionDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    dispositionStatus: Union[_str, 'types.StringWithAggregatesFilter']
    stateStatusLastChanged: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    state: 'enums.StateEnum'
    metadataJson: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    filingDescription: Union[_str, 'types.StringWithAggregatesFilter']
    filingSummary: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FilingScalarWhereWithAggregatesInput']
    OR: List['FilingScalarWhereWithAggregatesInput']
    NOT: List['FilingScalarWhereWithAggregatesInput']



class FilingGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    stateTrackingNumber: _str
    companyTrackingNumber: _str
    product: _str
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: _str
    filingType: _str
    submissionDate: datetime.datetime
    filingStatus: _str
    serffStatus: _str
    dispositionDate: datetime.datetime
    dispositionStatus: _str
    stateStatusLastChanged: datetime.datetime
    state: 'enums.StateEnum'
    metadataJson: 'fields.Json'
    filingDescription: _str
    filingSummary: _str
    _sum: 'FilingSumAggregateOutput'
    _avg: 'FilingAvgAggregateOutput'
    _min: 'FilingMinAggregateOutput'
    _max: 'FilingMaxAggregateOutput'
    _count: 'FilingCountAggregateOutput'


class FilingAvgAggregateOutput(TypedDict, total=False):
    """Filing output for aggregating averages"""


class FilingSumAggregateOutput(TypedDict, total=False):
    """Filing output for aggregating sums"""


class FilingScalarAggregateOutput(TypedDict, total=False):
    """Filing output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    stateTrackingNumber: _str
    companyTrackingNumber: _str
    product: _str
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: _str
    filingType: _str
    submissionDate: datetime.datetime
    filingStatus: _str
    serffStatus: _str
    dispositionDate: datetime.datetime
    dispositionStatus: _str
    stateStatusLastChanged: datetime.datetime
    state: 'enums.StateEnum'
    metadataJson: 'fields.Json'
    filingDescription: _str
    filingSummary: _str


FilingMinAggregateOutput = FilingScalarAggregateOutput
FilingMaxAggregateOutput = FilingScalarAggregateOutput


class FilingMaxAggregateInput(TypedDict, total=False):
    """Filing input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    stateTrackingNumber: bool
    companyTrackingNumber: bool
    product: bool
    typeOfInsurance: bool
    subTypeOfInsurance: bool
    filingType: bool
    submissionDate: bool
    filingStatus: bool
    serffStatus: bool
    dispositionDate: bool
    dispositionStatus: bool
    stateStatusLastChanged: bool
    state: bool
    metadataJson: bool
    filingDescription: bool
    filingSummary: bool


class FilingMinAggregateInput(TypedDict, total=False):
    """Filing input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    stateTrackingNumber: bool
    companyTrackingNumber: bool
    product: bool
    typeOfInsurance: bool
    subTypeOfInsurance: bool
    filingType: bool
    submissionDate: bool
    filingStatus: bool
    serffStatus: bool
    dispositionDate: bool
    dispositionStatus: bool
    stateStatusLastChanged: bool
    state: bool
    metadataJson: bool
    filingDescription: bool
    filingSummary: bool


class FilingNumberAggregateInput(TypedDict, total=False):
    """Filing input for aggregating numbers"""


FilingAvgAggregateInput = FilingNumberAggregateInput
FilingSumAggregateInput = FilingNumberAggregateInput


FilingCountAggregateInput = TypedDict(
    'FilingCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'serffTrackingNumber': bool,
        'stateTrackingNumber': bool,
        'companyTrackingNumber': bool,
        'product': bool,
        'typeOfInsurance': bool,
        'subTypeOfInsurance': bool,
        'filingType': bool,
        'submissionDate': bool,
        'filingStatus': bool,
        'serffStatus': bool,
        'dispositionDate': bool,
        'dispositionStatus': bool,
        'stateStatusLastChanged': bool,
        'state': bool,
        'metadataJson': bool,
        'filingDescription': bool,
        'filingSummary': bool,
        '_all': bool,
    },
    total=False,
)

FilingCountAggregateOutput = TypedDict(
    'FilingCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'serffTrackingNumber': int,
        'stateTrackingNumber': int,
        'companyTrackingNumber': int,
        'product': int,
        'typeOfInsurance': int,
        'subTypeOfInsurance': int,
        'filingType': int,
        'submissionDate': int,
        'filingStatus': int,
        'serffStatus': int,
        'dispositionDate': int,
        'dispositionStatus': int,
        'stateStatusLastChanged': int,
        'state': int,
        'metadataJson': int,
        'filingDescription': int,
        'filingSummary': int,
        '_all': int,
    },
    total=False,
)


FilingKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'stateTrackingNumber',
    'companyTrackingNumber',
    'product',
    'typeOfInsurance',
    'subTypeOfInsurance',
    'filingType',
    'submissionDate',
    'filingStatus',
    'serffStatus',
    'dispositionDate',
    'dispositionStatus',
    'stateStatusLastChanged',
    'state',
    'metadataJson',
    'filingDescription',
    'filingSummary',
    'documents',
    'companies',
]
FilingScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'stateTrackingNumber',
    'companyTrackingNumber',
    'product',
    'typeOfInsurance',
    'subTypeOfInsurance',
    'filingType',
    'submissionDate',
    'filingStatus',
    'serffStatus',
    'dispositionDate',
    'dispositionStatus',
    'stateStatusLastChanged',
    'state',
    'metadataJson',
    'filingDescription',
    'filingSummary',
]
FilingScalarFieldKeysT = TypeVar('FilingScalarFieldKeysT', bound=FilingScalarFieldKeys)

FilingRelationalFieldKeys = Literal[
        'documents',
        'companies',
    ]

# FilingCompany types

class FilingCompanyOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the FilingCompany create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    companyGroupName: Optional[_str]
    state: Optional[_str]
    statement: Optional[_str]
    companyStatus: Optional[_str]
    filings: 'FilingToCompanyCreateManyNestedWithoutRelationsInput'


class FilingCompanyCreateInput(FilingCompanyOptionalCreateInput):
    """Required arguments to the FilingCompany create method"""
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupCode: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class FilingCompanyOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the FilingCompany create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    companyGroupName: Optional[_str]
    state: Optional[_str]
    statement: Optional[_str]
    companyStatus: Optional[_str]


class FilingCompanyCreateWithoutRelationsInput(FilingCompanyOptionalCreateWithoutRelationsInput):
    """Required arguments to the FilingCompany create method, without relations"""
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupCode: _str

class FilingCompanyConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'FilingCompanyCreateWithoutRelationsInput'
    where: 'FilingCompanyWhereUniqueInput'

class FilingCompanyCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingCompanyCreateWithoutRelationsInput'
    connect: 'FilingCompanyWhereUniqueInput'
    connect_or_create: 'FilingCompanyConnectOrCreateWithoutRelationsInput'


class FilingCompanyCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['FilingCompanyCreateWithoutRelationsInput', List['FilingCompanyCreateWithoutRelationsInput']]
    connect: Union['FilingCompanyWhereUniqueInput', List['FilingCompanyWhereUniqueInput']]
    connect_or_create: Union['FilingCompanyConnectOrCreateWithoutRelationsInput', List['FilingCompanyConnectOrCreateWithoutRelationsInput']]

_FilingCompanyWhereUnique_id_Input = TypedDict(
    '_FilingCompanyWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_FilingCompanyWhereUnique_companyCode_Input = TypedDict(
    '_FilingCompanyWhereUnique_companyCode_Input',
    {
        'companyCode': '_str',
    },
    total=True
)

FilingCompanyWhereUniqueInput = Union[
    '_FilingCompanyWhereUnique_id_Input',
    '_FilingCompanyWhereUnique_companyCode_Input',
]


class FilingCompanyUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupName: Optional[_str]
    companyGroupCode: _str
    state: Optional[_str]
    statement: Optional[_str]
    companyStatus: Optional[_str]
    filings: 'FilingToCompanyUpdateManyWithoutRelationsInput'


class FilingCompanyUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupName: Optional[_str]
    companyGroupCode: _str
    state: Optional[_str]
    statement: Optional[_str]
    companyStatus: Optional[_str]


class FilingCompanyUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['FilingCompanyCreateWithoutRelationsInput']
    connect: List['FilingCompanyWhereUniqueInput']
    connect_or_create: List['FilingCompanyConnectOrCreateWithoutRelationsInput']
    set: List['FilingCompanyWhereUniqueInput']
    disconnect: List['FilingCompanyWhereUniqueInput']
    delete: List['FilingCompanyWhereUniqueInput']

    # TODO
    # update: List['FilingCompanyUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['FilingCompanyUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['FilingCompanyScalarWhereInput']
    # upsert: List['FilingCompanyUpserteWithWhereUniqueWithoutRelationsInput']


class FilingCompanyUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingCompanyCreateWithoutRelationsInput'
    connect: 'FilingCompanyWhereUniqueInput'
    connect_or_create: 'FilingCompanyConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'FilingCompanyUpdateInput'
    # upsert: 'FilingCompanyUpsertWithoutRelationsInput'


class FilingCompanyUpsertInput(TypedDict):
    create: 'FilingCompanyCreateInput'
    update: 'FilingCompanyUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_FilingCompany_id_OrderByInput = TypedDict(
    '_FilingCompany_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_FilingCompany_createdAt_OrderByInput = TypedDict(
    '_FilingCompany_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_FilingCompany_updatedAt_OrderByInput = TypedDict(
    '_FilingCompany_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_FilingCompany_status_OrderByInput = TypedDict(
    '_FilingCompany_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_FilingCompany_companyName_OrderByInput = TypedDict(
    '_FilingCompany_companyName_OrderByInput',
    {
        'companyName': 'SortOrder',
    },
    total=True
)

_FilingCompany_companyCode_OrderByInput = TypedDict(
    '_FilingCompany_companyCode_OrderByInput',
    {
        'companyCode': 'SortOrder',
    },
    total=True
)

_FilingCompany_companyGroupName_OrderByInput = TypedDict(
    '_FilingCompany_companyGroupName_OrderByInput',
    {
        'companyGroupName': 'SortOrder',
    },
    total=True
)

_FilingCompany_companyGroupCode_OrderByInput = TypedDict(
    '_FilingCompany_companyGroupCode_OrderByInput',
    {
        'companyGroupCode': 'SortOrder',
    },
    total=True
)

_FilingCompany_state_OrderByInput = TypedDict(
    '_FilingCompany_state_OrderByInput',
    {
        'state': 'SortOrder',
    },
    total=True
)

_FilingCompany_statement_OrderByInput = TypedDict(
    '_FilingCompany_statement_OrderByInput',
    {
        'statement': 'SortOrder',
    },
    total=True
)

_FilingCompany_companyStatus_OrderByInput = TypedDict(
    '_FilingCompany_companyStatus_OrderByInput',
    {
        'companyStatus': 'SortOrder',
    },
    total=True
)

_FilingCompany_RelevanceInner = TypedDict(
    '_FilingCompany_RelevanceInner',
    {
        'fields': 'List[FilingCompanyScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_FilingCompany_RelevanceOrderByInput = TypedDict(
    '_FilingCompany_RelevanceOrderByInput',
    {
        '_relevance': '_FilingCompany_RelevanceInner',
    },
    total=True
)

FilingCompanyOrderByInput = Union[
    '_FilingCompany_id_OrderByInput',
    '_FilingCompany_createdAt_OrderByInput',
    '_FilingCompany_updatedAt_OrderByInput',
    '_FilingCompany_status_OrderByInput',
    '_FilingCompany_companyName_OrderByInput',
    '_FilingCompany_companyCode_OrderByInput',
    '_FilingCompany_companyGroupName_OrderByInput',
    '_FilingCompany_companyGroupCode_OrderByInput',
    '_FilingCompany_state_OrderByInput',
    '_FilingCompany_statement_OrderByInput',
    '_FilingCompany_companyStatus_OrderByInput',
    '_FilingCompany_RelevanceOrderByInput',
]



# recursive FilingCompany types
# TODO: cleanup these types



FilingCompanyRelationFilter = TypedDict(
    'FilingCompanyRelationFilter',
    {
        'is': 'FilingCompanyWhereInput',
        'is_not': 'FilingCompanyWhereInput',
    },
    total=False,
)


class FilingCompanyListRelationFilter(TypedDict, total=False):
    some: 'FilingCompanyWhereInput'
    none: 'FilingCompanyWhereInput'
    every: 'FilingCompanyWhereInput'


class FilingCompanyInclude(TypedDict, total=False):
    """FilingCompany relational arguments"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromFilingCompany']


class FilingIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    documents: Union[bool, 'FindManyDocumentArgsFromFilingCompany']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromFilingCompany']


class FilingArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromFilingCompany']


class FilingCompanyArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    Filing: Union[bool, 'FilingArgsFromFilingCompany']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromFilingCompany']


class FilingToCompanyArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    Filing: Union[bool, 'FilingArgsFromFilingCompany']
    pages: Union[bool, 'FindManyPageArgsFromFilingCompany']
    chunks: Union[bool, 'FindManyChunkArgsFromFilingCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingCompany']


class DocumentArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    Document: Union[bool, 'DocumentArgsFromFilingCompany']
    chunks: Union[bool, 'FindManyChunkArgsFromFilingCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingCompany']


class PageArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    Document: Union[bool, 'DocumentArgsFromFilingCompany']
    pages: Union[bool, 'FindManyPageArgsFromFilingCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingCompany']


class ChunkArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    Chunk: Union[bool, 'ChunkArgsFromFilingCompany']
    Document: Union[bool, 'DocumentArgsFromFilingCompany']
    Page: Union[bool, 'PageArgsFromFilingCompany']


class BlockArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    users: Union[bool, 'FindManyUserArgsFromFilingCompany']
    plan: Union[bool, 'PlanArgsFromFilingCompany']


class TenantArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    tenants: Union[bool, 'FindManyTenantArgsFromFilingCompany']


class PlanArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    chats: Union[bool, 'FindManyChatArgsFromFilingCompany']
    tenant: Union[bool, 'TenantArgsFromFilingCompany']


class UserArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    chats: Union[bool, 'ChatArgsFromFilingCompany']


class MessageArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromFilingCompany(TypedDict, total=False):
    """Relational arguments for FilingCompany"""
    user: Union[bool, 'UserArgsFromFilingCompany']
    messages: Union[bool, 'FindManyMessageArgsFromFilingCompany']


class ChatArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromFilingCompany(TypedDict, total=False):
    """Arguments for FilingCompany"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyFilingCompanyArgs = FindManyFilingCompanyArgsFromFilingCompany
FindFirstFilingCompanyArgs = FindManyFilingCompanyArgsFromFilingCompany


class FilingCompanyWhereInput(TypedDict, total=False):
    """FilingCompany arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    companyName: Union[_str, 'types.StringFilter']
    companyCode: Union[_str, 'types.StringFilter']
    companyGroupName: Union[None, _str, 'types.StringFilter']
    companyGroupCode: Union[_str, 'types.StringFilter']
    state: Union[None, _str, 'types.StringFilter']
    statement: Union[None, _str, 'types.StringFilter']
    companyStatus: Union[None, _str, 'types.StringFilter']
    filings: 'FilingToCompanyListRelationFilter'

    # should be noted that AND and NOT should be Union['FilingCompanyWhereInput', List['FilingCompanyWhereInput']]
    # but this causes mypy to hang :/
    AND: List['FilingCompanyWhereInput']
    OR: List['FilingCompanyWhereInput']
    NOT: List['FilingCompanyWhereInput']



# aggregate FilingCompany types


class FilingCompanyScalarWhereWithAggregatesInput(TypedDict, total=False):
    """FilingCompany arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    companyName: Union[_str, 'types.StringWithAggregatesFilter']
    companyCode: Union[_str, 'types.StringWithAggregatesFilter']
    companyGroupName: Union[_str, 'types.StringWithAggregatesFilter']
    companyGroupCode: Union[_str, 'types.StringWithAggregatesFilter']
    state: Union[_str, 'types.StringWithAggregatesFilter']
    statement: Union[_str, 'types.StringWithAggregatesFilter']
    companyStatus: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FilingCompanyScalarWhereWithAggregatesInput']
    OR: List['FilingCompanyScalarWhereWithAggregatesInput']
    NOT: List['FilingCompanyScalarWhereWithAggregatesInput']



class FilingCompanyGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupName: _str
    companyGroupCode: _str
    state: _str
    statement: _str
    companyStatus: _str
    _sum: 'FilingCompanySumAggregateOutput'
    _avg: 'FilingCompanyAvgAggregateOutput'
    _min: 'FilingCompanyMinAggregateOutput'
    _max: 'FilingCompanyMaxAggregateOutput'
    _count: 'FilingCompanyCountAggregateOutput'


class FilingCompanyAvgAggregateOutput(TypedDict, total=False):
    """FilingCompany output for aggregating averages"""


class FilingCompanySumAggregateOutput(TypedDict, total=False):
    """FilingCompany output for aggregating sums"""


class FilingCompanyScalarAggregateOutput(TypedDict, total=False):
    """FilingCompany output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupName: _str
    companyGroupCode: _str
    state: _str
    statement: _str
    companyStatus: _str


FilingCompanyMinAggregateOutput = FilingCompanyScalarAggregateOutput
FilingCompanyMaxAggregateOutput = FilingCompanyScalarAggregateOutput


class FilingCompanyMaxAggregateInput(TypedDict, total=False):
    """FilingCompany input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    companyName: bool
    companyCode: bool
    companyGroupName: bool
    companyGroupCode: bool
    state: bool
    statement: bool
    companyStatus: bool


class FilingCompanyMinAggregateInput(TypedDict, total=False):
    """FilingCompany input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    companyName: bool
    companyCode: bool
    companyGroupName: bool
    companyGroupCode: bool
    state: bool
    statement: bool
    companyStatus: bool


class FilingCompanyNumberAggregateInput(TypedDict, total=False):
    """FilingCompany input for aggregating numbers"""


FilingCompanyAvgAggregateInput = FilingCompanyNumberAggregateInput
FilingCompanySumAggregateInput = FilingCompanyNumberAggregateInput


FilingCompanyCountAggregateInput = TypedDict(
    'FilingCompanyCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'companyName': bool,
        'companyCode': bool,
        'companyGroupName': bool,
        'companyGroupCode': bool,
        'state': bool,
        'statement': bool,
        'companyStatus': bool,
        '_all': bool,
    },
    total=False,
)

FilingCompanyCountAggregateOutput = TypedDict(
    'FilingCompanyCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'companyName': int,
        'companyCode': int,
        'companyGroupName': int,
        'companyGroupCode': int,
        'state': int,
        'statement': int,
        'companyStatus': int,
        '_all': int,
    },
    total=False,
)


FilingCompanyKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'companyName',
    'companyCode',
    'companyGroupName',
    'companyGroupCode',
    'state',
    'statement',
    'companyStatus',
    'filings',
]
FilingCompanyScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'companyName',
    'companyCode',
    'companyGroupName',
    'companyGroupCode',
    'state',
    'statement',
    'companyStatus',
]
FilingCompanyScalarFieldKeysT = TypeVar('FilingCompanyScalarFieldKeysT', bound=FilingCompanyScalarFieldKeys)

FilingCompanyRelationalFieldKeys = Literal[
        'filings',
    ]

# FilingToCompany types

class FilingToCompanyOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the FilingToCompany create method"""
    filingId: _str
    companyId: _str
    Filing: 'FilingCreateNestedWithoutRelationsInput'
    FilingCompany: 'FilingCompanyCreateNestedWithoutRelationsInput'


class FilingToCompanyCreateInput(FilingToCompanyOptionalCreateInput):
    """Required arguments to the FilingToCompany create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class FilingToCompanyOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the FilingToCompany create method, without relations"""
    filingId: _str
    companyId: _str


class FilingToCompanyCreateWithoutRelationsInput(FilingToCompanyOptionalCreateWithoutRelationsInput):
    """Required arguments to the FilingToCompany create method, without relations"""

class FilingToCompanyConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'FilingToCompanyCreateWithoutRelationsInput'
    where: 'FilingToCompanyWhereUniqueInput'

class FilingToCompanyCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingToCompanyCreateWithoutRelationsInput'
    connect: 'FilingToCompanyWhereUniqueInput'
    connect_or_create: 'FilingToCompanyConnectOrCreateWithoutRelationsInput'


class FilingToCompanyCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['FilingToCompanyCreateWithoutRelationsInput', List['FilingToCompanyCreateWithoutRelationsInput']]
    connect: Union['FilingToCompanyWhereUniqueInput', List['FilingToCompanyWhereUniqueInput']]
    connect_or_create: Union['FilingToCompanyConnectOrCreateWithoutRelationsInput', List['FilingToCompanyConnectOrCreateWithoutRelationsInput']]

_FilingToCompanyCompoundPrimaryKeyInner = TypedDict(
    '_FilingToCompanyCompoundPrimaryKeyInner',
    {
        'filingId': '_str',
        'companyId': '_str',
    },
    total=True
)

_FilingToCompanyCompoundPrimaryKey = TypedDict(
    '_FilingToCompanyCompoundPrimaryKey',
    {
        'filingId_companyId': '_FilingToCompanyCompoundPrimaryKeyInner',
    },
    total=True
)

FilingToCompanyWhereUniqueInput = _FilingToCompanyCompoundPrimaryKey


class FilingToCompanyUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    Filing: 'FilingUpdateOneWithoutRelationsInput'
    FilingCompany: 'FilingCompanyUpdateOneWithoutRelationsInput'


class FilingToCompanyUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class FilingToCompanyUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['FilingToCompanyCreateWithoutRelationsInput']
    connect: List['FilingToCompanyWhereUniqueInput']
    connect_or_create: List['FilingToCompanyConnectOrCreateWithoutRelationsInput']
    set: List['FilingToCompanyWhereUniqueInput']
    disconnect: List['FilingToCompanyWhereUniqueInput']
    delete: List['FilingToCompanyWhereUniqueInput']

    # TODO
    # update: List['FilingToCompanyUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['FilingToCompanyUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['FilingToCompanyScalarWhereInput']
    # upsert: List['FilingToCompanyUpserteWithWhereUniqueWithoutRelationsInput']


class FilingToCompanyUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'FilingToCompanyCreateWithoutRelationsInput'
    connect: 'FilingToCompanyWhereUniqueInput'
    connect_or_create: 'FilingToCompanyConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'FilingToCompanyUpdateInput'
    # upsert: 'FilingToCompanyUpsertWithoutRelationsInput'


class FilingToCompanyUpsertInput(TypedDict):
    create: 'FilingToCompanyCreateInput'
    update: 'FilingToCompanyUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_FilingToCompany_filingId_OrderByInput = TypedDict(
    '_FilingToCompany_filingId_OrderByInput',
    {
        'filingId': 'SortOrder',
    },
    total=True
)

_FilingToCompany_companyId_OrderByInput = TypedDict(
    '_FilingToCompany_companyId_OrderByInput',
    {
        'companyId': 'SortOrder',
    },
    total=True
)

_FilingToCompany_RelevanceInner = TypedDict(
    '_FilingToCompany_RelevanceInner',
    {
        'fields': 'List[FilingToCompanyScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_FilingToCompany_RelevanceOrderByInput = TypedDict(
    '_FilingToCompany_RelevanceOrderByInput',
    {
        '_relevance': '_FilingToCompany_RelevanceInner',
    },
    total=True
)

FilingToCompanyOrderByInput = Union[
    '_FilingToCompany_filingId_OrderByInput',
    '_FilingToCompany_companyId_OrderByInput',
    '_FilingToCompany_RelevanceOrderByInput',
]



# recursive FilingToCompany types
# TODO: cleanup these types



FilingToCompanyRelationFilter = TypedDict(
    'FilingToCompanyRelationFilter',
    {
        'is': 'FilingToCompanyWhereInput',
        'is_not': 'FilingToCompanyWhereInput',
    },
    total=False,
)


class FilingToCompanyListRelationFilter(TypedDict, total=False):
    some: 'FilingToCompanyWhereInput'
    none: 'FilingToCompanyWhereInput'
    every: 'FilingToCompanyWhereInput'


class FilingToCompanyInclude(TypedDict, total=False):
    """FilingToCompany relational arguments"""
    Filing: Union[bool, 'FilingArgsFromFilingToCompany']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromFilingToCompany']


class FilingIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    documents: Union[bool, 'FindManyDocumentArgsFromFilingToCompany']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromFilingToCompany']


class FilingArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromFilingToCompany']


class FilingCompanyArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    Filing: Union[bool, 'FilingArgsFromFilingToCompany']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromFilingToCompany']


class FilingToCompanyArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    Filing: Union[bool, 'FilingArgsFromFilingToCompany']
    pages: Union[bool, 'FindManyPageArgsFromFilingToCompany']
    chunks: Union[bool, 'FindManyChunkArgsFromFilingToCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingToCompany']


class DocumentArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    Document: Union[bool, 'DocumentArgsFromFilingToCompany']
    chunks: Union[bool, 'FindManyChunkArgsFromFilingToCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingToCompany']


class PageArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    Document: Union[bool, 'DocumentArgsFromFilingToCompany']
    pages: Union[bool, 'FindManyPageArgsFromFilingToCompany']
    blocks: Union[bool, 'FindManyBlockArgsFromFilingToCompany']


class ChunkArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    Chunk: Union[bool, 'ChunkArgsFromFilingToCompany']
    Document: Union[bool, 'DocumentArgsFromFilingToCompany']
    Page: Union[bool, 'PageArgsFromFilingToCompany']


class BlockArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    users: Union[bool, 'FindManyUserArgsFromFilingToCompany']
    plan: Union[bool, 'PlanArgsFromFilingToCompany']


class TenantArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    tenants: Union[bool, 'FindManyTenantArgsFromFilingToCompany']


class PlanArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    chats: Union[bool, 'FindManyChatArgsFromFilingToCompany']
    tenant: Union[bool, 'TenantArgsFromFilingToCompany']


class UserArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    chats: Union[bool, 'ChatArgsFromFilingToCompany']


class MessageArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromFilingToCompany(TypedDict, total=False):
    """Relational arguments for FilingToCompany"""
    user: Union[bool, 'UserArgsFromFilingToCompany']
    messages: Union[bool, 'FindManyMessageArgsFromFilingToCompany']


class ChatArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromFilingToCompany(TypedDict, total=False):
    """Arguments for FilingToCompany"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyFilingToCompanyArgs = FindManyFilingToCompanyArgsFromFilingToCompany
FindFirstFilingToCompanyArgs = FindManyFilingToCompanyArgsFromFilingToCompany


class FilingToCompanyWhereInput(TypedDict, total=False):
    """FilingToCompany arguments for searching"""
    filingId: Union[_str, 'types.StringFilter']
    companyId: Union[_str, 'types.StringFilter']
    Filing: 'FilingRelationFilter'
    FilingCompany: 'FilingCompanyRelationFilter'

    # should be noted that AND and NOT should be Union['FilingToCompanyWhereInput', List['FilingToCompanyWhereInput']]
    # but this causes mypy to hang :/
    AND: List['FilingToCompanyWhereInput']
    OR: List['FilingToCompanyWhereInput']
    NOT: List['FilingToCompanyWhereInput']



# aggregate FilingToCompany types


class FilingToCompanyScalarWhereWithAggregatesInput(TypedDict, total=False):
    """FilingToCompany arguments for searching"""
    filingId: Union[_str, 'types.StringWithAggregatesFilter']
    companyId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['FilingToCompanyScalarWhereWithAggregatesInput']
    OR: List['FilingToCompanyScalarWhereWithAggregatesInput']
    NOT: List['FilingToCompanyScalarWhereWithAggregatesInput']



class FilingToCompanyGroupByOutput(TypedDict, total=False):
    filingId: _str
    companyId: _str
    _sum: 'FilingToCompanySumAggregateOutput'
    _avg: 'FilingToCompanyAvgAggregateOutput'
    _min: 'FilingToCompanyMinAggregateOutput'
    _max: 'FilingToCompanyMaxAggregateOutput'
    _count: 'FilingToCompanyCountAggregateOutput'


class FilingToCompanyAvgAggregateOutput(TypedDict, total=False):
    """FilingToCompany output for aggregating averages"""


class FilingToCompanySumAggregateOutput(TypedDict, total=False):
    """FilingToCompany output for aggregating sums"""


class FilingToCompanyScalarAggregateOutput(TypedDict, total=False):
    """FilingToCompany output including scalar fields"""
    filingId: _str
    companyId: _str


FilingToCompanyMinAggregateOutput = FilingToCompanyScalarAggregateOutput
FilingToCompanyMaxAggregateOutput = FilingToCompanyScalarAggregateOutput


class FilingToCompanyMaxAggregateInput(TypedDict, total=False):
    """FilingToCompany input for aggregating by max"""
    filingId: bool
    companyId: bool


class FilingToCompanyMinAggregateInput(TypedDict, total=False):
    """FilingToCompany input for aggregating by min"""
    filingId: bool
    companyId: bool


class FilingToCompanyNumberAggregateInput(TypedDict, total=False):
    """FilingToCompany input for aggregating numbers"""


FilingToCompanyAvgAggregateInput = FilingToCompanyNumberAggregateInput
FilingToCompanySumAggregateInput = FilingToCompanyNumberAggregateInput


FilingToCompanyCountAggregateInput = TypedDict(
    'FilingToCompanyCountAggregateInput',
    {
        'filingId': bool,
        'companyId': bool,
        '_all': bool,
    },
    total=False,
)

FilingToCompanyCountAggregateOutput = TypedDict(
    'FilingToCompanyCountAggregateOutput',
    {
        'filingId': int,
        'companyId': int,
        '_all': int,
    },
    total=False,
)


FilingToCompanyKeys = Literal[
    'filingId',
    'companyId',
    'Filing',
    'FilingCompany',
]
FilingToCompanyScalarFieldKeys = Literal[
    'filingId',
    'companyId',
]
FilingToCompanyScalarFieldKeysT = TypeVar('FilingToCompanyScalarFieldKeysT', bound=FilingToCompanyScalarFieldKeys)

FilingToCompanyRelationalFieldKeys = Literal[
        'Filing',
        'FilingCompany',
    ]

# Document types

class DocumentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Document create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    serffTrackingNumber: _str
    documentType: Optional[_str]
    documentName: Optional[_str]
    fileName: Optional[_str]
    formNumber: Optional[_str]
    path: Optional[_str]
    fileType: Optional[_str]
    totalPages: Optional[_int]
    tableOfContents: Optional[_str]
    header: Optional[_str]
    footer: Optional[_str]
    version: Optional[_str]
    dateSubmitted: Optional[datetime.datetime]
    Filing: 'FilingCreateNestedWithoutRelationsInput'
    pages: 'PageCreateManyNestedWithoutRelationsInput'
    chunks: 'ChunkCreateManyNestedWithoutRelationsInput'
    blocks: 'BlockCreateManyNestedWithoutRelationsInput'


class DocumentCreateInput(DocumentOptionalCreateInput):
    """Required arguments to the Document create method"""
    status: 'enums.StatusEnum'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DocumentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Document create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    serffTrackingNumber: _str
    documentType: Optional[_str]
    documentName: Optional[_str]
    fileName: Optional[_str]
    formNumber: Optional[_str]
    path: Optional[_str]
    fileType: Optional[_str]
    totalPages: Optional[_int]
    tableOfContents: Optional[_str]
    header: Optional[_str]
    footer: Optional[_str]
    version: Optional[_str]
    dateSubmitted: Optional[datetime.datetime]


class DocumentCreateWithoutRelationsInput(DocumentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Document create method, without relations"""
    status: 'enums.StatusEnum'

class DocumentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'DocumentCreateWithoutRelationsInput'
    where: 'DocumentWhereUniqueInput'

class DocumentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DocumentCreateWithoutRelationsInput'
    connect: 'DocumentWhereUniqueInput'
    connect_or_create: 'DocumentConnectOrCreateWithoutRelationsInput'


class DocumentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DocumentCreateWithoutRelationsInput', List['DocumentCreateWithoutRelationsInput']]
    connect: Union['DocumentWhereUniqueInput', List['DocumentWhereUniqueInput']]
    connect_or_create: Union['DocumentConnectOrCreateWithoutRelationsInput', List['DocumentConnectOrCreateWithoutRelationsInput']]

_DocumentWhereUnique_id_Input = TypedDict(
    '_DocumentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DocumentWhereUniqueInput = _DocumentWhereUnique_id_Input


class DocumentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    documentType: Optional[_str]
    documentName: Optional[_str]
    fileName: Optional[_str]
    formNumber: Optional[_str]
    path: Optional[_str]
    fileType: Optional[_str]
    totalPages: Optional[Union[AtomicIntInput, _int]]
    tableOfContents: Optional[_str]
    header: Optional[_str]
    footer: Optional[_str]
    version: Optional[_str]
    dateSubmitted: Optional[datetime.datetime]
    Filing: 'FilingUpdateOneWithoutRelationsInput'
    pages: 'PageUpdateManyWithoutRelationsInput'
    chunks: 'ChunkUpdateManyWithoutRelationsInput'
    blocks: 'BlockUpdateManyWithoutRelationsInput'


class DocumentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    documentType: Optional[_str]
    documentName: Optional[_str]
    fileName: Optional[_str]
    formNumber: Optional[_str]
    path: Optional[_str]
    fileType: Optional[_str]
    totalPages: Optional[Union[AtomicIntInput, _int]]
    tableOfContents: Optional[_str]
    header: Optional[_str]
    footer: Optional[_str]
    version: Optional[_str]
    dateSubmitted: Optional[datetime.datetime]


class DocumentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DocumentCreateWithoutRelationsInput']
    connect: List['DocumentWhereUniqueInput']
    connect_or_create: List['DocumentConnectOrCreateWithoutRelationsInput']
    set: List['DocumentWhereUniqueInput']
    disconnect: List['DocumentWhereUniqueInput']
    delete: List['DocumentWhereUniqueInput']

    # TODO
    # update: List['DocumentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DocumentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DocumentScalarWhereInput']
    # upsert: List['DocumentUpserteWithWhereUniqueWithoutRelationsInput']


class DocumentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DocumentCreateWithoutRelationsInput'
    connect: 'DocumentWhereUniqueInput'
    connect_or_create: 'DocumentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DocumentUpdateInput'
    # upsert: 'DocumentUpsertWithoutRelationsInput'


class DocumentUpsertInput(TypedDict):
    create: 'DocumentCreateInput'
    update: 'DocumentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Document_id_OrderByInput = TypedDict(
    '_Document_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Document_createdAt_OrderByInput = TypedDict(
    '_Document_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Document_updatedAt_OrderByInput = TypedDict(
    '_Document_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Document_status_OrderByInput = TypedDict(
    '_Document_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Document_serffTrackingNumber_OrderByInput = TypedDict(
    '_Document_serffTrackingNumber_OrderByInput',
    {
        'serffTrackingNumber': 'SortOrder',
    },
    total=True
)

_Document_documentType_OrderByInput = TypedDict(
    '_Document_documentType_OrderByInput',
    {
        'documentType': 'SortOrder',
    },
    total=True
)

_Document_documentName_OrderByInput = TypedDict(
    '_Document_documentName_OrderByInput',
    {
        'documentName': 'SortOrder',
    },
    total=True
)

_Document_fileName_OrderByInput = TypedDict(
    '_Document_fileName_OrderByInput',
    {
        'fileName': 'SortOrder',
    },
    total=True
)

_Document_formNumber_OrderByInput = TypedDict(
    '_Document_formNumber_OrderByInput',
    {
        'formNumber': 'SortOrder',
    },
    total=True
)

_Document_path_OrderByInput = TypedDict(
    '_Document_path_OrderByInput',
    {
        'path': 'SortOrder',
    },
    total=True
)

_Document_fileType_OrderByInput = TypedDict(
    '_Document_fileType_OrderByInput',
    {
        'fileType': 'SortOrder',
    },
    total=True
)

_Document_totalPages_OrderByInput = TypedDict(
    '_Document_totalPages_OrderByInput',
    {
        'totalPages': 'SortOrder',
    },
    total=True
)

_Document_tableOfContents_OrderByInput = TypedDict(
    '_Document_tableOfContents_OrderByInput',
    {
        'tableOfContents': 'SortOrder',
    },
    total=True
)

_Document_header_OrderByInput = TypedDict(
    '_Document_header_OrderByInput',
    {
        'header': 'SortOrder',
    },
    total=True
)

_Document_footer_OrderByInput = TypedDict(
    '_Document_footer_OrderByInput',
    {
        'footer': 'SortOrder',
    },
    total=True
)

_Document_version_OrderByInput = TypedDict(
    '_Document_version_OrderByInput',
    {
        'version': 'SortOrder',
    },
    total=True
)

_Document_dateSubmitted_OrderByInput = TypedDict(
    '_Document_dateSubmitted_OrderByInput',
    {
        'dateSubmitted': 'SortOrder',
    },
    total=True
)

_Document_RelevanceInner = TypedDict(
    '_Document_RelevanceInner',
    {
        'fields': 'List[DocumentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Document_RelevanceOrderByInput = TypedDict(
    '_Document_RelevanceOrderByInput',
    {
        '_relevance': '_Document_RelevanceInner',
    },
    total=True
)

DocumentOrderByInput = Union[
    '_Document_id_OrderByInput',
    '_Document_createdAt_OrderByInput',
    '_Document_updatedAt_OrderByInput',
    '_Document_status_OrderByInput',
    '_Document_serffTrackingNumber_OrderByInput',
    '_Document_documentType_OrderByInput',
    '_Document_documentName_OrderByInput',
    '_Document_fileName_OrderByInput',
    '_Document_formNumber_OrderByInput',
    '_Document_path_OrderByInput',
    '_Document_fileType_OrderByInput',
    '_Document_totalPages_OrderByInput',
    '_Document_tableOfContents_OrderByInput',
    '_Document_header_OrderByInput',
    '_Document_footer_OrderByInput',
    '_Document_version_OrderByInput',
    '_Document_dateSubmitted_OrderByInput',
    '_Document_RelevanceOrderByInput',
]



# recursive Document types
# TODO: cleanup these types



DocumentRelationFilter = TypedDict(
    'DocumentRelationFilter',
    {
        'is': 'DocumentWhereInput',
        'is_not': 'DocumentWhereInput',
    },
    total=False,
)


class DocumentListRelationFilter(TypedDict, total=False):
    some: 'DocumentWhereInput'
    none: 'DocumentWhereInput'
    every: 'DocumentWhereInput'


class DocumentInclude(TypedDict, total=False):
    """Document relational arguments"""
    Filing: Union[bool, 'FilingArgsFromDocument']
    pages: Union[bool, 'FindManyPageArgsFromDocument']
    chunks: Union[bool, 'FindManyChunkArgsFromDocument']
    blocks: Union[bool, 'FindManyBlockArgsFromDocument']


class FilingIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    documents: Union[bool, 'FindManyDocumentArgsFromDocument']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromDocument']


class FilingArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromDocument']


class FilingCompanyArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    Filing: Union[bool, 'FilingArgsFromDocument']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromDocument']


class FilingToCompanyArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    Filing: Union[bool, 'FilingArgsFromDocument']
    pages: Union[bool, 'FindManyPageArgsFromDocument']
    chunks: Union[bool, 'FindManyChunkArgsFromDocument']
    blocks: Union[bool, 'FindManyBlockArgsFromDocument']


class DocumentArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    Document: Union[bool, 'DocumentArgsFromDocument']
    chunks: Union[bool, 'FindManyChunkArgsFromDocument']
    blocks: Union[bool, 'FindManyBlockArgsFromDocument']


class PageArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    Document: Union[bool, 'DocumentArgsFromDocument']
    pages: Union[bool, 'FindManyPageArgsFromDocument']
    blocks: Union[bool, 'FindManyBlockArgsFromDocument']


class ChunkArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    Chunk: Union[bool, 'ChunkArgsFromDocument']
    Document: Union[bool, 'DocumentArgsFromDocument']
    Page: Union[bool, 'PageArgsFromDocument']


class BlockArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    users: Union[bool, 'FindManyUserArgsFromDocument']
    plan: Union[bool, 'PlanArgsFromDocument']


class TenantArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    tenants: Union[bool, 'FindManyTenantArgsFromDocument']


class PlanArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    chats: Union[bool, 'FindManyChatArgsFromDocument']
    tenant: Union[bool, 'TenantArgsFromDocument']


class UserArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    chats: Union[bool, 'ChatArgsFromDocument']


class MessageArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromDocument(TypedDict, total=False):
    """Relational arguments for Document"""
    user: Union[bool, 'UserArgsFromDocument']
    messages: Union[bool, 'FindManyMessageArgsFromDocument']


class ChatArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromDocument(TypedDict, total=False):
    """Arguments for Document"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyDocumentArgs = FindManyDocumentArgsFromDocument
FindFirstDocumentArgs = FindManyDocumentArgsFromDocument


class DocumentWhereInput(TypedDict, total=False):
    """Document arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringFilter']
    documentType: Union[None, _str, 'types.StringFilter']
    documentName: Union[None, _str, 'types.StringFilter']
    fileName: Union[None, _str, 'types.StringFilter']
    formNumber: Union[None, _str, 'types.StringFilter']
    path: Union[None, _str, 'types.StringFilter']
    fileType: Union[None, _str, 'types.StringFilter']
    totalPages: Union[None, _int, 'types.IntFilter']
    tableOfContents: Union[None, _str, 'types.StringFilter']
    header: Union[None, _str, 'types.StringFilter']
    footer: Union[None, _str, 'types.StringFilter']
    version: Union[None, _str, 'types.StringFilter']
    dateSubmitted: Union[None, datetime.datetime, 'types.DateTimeFilter']
    Filing: 'FilingRelationFilter'
    pages: 'PageListRelationFilter'
    chunks: 'ChunkListRelationFilter'
    blocks: 'BlockListRelationFilter'

    # should be noted that AND and NOT should be Union['DocumentWhereInput', List['DocumentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['DocumentWhereInput']
    OR: List['DocumentWhereInput']
    NOT: List['DocumentWhereInput']



# aggregate Document types


class DocumentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Document arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    documentType: Union[_str, 'types.StringWithAggregatesFilter']
    documentName: Union[_str, 'types.StringWithAggregatesFilter']
    fileName: Union[_str, 'types.StringWithAggregatesFilter']
    formNumber: Union[_str, 'types.StringWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    fileType: Union[_str, 'types.StringWithAggregatesFilter']
    totalPages: Union[_int, 'types.IntWithAggregatesFilter']
    tableOfContents: Union[_str, 'types.StringWithAggregatesFilter']
    header: Union[_str, 'types.StringWithAggregatesFilter']
    footer: Union[_str, 'types.StringWithAggregatesFilter']
    version: Union[_str, 'types.StringWithAggregatesFilter']
    dateSubmitted: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DocumentScalarWhereWithAggregatesInput']
    OR: List['DocumentScalarWhereWithAggregatesInput']
    NOT: List['DocumentScalarWhereWithAggregatesInput']



class DocumentGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    documentType: _str
    documentName: _str
    fileName: _str
    formNumber: _str
    path: _str
    fileType: _str
    totalPages: _int
    tableOfContents: _str
    header: _str
    footer: _str
    version: _str
    dateSubmitted: datetime.datetime
    _sum: 'DocumentSumAggregateOutput'
    _avg: 'DocumentAvgAggregateOutput'
    _min: 'DocumentMinAggregateOutput'
    _max: 'DocumentMaxAggregateOutput'
    _count: 'DocumentCountAggregateOutput'


class DocumentAvgAggregateOutput(TypedDict, total=False):
    """Document output for aggregating averages"""
    totalPages: float


class DocumentSumAggregateOutput(TypedDict, total=False):
    """Document output for aggregating sums"""
    totalPages: _int


class DocumentScalarAggregateOutput(TypedDict, total=False):
    """Document output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    documentType: _str
    documentName: _str
    fileName: _str
    formNumber: _str
    path: _str
    fileType: _str
    totalPages: _int
    tableOfContents: _str
    header: _str
    footer: _str
    version: _str
    dateSubmitted: datetime.datetime


DocumentMinAggregateOutput = DocumentScalarAggregateOutput
DocumentMaxAggregateOutput = DocumentScalarAggregateOutput


class DocumentMaxAggregateInput(TypedDict, total=False):
    """Document input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    documentType: bool
    documentName: bool
    fileName: bool
    formNumber: bool
    path: bool
    fileType: bool
    totalPages: bool
    tableOfContents: bool
    header: bool
    footer: bool
    version: bool
    dateSubmitted: bool


class DocumentMinAggregateInput(TypedDict, total=False):
    """Document input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    documentType: bool
    documentName: bool
    fileName: bool
    formNumber: bool
    path: bool
    fileType: bool
    totalPages: bool
    tableOfContents: bool
    header: bool
    footer: bool
    version: bool
    dateSubmitted: bool


class DocumentNumberAggregateInput(TypedDict, total=False):
    """Document input for aggregating numbers"""
    totalPages: bool


DocumentAvgAggregateInput = DocumentNumberAggregateInput
DocumentSumAggregateInput = DocumentNumberAggregateInput


DocumentCountAggregateInput = TypedDict(
    'DocumentCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'serffTrackingNumber': bool,
        'documentType': bool,
        'documentName': bool,
        'fileName': bool,
        'formNumber': bool,
        'path': bool,
        'fileType': bool,
        'totalPages': bool,
        'tableOfContents': bool,
        'header': bool,
        'footer': bool,
        'version': bool,
        'dateSubmitted': bool,
        '_all': bool,
    },
    total=False,
)

DocumentCountAggregateOutput = TypedDict(
    'DocumentCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'serffTrackingNumber': int,
        'documentType': int,
        'documentName': int,
        'fileName': int,
        'formNumber': int,
        'path': int,
        'fileType': int,
        'totalPages': int,
        'tableOfContents': int,
        'header': int,
        'footer': int,
        'version': int,
        'dateSubmitted': int,
        '_all': int,
    },
    total=False,
)


DocumentKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'documentType',
    'documentName',
    'fileName',
    'formNumber',
    'path',
    'fileType',
    'totalPages',
    'tableOfContents',
    'header',
    'footer',
    'version',
    'dateSubmitted',
    'Filing',
    'pages',
    'chunks',
    'blocks',
]
DocumentScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'documentType',
    'documentName',
    'fileName',
    'formNumber',
    'path',
    'fileType',
    'totalPages',
    'tableOfContents',
    'header',
    'footer',
    'version',
    'dateSubmitted',
]
DocumentScalarFieldKeysT = TypeVar('DocumentScalarFieldKeysT', bound=DocumentScalarFieldKeys)

DocumentRelationalFieldKeys = Literal[
        'Filing',
        'pages',
        'chunks',
        'blocks',
    ]

# Page types

class PageOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Page create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    aoi: Optional['fields.Json']
    documentId: _str
    Document: 'DocumentCreateNestedWithoutRelationsInput'
    chunks: 'ChunkCreateManyNestedWithoutRelationsInput'
    blocks: 'BlockCreateManyNestedWithoutRelationsInput'


class PageCreateInput(PageOptionalCreateInput):
    """Required arguments to the Page create method"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: _int
    rawContent: _str
    tokenCount: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PageOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Page create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    aoi: Optional['fields.Json']
    documentId: _str


class PageCreateWithoutRelationsInput(PageOptionalCreateWithoutRelationsInput):
    """Required arguments to the Page create method, without relations"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: _int
    rawContent: _str
    tokenCount: _int

class PageConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PageCreateWithoutRelationsInput'
    where: 'PageWhereUniqueInput'

class PageCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PageCreateWithoutRelationsInput'
    connect: 'PageWhereUniqueInput'
    connect_or_create: 'PageConnectOrCreateWithoutRelationsInput'


class PageCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PageCreateWithoutRelationsInput', List['PageCreateWithoutRelationsInput']]
    connect: Union['PageWhereUniqueInput', List['PageWhereUniqueInput']]
    connect_or_create: Union['PageConnectOrCreateWithoutRelationsInput', List['PageConnectOrCreateWithoutRelationsInput']]

_PageWhereUnique_id_Input = TypedDict(
    '_PageWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_PageCompounddocumentId_pageNumberKeyInner = TypedDict(
    '_PageCompounddocumentId_pageNumberKeyInner',
    {
        'documentId': '_str',
        'pageNumber': '_int',
    },
    total=True
)

_PageCompounddocumentId_pageNumberKey = TypedDict(
    '_PageCompounddocumentId_pageNumberKey',
    {
        'documentId_pageNumber': '_PageCompounddocumentId_pageNumberKeyInner',
    },
    total=True
)

PageWhereUniqueInput = Union[
    '_PageWhereUnique_id_Input',
    '_PageCompounddocumentId_pageNumberKey',
]


class PageUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: Union[AtomicIntInput, _int]
    rawContent: _str
    aoi: Optional['fields.Json']
    tokenCount: Union[AtomicIntInput, _int]
    Document: 'DocumentUpdateOneWithoutRelationsInput'
    chunks: 'ChunkUpdateManyWithoutRelationsInput'
    blocks: 'BlockUpdateManyWithoutRelationsInput'


class PageUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: Union[AtomicIntInput, _int]
    rawContent: _str
    aoi: Optional['fields.Json']
    tokenCount: Union[AtomicIntInput, _int]


class PageUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PageCreateWithoutRelationsInput']
    connect: List['PageWhereUniqueInput']
    connect_or_create: List['PageConnectOrCreateWithoutRelationsInput']
    set: List['PageWhereUniqueInput']
    disconnect: List['PageWhereUniqueInput']
    delete: List['PageWhereUniqueInput']

    # TODO
    # update: List['PageUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PageUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PageScalarWhereInput']
    # upsert: List['PageUpserteWithWhereUniqueWithoutRelationsInput']


class PageUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PageCreateWithoutRelationsInput'
    connect: 'PageWhereUniqueInput'
    connect_or_create: 'PageConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PageUpdateInput'
    # upsert: 'PageUpsertWithoutRelationsInput'


class PageUpsertInput(TypedDict):
    create: 'PageCreateInput'
    update: 'PageUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Page_id_OrderByInput = TypedDict(
    '_Page_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Page_createdAt_OrderByInput = TypedDict(
    '_Page_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Page_updatedAt_OrderByInput = TypedDict(
    '_Page_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Page_status_OrderByInput = TypedDict(
    '_Page_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Page_serffTrackingNumber_OrderByInput = TypedDict(
    '_Page_serffTrackingNumber_OrderByInput',
    {
        'serffTrackingNumber': 'SortOrder',
    },
    total=True
)

_Page_pageNumber_OrderByInput = TypedDict(
    '_Page_pageNumber_OrderByInput',
    {
        'pageNumber': 'SortOrder',
    },
    total=True
)

_Page_rawContent_OrderByInput = TypedDict(
    '_Page_rawContent_OrderByInput',
    {
        'rawContent': 'SortOrder',
    },
    total=True
)

_Page_aoi_OrderByInput = TypedDict(
    '_Page_aoi_OrderByInput',
    {
        'aoi': 'SortOrder',
    },
    total=True
)

_Page_tokenCount_OrderByInput = TypedDict(
    '_Page_tokenCount_OrderByInput',
    {
        'tokenCount': 'SortOrder',
    },
    total=True
)

_Page_documentId_OrderByInput = TypedDict(
    '_Page_documentId_OrderByInput',
    {
        'documentId': 'SortOrder',
    },
    total=True
)

_Page_RelevanceInner = TypedDict(
    '_Page_RelevanceInner',
    {
        'fields': 'List[PageScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Page_RelevanceOrderByInput = TypedDict(
    '_Page_RelevanceOrderByInput',
    {
        '_relevance': '_Page_RelevanceInner',
    },
    total=True
)

PageOrderByInput = Union[
    '_Page_id_OrderByInput',
    '_Page_createdAt_OrderByInput',
    '_Page_updatedAt_OrderByInput',
    '_Page_status_OrderByInput',
    '_Page_serffTrackingNumber_OrderByInput',
    '_Page_pageNumber_OrderByInput',
    '_Page_rawContent_OrderByInput',
    '_Page_aoi_OrderByInput',
    '_Page_tokenCount_OrderByInput',
    '_Page_documentId_OrderByInput',
    '_Page_RelevanceOrderByInput',
]



# recursive Page types
# TODO: cleanup these types



PageRelationFilter = TypedDict(
    'PageRelationFilter',
    {
        'is': 'PageWhereInput',
        'is_not': 'PageWhereInput',
    },
    total=False,
)


class PageListRelationFilter(TypedDict, total=False):
    some: 'PageWhereInput'
    none: 'PageWhereInput'
    every: 'PageWhereInput'


class PageInclude(TypedDict, total=False):
    """Page relational arguments"""
    Document: Union[bool, 'DocumentArgsFromPage']
    chunks: Union[bool, 'FindManyChunkArgsFromPage']
    blocks: Union[bool, 'FindManyBlockArgsFromPage']


class FilingIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    documents: Union[bool, 'FindManyDocumentArgsFromPage']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromPage']


class FilingArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromPage']


class FilingCompanyArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    Filing: Union[bool, 'FilingArgsFromPage']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromPage']


class FilingToCompanyArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    Filing: Union[bool, 'FilingArgsFromPage']
    pages: Union[bool, 'FindManyPageArgsFromPage']
    chunks: Union[bool, 'FindManyChunkArgsFromPage']
    blocks: Union[bool, 'FindManyBlockArgsFromPage']


class DocumentArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    Document: Union[bool, 'DocumentArgsFromPage']
    chunks: Union[bool, 'FindManyChunkArgsFromPage']
    blocks: Union[bool, 'FindManyBlockArgsFromPage']


class PageArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    Document: Union[bool, 'DocumentArgsFromPage']
    pages: Union[bool, 'FindManyPageArgsFromPage']
    blocks: Union[bool, 'FindManyBlockArgsFromPage']


class ChunkArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    Chunk: Union[bool, 'ChunkArgsFromPage']
    Document: Union[bool, 'DocumentArgsFromPage']
    Page: Union[bool, 'PageArgsFromPage']


class BlockArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    users: Union[bool, 'FindManyUserArgsFromPage']
    plan: Union[bool, 'PlanArgsFromPage']


class TenantArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    tenants: Union[bool, 'FindManyTenantArgsFromPage']


class PlanArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    chats: Union[bool, 'FindManyChatArgsFromPage']
    tenant: Union[bool, 'TenantArgsFromPage']


class UserArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    chats: Union[bool, 'ChatArgsFromPage']


class MessageArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromPage(TypedDict, total=False):
    """Relational arguments for Page"""
    user: Union[bool, 'UserArgsFromPage']
    messages: Union[bool, 'FindManyMessageArgsFromPage']


class ChatArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromPage(TypedDict, total=False):
    """Arguments for Page"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyPageArgs = FindManyPageArgsFromPage
FindFirstPageArgs = FindManyPageArgsFromPage


class PageWhereInput(TypedDict, total=False):
    """Page arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringFilter']
    pageNumber: Union[_int, 'types.IntFilter']
    rawContent: Union[_str, 'types.StringFilter']
    aoi: Union[None, 'fields.Json', 'types.JsonFilter']
    tokenCount: Union[_int, 'types.IntFilter']
    documentId: Union[_str, 'types.StringFilter']
    Document: 'DocumentRelationFilter'
    chunks: 'ChunkListRelationFilter'
    blocks: 'BlockListRelationFilter'

    # should be noted that AND and NOT should be Union['PageWhereInput', List['PageWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PageWhereInput']
    OR: List['PageWhereInput']
    NOT: List['PageWhereInput']



# aggregate Page types


class PageScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Page arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    pageNumber: Union[_int, 'types.IntWithAggregatesFilter']
    rawContent: Union[_str, 'types.StringWithAggregatesFilter']
    aoi: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    tokenCount: Union[_int, 'types.IntWithAggregatesFilter']
    documentId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PageScalarWhereWithAggregatesInput']
    OR: List['PageScalarWhereWithAggregatesInput']
    NOT: List['PageScalarWhereWithAggregatesInput']



class PageGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: _int
    rawContent: _str
    aoi: 'fields.Json'
    tokenCount: _int
    documentId: _str
    _sum: 'PageSumAggregateOutput'
    _avg: 'PageAvgAggregateOutput'
    _min: 'PageMinAggregateOutput'
    _max: 'PageMaxAggregateOutput'
    _count: 'PageCountAggregateOutput'


class PageAvgAggregateOutput(TypedDict, total=False):
    """Page output for aggregating averages"""
    pageNumber: float
    tokenCount: float


class PageSumAggregateOutput(TypedDict, total=False):
    """Page output for aggregating sums"""
    pageNumber: _int
    tokenCount: _int


class PageScalarAggregateOutput(TypedDict, total=False):
    """Page output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: _int
    rawContent: _str
    aoi: 'fields.Json'
    tokenCount: _int
    documentId: _str


PageMinAggregateOutput = PageScalarAggregateOutput
PageMaxAggregateOutput = PageScalarAggregateOutput


class PageMaxAggregateInput(TypedDict, total=False):
    """Page input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    pageNumber: bool
    rawContent: bool
    aoi: bool
    tokenCount: bool
    documentId: bool


class PageMinAggregateInput(TypedDict, total=False):
    """Page input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    pageNumber: bool
    rawContent: bool
    aoi: bool
    tokenCount: bool
    documentId: bool


class PageNumberAggregateInput(TypedDict, total=False):
    """Page input for aggregating numbers"""
    pageNumber: bool
    tokenCount: bool


PageAvgAggregateInput = PageNumberAggregateInput
PageSumAggregateInput = PageNumberAggregateInput


PageCountAggregateInput = TypedDict(
    'PageCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'serffTrackingNumber': bool,
        'pageNumber': bool,
        'rawContent': bool,
        'aoi': bool,
        'tokenCount': bool,
        'documentId': bool,
        '_all': bool,
    },
    total=False,
)

PageCountAggregateOutput = TypedDict(
    'PageCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'serffTrackingNumber': int,
        'pageNumber': int,
        'rawContent': int,
        'aoi': int,
        'tokenCount': int,
        'documentId': int,
        '_all': int,
    },
    total=False,
)


PageKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'pageNumber',
    'rawContent',
    'aoi',
    'tokenCount',
    'documentId',
    'Document',
    'chunks',
    'blocks',
]
PageScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'pageNumber',
    'rawContent',
    'aoi',
    'tokenCount',
    'documentId',
]
PageScalarFieldKeysT = TypeVar('PageScalarFieldKeysT', bound=PageScalarFieldKeys)

PageRelationalFieldKeys = Literal[
        'Document',
        'chunks',
        'blocks',
    ]

# Chunk types

class ChunkOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Chunk create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    bbox: Optional['fields.Json']
    documentId: _str
    Document: 'DocumentCreateNestedWithoutRelationsInput'
    pages: 'PageCreateManyNestedWithoutRelationsInput'
    blocks: 'BlockCreateManyNestedWithoutRelationsInput'


class ChunkCreateInput(ChunkOptionalCreateInput):
    """Required arguments to the Chunk create method"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: _int
    text: _str
    tokenCount: _int
    version: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ChunkOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Chunk create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    bbox: Optional['fields.Json']
    documentId: _str


class ChunkCreateWithoutRelationsInput(ChunkOptionalCreateWithoutRelationsInput):
    """Required arguments to the Chunk create method, without relations"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: _int
    text: _str
    tokenCount: _int
    version: _str

class ChunkConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ChunkCreateWithoutRelationsInput'
    where: 'ChunkWhereUniqueInput'

class ChunkCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ChunkCreateWithoutRelationsInput'
    connect: 'ChunkWhereUniqueInput'
    connect_or_create: 'ChunkConnectOrCreateWithoutRelationsInput'


class ChunkCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ChunkCreateWithoutRelationsInput', List['ChunkCreateWithoutRelationsInput']]
    connect: Union['ChunkWhereUniqueInput', List['ChunkWhereUniqueInput']]
    connect_or_create: Union['ChunkConnectOrCreateWithoutRelationsInput', List['ChunkConnectOrCreateWithoutRelationsInput']]

_ChunkWhereUnique_id_Input = TypedDict(
    '_ChunkWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ChunkWhereUniqueInput = _ChunkWhereUnique_id_Input


class ChunkUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: Union[AtomicIntInput, _int]
    text: _str
    tokenCount: Union[AtomicIntInput, _int]
    bbox: Optional['fields.Json']
    version: _str
    Document: 'DocumentUpdateOneWithoutRelationsInput'
    pages: 'PageUpdateManyWithoutRelationsInput'
    blocks: 'BlockUpdateManyWithoutRelationsInput'


class ChunkUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: Union[AtomicIntInput, _int]
    text: _str
    tokenCount: Union[AtomicIntInput, _int]
    bbox: Optional['fields.Json']
    version: _str


class ChunkUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ChunkCreateWithoutRelationsInput']
    connect: List['ChunkWhereUniqueInput']
    connect_or_create: List['ChunkConnectOrCreateWithoutRelationsInput']
    set: List['ChunkWhereUniqueInput']
    disconnect: List['ChunkWhereUniqueInput']
    delete: List['ChunkWhereUniqueInput']

    # TODO
    # update: List['ChunkUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ChunkUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ChunkScalarWhereInput']
    # upsert: List['ChunkUpserteWithWhereUniqueWithoutRelationsInput']


class ChunkUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ChunkCreateWithoutRelationsInput'
    connect: 'ChunkWhereUniqueInput'
    connect_or_create: 'ChunkConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ChunkUpdateInput'
    # upsert: 'ChunkUpsertWithoutRelationsInput'


class ChunkUpsertInput(TypedDict):
    create: 'ChunkCreateInput'
    update: 'ChunkUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Chunk_id_OrderByInput = TypedDict(
    '_Chunk_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Chunk_createdAt_OrderByInput = TypedDict(
    '_Chunk_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Chunk_updatedAt_OrderByInput = TypedDict(
    '_Chunk_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Chunk_status_OrderByInput = TypedDict(
    '_Chunk_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Chunk_serffTrackingNumber_OrderByInput = TypedDict(
    '_Chunk_serffTrackingNumber_OrderByInput',
    {
        'serffTrackingNumber': 'SortOrder',
    },
    total=True
)

_Chunk_chunkNumber_OrderByInput = TypedDict(
    '_Chunk_chunkNumber_OrderByInput',
    {
        'chunkNumber': 'SortOrder',
    },
    total=True
)

_Chunk_text_OrderByInput = TypedDict(
    '_Chunk_text_OrderByInput',
    {
        'text': 'SortOrder',
    },
    total=True
)

_Chunk_tokenCount_OrderByInput = TypedDict(
    '_Chunk_tokenCount_OrderByInput',
    {
        'tokenCount': 'SortOrder',
    },
    total=True
)

_Chunk_bbox_OrderByInput = TypedDict(
    '_Chunk_bbox_OrderByInput',
    {
        'bbox': 'SortOrder',
    },
    total=True
)

_Chunk_version_OrderByInput = TypedDict(
    '_Chunk_version_OrderByInput',
    {
        'version': 'SortOrder',
    },
    total=True
)

_Chunk_documentId_OrderByInput = TypedDict(
    '_Chunk_documentId_OrderByInput',
    {
        'documentId': 'SortOrder',
    },
    total=True
)

_Chunk_RelevanceInner = TypedDict(
    '_Chunk_RelevanceInner',
    {
        'fields': 'List[ChunkScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Chunk_RelevanceOrderByInput = TypedDict(
    '_Chunk_RelevanceOrderByInput',
    {
        '_relevance': '_Chunk_RelevanceInner',
    },
    total=True
)

ChunkOrderByInput = Union[
    '_Chunk_id_OrderByInput',
    '_Chunk_createdAt_OrderByInput',
    '_Chunk_updatedAt_OrderByInput',
    '_Chunk_status_OrderByInput',
    '_Chunk_serffTrackingNumber_OrderByInput',
    '_Chunk_chunkNumber_OrderByInput',
    '_Chunk_text_OrderByInput',
    '_Chunk_tokenCount_OrderByInput',
    '_Chunk_bbox_OrderByInput',
    '_Chunk_version_OrderByInput',
    '_Chunk_documentId_OrderByInput',
    '_Chunk_RelevanceOrderByInput',
]



# recursive Chunk types
# TODO: cleanup these types



ChunkRelationFilter = TypedDict(
    'ChunkRelationFilter',
    {
        'is': 'ChunkWhereInput',
        'is_not': 'ChunkWhereInput',
    },
    total=False,
)


class ChunkListRelationFilter(TypedDict, total=False):
    some: 'ChunkWhereInput'
    none: 'ChunkWhereInput'
    every: 'ChunkWhereInput'


class ChunkInclude(TypedDict, total=False):
    """Chunk relational arguments"""
    Document: Union[bool, 'DocumentArgsFromChunk']
    pages: Union[bool, 'FindManyPageArgsFromChunk']
    blocks: Union[bool, 'FindManyBlockArgsFromChunk']


class FilingIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    documents: Union[bool, 'FindManyDocumentArgsFromChunk']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromChunk']


class FilingArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromChunk']


class FilingCompanyArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    Filing: Union[bool, 'FilingArgsFromChunk']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromChunk']


class FilingToCompanyArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    Filing: Union[bool, 'FilingArgsFromChunk']
    pages: Union[bool, 'FindManyPageArgsFromChunk']
    chunks: Union[bool, 'FindManyChunkArgsFromChunk']
    blocks: Union[bool, 'FindManyBlockArgsFromChunk']


class DocumentArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    Document: Union[bool, 'DocumentArgsFromChunk']
    chunks: Union[bool, 'FindManyChunkArgsFromChunk']
    blocks: Union[bool, 'FindManyBlockArgsFromChunk']


class PageArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    Document: Union[bool, 'DocumentArgsFromChunk']
    pages: Union[bool, 'FindManyPageArgsFromChunk']
    blocks: Union[bool, 'FindManyBlockArgsFromChunk']


class ChunkArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    Chunk: Union[bool, 'ChunkArgsFromChunk']
    Document: Union[bool, 'DocumentArgsFromChunk']
    Page: Union[bool, 'PageArgsFromChunk']


class BlockArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    users: Union[bool, 'FindManyUserArgsFromChunk']
    plan: Union[bool, 'PlanArgsFromChunk']


class TenantArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    tenants: Union[bool, 'FindManyTenantArgsFromChunk']


class PlanArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    chats: Union[bool, 'FindManyChatArgsFromChunk']
    tenant: Union[bool, 'TenantArgsFromChunk']


class UserArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    chats: Union[bool, 'ChatArgsFromChunk']


class MessageArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromChunk(TypedDict, total=False):
    """Relational arguments for Chunk"""
    user: Union[bool, 'UserArgsFromChunk']
    messages: Union[bool, 'FindManyMessageArgsFromChunk']


class ChatArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromChunk(TypedDict, total=False):
    """Arguments for Chunk"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyChunkArgs = FindManyChunkArgsFromChunk
FindFirstChunkArgs = FindManyChunkArgsFromChunk


class ChunkWhereInput(TypedDict, total=False):
    """Chunk arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringFilter']
    chunkNumber: Union[_int, 'types.IntFilter']
    text: Union[_str, 'types.StringFilter']
    tokenCount: Union[_int, 'types.IntFilter']
    bbox: Union[None, 'fields.Json', 'types.JsonFilter']
    version: Union[_str, 'types.StringFilter']
    documentId: Union[_str, 'types.StringFilter']
    Document: 'DocumentRelationFilter'
    pages: 'PageListRelationFilter'
    blocks: 'BlockListRelationFilter'

    # should be noted that AND and NOT should be Union['ChunkWhereInput', List['ChunkWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ChunkWhereInput']
    OR: List['ChunkWhereInput']
    NOT: List['ChunkWhereInput']



# aggregate Chunk types


class ChunkScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Chunk arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    chunkNumber: Union[_int, 'types.IntWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    tokenCount: Union[_int, 'types.IntWithAggregatesFilter']
    bbox: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    version: Union[_str, 'types.StringWithAggregatesFilter']
    documentId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['ChunkScalarWhereWithAggregatesInput']
    OR: List['ChunkScalarWhereWithAggregatesInput']
    NOT: List['ChunkScalarWhereWithAggregatesInput']



class ChunkGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: _int
    text: _str
    tokenCount: _int
    bbox: 'fields.Json'
    version: _str
    documentId: _str
    _sum: 'ChunkSumAggregateOutput'
    _avg: 'ChunkAvgAggregateOutput'
    _min: 'ChunkMinAggregateOutput'
    _max: 'ChunkMaxAggregateOutput'
    _count: 'ChunkCountAggregateOutput'


class ChunkAvgAggregateOutput(TypedDict, total=False):
    """Chunk output for aggregating averages"""
    chunkNumber: float
    tokenCount: float


class ChunkSumAggregateOutput(TypedDict, total=False):
    """Chunk output for aggregating sums"""
    chunkNumber: _int
    tokenCount: _int


class ChunkScalarAggregateOutput(TypedDict, total=False):
    """Chunk output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: _int
    text: _str
    tokenCount: _int
    bbox: 'fields.Json'
    version: _str
    documentId: _str


ChunkMinAggregateOutput = ChunkScalarAggregateOutput
ChunkMaxAggregateOutput = ChunkScalarAggregateOutput


class ChunkMaxAggregateInput(TypedDict, total=False):
    """Chunk input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    chunkNumber: bool
    text: bool
    tokenCount: bool
    bbox: bool
    version: bool
    documentId: bool


class ChunkMinAggregateInput(TypedDict, total=False):
    """Chunk input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    chunkNumber: bool
    text: bool
    tokenCount: bool
    bbox: bool
    version: bool
    documentId: bool


class ChunkNumberAggregateInput(TypedDict, total=False):
    """Chunk input for aggregating numbers"""
    chunkNumber: bool
    tokenCount: bool


ChunkAvgAggregateInput = ChunkNumberAggregateInput
ChunkSumAggregateInput = ChunkNumberAggregateInput


ChunkCountAggregateInput = TypedDict(
    'ChunkCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'serffTrackingNumber': bool,
        'chunkNumber': bool,
        'text': bool,
        'tokenCount': bool,
        'bbox': bool,
        'version': bool,
        'documentId': bool,
        '_all': bool,
    },
    total=False,
)

ChunkCountAggregateOutput = TypedDict(
    'ChunkCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'serffTrackingNumber': int,
        'chunkNumber': int,
        'text': int,
        'tokenCount': int,
        'bbox': int,
        'version': int,
        'documentId': int,
        '_all': int,
    },
    total=False,
)


ChunkKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'chunkNumber',
    'text',
    'tokenCount',
    'bbox',
    'version',
    'documentId',
    'Document',
    'pages',
    'blocks',
]
ChunkScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'chunkNumber',
    'text',
    'tokenCount',
    'bbox',
    'version',
    'documentId',
]
ChunkScalarFieldKeysT = TypeVar('ChunkScalarFieldKeysT', bound=ChunkScalarFieldKeys)

ChunkRelationalFieldKeys = Literal[
        'Document',
        'pages',
        'blocks',
    ]

# Block types

class BlockOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Block create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    bbox: List[_float]
    chunkId: _str
    documentId: _str
    pageId: _str
    Chunk: 'ChunkCreateNestedWithoutRelationsInput'
    Document: 'DocumentCreateNestedWithoutRelationsInput'
    Page: 'PageCreateNestedWithoutRelationsInput'


class BlockCreateInput(BlockOptionalCreateInput):
    """Required arguments to the Block create method"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: _int
    pageNumber: _int
    text: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BlockOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Block create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    bbox: List[_float]
    chunkId: _str
    documentId: _str
    pageId: _str


class BlockCreateWithoutRelationsInput(BlockOptionalCreateWithoutRelationsInput):
    """Required arguments to the Block create method, without relations"""
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: _int
    pageNumber: _int
    text: _str

class BlockConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BlockCreateWithoutRelationsInput'
    where: 'BlockWhereUniqueInput'

class BlockCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BlockCreateWithoutRelationsInput'
    connect: 'BlockWhereUniqueInput'
    connect_or_create: 'BlockConnectOrCreateWithoutRelationsInput'


class BlockCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BlockCreateWithoutRelationsInput', List['BlockCreateWithoutRelationsInput']]
    connect: Union['BlockWhereUniqueInput', List['BlockWhereUniqueInput']]
    connect_or_create: Union['BlockConnectOrCreateWithoutRelationsInput', List['BlockConnectOrCreateWithoutRelationsInput']]

_BlockWhereUnique_id_Input = TypedDict(
    '_BlockWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

BlockWhereUniqueInput = _BlockWhereUnique_id_Input


class BlockUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: Union[AtomicIntInput, _int]
    pageNumber: Union[AtomicIntInput, _int]
    text: _str
    bbox: 'types.FloatListUpdate'
    Chunk: 'ChunkUpdateOneWithoutRelationsInput'
    Document: 'DocumentUpdateOneWithoutRelationsInput'
    Page: 'PageUpdateOneWithoutRelationsInput'


class BlockUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: Union[AtomicIntInput, _int]
    pageNumber: Union[AtomicIntInput, _int]
    text: _str
    bbox: 'types.FloatListUpdate'


class BlockUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BlockCreateWithoutRelationsInput']
    connect: List['BlockWhereUniqueInput']
    connect_or_create: List['BlockConnectOrCreateWithoutRelationsInput']
    set: List['BlockWhereUniqueInput']
    disconnect: List['BlockWhereUniqueInput']
    delete: List['BlockWhereUniqueInput']

    # TODO
    # update: List['BlockUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BlockUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BlockScalarWhereInput']
    # upsert: List['BlockUpserteWithWhereUniqueWithoutRelationsInput']


class BlockUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BlockCreateWithoutRelationsInput'
    connect: 'BlockWhereUniqueInput'
    connect_or_create: 'BlockConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BlockUpdateInput'
    # upsert: 'BlockUpsertWithoutRelationsInput'


class BlockUpsertInput(TypedDict):
    create: 'BlockCreateInput'
    update: 'BlockUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Block_id_OrderByInput = TypedDict(
    '_Block_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Block_createdAt_OrderByInput = TypedDict(
    '_Block_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Block_updatedAt_OrderByInput = TypedDict(
    '_Block_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Block_status_OrderByInput = TypedDict(
    '_Block_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Block_serffTrackingNumber_OrderByInput = TypedDict(
    '_Block_serffTrackingNumber_OrderByInput',
    {
        'serffTrackingNumber': 'SortOrder',
    },
    total=True
)

_Block_blockNumber_OrderByInput = TypedDict(
    '_Block_blockNumber_OrderByInput',
    {
        'blockNumber': 'SortOrder',
    },
    total=True
)

_Block_pageNumber_OrderByInput = TypedDict(
    '_Block_pageNumber_OrderByInput',
    {
        'pageNumber': 'SortOrder',
    },
    total=True
)

_Block_text_OrderByInput = TypedDict(
    '_Block_text_OrderByInput',
    {
        'text': 'SortOrder',
    },
    total=True
)

_Block_bbox_OrderByInput = TypedDict(
    '_Block_bbox_OrderByInput',
    {
        'bbox': 'SortOrder',
    },
    total=True
)

_Block_chunkId_OrderByInput = TypedDict(
    '_Block_chunkId_OrderByInput',
    {
        'chunkId': 'SortOrder',
    },
    total=True
)

_Block_documentId_OrderByInput = TypedDict(
    '_Block_documentId_OrderByInput',
    {
        'documentId': 'SortOrder',
    },
    total=True
)

_Block_pageId_OrderByInput = TypedDict(
    '_Block_pageId_OrderByInput',
    {
        'pageId': 'SortOrder',
    },
    total=True
)

_Block_RelevanceInner = TypedDict(
    '_Block_RelevanceInner',
    {
        'fields': 'List[BlockScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Block_RelevanceOrderByInput = TypedDict(
    '_Block_RelevanceOrderByInput',
    {
        '_relevance': '_Block_RelevanceInner',
    },
    total=True
)

BlockOrderByInput = Union[
    '_Block_id_OrderByInput',
    '_Block_createdAt_OrderByInput',
    '_Block_updatedAt_OrderByInput',
    '_Block_status_OrderByInput',
    '_Block_serffTrackingNumber_OrderByInput',
    '_Block_blockNumber_OrderByInput',
    '_Block_pageNumber_OrderByInput',
    '_Block_text_OrderByInput',
    '_Block_bbox_OrderByInput',
    '_Block_chunkId_OrderByInput',
    '_Block_documentId_OrderByInput',
    '_Block_pageId_OrderByInput',
    '_Block_RelevanceOrderByInput',
]



# recursive Block types
# TODO: cleanup these types



BlockRelationFilter = TypedDict(
    'BlockRelationFilter',
    {
        'is': 'BlockWhereInput',
        'is_not': 'BlockWhereInput',
    },
    total=False,
)


class BlockListRelationFilter(TypedDict, total=False):
    some: 'BlockWhereInput'
    none: 'BlockWhereInput'
    every: 'BlockWhereInput'


class BlockInclude(TypedDict, total=False):
    """Block relational arguments"""
    Chunk: Union[bool, 'ChunkArgsFromBlock']
    Document: Union[bool, 'DocumentArgsFromBlock']
    Page: Union[bool, 'PageArgsFromBlock']


class FilingIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    documents: Union[bool, 'FindManyDocumentArgsFromBlock']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromBlock']


class FilingArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromBlock']


class FilingCompanyArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    Filing: Union[bool, 'FilingArgsFromBlock']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromBlock']


class FilingToCompanyArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    Filing: Union[bool, 'FilingArgsFromBlock']
    pages: Union[bool, 'FindManyPageArgsFromBlock']
    chunks: Union[bool, 'FindManyChunkArgsFromBlock']
    blocks: Union[bool, 'FindManyBlockArgsFromBlock']


class DocumentArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    Document: Union[bool, 'DocumentArgsFromBlock']
    chunks: Union[bool, 'FindManyChunkArgsFromBlock']
    blocks: Union[bool, 'FindManyBlockArgsFromBlock']


class PageArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    Document: Union[bool, 'DocumentArgsFromBlock']
    pages: Union[bool, 'FindManyPageArgsFromBlock']
    blocks: Union[bool, 'FindManyBlockArgsFromBlock']


class ChunkArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    Chunk: Union[bool, 'ChunkArgsFromBlock']
    Document: Union[bool, 'DocumentArgsFromBlock']
    Page: Union[bool, 'PageArgsFromBlock']


class BlockArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    users: Union[bool, 'FindManyUserArgsFromBlock']
    plan: Union[bool, 'PlanArgsFromBlock']


class TenantArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    tenants: Union[bool, 'FindManyTenantArgsFromBlock']


class PlanArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    chats: Union[bool, 'FindManyChatArgsFromBlock']
    tenant: Union[bool, 'TenantArgsFromBlock']


class UserArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    chats: Union[bool, 'ChatArgsFromBlock']


class MessageArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromBlock(TypedDict, total=False):
    """Relational arguments for Block"""
    user: Union[bool, 'UserArgsFromBlock']
    messages: Union[bool, 'FindManyMessageArgsFromBlock']


class ChatArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromBlock(TypedDict, total=False):
    """Arguments for Block"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyBlockArgs = FindManyBlockArgsFromBlock
FindFirstBlockArgs = FindManyBlockArgsFromBlock


class BlockWhereInput(TypedDict, total=False):
    """Block arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringFilter']
    blockNumber: Union[_int, 'types.IntFilter']
    pageNumber: Union[_int, 'types.IntFilter']
    text: Union[_str, 'types.StringFilter']
    bbox: 'types.FloatListFilter'
    chunkId: Union[_str, 'types.StringFilter']
    documentId: Union[_str, 'types.StringFilter']
    pageId: Union[_str, 'types.StringFilter']
    Chunk: 'ChunkRelationFilter'
    Document: 'DocumentRelationFilter'
    Page: 'PageRelationFilter'

    # should be noted that AND and NOT should be Union['BlockWhereInput', List['BlockWhereInput']]
    # but this causes mypy to hang :/
    AND: List['BlockWhereInput']
    OR: List['BlockWhereInput']
    NOT: List['BlockWhereInput']



# aggregate Block types


class BlockScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Block arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    serffTrackingNumber: Union[_str, 'types.StringWithAggregatesFilter']
    blockNumber: Union[_int, 'types.IntWithAggregatesFilter']
    pageNumber: Union[_int, 'types.IntWithAggregatesFilter']
    text: Union[_str, 'types.StringWithAggregatesFilter']
    bbox: Union[_float, 'types.FloatWithAggregatesFilter']
    chunkId: Union[_str, 'types.StringWithAggregatesFilter']
    documentId: Union[_str, 'types.StringWithAggregatesFilter']
    pageId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['BlockScalarWhereWithAggregatesInput']
    OR: List['BlockScalarWhereWithAggregatesInput']
    NOT: List['BlockScalarWhereWithAggregatesInput']



class BlockGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: _int
    pageNumber: _int
    text: _str
    bbox: List[_float]
    chunkId: _str
    documentId: _str
    pageId: _str
    _sum: 'BlockSumAggregateOutput'
    _avg: 'BlockAvgAggregateOutput'
    _min: 'BlockMinAggregateOutput'
    _max: 'BlockMaxAggregateOutput'
    _count: 'BlockCountAggregateOutput'


class BlockAvgAggregateOutput(TypedDict, total=False):
    """Block output for aggregating averages"""
    blockNumber: float
    pageNumber: float
    bbox: float


class BlockSumAggregateOutput(TypedDict, total=False):
    """Block output for aggregating sums"""
    blockNumber: _int
    pageNumber: _int
    bbox: List[_float]


class BlockScalarAggregateOutput(TypedDict, total=False):
    """Block output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: _int
    pageNumber: _int
    text: _str
    bbox: List[_float]
    chunkId: _str
    documentId: _str
    pageId: _str


BlockMinAggregateOutput = BlockScalarAggregateOutput
BlockMaxAggregateOutput = BlockScalarAggregateOutput


class BlockMaxAggregateInput(TypedDict, total=False):
    """Block input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    blockNumber: bool
    pageNumber: bool
    text: bool
    bbox: bool
    chunkId: bool
    documentId: bool
    pageId: bool


class BlockMinAggregateInput(TypedDict, total=False):
    """Block input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    serffTrackingNumber: bool
    blockNumber: bool
    pageNumber: bool
    text: bool
    bbox: bool
    chunkId: bool
    documentId: bool
    pageId: bool


class BlockNumberAggregateInput(TypedDict, total=False):
    """Block input for aggregating numbers"""
    blockNumber: bool
    pageNumber: bool
    bbox: bool


BlockAvgAggregateInput = BlockNumberAggregateInput
BlockSumAggregateInput = BlockNumberAggregateInput


BlockCountAggregateInput = TypedDict(
    'BlockCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'serffTrackingNumber': bool,
        'blockNumber': bool,
        'pageNumber': bool,
        'text': bool,
        'bbox': bool,
        'chunkId': bool,
        'documentId': bool,
        'pageId': bool,
        '_all': bool,
    },
    total=False,
)

BlockCountAggregateOutput = TypedDict(
    'BlockCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'serffTrackingNumber': int,
        'blockNumber': int,
        'pageNumber': int,
        'text': int,
        'bbox': int,
        'chunkId': int,
        'documentId': int,
        'pageId': int,
        '_all': int,
    },
    total=False,
)


BlockKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'blockNumber',
    'pageNumber',
    'text',
    'bbox',
    'chunkId',
    'documentId',
    'pageId',
    'Chunk',
    'Document',
    'Page',
]
BlockScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'serffTrackingNumber',
    'blockNumber',
    'pageNumber',
    'text',
    'bbox',
    'chunkId',
    'documentId',
    'pageId',
]
BlockScalarFieldKeysT = TypeVar('BlockScalarFieldKeysT', bound=BlockScalarFieldKeys)

BlockRelationalFieldKeys = Literal[
        'Chunk',
        'Document',
        'Page',
    ]

# Tenant types

class TenantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    logoUrl: Optional[_str]
    databaseUrl: Optional[_str]
    planId: _str
    users: 'UserCreateManyNestedWithoutRelationsInput'
    plan: 'PlanCreateNestedWithoutRelationsInput'


class TenantCreateInput(TenantOptionalCreateInput):
    """Required arguments to the Tenant create method"""
    status: 'enums.StatusEnum'
    name: _str
    slug: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TenantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    logoUrl: Optional[_str]
    databaseUrl: Optional[_str]
    planId: _str


class TenantCreateWithoutRelationsInput(TenantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tenant create method, without relations"""
    status: 'enums.StatusEnum'
    name: _str
    slug: _str

class TenantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TenantCreateWithoutRelationsInput'
    where: 'TenantWhereUniqueInput'

class TenantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'


class TenantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TenantCreateWithoutRelationsInput', List['TenantCreateWithoutRelationsInput']]
    connect: Union['TenantWhereUniqueInput', List['TenantWhereUniqueInput']]
    connect_or_create: Union['TenantConnectOrCreateWithoutRelationsInput', List['TenantConnectOrCreateWithoutRelationsInput']]

_TenantWhereUnique_id_Input = TypedDict(
    '_TenantWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TenantWhereUniqueInput = _TenantWhereUnique_id_Input


class TenantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    slug: _str
    logoUrl: Optional[_str]
    databaseUrl: Optional[_str]
    users: 'UserUpdateManyWithoutRelationsInput'
    plan: 'PlanUpdateOneWithoutRelationsInput'


class TenantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    slug: _str
    logoUrl: Optional[_str]
    databaseUrl: Optional[_str]


class TenantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TenantCreateWithoutRelationsInput']
    connect: List['TenantWhereUniqueInput']
    connect_or_create: List['TenantConnectOrCreateWithoutRelationsInput']
    set: List['TenantWhereUniqueInput']
    disconnect: List['TenantWhereUniqueInput']
    delete: List['TenantWhereUniqueInput']

    # TODO
    # update: List['TenantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TenantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TenantScalarWhereInput']
    # upsert: List['TenantUpserteWithWhereUniqueWithoutRelationsInput']


class TenantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TenantUpdateInput'
    # upsert: 'TenantUpsertWithoutRelationsInput'


class TenantUpsertInput(TypedDict):
    create: 'TenantCreateInput'
    update: 'TenantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tenant_id_OrderByInput = TypedDict(
    '_Tenant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tenant_createdAt_OrderByInput = TypedDict(
    '_Tenant_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tenant_updatedAt_OrderByInput = TypedDict(
    '_Tenant_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tenant_status_OrderByInput = TypedDict(
    '_Tenant_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Tenant_name_OrderByInput = TypedDict(
    '_Tenant_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Tenant_slug_OrderByInput = TypedDict(
    '_Tenant_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Tenant_logoUrl_OrderByInput = TypedDict(
    '_Tenant_logoUrl_OrderByInput',
    {
        'logoUrl': 'SortOrder',
    },
    total=True
)

_Tenant_databaseUrl_OrderByInput = TypedDict(
    '_Tenant_databaseUrl_OrderByInput',
    {
        'databaseUrl': 'SortOrder',
    },
    total=True
)

_Tenant_planId_OrderByInput = TypedDict(
    '_Tenant_planId_OrderByInput',
    {
        'planId': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceInner = TypedDict(
    '_Tenant_RelevanceInner',
    {
        'fields': 'List[TenantScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceOrderByInput = TypedDict(
    '_Tenant_RelevanceOrderByInput',
    {
        '_relevance': '_Tenant_RelevanceInner',
    },
    total=True
)

TenantOrderByInput = Union[
    '_Tenant_id_OrderByInput',
    '_Tenant_createdAt_OrderByInput',
    '_Tenant_updatedAt_OrderByInput',
    '_Tenant_status_OrderByInput',
    '_Tenant_name_OrderByInput',
    '_Tenant_slug_OrderByInput',
    '_Tenant_logoUrl_OrderByInput',
    '_Tenant_databaseUrl_OrderByInput',
    '_Tenant_planId_OrderByInput',
    '_Tenant_RelevanceOrderByInput',
]



# recursive Tenant types
# TODO: cleanup these types



TenantRelationFilter = TypedDict(
    'TenantRelationFilter',
    {
        'is': 'TenantWhereInput',
        'is_not': 'TenantWhereInput',
    },
    total=False,
)


class TenantListRelationFilter(TypedDict, total=False):
    some: 'TenantWhereInput'
    none: 'TenantWhereInput'
    every: 'TenantWhereInput'


class TenantInclude(TypedDict, total=False):
    """Tenant relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromTenant']
    plan: Union[bool, 'PlanArgsFromTenant']


class FilingIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    documents: Union[bool, 'FindManyDocumentArgsFromTenant']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromTenant']


class FilingArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromTenant']


class FilingCompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    Filing: Union[bool, 'FilingArgsFromTenant']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromTenant']


class FilingToCompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    Filing: Union[bool, 'FilingArgsFromTenant']
    pages: Union[bool, 'FindManyPageArgsFromTenant']
    chunks: Union[bool, 'FindManyChunkArgsFromTenant']
    blocks: Union[bool, 'FindManyBlockArgsFromTenant']


class DocumentArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    Document: Union[bool, 'DocumentArgsFromTenant']
    chunks: Union[bool, 'FindManyChunkArgsFromTenant']
    blocks: Union[bool, 'FindManyBlockArgsFromTenant']


class PageArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    Document: Union[bool, 'DocumentArgsFromTenant']
    pages: Union[bool, 'FindManyPageArgsFromTenant']
    blocks: Union[bool, 'FindManyBlockArgsFromTenant']


class ChunkArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    Chunk: Union[bool, 'ChunkArgsFromTenant']
    Document: Union[bool, 'DocumentArgsFromTenant']
    Page: Union[bool, 'PageArgsFromTenant']


class BlockArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenant']
    plan: Union[bool, 'PlanArgsFromTenant']


class TenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenants: Union[bool, 'FindManyTenantArgsFromTenant']


class PlanArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    chats: Union[bool, 'FindManyChatArgsFromTenant']
    tenant: Union[bool, 'TenantArgsFromTenant']


class UserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    chats: Union[bool, 'ChatArgsFromTenant']


class MessageArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenant']
    messages: Union[bool, 'FindManyMessageArgsFromTenant']


class ChatArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyTenantArgs = FindManyTenantArgsFromTenant
FindFirstTenantArgs = FindManyTenantArgsFromTenant


class TenantWhereInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    logoUrl: Union[None, _str, 'types.StringFilter']
    databaseUrl: Union[None, _str, 'types.StringFilter']
    planId: Union[_str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    plan: 'PlanRelationFilter'

    # should be noted that AND and NOT should be Union['TenantWhereInput', List['TenantWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInput']
    OR: List['TenantWhereInput']
    NOT: List['TenantWhereInput']



# aggregate Tenant types


class TenantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    logoUrl: Union[_str, 'types.StringWithAggregatesFilter']
    databaseUrl: Union[_str, 'types.StringWithAggregatesFilter']
    planId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInput']
    OR: List['TenantScalarWhereWithAggregatesInput']
    NOT: List['TenantScalarWhereWithAggregatesInput']



class TenantGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    slug: _str
    logoUrl: _str
    databaseUrl: _str
    planId: _str
    _sum: 'TenantSumAggregateOutput'
    _avg: 'TenantAvgAggregateOutput'
    _min: 'TenantMinAggregateOutput'
    _max: 'TenantMaxAggregateOutput'
    _count: 'TenantCountAggregateOutput'


class TenantAvgAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating averages"""


class TenantSumAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating sums"""


class TenantScalarAggregateOutput(TypedDict, total=False):
    """Tenant output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    slug: _str
    logoUrl: _str
    databaseUrl: _str
    planId: _str


TenantMinAggregateOutput = TenantScalarAggregateOutput
TenantMaxAggregateOutput = TenantScalarAggregateOutput


class TenantMaxAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    name: bool
    slug: bool
    logoUrl: bool
    databaseUrl: bool
    planId: bool


class TenantMinAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    name: bool
    slug: bool
    logoUrl: bool
    databaseUrl: bool
    planId: bool


class TenantNumberAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating numbers"""


TenantAvgAggregateInput = TenantNumberAggregateInput
TenantSumAggregateInput = TenantNumberAggregateInput


TenantCountAggregateInput = TypedDict(
    'TenantCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'name': bool,
        'slug': bool,
        'logoUrl': bool,
        'databaseUrl': bool,
        'planId': bool,
        '_all': bool,
    },
    total=False,
)

TenantCountAggregateOutput = TypedDict(
    'TenantCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'name': int,
        'slug': int,
        'logoUrl': int,
        'databaseUrl': int,
        'planId': int,
        '_all': int,
    },
    total=False,
)


TenantKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'name',
    'slug',
    'logoUrl',
    'databaseUrl',
    'planId',
    'users',
    'plan',
]
TenantScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'name',
    'slug',
    'logoUrl',
    'databaseUrl',
    'planId',
]
TenantScalarFieldKeysT = TypeVar('TenantScalarFieldKeysT', bound=TenantScalarFieldKeys)

TenantRelationalFieldKeys = Literal[
        'users',
        'plan',
    ]

# Plan types

class PlanOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Plan create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    description: Optional[_str]
    features: Optional['fields.Json']
    tenants: 'TenantCreateManyNestedWithoutRelationsInput'


class PlanCreateInput(PlanOptionalCreateInput):
    """Required arguments to the Plan create method"""
    status: 'enums.StatusEnum'
    name: _str
    type: 'enums.PlanTypeEnum'
    price: _int
    tenantId: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PlanOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Plan create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    description: Optional[_str]
    features: Optional['fields.Json']


class PlanCreateWithoutRelationsInput(PlanOptionalCreateWithoutRelationsInput):
    """Required arguments to the Plan create method, without relations"""
    status: 'enums.StatusEnum'
    name: _str
    type: 'enums.PlanTypeEnum'
    price: _int
    tenantId: _str

class PlanConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PlanCreateWithoutRelationsInput'
    where: 'PlanWhereUniqueInput'

class PlanCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PlanCreateWithoutRelationsInput'
    connect: 'PlanWhereUniqueInput'
    connect_or_create: 'PlanConnectOrCreateWithoutRelationsInput'


class PlanCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PlanCreateWithoutRelationsInput', List['PlanCreateWithoutRelationsInput']]
    connect: Union['PlanWhereUniqueInput', List['PlanWhereUniqueInput']]
    connect_or_create: Union['PlanConnectOrCreateWithoutRelationsInput', List['PlanConnectOrCreateWithoutRelationsInput']]

_PlanWhereUnique_id_Input = TypedDict(
    '_PlanWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PlanWhereUniqueInput = _PlanWhereUnique_id_Input


class PlanUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    description: Optional[_str]
    type: 'enums.PlanTypeEnum'
    price: Union[AtomicIntInput, _int]
    features: Optional['fields.Json']
    tenantId: _str
    tenants: 'TenantUpdateManyWithoutRelationsInput'


class PlanUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    description: Optional[_str]
    type: 'enums.PlanTypeEnum'
    price: Union[AtomicIntInput, _int]
    features: Optional['fields.Json']
    tenantId: _str


class PlanUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PlanCreateWithoutRelationsInput']
    connect: List['PlanWhereUniqueInput']
    connect_or_create: List['PlanConnectOrCreateWithoutRelationsInput']
    set: List['PlanWhereUniqueInput']
    disconnect: List['PlanWhereUniqueInput']
    delete: List['PlanWhereUniqueInput']

    # TODO
    # update: List['PlanUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PlanUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PlanScalarWhereInput']
    # upsert: List['PlanUpserteWithWhereUniqueWithoutRelationsInput']


class PlanUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PlanCreateWithoutRelationsInput'
    connect: 'PlanWhereUniqueInput'
    connect_or_create: 'PlanConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PlanUpdateInput'
    # upsert: 'PlanUpsertWithoutRelationsInput'


class PlanUpsertInput(TypedDict):
    create: 'PlanCreateInput'
    update: 'PlanUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Plan_id_OrderByInput = TypedDict(
    '_Plan_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Plan_createdAt_OrderByInput = TypedDict(
    '_Plan_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Plan_updatedAt_OrderByInput = TypedDict(
    '_Plan_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Plan_status_OrderByInput = TypedDict(
    '_Plan_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Plan_name_OrderByInput = TypedDict(
    '_Plan_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Plan_description_OrderByInput = TypedDict(
    '_Plan_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Plan_type_OrderByInput = TypedDict(
    '_Plan_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Plan_price_OrderByInput = TypedDict(
    '_Plan_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_Plan_features_OrderByInput = TypedDict(
    '_Plan_features_OrderByInput',
    {
        'features': 'SortOrder',
    },
    total=True
)

_Plan_tenantId_OrderByInput = TypedDict(
    '_Plan_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Plan_RelevanceInner = TypedDict(
    '_Plan_RelevanceInner',
    {
        'fields': 'List[PlanScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Plan_RelevanceOrderByInput = TypedDict(
    '_Plan_RelevanceOrderByInput',
    {
        '_relevance': '_Plan_RelevanceInner',
    },
    total=True
)

PlanOrderByInput = Union[
    '_Plan_id_OrderByInput',
    '_Plan_createdAt_OrderByInput',
    '_Plan_updatedAt_OrderByInput',
    '_Plan_status_OrderByInput',
    '_Plan_name_OrderByInput',
    '_Plan_description_OrderByInput',
    '_Plan_type_OrderByInput',
    '_Plan_price_OrderByInput',
    '_Plan_features_OrderByInput',
    '_Plan_tenantId_OrderByInput',
    '_Plan_RelevanceOrderByInput',
]



# recursive Plan types
# TODO: cleanup these types



PlanRelationFilter = TypedDict(
    'PlanRelationFilter',
    {
        'is': 'PlanWhereInput',
        'is_not': 'PlanWhereInput',
    },
    total=False,
)


class PlanListRelationFilter(TypedDict, total=False):
    some: 'PlanWhereInput'
    none: 'PlanWhereInput'
    every: 'PlanWhereInput'


class PlanInclude(TypedDict, total=False):
    """Plan relational arguments"""
    tenants: Union[bool, 'FindManyTenantArgsFromPlan']


class FilingIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    documents: Union[bool, 'FindManyDocumentArgsFromPlan']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromPlan']


class FilingArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromPlan']


class FilingCompanyArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    Filing: Union[bool, 'FilingArgsFromPlan']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromPlan']


class FilingToCompanyArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    Filing: Union[bool, 'FilingArgsFromPlan']
    pages: Union[bool, 'FindManyPageArgsFromPlan']
    chunks: Union[bool, 'FindManyChunkArgsFromPlan']
    blocks: Union[bool, 'FindManyBlockArgsFromPlan']


class DocumentArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    Document: Union[bool, 'DocumentArgsFromPlan']
    chunks: Union[bool, 'FindManyChunkArgsFromPlan']
    blocks: Union[bool, 'FindManyBlockArgsFromPlan']


class PageArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    Document: Union[bool, 'DocumentArgsFromPlan']
    pages: Union[bool, 'FindManyPageArgsFromPlan']
    blocks: Union[bool, 'FindManyBlockArgsFromPlan']


class ChunkArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    Chunk: Union[bool, 'ChunkArgsFromPlan']
    Document: Union[bool, 'DocumentArgsFromPlan']
    Page: Union[bool, 'PageArgsFromPlan']


class BlockArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    users: Union[bool, 'FindManyUserArgsFromPlan']
    plan: Union[bool, 'PlanArgsFromPlan']


class TenantArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    tenants: Union[bool, 'FindManyTenantArgsFromPlan']


class PlanArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    chats: Union[bool, 'FindManyChatArgsFromPlan']
    tenant: Union[bool, 'TenantArgsFromPlan']


class UserArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    chats: Union[bool, 'ChatArgsFromPlan']


class MessageArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromPlan(TypedDict, total=False):
    """Relational arguments for Plan"""
    user: Union[bool, 'UserArgsFromPlan']
    messages: Union[bool, 'FindManyMessageArgsFromPlan']


class ChatArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromPlan(TypedDict, total=False):
    """Arguments for Plan"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyPlanArgs = FindManyPlanArgsFromPlan
FindFirstPlanArgs = FindManyPlanArgsFromPlan


class PlanWhereInput(TypedDict, total=False):
    """Plan arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    type: 'enums.PlanTypeEnum'
    price: Union[_int, 'types.IntFilter']
    features: Union[None, 'fields.Json', 'types.JsonFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenants: 'TenantListRelationFilter'

    # should be noted that AND and NOT should be Union['PlanWhereInput', List['PlanWhereInput']]
    # but this causes mypy to hang :/
    AND: List['PlanWhereInput']
    OR: List['PlanWhereInput']
    NOT: List['PlanWhereInput']



# aggregate Plan types


class PlanScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Plan arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.PlanTypeEnum'
    price: Union[_int, 'types.IntWithAggregatesFilter']
    features: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['PlanScalarWhereWithAggregatesInput']
    OR: List['PlanScalarWhereWithAggregatesInput']
    NOT: List['PlanScalarWhereWithAggregatesInput']



class PlanGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    description: _str
    type: 'enums.PlanTypeEnum'
    price: _int
    features: 'fields.Json'
    tenantId: _str
    _sum: 'PlanSumAggregateOutput'
    _avg: 'PlanAvgAggregateOutput'
    _min: 'PlanMinAggregateOutput'
    _max: 'PlanMaxAggregateOutput'
    _count: 'PlanCountAggregateOutput'


class PlanAvgAggregateOutput(TypedDict, total=False):
    """Plan output for aggregating averages"""
    price: float


class PlanSumAggregateOutput(TypedDict, total=False):
    """Plan output for aggregating sums"""
    price: _int


class PlanScalarAggregateOutput(TypedDict, total=False):
    """Plan output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    description: _str
    type: 'enums.PlanTypeEnum'
    price: _int
    features: 'fields.Json'
    tenantId: _str


PlanMinAggregateOutput = PlanScalarAggregateOutput
PlanMaxAggregateOutput = PlanScalarAggregateOutput


class PlanMaxAggregateInput(TypedDict, total=False):
    """Plan input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    name: bool
    description: bool
    type: bool
    price: bool
    features: bool
    tenantId: bool


class PlanMinAggregateInput(TypedDict, total=False):
    """Plan input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    name: bool
    description: bool
    type: bool
    price: bool
    features: bool
    tenantId: bool


class PlanNumberAggregateInput(TypedDict, total=False):
    """Plan input for aggregating numbers"""
    price: bool


PlanAvgAggregateInput = PlanNumberAggregateInput
PlanSumAggregateInput = PlanNumberAggregateInput


PlanCountAggregateInput = TypedDict(
    'PlanCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'name': bool,
        'description': bool,
        'type': bool,
        'price': bool,
        'features': bool,
        'tenantId': bool,
        '_all': bool,
    },
    total=False,
)

PlanCountAggregateOutput = TypedDict(
    'PlanCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'name': int,
        'description': int,
        'type': int,
        'price': int,
        'features': int,
        'tenantId': int,
        '_all': int,
    },
    total=False,
)


PlanKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'name',
    'description',
    'type',
    'price',
    'features',
    'tenantId',
    'tenants',
]
PlanScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'name',
    'description',
    'type',
    'price',
    'features',
    'tenantId',
]
PlanScalarFieldKeysT = TypeVar('PlanScalarFieldKeysT', bound=PlanScalarFieldKeys)

PlanRelationalFieldKeys = Literal[
        'tenants',
    ]

# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tenantId: _str
    isEmailVerified: _bool
    lastLoginAt: Optional[datetime.datetime]
    chats: 'ChatCreateManyNestedWithoutRelationsInput'
    tenant: 'TenantCreateNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    hashedPassword: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tenantId: _str
    isEmailVerified: _bool
    lastLoginAt: Optional[datetime.datetime]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    hashedPassword: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    hashedPassword: _str
    isEmailVerified: _bool
    lastLoginAt: Optional[datetime.datetime]
    chats: 'ChatUpdateManyWithoutRelationsInput'
    tenant: 'TenantUpdateOneWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    hashedPassword: _str
    isEmailVerified: _bool
    lastLoginAt: Optional[datetime.datetime]


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_status_OrderByInput = TypedDict(
    '_User_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_tenantId_OrderByInput = TypedDict(
    '_User_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_User_hashedPassword_OrderByInput = TypedDict(
    '_User_hashedPassword_OrderByInput',
    {
        'hashedPassword': 'SortOrder',
    },
    total=True
)

_User_isEmailVerified_OrderByInput = TypedDict(
    '_User_isEmailVerified_OrderByInput',
    {
        'isEmailVerified': 'SortOrder',
    },
    total=True
)

_User_lastLoginAt_OrderByInput = TypedDict(
    '_User_lastLoginAt_OrderByInput',
    {
        'lastLoginAt': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_status_OrderByInput',
    '_User_email_OrderByInput',
    '_User_name_OrderByInput',
    '_User_tenantId_OrderByInput',
    '_User_hashedPassword_OrderByInput',
    '_User_isEmailVerified_OrderByInput',
    '_User_lastLoginAt_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    chats: Union[bool, 'FindManyChatArgsFromUser']
    tenant: Union[bool, 'TenantArgsFromUser']


class FilingIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    documents: Union[bool, 'FindManyDocumentArgsFromUser']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromUser']


class FilingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromUser']


class FilingCompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Filing: Union[bool, 'FilingArgsFromUser']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromUser']


class FilingToCompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Filing: Union[bool, 'FilingArgsFromUser']
    pages: Union[bool, 'FindManyPageArgsFromUser']
    chunks: Union[bool, 'FindManyChunkArgsFromUser']
    blocks: Union[bool, 'FindManyBlockArgsFromUser']


class DocumentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Document: Union[bool, 'DocumentArgsFromUser']
    chunks: Union[bool, 'FindManyChunkArgsFromUser']
    blocks: Union[bool, 'FindManyBlockArgsFromUser']


class PageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Document: Union[bool, 'DocumentArgsFromUser']
    pages: Union[bool, 'FindManyPageArgsFromUser']
    blocks: Union[bool, 'FindManyBlockArgsFromUser']


class ChunkArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    Chunk: Union[bool, 'ChunkArgsFromUser']
    Document: Union[bool, 'DocumentArgsFromUser']
    Page: Union[bool, 'PageArgsFromUser']


class BlockArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUser']
    plan: Union[bool, 'PlanArgsFromUser']


class TenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenants: Union[bool, 'FindManyTenantArgsFromUser']


class PlanArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    chats: Union[bool, 'FindManyChatArgsFromUser']
    tenant: Union[bool, 'TenantArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    chats: Union[bool, 'ChatArgsFromUser']


class MessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']
    messages: Union[bool, 'FindManyMessageArgsFromUser']


class ChatArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    email: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    hashedPassword: Union[_str, 'types.StringFilter']
    isEmailVerified: Union[_bool, 'types.BooleanFilter']
    lastLoginAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    chats: 'ChatListRelationFilter'
    tenant: 'TenantRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    hashedPassword: Union[_str, 'types.StringWithAggregatesFilter']
    isEmailVerified: Union[_bool, 'types.BooleanWithAggregatesFilter']
    lastLoginAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    tenantId: _str
    hashedPassword: _str
    isEmailVerified: _bool
    lastLoginAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    tenantId: _str
    hashedPassword: _str
    isEmailVerified: _bool
    lastLoginAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    email: bool
    name: bool
    tenantId: bool
    hashedPassword: bool
    isEmailVerified: bool
    lastLoginAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    email: bool
    name: bool
    tenantId: bool
    hashedPassword: bool
    isEmailVerified: bool
    lastLoginAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'email': bool,
        'name': bool,
        'tenantId': bool,
        'hashedPassword': bool,
        'isEmailVerified': bool,
        'lastLoginAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'email': int,
        'name': int,
        'tenantId': int,
        'hashedPassword': int,
        'isEmailVerified': int,
        'lastLoginAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'email',
    'name',
    'tenantId',
    'hashedPassword',
    'isEmailVerified',
    'lastLoginAt',
    'chats',
    'tenant',
]
UserScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'email',
    'name',
    'tenantId',
    'hashedPassword',
    'isEmailVerified',
    'lastLoginAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'chats',
        'tenant',
    ]

# Message types

class MessageOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Message create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    rawJson: Optional[_str]
    messageType: Optional[_str]
    tokensUsed: Optional[_int]
    processingTime: Optional[_int]
    chatId: _str
    chats: 'ChatCreateNestedWithoutRelationsInput'


class MessageCreateInput(MessageOptionalCreateInput):
    """Required arguments to the Message create method"""
    status: 'enums.StatusEnum'
    role: _str
    content: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MessageOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Message create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    rawJson: Optional[_str]
    messageType: Optional[_str]
    tokensUsed: Optional[_int]
    processingTime: Optional[_int]
    chatId: _str


class MessageCreateWithoutRelationsInput(MessageOptionalCreateWithoutRelationsInput):
    """Required arguments to the Message create method, without relations"""
    status: 'enums.StatusEnum'
    role: _str
    content: _str

class MessageConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MessageCreateWithoutRelationsInput'
    where: 'MessageWhereUniqueInput'

class MessageCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'


class MessageCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MessageCreateWithoutRelationsInput', List['MessageCreateWithoutRelationsInput']]
    connect: Union['MessageWhereUniqueInput', List['MessageWhereUniqueInput']]
    connect_or_create: Union['MessageConnectOrCreateWithoutRelationsInput', List['MessageConnectOrCreateWithoutRelationsInput']]

_MessageWhereUnique_id_Input = TypedDict(
    '_MessageWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

MessageWhereUniqueInput = _MessageWhereUnique_id_Input


class MessageUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    role: _str
    content: _str
    rawJson: Optional[_str]
    messageType: Optional[_str]
    tokensUsed: Optional[Union[AtomicIntInput, _int]]
    processingTime: Optional[Union[AtomicIntInput, _int]]
    chats: 'ChatUpdateOneWithoutRelationsInput'


class MessageUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    role: _str
    content: _str
    rawJson: Optional[_str]
    messageType: Optional[_str]
    tokensUsed: Optional[Union[AtomicIntInput, _int]]
    processingTime: Optional[Union[AtomicIntInput, _int]]


class MessageUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MessageCreateWithoutRelationsInput']
    connect: List['MessageWhereUniqueInput']
    connect_or_create: List['MessageConnectOrCreateWithoutRelationsInput']
    set: List['MessageWhereUniqueInput']
    disconnect: List['MessageWhereUniqueInput']
    delete: List['MessageWhereUniqueInput']

    # TODO
    # update: List['MessageUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MessageUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MessageScalarWhereInput']
    # upsert: List['MessageUpserteWithWhereUniqueWithoutRelationsInput']


class MessageUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MessageCreateWithoutRelationsInput'
    connect: 'MessageWhereUniqueInput'
    connect_or_create: 'MessageConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MessageUpdateInput'
    # upsert: 'MessageUpsertWithoutRelationsInput'


class MessageUpsertInput(TypedDict):
    create: 'MessageCreateInput'
    update: 'MessageUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Message_id_OrderByInput = TypedDict(
    '_Message_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Message_createdAt_OrderByInput = TypedDict(
    '_Message_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Message_updatedAt_OrderByInput = TypedDict(
    '_Message_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Message_status_OrderByInput = TypedDict(
    '_Message_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Message_role_OrderByInput = TypedDict(
    '_Message_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_Message_content_OrderByInput = TypedDict(
    '_Message_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_Message_rawJson_OrderByInput = TypedDict(
    '_Message_rawJson_OrderByInput',
    {
        'rawJson': 'SortOrder',
    },
    total=True
)

_Message_messageType_OrderByInput = TypedDict(
    '_Message_messageType_OrderByInput',
    {
        'messageType': 'SortOrder',
    },
    total=True
)

_Message_tokensUsed_OrderByInput = TypedDict(
    '_Message_tokensUsed_OrderByInput',
    {
        'tokensUsed': 'SortOrder',
    },
    total=True
)

_Message_processingTime_OrderByInput = TypedDict(
    '_Message_processingTime_OrderByInput',
    {
        'processingTime': 'SortOrder',
    },
    total=True
)

_Message_chatId_OrderByInput = TypedDict(
    '_Message_chatId_OrderByInput',
    {
        'chatId': 'SortOrder',
    },
    total=True
)

_Message_RelevanceInner = TypedDict(
    '_Message_RelevanceInner',
    {
        'fields': 'List[MessageScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Message_RelevanceOrderByInput = TypedDict(
    '_Message_RelevanceOrderByInput',
    {
        '_relevance': '_Message_RelevanceInner',
    },
    total=True
)

MessageOrderByInput = Union[
    '_Message_id_OrderByInput',
    '_Message_createdAt_OrderByInput',
    '_Message_updatedAt_OrderByInput',
    '_Message_status_OrderByInput',
    '_Message_role_OrderByInput',
    '_Message_content_OrderByInput',
    '_Message_rawJson_OrderByInput',
    '_Message_messageType_OrderByInput',
    '_Message_tokensUsed_OrderByInput',
    '_Message_processingTime_OrderByInput',
    '_Message_chatId_OrderByInput',
    '_Message_RelevanceOrderByInput',
]



# recursive Message types
# TODO: cleanup these types



MessageRelationFilter = TypedDict(
    'MessageRelationFilter',
    {
        'is': 'MessageWhereInput',
        'is_not': 'MessageWhereInput',
    },
    total=False,
)


class MessageListRelationFilter(TypedDict, total=False):
    some: 'MessageWhereInput'
    none: 'MessageWhereInput'
    every: 'MessageWhereInput'


class MessageInclude(TypedDict, total=False):
    """Message relational arguments"""
    chats: Union[bool, 'ChatArgsFromMessage']


class FilingIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    documents: Union[bool, 'FindManyDocumentArgsFromMessage']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromMessage']


class FilingArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromMessage']


class FilingCompanyArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    Filing: Union[bool, 'FilingArgsFromMessage']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromMessage']


class FilingToCompanyArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    Filing: Union[bool, 'FilingArgsFromMessage']
    pages: Union[bool, 'FindManyPageArgsFromMessage']
    chunks: Union[bool, 'FindManyChunkArgsFromMessage']
    blocks: Union[bool, 'FindManyBlockArgsFromMessage']


class DocumentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    Document: Union[bool, 'DocumentArgsFromMessage']
    chunks: Union[bool, 'FindManyChunkArgsFromMessage']
    blocks: Union[bool, 'FindManyBlockArgsFromMessage']


class PageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    Document: Union[bool, 'DocumentArgsFromMessage']
    pages: Union[bool, 'FindManyPageArgsFromMessage']
    blocks: Union[bool, 'FindManyBlockArgsFromMessage']


class ChunkArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    Chunk: Union[bool, 'ChunkArgsFromMessage']
    Document: Union[bool, 'DocumentArgsFromMessage']
    Page: Union[bool, 'PageArgsFromMessage']


class BlockArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    users: Union[bool, 'FindManyUserArgsFromMessage']
    plan: Union[bool, 'PlanArgsFromMessage']


class TenantArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    tenants: Union[bool, 'FindManyTenantArgsFromMessage']


class PlanArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    chats: Union[bool, 'FindManyChatArgsFromMessage']
    tenant: Union[bool, 'TenantArgsFromMessage']


class UserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    chats: Union[bool, 'ChatArgsFromMessage']


class MessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromMessage(TypedDict, total=False):
    """Relational arguments for Message"""
    user: Union[bool, 'UserArgsFromMessage']
    messages: Union[bool, 'FindManyMessageArgsFromMessage']


class ChatArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromMessage(TypedDict, total=False):
    """Arguments for Message"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyMessageArgs = FindManyMessageArgsFromMessage
FindFirstMessageArgs = FindManyMessageArgsFromMessage


class MessageWhereInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    role: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    rawJson: Union[None, _str, 'types.StringFilter']
    messageType: Union[None, _str, 'types.StringFilter']
    tokensUsed: Union[None, _int, 'types.IntFilter']
    processingTime: Union[None, _int, 'types.IntFilter']
    chatId: Union[_str, 'types.StringFilter']
    chats: 'ChatRelationFilter'

    # should be noted that AND and NOT should be Union['MessageWhereInput', List['MessageWhereInput']]
    # but this causes mypy to hang :/
    AND: List['MessageWhereInput']
    OR: List['MessageWhereInput']
    NOT: List['MessageWhereInput']



# aggregate Message types


class MessageScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Message arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    role: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    rawJson: Union[_str, 'types.StringWithAggregatesFilter']
    messageType: Union[_str, 'types.StringWithAggregatesFilter']
    tokensUsed: Union[_int, 'types.IntWithAggregatesFilter']
    processingTime: Union[_int, 'types.IntWithAggregatesFilter']
    chatId: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['MessageScalarWhereWithAggregatesInput']
    OR: List['MessageScalarWhereWithAggregatesInput']
    NOT: List['MessageScalarWhereWithAggregatesInput']



class MessageGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    role: _str
    content: _str
    rawJson: _str
    messageType: _str
    tokensUsed: _int
    processingTime: _int
    chatId: _str
    _sum: 'MessageSumAggregateOutput'
    _avg: 'MessageAvgAggregateOutput'
    _min: 'MessageMinAggregateOutput'
    _max: 'MessageMaxAggregateOutput'
    _count: 'MessageCountAggregateOutput'


class MessageAvgAggregateOutput(TypedDict, total=False):
    """Message output for aggregating averages"""
    tokensUsed: float
    processingTime: float


class MessageSumAggregateOutput(TypedDict, total=False):
    """Message output for aggregating sums"""
    tokensUsed: _int
    processingTime: _int


class MessageScalarAggregateOutput(TypedDict, total=False):
    """Message output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    role: _str
    content: _str
    rawJson: _str
    messageType: _str
    tokensUsed: _int
    processingTime: _int
    chatId: _str


MessageMinAggregateOutput = MessageScalarAggregateOutput
MessageMaxAggregateOutput = MessageScalarAggregateOutput


class MessageMaxAggregateInput(TypedDict, total=False):
    """Message input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    role: bool
    content: bool
    rawJson: bool
    messageType: bool
    tokensUsed: bool
    processingTime: bool
    chatId: bool


class MessageMinAggregateInput(TypedDict, total=False):
    """Message input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    role: bool
    content: bool
    rawJson: bool
    messageType: bool
    tokensUsed: bool
    processingTime: bool
    chatId: bool


class MessageNumberAggregateInput(TypedDict, total=False):
    """Message input for aggregating numbers"""
    tokensUsed: bool
    processingTime: bool


MessageAvgAggregateInput = MessageNumberAggregateInput
MessageSumAggregateInput = MessageNumberAggregateInput


MessageCountAggregateInput = TypedDict(
    'MessageCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'role': bool,
        'content': bool,
        'rawJson': bool,
        'messageType': bool,
        'tokensUsed': bool,
        'processingTime': bool,
        'chatId': bool,
        '_all': bool,
    },
    total=False,
)

MessageCountAggregateOutput = TypedDict(
    'MessageCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'role': int,
        'content': int,
        'rawJson': int,
        'messageType': int,
        'tokensUsed': int,
        'processingTime': int,
        'chatId': int,
        '_all': int,
    },
    total=False,
)


MessageKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'role',
    'content',
    'rawJson',
    'messageType',
    'tokensUsed',
    'processingTime',
    'chatId',
    'chats',
]
MessageScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'role',
    'content',
    'rawJson',
    'messageType',
    'tokensUsed',
    'processingTime',
    'chatId',
]
MessageScalarFieldKeysT = TypeVar('MessageScalarFieldKeysT', bound=MessageScalarFieldKeys)

MessageRelationalFieldKeys = Literal[
        'chats',
    ]

# Chat types

class ChatOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Chat create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    title: Optional[_str]
    userId: _str
    isActive: _bool
    user: 'UserCreateNestedWithoutRelationsInput'
    messages: 'MessageCreateManyNestedWithoutRelationsInput'


class ChatCreateInput(ChatOptionalCreateInput):
    """Required arguments to the Chat create method"""
    status: 'enums.StatusEnum'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ChatOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Chat create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    title: Optional[_str]
    userId: _str
    isActive: _bool


class ChatCreateWithoutRelationsInput(ChatOptionalCreateWithoutRelationsInput):
    """Required arguments to the Chat create method, without relations"""
    status: 'enums.StatusEnum'

class ChatConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ChatCreateWithoutRelationsInput'
    where: 'ChatWhereUniqueInput'

class ChatCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ChatCreateWithoutRelationsInput'
    connect: 'ChatWhereUniqueInput'
    connect_or_create: 'ChatConnectOrCreateWithoutRelationsInput'


class ChatCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ChatCreateWithoutRelationsInput', List['ChatCreateWithoutRelationsInput']]
    connect: Union['ChatWhereUniqueInput', List['ChatWhereUniqueInput']]
    connect_or_create: Union['ChatConnectOrCreateWithoutRelationsInput', List['ChatConnectOrCreateWithoutRelationsInput']]

_ChatWhereUnique_id_Input = TypedDict(
    '_ChatWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ChatWhereUniqueInput = _ChatWhereUnique_id_Input


class ChatUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    title: Optional[_str]
    isActive: _bool
    user: 'UserUpdateOneWithoutRelationsInput'
    messages: 'MessageUpdateManyWithoutRelationsInput'


class ChatUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    title: Optional[_str]
    isActive: _bool


class ChatUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ChatCreateWithoutRelationsInput']
    connect: List['ChatWhereUniqueInput']
    connect_or_create: List['ChatConnectOrCreateWithoutRelationsInput']
    set: List['ChatWhereUniqueInput']
    disconnect: List['ChatWhereUniqueInput']
    delete: List['ChatWhereUniqueInput']

    # TODO
    # update: List['ChatUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ChatUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ChatScalarWhereInput']
    # upsert: List['ChatUpserteWithWhereUniqueWithoutRelationsInput']


class ChatUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ChatCreateWithoutRelationsInput'
    connect: 'ChatWhereUniqueInput'
    connect_or_create: 'ChatConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ChatUpdateInput'
    # upsert: 'ChatUpsertWithoutRelationsInput'


class ChatUpsertInput(TypedDict):
    create: 'ChatCreateInput'
    update: 'ChatUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Chat_id_OrderByInput = TypedDict(
    '_Chat_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Chat_createdAt_OrderByInput = TypedDict(
    '_Chat_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Chat_updatedAt_OrderByInput = TypedDict(
    '_Chat_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Chat_status_OrderByInput = TypedDict(
    '_Chat_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Chat_title_OrderByInput = TypedDict(
    '_Chat_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Chat_userId_OrderByInput = TypedDict(
    '_Chat_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Chat_isActive_OrderByInput = TypedDict(
    '_Chat_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_Chat_RelevanceInner = TypedDict(
    '_Chat_RelevanceInner',
    {
        'fields': 'List[ChatScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Chat_RelevanceOrderByInput = TypedDict(
    '_Chat_RelevanceOrderByInput',
    {
        '_relevance': '_Chat_RelevanceInner',
    },
    total=True
)

ChatOrderByInput = Union[
    '_Chat_id_OrderByInput',
    '_Chat_createdAt_OrderByInput',
    '_Chat_updatedAt_OrderByInput',
    '_Chat_status_OrderByInput',
    '_Chat_title_OrderByInput',
    '_Chat_userId_OrderByInput',
    '_Chat_isActive_OrderByInput',
    '_Chat_RelevanceOrderByInput',
]



# recursive Chat types
# TODO: cleanup these types



ChatRelationFilter = TypedDict(
    'ChatRelationFilter',
    {
        'is': 'ChatWhereInput',
        'is_not': 'ChatWhereInput',
    },
    total=False,
)


class ChatListRelationFilter(TypedDict, total=False):
    some: 'ChatWhereInput'
    none: 'ChatWhereInput'
    every: 'ChatWhereInput'


class ChatInclude(TypedDict, total=False):
    """Chat relational arguments"""
    user: Union[bool, 'UserArgsFromChat']
    messages: Union[bool, 'FindManyMessageArgsFromChat']


class FilingIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    documents: Union[bool, 'FindManyDocumentArgsFromChat']
    companies: Union[bool, 'FindManyFilingToCompanyArgsFromChat']


class FilingArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'FilingIncludeFromFiling'


class FindManyFilingArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['FilingOrderByInput', List['FilingOrderByInput']]
    where: 'FilingWhereInput'
    cursor: 'FilingWhereUniqueInput'
    distinct: List['FilingScalarFieldKeys']
    include: 'FilingIncludeFromFiling'


class FilingCompanyIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    filings: Union[bool, 'FindManyFilingToCompanyArgsFromChat']


class FilingCompanyArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'FilingCompanyIncludeFromFilingCompany'


class FindManyFilingCompanyArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['FilingCompanyOrderByInput', List['FilingCompanyOrderByInput']]
    where: 'FilingCompanyWhereInput'
    cursor: 'FilingCompanyWhereUniqueInput'
    distinct: List['FilingCompanyScalarFieldKeys']
    include: 'FilingCompanyIncludeFromFilingCompany'


class FilingToCompanyIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    Filing: Union[bool, 'FilingArgsFromChat']
    FilingCompany: Union[bool, 'FilingCompanyArgsFromChat']


class FilingToCompanyArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class FindManyFilingToCompanyArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['FilingToCompanyOrderByInput', List['FilingToCompanyOrderByInput']]
    where: 'FilingToCompanyWhereInput'
    cursor: 'FilingToCompanyWhereUniqueInput'
    distinct: List['FilingToCompanyScalarFieldKeys']
    include: 'FilingToCompanyIncludeFromFilingToCompany'


class DocumentIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    Filing: Union[bool, 'FilingArgsFromChat']
    pages: Union[bool, 'FindManyPageArgsFromChat']
    chunks: Union[bool, 'FindManyChunkArgsFromChat']
    blocks: Union[bool, 'FindManyBlockArgsFromChat']


class DocumentArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'DocumentIncludeFromDocument'


class FindManyDocumentArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['DocumentOrderByInput', List['DocumentOrderByInput']]
    where: 'DocumentWhereInput'
    cursor: 'DocumentWhereUniqueInput'
    distinct: List['DocumentScalarFieldKeys']
    include: 'DocumentIncludeFromDocument'


class PageIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    Document: Union[bool, 'DocumentArgsFromChat']
    chunks: Union[bool, 'FindManyChunkArgsFromChat']
    blocks: Union[bool, 'FindManyBlockArgsFromChat']


class PageArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'PageIncludeFromPage'


class FindManyPageArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['PageOrderByInput', List['PageOrderByInput']]
    where: 'PageWhereInput'
    cursor: 'PageWhereUniqueInput'
    distinct: List['PageScalarFieldKeys']
    include: 'PageIncludeFromPage'


class ChunkIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    Document: Union[bool, 'DocumentArgsFromChat']
    pages: Union[bool, 'FindManyPageArgsFromChat']
    blocks: Union[bool, 'FindManyBlockArgsFromChat']


class ChunkArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'ChunkIncludeFromChunk'


class FindManyChunkArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['ChunkOrderByInput', List['ChunkOrderByInput']]
    where: 'ChunkWhereInput'
    cursor: 'ChunkWhereUniqueInput'
    distinct: List['ChunkScalarFieldKeys']
    include: 'ChunkIncludeFromChunk'


class BlockIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    Chunk: Union[bool, 'ChunkArgsFromChat']
    Document: Union[bool, 'DocumentArgsFromChat']
    Page: Union[bool, 'PageArgsFromChat']


class BlockArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'BlockIncludeFromBlock'


class FindManyBlockArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['BlockOrderByInput', List['BlockOrderByInput']]
    where: 'BlockWhereInput'
    cursor: 'BlockWhereUniqueInput'
    distinct: List['BlockScalarFieldKeys']
    include: 'BlockIncludeFromBlock'


class TenantIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    users: Union[bool, 'FindManyUserArgsFromChat']
    plan: Union[bool, 'PlanArgsFromChat']


class TenantArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class PlanIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    tenants: Union[bool, 'FindManyTenantArgsFromChat']


class PlanArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'PlanIncludeFromPlan'


class FindManyPlanArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['PlanOrderByInput', List['PlanOrderByInput']]
    where: 'PlanWhereInput'
    cursor: 'PlanWhereUniqueInput'
    distinct: List['PlanScalarFieldKeys']
    include: 'PlanIncludeFromPlan'


class UserIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    chats: Union[bool, 'FindManyChatArgsFromChat']
    tenant: Union[bool, 'TenantArgsFromChat']


class UserArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class MessageIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    chats: Union[bool, 'ChatArgsFromChat']


class MessageArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'MessageIncludeFromMessage'


class FindManyMessageArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['MessageOrderByInput', List['MessageOrderByInput']]
    where: 'MessageWhereInput'
    cursor: 'MessageWhereUniqueInput'
    distinct: List['MessageScalarFieldKeys']
    include: 'MessageIncludeFromMessage'


class ChatIncludeFromChat(TypedDict, total=False):
    """Relational arguments for Chat"""
    user: Union[bool, 'UserArgsFromChat']
    messages: Union[bool, 'FindManyMessageArgsFromChat']


class ChatArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    include: 'ChatIncludeFromChat'


class FindManyChatArgsFromChat(TypedDict, total=False):
    """Arguments for Chat"""
    take: int
    skip: int
    order_by: Union['ChatOrderByInput', List['ChatOrderByInput']]
    where: 'ChatWhereInput'
    cursor: 'ChatWhereUniqueInput'
    distinct: List['ChatScalarFieldKeys']
    include: 'ChatIncludeFromChat'




FindManyChatArgs = FindManyChatArgsFromChat
FindFirstChatArgs = FindManyChatArgsFromChat


class ChatWhereInput(TypedDict, total=False):
    """Chat arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.StatusEnum'
    title: Union[None, _str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    user: 'UserRelationFilter'
    messages: 'MessageListRelationFilter'

    # should be noted that AND and NOT should be Union['ChatWhereInput', List['ChatWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ChatWhereInput']
    OR: List['ChatWhereInput']
    NOT: List['ChatWhereInput']



# aggregate Chat types


class ChatScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Chat arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.StatusEnum'
    title: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']

    AND: List['ChatScalarWhereWithAggregatesInput']
    OR: List['ChatScalarWhereWithAggregatesInput']
    NOT: List['ChatScalarWhereWithAggregatesInput']



class ChatGroupByOutput(TypedDict, total=False):
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    title: _str
    userId: _str
    isActive: _bool
    _sum: 'ChatSumAggregateOutput'
    _avg: 'ChatAvgAggregateOutput'
    _min: 'ChatMinAggregateOutput'
    _max: 'ChatMaxAggregateOutput'
    _count: 'ChatCountAggregateOutput'


class ChatAvgAggregateOutput(TypedDict, total=False):
    """Chat output for aggregating averages"""


class ChatSumAggregateOutput(TypedDict, total=False):
    """Chat output for aggregating sums"""


class ChatScalarAggregateOutput(TypedDict, total=False):
    """Chat output including scalar fields"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    title: _str
    userId: _str
    isActive: _bool


ChatMinAggregateOutput = ChatScalarAggregateOutput
ChatMaxAggregateOutput = ChatScalarAggregateOutput


class ChatMaxAggregateInput(TypedDict, total=False):
    """Chat input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    title: bool
    userId: bool
    isActive: bool


class ChatMinAggregateInput(TypedDict, total=False):
    """Chat input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    status: bool
    title: bool
    userId: bool
    isActive: bool


class ChatNumberAggregateInput(TypedDict, total=False):
    """Chat input for aggregating numbers"""


ChatAvgAggregateInput = ChatNumberAggregateInput
ChatSumAggregateInput = ChatNumberAggregateInput


ChatCountAggregateInput = TypedDict(
    'ChatCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'status': bool,
        'title': bool,
        'userId': bool,
        'isActive': bool,
        '_all': bool,
    },
    total=False,
)

ChatCountAggregateOutput = TypedDict(
    'ChatCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'status': int,
        'title': int,
        'userId': int,
        'isActive': int,
        '_all': int,
    },
    total=False,
)


ChatKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'title',
    'userId',
    'isActive',
    'user',
    'messages',
]
ChatScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'status',
    'title',
    'userId',
    'isActive',
]
ChatScalarFieldKeysT = TypeVar('ChatScalarFieldKeysT', bound=ChatScalarFieldKeys)

ChatRelationalFieldKeys = Literal[
        'user',
        'messages',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields