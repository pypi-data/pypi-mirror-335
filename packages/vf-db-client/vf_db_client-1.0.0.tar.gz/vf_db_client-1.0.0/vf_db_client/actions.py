# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class FilingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Filing]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Filing.prisma().query_raw(
            'SELECT * FROM Filing WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Filing
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Filing.prisma().query_first(
            'SELECT * FROM Filing WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FilingCreateInput,
        include: Optional[types.FilingInclude] = None
    ) -> _PrismaModelT:
        """Create a new Filing record.

        Parameters
        ----------
        data
            Filing record data
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The created Filing record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Filing record from just the required fields
        filing = await Filing.prisma().create(
            data={
                # data to create a Filing record
                'status': enums.StatusEnum.Active,
                'serffTrackingNumber': 'dhheabfhf',
                'typeOfInsurance': enums.ProductEnum.Property,
                'state': enums.StateEnum.AL,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FilingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Filing records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Filing record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Filing.prisma().create_many(
            data=[
                {
                    # data to create a Filing record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'ggciceaie',
                    'typeOfInsurance': enums.ProductEnum.Property,
                    'state': enums.StateEnum.AL,
                },
                {
                    # data to create a Filing record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bbehjachib',
                    'typeOfInsurance': enums.ProductEnum.Property,
                    'state': enums.StateEnum.AL,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FilingWhereUniqueInput,
        include: Optional[types.FilingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Filing record.

        Parameters
        ----------
        where
            Filing filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The deleted Filing record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filing = await Filing.prisma().delete(
            where={
                'id': 'cadfabfehe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FilingWhereUniqueInput,
        include: Optional[types.FilingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Filing record.

        Parameters
        ----------
        where
            Filing filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The found Filing record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filing = await Filing.prisma().find_unique(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FilingWhereUniqueInput,
        include: Optional[types.FilingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Filing record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Filing filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The found Filing record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filing = await Filing.prisma().find_unique_or_raise(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
        include: Optional[types.FilingInclude] = None,
        order: Optional[Union[types.FilingOrderByInput, List[types.FilingOrderByInput]]] = None,
        distinct: Optional[List[types.FilingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Filing records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Filing records returned
        skip
            Ignore the first N results
        where
            Filing filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Filing model
        order
            Order the returned Filing records by any field
        distinct
            Filter Filing records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Filing]
            The list of all Filing records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Filing records
        filings = await Filing.prisma().find_many(take=10)

        # find the first 5 Filing records ordered by the updatedAt field
        filings = await Filing.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
        include: Optional[types.FilingInclude] = None,
        order: Optional[Union[types.FilingOrderByInput, List[types.FilingOrderByInput]]] = None,
        distinct: Optional[List[types.FilingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Filing record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Filing filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Filing model
        order
            Order the returned Filing records by any field
        distinct
            Filter Filing records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Filing
            The first Filing record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Filing record ordered by the status field
        filing = await Filing.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
        include: Optional[types.FilingInclude] = None,
        order: Optional[Union[types.FilingOrderByInput, List[types.FilingOrderByInput]]] = None,
        distinct: Optional[List[types.FilingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Filing record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Filing filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Filing model
        order
            Order the returned Filing records by any field
        distinct
            Filter Filing records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Filing
            The first Filing record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Filing record ordered by the serffTrackingNumber field
        filing = await Filing.prisma().find_first_or_raise(
            skip=1,
            order={
                'serffTrackingNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FilingUpdateInput,
        where: types.FilingWhereUniqueInput,
        include: Optional[types.FilingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Filing record.

        Parameters
        ----------
        data
            Filing record data specifying what to update
        where
            Filing filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The updated Filing record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        filing = await Filing.prisma().update(
            where={
                'id': 'eigcfgbif',
            },
            data={
                # data to update the Filing record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FilingWhereUniqueInput,
        data: types.FilingUpsertInput,
        include: Optional[types.FilingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Filing filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Filing model

        Returns
        -------
        prisma.models.Filing
            The created or updated Filing record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filing = await Filing.prisma().upsert(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                'create': {
                    'id': 'bagcfbhiig',
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bbehjachib',
                    'typeOfInsurance': enums.ProductEnum.Property,
                    'state': enums.StateEnum.AL,
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bbehjachib',
                    'typeOfInsurance': enums.ProductEnum.Property,
                    'state': enums.StateEnum.AL,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FilingUpdateManyMutationInput,
        where: types.FilingWhereInput,
    ) -> int:
        """Update multiple Filing records

        Parameters
        ----------
        data
            Filing data to update the selected Filing records to
        where
            Filter to select the Filing records to update

        Returns
        -------
        int
            The total number of Filing records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Filing records
        total = await Filing.prisma().update_many(
            data={
                'stateTrackingNumber': 'cghideieh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Filing records present in the database

        Parameters
        ----------
        select
            Select the Filing fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Filing filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Filing.prisma().count()

        # results: prisma.types.FilingCountAggregateOutput
        results = await Filing.prisma().count(
            select={
                '_all': True,
                'companyTrackingNumber': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FilingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
    ) -> types.FilingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FilingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingWhereInput] = None,
        cursor: Optional[types.FilingWhereUniqueInput] = None,
    ) -> Union[int, types.FilingCountAggregateOutput]:
        """Count the number of Filing records present in the database

        Parameters
        ----------
        select
            Select the Filing fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Filing filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Filing.prisma().count()

        # results: prisma.types.FilingCountAggregateOutput
        results = await Filing.prisma().count(
            select={
                '_all': True,
                'product': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FilingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FilingWhereInput] = None
    ) -> int:
        """Delete multiple Filing records.

        Parameters
        ----------
        where
            Optional Filing filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Filing records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Filing records
        total = await Filing.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FilingScalarFieldKeysT'],
        *,
        where: Optional['types.FilingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FilingAvgAggregateInput'] = None,
        sum: Optional['types.FilingSumAggregateInput'] = None,
        min: Optional['types.FilingMinAggregateInput'] = None,
        max: Optional['types.FilingMaxAggregateInput'] = None,
        having: Optional['types.FilingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FilingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FilingScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.FilingScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.FilingGroupByOutput']:
        """Group Filing records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Filing fields to group records by
        where
            Filing filter to select records
        take
            Limit the maximum number of Filing records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FilingGroupByOutput]
            A list of dictionaries representing the Filing record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Filing records by typeOfInsurance values
        # and count how many records are in each group
        results = await Filing.prisma().group_by(
            ['typeOfInsurance'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FilingCompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FilingCompany]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await FilingCompany.prisma().query_raw(
            'SELECT * FROM FilingCompany WHERE id = $1',
            'biabhbdai',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FilingCompany
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await FilingCompany.prisma().query_first(
            'SELECT * FROM FilingCompany WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FilingCompanyCreateInput,
        include: Optional[types.FilingCompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new FilingCompany record.

        Parameters
        ----------
        data
            FilingCompany record data
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The created FilingCompany record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FilingCompany record from just the required fields
        filingcompany = await FilingCompany.prisma().create(
            data={
                # data to create a FilingCompany record
                'status': enums.StatusEnum.Active,
                'companyName': 'idghgaicb',
                'companyCode': 'fjfddhigg',
                'companyGroupCode': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FilingCompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FilingCompany records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FilingCompany record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FilingCompany.prisma().create_many(
            data=[
                {
                    # data to create a FilingCompany record
                    'status': enums.StatusEnum.Active,
                    'companyName': 'cbbbjbfcii',
                    'companyCode': 'bbejhfidcb',
                    'companyGroupCode': 'bgeecijdgg',
                },
                {
                    # data to create a FilingCompany record
                    'status': enums.StatusEnum.Active,
                    'companyName': 'bdiicjafbj',
                    'companyCode': 'bgehebiafc',
                    'companyGroupCode': 'bghffegacj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FilingCompanyWhereUniqueInput,
        include: Optional[types.FilingCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FilingCompany record.

        Parameters
        ----------
        where
            FilingCompany filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The deleted FilingCompany record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingcompany = await FilingCompany.prisma().delete(
            where={
                'id': 'bhghchehcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FilingCompanyWhereUniqueInput,
        include: Optional[types.FilingCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FilingCompany record.

        Parameters
        ----------
        where
            FilingCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The found FilingCompany record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingcompany = await FilingCompany.prisma().find_unique(
            where={
                'id': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FilingCompanyWhereUniqueInput,
        include: Optional[types.FilingCompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FilingCompany record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FilingCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The found FilingCompany record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingcompany = await FilingCompany.prisma().find_unique_or_raise(
            where={
                'id': 'bdedcabahc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingCompanyInclude] = None,
        order: Optional[Union[types.FilingCompanyOrderByInput, List[types.FilingCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingCompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FilingCompany records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FilingCompany records returned
        skip
            Ignore the first N results
        where
            FilingCompany filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingCompany model
        order
            Order the returned FilingCompany records by any field
        distinct
            Filter FilingCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FilingCompany]
            The list of all FilingCompany records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FilingCompany records
        filingcompanys = await FilingCompany.prisma().find_many(take=10)

        # find the first 5 FilingCompany records ordered by the updatedAt field
        filingcompanys = await FilingCompany.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingCompanyInclude] = None,
        order: Optional[Union[types.FilingCompanyOrderByInput, List[types.FilingCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingCompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FilingCompany record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FilingCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingCompany model
        order
            Order the returned FilingCompany records by any field
        distinct
            Filter FilingCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FilingCompany
            The first FilingCompany record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FilingCompany record ordered by the status field
        filingcompany = await FilingCompany.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingCompanyInclude] = None,
        order: Optional[Union[types.FilingCompanyOrderByInput, List[types.FilingCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingCompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FilingCompany record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FilingCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingCompany model
        order
            Order the returned FilingCompany records by any field
        distinct
            Filter FilingCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FilingCompany
            The first FilingCompany record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FilingCompany record ordered by the companyName field
        filingcompany = await FilingCompany.prisma().find_first_or_raise(
            skip=1,
            order={
                'companyName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FilingCompanyUpdateInput,
        where: types.FilingCompanyWhereUniqueInput,
        include: Optional[types.FilingCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FilingCompany record.

        Parameters
        ----------
        data
            FilingCompany record data specifying what to update
        where
            FilingCompany filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The updated FilingCompany record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        filingcompany = await FilingCompany.prisma().update(
            where={
                'id': 'ghfhiafcb',
            },
            data={
                # data to update the FilingCompany record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FilingCompanyWhereUniqueInput,
        data: types.FilingCompanyUpsertInput,
        include: Optional[types.FilingCompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FilingCompany filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FilingCompany model

        Returns
        -------
        prisma.models.FilingCompany
            The created or updated FilingCompany record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingcompany = await FilingCompany.prisma().upsert(
            where={
                'id': 'heejgedji',
            },
            data={
                'create': {
                    'id': 'heejgedji',
                    'status': enums.StatusEnum.Active,
                    'companyName': 'bdiicjafbj',
                    'companyCode': 'bgehebiafc',
                    'companyGroupCode': 'bghffegacj',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'companyName': 'bdiicjafbj',
                    'companyCode': 'bgehebiafc',
                    'companyGroupCode': 'bghffegacj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FilingCompanyUpdateManyMutationInput,
        where: types.FilingCompanyWhereInput,
    ) -> int:
        """Update multiple FilingCompany records

        Parameters
        ----------
        data
            FilingCompany data to update the selected FilingCompany records to
        where
            Filter to select the FilingCompany records to update

        Returns
        -------
        int
            The total number of FilingCompany records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FilingCompany records
        total = await FilingCompany.prisma().update_many(
            data={
                'companyCode': 'bjgjgibgbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FilingCompany records present in the database

        Parameters
        ----------
        select
            Select the FilingCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FilingCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FilingCompany.prisma().count()

        # results: prisma.types.FilingCompanyCountAggregateOutput
        results = await FilingCompany.prisma().count(
            select={
                '_all': True,
                'companyGroupName': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FilingCompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
    ) -> types.FilingCompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FilingCompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingCompanyWhereInput] = None,
        cursor: Optional[types.FilingCompanyWhereUniqueInput] = None,
    ) -> Union[int, types.FilingCompanyCountAggregateOutput]:
        """Count the number of FilingCompany records present in the database

        Parameters
        ----------
        select
            Select the FilingCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FilingCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FilingCompany.prisma().count()

        # results: prisma.types.FilingCompanyCountAggregateOutput
        results = await FilingCompany.prisma().count(
            select={
                '_all': True,
                'companyGroupCode': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FilingCompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FilingCompanyWhereInput] = None
    ) -> int:
        """Delete multiple FilingCompany records.

        Parameters
        ----------
        where
            Optional FilingCompany filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FilingCompany records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FilingCompany records
        total = await FilingCompany.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FilingCompanyScalarFieldKeysT'],
        *,
        where: Optional['types.FilingCompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FilingCompanyAvgAggregateInput'] = None,
        sum: Optional['types.FilingCompanySumAggregateInput'] = None,
        min: Optional['types.FilingCompanyMinAggregateInput'] = None,
        max: Optional['types.FilingCompanyMaxAggregateInput'] = None,
        having: Optional['types.FilingCompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FilingCompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FilingCompanyScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.FilingCompanyScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.FilingCompanyGroupByOutput']:
        """Group FilingCompany records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FilingCompany fields to group records by
        where
            FilingCompany filter to select records
        take
            Limit the maximum number of FilingCompany records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FilingCompanyGroupByOutput]
            A list of dictionaries representing the FilingCompany record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FilingCompany records by state values
        # and count how many records are in each group
        results = await FilingCompany.prisma().group_by(
            ['state'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FilingToCompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FilingToCompany]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await FilingToCompany.prisma().query_raw(
            'SELECT * FROM FilingToCompany WHERE filingId = $1',
            'bbbgbhfjge',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FilingToCompany
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await FilingToCompany.prisma().query_first(
            'SELECT * FROM FilingToCompany WHERE companyId = $1',
            'igbehcbab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FilingToCompanyCreateInput,
        include: Optional[types.FilingToCompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new FilingToCompany record.

        Parameters
        ----------
        data
            FilingToCompany record data
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The created FilingToCompany record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FilingToCompany record from just the required fields
        filingtocompany = await FilingToCompany.prisma().create(
            data={
                # data to create a FilingToCompany record
                'filingId': 'bdadaadhag',
                'companyId': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FilingToCompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FilingToCompany records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FilingToCompany record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FilingToCompany.prisma().create_many(
            data=[
                {
                    # data to create a FilingToCompany record
                    'filingId': 'caaaedabfc',
                    'companyId': 'bigibebcib',
                },
                {
                    # data to create a FilingToCompany record
                    'filingId': 'bigaiehgcc',
                    'companyId': 'beeifcbebf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FilingToCompanyWhereUniqueInput,
        include: Optional[types.FilingToCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FilingToCompany record.

        Parameters
        ----------
        where
            FilingToCompany filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The deleted FilingToCompany record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingtocompany = await FilingToCompany.prisma().delete(
            where={
                # FilingToCompany where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FilingToCompanyWhereUniqueInput,
        include: Optional[types.FilingToCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FilingToCompany record.

        Parameters
        ----------
        where
            FilingToCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The found FilingToCompany record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingtocompany = await FilingToCompany.prisma().find_unique(
            where={
                # FilingToCompany where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FilingToCompanyWhereUniqueInput,
        include: Optional[types.FilingToCompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FilingToCompany record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FilingToCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The found FilingToCompany record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingtocompany = await FilingToCompany.prisma().find_unique_or_raise(
            where={
                # FilingToCompany where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingToCompanyInclude] = None,
        order: Optional[Union[types.FilingToCompanyOrderByInput, List[types.FilingToCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingToCompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FilingToCompany records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FilingToCompany records returned
        skip
            Ignore the first N results
        where
            FilingToCompany filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingToCompany model
        order
            Order the returned FilingToCompany records by any field
        distinct
            Filter FilingToCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FilingToCompany]
            The list of all FilingToCompany records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FilingToCompany records
        filingtocompanys = await FilingToCompany.prisma().find_many(take=10)

        # find the first 5 FilingToCompany records ordered by the filingId field
        filingtocompanys = await FilingToCompany.prisma().find_many(
            take=5,
            order={
                'filingId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingToCompanyInclude] = None,
        order: Optional[Union[types.FilingToCompanyOrderByInput, List[types.FilingToCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingToCompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FilingToCompany record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FilingToCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingToCompany model
        order
            Order the returned FilingToCompany records by any field
        distinct
            Filter FilingToCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FilingToCompany
            The first FilingToCompany record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FilingToCompany record ordered by the companyId field
        filingtocompany = await FilingToCompany.prisma().find_first(
            skip=1,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
        include: Optional[types.FilingToCompanyInclude] = None,
        order: Optional[Union[types.FilingToCompanyOrderByInput, List[types.FilingToCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.FilingToCompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FilingToCompany record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FilingToCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FilingToCompany model
        order
            Order the returned FilingToCompany records by any field
        distinct
            Filter FilingToCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FilingToCompany
            The first FilingToCompany record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FilingToCompany record ordered by the filingId field
        filingtocompany = await FilingToCompany.prisma().find_first_or_raise(
            skip=1,
            order={
                'filingId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FilingToCompanyUpdateInput,
        where: types.FilingToCompanyWhereUniqueInput,
        include: Optional[types.FilingToCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FilingToCompany record.

        Parameters
        ----------
        data
            FilingToCompany record data specifying what to update
        where
            FilingToCompany filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The updated FilingToCompany record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        filingtocompany = await FilingToCompany.prisma().update(
            where={
                # FilingToCompany where unique filter

            },
            data={
                # data to update the FilingToCompany record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FilingToCompanyWhereUniqueInput,
        data: types.FilingToCompanyUpsertInput,
        include: Optional[types.FilingToCompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FilingToCompany filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FilingToCompany model

        Returns
        -------
        prisma.models.FilingToCompany
            The created or updated FilingToCompany record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        filingtocompany = await FilingToCompany.prisma().upsert(
            where={
                # FilingToCompany where unique filter
            },
            data={
                'create': {
                    # FilingToCompany data to be set if the record does not exist
                },
                'update': {
                    # FilingToCompany data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FilingToCompanyUpdateManyMutationInput,
        where: types.FilingToCompanyWhereInput,
    ) -> int:
        """Update multiple FilingToCompany records

        Parameters
        ----------
        data
            FilingToCompany data to update the selected FilingToCompany records to
        where
            Filter to select the FilingToCompany records to update

        Returns
        -------
        int
            The total number of FilingToCompany records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FilingToCompany records
        total = await FilingToCompany.prisma().update_many(
            data={
                'companyId': 'bgcigfahea'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FilingToCompany records present in the database

        Parameters
        ----------
        select
            Select the FilingToCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FilingToCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingToCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FilingToCompany.prisma().count()

        # results: prisma.types.FilingToCompanyCountAggregateOutput
        results = await FilingToCompany.prisma().count(
            select={
                '_all': True,
                'filingId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FilingToCompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
    ) -> types.FilingToCompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FilingToCompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FilingToCompanyWhereInput] = None,
        cursor: Optional[types.FilingToCompanyWhereUniqueInput] = None,
    ) -> Union[int, types.FilingToCompanyCountAggregateOutput]:
        """Count the number of FilingToCompany records present in the database

        Parameters
        ----------
        select
            Select the FilingToCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FilingToCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FilingToCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FilingToCompany.prisma().count()

        # results: prisma.types.FilingToCompanyCountAggregateOutput
        results = await FilingToCompany.prisma().count(
            select={
                '_all': True,
                'companyId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FilingToCompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FilingToCompanyWhereInput] = None
    ) -> int:
        """Delete multiple FilingToCompany records.

        Parameters
        ----------
        where
            Optional FilingToCompany filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FilingToCompany records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FilingToCompany records
        total = await FilingToCompany.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FilingToCompanyScalarFieldKeysT'],
        *,
        where: Optional['types.FilingToCompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FilingToCompanyAvgAggregateInput'] = None,
        sum: Optional['types.FilingToCompanySumAggregateInput'] = None,
        min: Optional['types.FilingToCompanyMinAggregateInput'] = None,
        max: Optional['types.FilingToCompanyMaxAggregateInput'] = None,
        having: Optional['types.FilingToCompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FilingToCompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FilingToCompanyScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.FilingToCompanyScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.FilingToCompanyGroupByOutput']:
        """Group FilingToCompany records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FilingToCompany fields to group records by
        where
            FilingToCompany filter to select records
        take
            Limit the maximum number of FilingToCompany records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FilingToCompanyGroupByOutput]
            A list of dictionaries representing the FilingToCompany record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FilingToCompany records by filingId values
        # and count how many records are in each group
        results = await FilingToCompany.prisma().group_by(
            ['filingId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Document]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Document.prisma().query_raw(
            'SELECT * FROM Document WHERE id = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Document
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Document.prisma().query_first(
            'SELECT * FROM Document WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DocumentCreateInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Document record.

        Parameters
        ----------
        data
            Document record data
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created Document record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Document record from just the required fields
        document = await Document.prisma().create(
            data={
                # data to create a Document record
                'status': enums.StatusEnum.Active,
                'serffTrackingNumber': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Document records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Document record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Document.prisma().create_many(
            data=[
                {
                    # data to create a Document record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'hgdhbjhhj',
                },
                {
                    # data to create a Document record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'ecjjjfbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Document record.

        Parameters
        ----------
        where
            Document filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The deleted Document record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().delete(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Document record.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Document record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique_or_raise(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Document records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N results
        where
            Document filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Document]
            The list of all Document records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Document records
        documents = await Document.prisma().find_many(take=10)

        # find the first 5 Document records ordered by the updatedAt field
        documents = await Document.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Document record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the status field
        document = await Document.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Document record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the serffTrackingNumber field
        document = await Document.prisma().find_first_or_raise(
            skip=1,
            order={
                'serffTrackingNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DocumentUpdateInput,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Document record.

        Parameters
        ----------
        data
            Document record data specifying what to update
        where
            Document filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The updated Document record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        document = await Document.prisma().update(
            where={
                'id': 'cbachdgfce',
            },
            data={
                # data to update the Document record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DocumentWhereUniqueInput,
        data: types.DocumentUpsertInput,
        include: Optional[types.DocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Document filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created or updated Document record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().upsert(
            where={
                'id': 'chbfcacbd',
            },
            data={
                'create': {
                    'id': 'chbfcacbd',
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'ecjjjfbae',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'ecjjjfbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DocumentUpdateManyMutationInput,
        where: types.DocumentWhereInput,
    ) -> int:
        """Update multiple Document records

        Parameters
        ----------
        data
            Document data to update the selected Document records to
        where
            Filter to select the Document records to update

        Returns
        -------
        int
            The total number of Document records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Document records
        total = await Document.prisma().update_many(
            data={
                'documentType': 'efggddide'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'documentName': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> types.DocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> Union[int, types.DocumentCountAggregateOutput]:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'fileName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DocumentWhereInput] = None
    ) -> int:
        """Delete multiple Document records.

        Parameters
        ----------
        where
            Optional Document filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Document records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Document records
        total = await Document.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DocumentScalarFieldKeysT'],
        *,
        where: Optional['types.DocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DocumentAvgAggregateInput'] = None,
        sum: Optional['types.DocumentSumAggregateInput'] = None,
        min: Optional['types.DocumentMinAggregateInput'] = None,
        max: Optional['types.DocumentMaxAggregateInput'] = None,
        having: Optional['types.DocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DocumentScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.DocumentScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.DocumentGroupByOutput']:
        """Group Document records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Document fields to group records by
        where
            Document filter to select records
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DocumentGroupByOutput]
            A list of dictionaries representing the Document record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Document records by formNumber values
        # and count how many records are in each group
        results = await Document.prisma().group_by(
            ['formNumber'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Page]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Page.prisma().query_raw(
            'SELECT * FROM Page WHERE id = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Page
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Page.prisma().query_first(
            'SELECT * FROM Page WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PageCreateInput,
        include: Optional[types.PageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Page record.

        Parameters
        ----------
        data
            Page record data
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The created Page record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Page record from just the required fields
        page = await Page.prisma().create(
            data={
                # data to create a Page record
                'status': enums.StatusEnum.Active,
                'serffTrackingNumber': 'bfidgijfjc',
                'pageNumber': 878442065,
                'rawContent': 'bghfciaafe',
                'tokenCount': 1627576247,
                'documentId': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Page records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Page record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Page.prisma().create_many(
            data=[
                {
                    # data to create a Page record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'gaddfhfh',
                    'pageNumber': 684462146,
                    'rawContent': 'bgcffadich',
                    'tokenCount': 521827728,
                    'documentId': 'bcggadccgf',
                },
                {
                    # data to create a Page record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'jdcfdcgc',
                    'pageNumber': 2053047983,
                    'rawContent': 'gifdddbia',
                    'tokenCount': 127474245,
                    'documentId': 'jeijcbhfe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PageWhereUniqueInput,
        include: Optional[types.PageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Page record.

        Parameters
        ----------
        where
            Page filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The deleted Page record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        page = await Page.prisma().delete(
            where={
                'id': 'bjgejjabff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PageWhereUniqueInput,
        include: Optional[types.PageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Page record.

        Parameters
        ----------
        where
            Page filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The found Page record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        page = await Page.prisma().find_unique(
            where={
                'id': 'bcciijbibg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PageWhereUniqueInput,
        include: Optional[types.PageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Page record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Page filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The found Page record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        page = await Page.prisma().find_unique_or_raise(
            where={
                'id': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
        include: Optional[types.PageInclude] = None,
        order: Optional[Union[types.PageOrderByInput, List[types.PageOrderByInput]]] = None,
        distinct: Optional[List[types.PageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Page records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Page records returned
        skip
            Ignore the first N results
        where
            Page filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Page model
        order
            Order the returned Page records by any field
        distinct
            Filter Page records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Page]
            The list of all Page records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Page records
        pages = await Page.prisma().find_many(take=10)

        # find the first 5 Page records ordered by the updatedAt field
        pages = await Page.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
        include: Optional[types.PageInclude] = None,
        order: Optional[Union[types.PageOrderByInput, List[types.PageOrderByInput]]] = None,
        distinct: Optional[List[types.PageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Page record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Page filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Page model
        order
            Order the returned Page records by any field
        distinct
            Filter Page records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Page
            The first Page record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Page record ordered by the status field
        page = await Page.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
        include: Optional[types.PageInclude] = None,
        order: Optional[Union[types.PageOrderByInput, List[types.PageOrderByInput]]] = None,
        distinct: Optional[List[types.PageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Page record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Page filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Page model
        order
            Order the returned Page records by any field
        distinct
            Filter Page records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Page
            The first Page record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Page record ordered by the serffTrackingNumber field
        page = await Page.prisma().find_first_or_raise(
            skip=1,
            order={
                'serffTrackingNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PageUpdateInput,
        where: types.PageWhereUniqueInput,
        include: Optional[types.PageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Page record.

        Parameters
        ----------
        data
            Page record data specifying what to update
        where
            Page filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The updated Page record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        page = await Page.prisma().update(
            where={
                'id': 'bccdfhdigc',
            },
            data={
                # data to update the Page record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PageWhereUniqueInput,
        data: types.PageUpsertInput,
        include: Optional[types.PageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Page filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Page model

        Returns
        -------
        prisma.models.Page
            The created or updated Page record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        page = await Page.prisma().upsert(
            where={
                'id': 'febcgjbfj',
            },
            data={
                'create': {
                    'id': 'febcgjbfj',
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'jdcfdcgc',
                    'pageNumber': 2053047983,
                    'rawContent': 'gifdddbia',
                    'tokenCount': 127474245,
                    'documentId': 'jeijcbhfe',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'jdcfdcgc',
                    'pageNumber': 2053047983,
                    'rawContent': 'gifdddbia',
                    'tokenCount': 127474245,
                    'documentId': 'jeijcbhfe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PageUpdateManyMutationInput,
        where: types.PageWhereInput,
    ) -> int:
        """Update multiple Page records

        Parameters
        ----------
        data
            Page data to update the selected Page records to
        where
            Filter to select the Page records to update

        Returns
        -------
        int
            The total number of Page records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Page records
        total = await Page.prisma().update_many(
            data={
                'pageNumber': 1064846676
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Page records present in the database

        Parameters
        ----------
        select
            Select the Page fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Page filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Page.prisma().count()

        # results: prisma.types.PageCountAggregateOutput
        results = await Page.prisma().count(
            select={
                '_all': True,
                'rawContent': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
    ) -> types.PageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PageWhereInput] = None,
        cursor: Optional[types.PageWhereUniqueInput] = None,
    ) -> Union[int, types.PageCountAggregateOutput]:
        """Count the number of Page records present in the database

        Parameters
        ----------
        select
            Select the Page fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Page filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Page.prisma().count()

        # results: prisma.types.PageCountAggregateOutput
        results = await Page.prisma().count(
            select={
                '_all': True,
                'aoi': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PageWhereInput] = None
    ) -> int:
        """Delete multiple Page records.

        Parameters
        ----------
        where
            Optional Page filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Page records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Page records
        total = await Page.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PageScalarFieldKeysT'],
        *,
        where: Optional['types.PageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PageAvgAggregateInput'] = None,
        sum: Optional['types.PageSumAggregateInput'] = None,
        min: Optional['types.PageMinAggregateInput'] = None,
        max: Optional['types.PageMaxAggregateInput'] = None,
        having: Optional['types.PageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PageScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PageScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PageGroupByOutput']:
        """Group Page records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Page fields to group records by
        where
            Page filter to select records
        take
            Limit the maximum number of Page records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PageGroupByOutput]
            A list of dictionaries representing the Page record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Page records by tokenCount values
        # and count how many records are in each group
        results = await Page.prisma().group_by(
            ['tokenCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChunkActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Chunk]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Chunk.prisma().query_raw(
            'SELECT * FROM Chunk WHERE id = $1',
            'faidicegb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Chunk
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Chunk.prisma().query_first(
            'SELECT * FROM Chunk WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChunkCreateInput,
        include: Optional[types.ChunkInclude] = None
    ) -> _PrismaModelT:
        """Create a new Chunk record.

        Parameters
        ----------
        data
            Chunk record data
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The created Chunk record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Chunk record from just the required fields
        chunk = await Chunk.prisma().create(
            data={
                # data to create a Chunk record
                'status': enums.StatusEnum.Active,
                'serffTrackingNumber': 'bacecgfhbe',
                'chunkNumber': 872078403,
                'text': 'biheheiajg',
                'tokenCount': 916896761,
                'version': 'hgjcghfbi',
                'documentId': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChunkCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Chunk records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Chunk record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Chunk.prisma().create_many(
            data=[
                {
                    # data to create a Chunk record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'jchciaee',
                    'chunkNumber': 344858293,
                    'text': 'bbcbhebbda',
                    'tokenCount': 1495896251,
                    'version': 'caifcbgii',
                    'documentId': 'igaibbfgj',
                },
                {
                    # data to create a Chunk record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bggajdcbbi',
                    'chunkNumber': 525761943,
                    'text': 'hdgcajhjg',
                    'tokenCount': 493907821,
                    'version': 'gdjgigfgc',
                    'documentId': 'gfeaahdeh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChunkWhereUniqueInput,
        include: Optional[types.ChunkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Chunk record.

        Parameters
        ----------
        where
            Chunk filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The deleted Chunk record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chunk = await Chunk.prisma().delete(
            where={
                'id': 'bjafcgbffc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChunkWhereUniqueInput,
        include: Optional[types.ChunkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Chunk record.

        Parameters
        ----------
        where
            Chunk filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The found Chunk record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chunk = await Chunk.prisma().find_unique(
            where={
                'id': 'hihegjif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChunkWhereUniqueInput,
        include: Optional[types.ChunkInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Chunk record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Chunk filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The found Chunk record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chunk = await Chunk.prisma().find_unique_or_raise(
            where={
                'id': 'bdjidcidac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
        include: Optional[types.ChunkInclude] = None,
        order: Optional[Union[types.ChunkOrderByInput, List[types.ChunkOrderByInput]]] = None,
        distinct: Optional[List[types.ChunkScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Chunk records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Chunk records returned
        skip
            Ignore the first N results
        where
            Chunk filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chunk model
        order
            Order the returned Chunk records by any field
        distinct
            Filter Chunk records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Chunk]
            The list of all Chunk records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Chunk records
        chunks = await Chunk.prisma().find_many(take=10)

        # find the first 5 Chunk records ordered by the updatedAt field
        chunks = await Chunk.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
        include: Optional[types.ChunkInclude] = None,
        order: Optional[Union[types.ChunkOrderByInput, List[types.ChunkOrderByInput]]] = None,
        distinct: Optional[List[types.ChunkScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Chunk record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Chunk filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chunk model
        order
            Order the returned Chunk records by any field
        distinct
            Filter Chunk records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Chunk
            The first Chunk record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Chunk record ordered by the status field
        chunk = await Chunk.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
        include: Optional[types.ChunkInclude] = None,
        order: Optional[Union[types.ChunkOrderByInput, List[types.ChunkOrderByInput]]] = None,
        distinct: Optional[List[types.ChunkScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Chunk record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Chunk filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chunk model
        order
            Order the returned Chunk records by any field
        distinct
            Filter Chunk records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Chunk
            The first Chunk record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Chunk record ordered by the serffTrackingNumber field
        chunk = await Chunk.prisma().find_first_or_raise(
            skip=1,
            order={
                'serffTrackingNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChunkUpdateInput,
        where: types.ChunkWhereUniqueInput,
        include: Optional[types.ChunkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Chunk record.

        Parameters
        ----------
        data
            Chunk record data specifying what to update
        where
            Chunk filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The updated Chunk record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chunk = await Chunk.prisma().update(
            where={
                'id': 'ifgaaagff',
            },
            data={
                # data to update the Chunk record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChunkWhereUniqueInput,
        data: types.ChunkUpsertInput,
        include: Optional[types.ChunkInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Chunk filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Chunk model

        Returns
        -------
        prisma.models.Chunk
            The created or updated Chunk record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chunk = await Chunk.prisma().upsert(
            where={
                'id': 'befcddgjce',
            },
            data={
                'create': {
                    'id': 'befcddgjce',
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bggajdcbbi',
                    'chunkNumber': 525761943,
                    'text': 'hdgcajhjg',
                    'tokenCount': 493907821,
                    'version': 'gdjgigfgc',
                    'documentId': 'gfeaahdeh',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'bggajdcbbi',
                    'chunkNumber': 525761943,
                    'text': 'hdgcajhjg',
                    'tokenCount': 493907821,
                    'version': 'gdjgigfgc',
                    'documentId': 'gfeaahdeh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChunkUpdateManyMutationInput,
        where: types.ChunkWhereInput,
    ) -> int:
        """Update multiple Chunk records

        Parameters
        ----------
        data
            Chunk data to update the selected Chunk records to
        where
            Filter to select the Chunk records to update

        Returns
        -------
        int
            The total number of Chunk records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Chunk records
        total = await Chunk.prisma().update_many(
            data={
                'chunkNumber': 1573199653
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Chunk records present in the database

        Parameters
        ----------
        select
            Select the Chunk fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Chunk filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChunkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Chunk.prisma().count()

        # results: prisma.types.ChunkCountAggregateOutput
        results = await Chunk.prisma().count(
            select={
                '_all': True,
                'text': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChunkCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
    ) -> types.ChunkCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChunkCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChunkWhereInput] = None,
        cursor: Optional[types.ChunkWhereUniqueInput] = None,
    ) -> Union[int, types.ChunkCountAggregateOutput]:
        """Count the number of Chunk records present in the database

        Parameters
        ----------
        select
            Select the Chunk fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Chunk filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChunkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Chunk.prisma().count()

        # results: prisma.types.ChunkCountAggregateOutput
        results = await Chunk.prisma().count(
            select={
                '_all': True,
                'tokenCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChunkCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChunkWhereInput] = None
    ) -> int:
        """Delete multiple Chunk records.

        Parameters
        ----------
        where
            Optional Chunk filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Chunk records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Chunk records
        total = await Chunk.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChunkScalarFieldKeysT'],
        *,
        where: Optional['types.ChunkWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChunkAvgAggregateInput'] = None,
        sum: Optional['types.ChunkSumAggregateInput'] = None,
        min: Optional['types.ChunkMinAggregateInput'] = None,
        max: Optional['types.ChunkMaxAggregateInput'] = None,
        having: Optional['types.ChunkScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChunkCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChunkScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ChunkScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ChunkGroupByOutput']:
        """Group Chunk records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Chunk fields to group records by
        where
            Chunk filter to select records
        take
            Limit the maximum number of Chunk records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChunkGroupByOutput]
            A list of dictionaries representing the Chunk record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Chunk records by bbox values
        # and count how many records are in each group
        results = await Chunk.prisma().group_by(
            ['bbox'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BlockActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Block]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Block.prisma().query_raw(
            'SELECT * FROM Block WHERE id = $1',
            'cabdjadaji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Block
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Block.prisma().query_first(
            'SELECT * FROM Block WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BlockCreateInput,
        include: Optional[types.BlockInclude] = None
    ) -> _PrismaModelT:
        """Create a new Block record.

        Parameters
        ----------
        data
            Block record data
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The created Block record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Block record from just the required fields
        block = await Block.prisma().create(
            data={
                # data to create a Block record
                'status': enums.StatusEnum.Active,
                'serffTrackingNumber': 'faajgfadf',
                'blockNumber': 1800624392,
                'pageNumber': 2077067425,
                'text': 'bghcbbcidi',
                'chunkId': 'jcgghhgdj',
                'documentId': 'beehgcebbg',
                'pageId': 'bhdiaidiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BlockCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Block records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Block record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Block.prisma().create_many(
            data=[
                {
                    # data to create a Block record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'deajegcfi',
                    'blockNumber': 601077795,
                    'pageNumber': 290603296,
                    'text': 'bifficggej',
                    'chunkId': 'bgbbaajbic',
                    'documentId': 'eegghdhjb',
                    'pageId': 'daafgidjg',
                },
                {
                    # data to create a Block record
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'gdcgcgagj',
                    'blockNumber': 1724011690,
                    'pageNumber': 470157467,
                    'text': 'bcajcajjbc',
                    'chunkId': 'bfdgheeegf',
                    'documentId': 'ececbijji',
                    'pageId': 'cbcfgdcdhf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BlockWhereUniqueInput,
        include: Optional[types.BlockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Block record.

        Parameters
        ----------
        where
            Block filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The deleted Block record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        block = await Block.prisma().delete(
            where={
                'id': 'fdgjfbhia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BlockWhereUniqueInput,
        include: Optional[types.BlockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Block record.

        Parameters
        ----------
        where
            Block filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The found Block record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        block = await Block.prisma().find_unique(
            where={
                'id': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BlockWhereUniqueInput,
        include: Optional[types.BlockInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Block record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Block filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The found Block record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        block = await Block.prisma().find_unique_or_raise(
            where={
                'id': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
        include: Optional[types.BlockInclude] = None,
        order: Optional[Union[types.BlockOrderByInput, List[types.BlockOrderByInput]]] = None,
        distinct: Optional[List[types.BlockScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Block records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Block records returned
        skip
            Ignore the first N results
        where
            Block filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Block model
        order
            Order the returned Block records by any field
        distinct
            Filter Block records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Block]
            The list of all Block records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Block records
        blocks = await Block.prisma().find_many(take=10)

        # find the first 5 Block records ordered by the updatedAt field
        blocks = await Block.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
        include: Optional[types.BlockInclude] = None,
        order: Optional[Union[types.BlockOrderByInput, List[types.BlockOrderByInput]]] = None,
        distinct: Optional[List[types.BlockScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Block record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Block filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Block model
        order
            Order the returned Block records by any field
        distinct
            Filter Block records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Block
            The first Block record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Block record ordered by the status field
        block = await Block.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
        include: Optional[types.BlockInclude] = None,
        order: Optional[Union[types.BlockOrderByInput, List[types.BlockOrderByInput]]] = None,
        distinct: Optional[List[types.BlockScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Block record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Block filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Block model
        order
            Order the returned Block records by any field
        distinct
            Filter Block records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Block
            The first Block record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Block record ordered by the serffTrackingNumber field
        block = await Block.prisma().find_first_or_raise(
            skip=1,
            order={
                'serffTrackingNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BlockUpdateInput,
        where: types.BlockWhereUniqueInput,
        include: Optional[types.BlockInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Block record.

        Parameters
        ----------
        data
            Block record data specifying what to update
        where
            Block filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The updated Block record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        block = await Block.prisma().update(
            where={
                'id': 'bieiidcabj',
            },
            data={
                # data to update the Block record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BlockWhereUniqueInput,
        data: types.BlockUpsertInput,
        include: Optional[types.BlockInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Block filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Block model

        Returns
        -------
        prisma.models.Block
            The created or updated Block record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        block = await Block.prisma().upsert(
            where={
                'id': 'bjcbfcieaa',
            },
            data={
                'create': {
                    'id': 'bjcbfcieaa',
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'gdcgcgagj',
                    'blockNumber': 1724011690,
                    'pageNumber': 470157467,
                    'text': 'bcajcajjbc',
                    'chunkId': 'bfdgheeegf',
                    'documentId': 'ececbijji',
                    'pageId': 'cbcfgdcdhf',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'serffTrackingNumber': 'gdcgcgagj',
                    'blockNumber': 1724011690,
                    'pageNumber': 470157467,
                    'text': 'bcajcajjbc',
                    'chunkId': 'bfdgheeegf',
                    'documentId': 'ececbijji',
                    'pageId': 'cbcfgdcdhf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BlockUpdateManyMutationInput,
        where: types.BlockWhereInput,
    ) -> int:
        """Update multiple Block records

        Parameters
        ----------
        data
            Block data to update the selected Block records to
        where
            Filter to select the Block records to update

        Returns
        -------
        int
            The total number of Block records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Block records
        total = await Block.prisma().update_many(
            data={
                'blockNumber': 2100427849
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Block records present in the database

        Parameters
        ----------
        select
            Select the Block fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Block filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BlockCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Block.prisma().count()

        # results: prisma.types.BlockCountAggregateOutput
        results = await Block.prisma().count(
            select={
                '_all': True,
                'pageNumber': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BlockCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
    ) -> types.BlockCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BlockCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BlockWhereInput] = None,
        cursor: Optional[types.BlockWhereUniqueInput] = None,
    ) -> Union[int, types.BlockCountAggregateOutput]:
        """Count the number of Block records present in the database

        Parameters
        ----------
        select
            Select the Block fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Block filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BlockCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Block.prisma().count()

        # results: prisma.types.BlockCountAggregateOutput
        results = await Block.prisma().count(
            select={
                '_all': True,
                'text': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BlockCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BlockWhereInput] = None
    ) -> int:
        """Delete multiple Block records.

        Parameters
        ----------
        where
            Optional Block filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Block records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Block records
        total = await Block.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BlockScalarFieldKeysT'],
        *,
        where: Optional['types.BlockWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BlockAvgAggregateInput'] = None,
        sum: Optional['types.BlockSumAggregateInput'] = None,
        min: Optional['types.BlockMinAggregateInput'] = None,
        max: Optional['types.BlockMaxAggregateInput'] = None,
        having: Optional['types.BlockScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BlockCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BlockScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.BlockScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.BlockGroupByOutput']:
        """Group Block records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Block fields to group records by
        where
            Block filter to select records
        take
            Limit the maximum number of Block records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BlockGroupByOutput]
            A list of dictionaries representing the Block record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Block records by bbox values
        # and count how many records are in each group
        results = await Block.prisma().group_by(
            ['bbox'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TenantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tenant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tenant.prisma().query_raw(
            'SELECT * FROM Tenant WHERE id = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tenant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tenant.prisma().query_first(
            'SELECT * FROM Tenant WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TenantCreateInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tenant record.

        Parameters
        ----------
        data
            Tenant record data
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created Tenant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tenant record from just the required fields
        tenant = await Tenant.prisma().create(
            data={
                # data to create a Tenant record
                'status': enums.StatusEnum.Active,
                'name': 'jcibfcbhf',
                'slug': 'chdadcaga',
                'planId': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TenantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tenant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tenant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tenant.prisma().create_many(
            data=[
                {
                    # data to create a Tenant record
                    'status': enums.StatusEnum.Active,
                    'name': 'fbahdheji',
                    'slug': 'cbbheiicgh',
                    'planId': 'beabjeejdg',
                },
                {
                    # data to create a Tenant record
                    'status': enums.StatusEnum.Active,
                    'name': 'bcjhgahffd',
                    'slug': 'fbjeiiffa',
                    'planId': 'jhgidcgbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tenant record.

        Parameters
        ----------
        where
            Tenant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The deleted Tenant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().delete(
            where={
                'id': 'bgjgecfejc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tenant record.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique(
            where={
                'id': 'bgjcgchib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tenant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tenant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The found Tenant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().find_unique_or_raise(
            where={
                'id': 'bacdaibgfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tenant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N results
        where
            Tenant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tenant]
            The list of all Tenant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tenant records
        tenants = await Tenant.prisma().find_many(take=10)

        # find the first 5 Tenant records ordered by the updatedAt field
        tenants = await Tenant.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tenant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the status field
        tenant = await Tenant.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
        include: Optional[types.TenantInclude] = None,
        order: Optional[Union[types.TenantOrderByInput, List[types.TenantOrderByInput]]] = None,
        distinct: Optional[List[types.TenantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tenant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tenant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tenant model
        order
            Order the returned Tenant records by any field
        distinct
            Filter Tenant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tenant
            The first Tenant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tenant record ordered by the name field
        tenant = await Tenant.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TenantUpdateInput,
        where: types.TenantWhereUniqueInput,
        include: Optional[types.TenantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tenant record.

        Parameters
        ----------
        data
            Tenant record data specifying what to update
        where
            Tenant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The updated Tenant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tenant = await Tenant.prisma().update(
            where={
                'id': 'dchgibach',
            },
            data={
                # data to update the Tenant record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TenantWhereUniqueInput,
        data: types.TenantUpsertInput,
        include: Optional[types.TenantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tenant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tenant model

        Returns
        -------
        prisma.models.Tenant
            The created or updated Tenant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tenant = await Tenant.prisma().upsert(
            where={
                'id': 'fchheijjc',
            },
            data={
                'create': {
                    'id': 'fchheijjc',
                    'status': enums.StatusEnum.Active,
                    'name': 'bcjhgahffd',
                    'slug': 'fbjeiiffa',
                    'planId': 'jhgidcgbf',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'name': 'bcjhgahffd',
                    'slug': 'fbjeiiffa',
                    'planId': 'jhgidcgbf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TenantUpdateManyMutationInput,
        where: types.TenantWhereInput,
    ) -> int:
        """Update multiple Tenant records

        Parameters
        ----------
        data
            Tenant data to update the selected Tenant records to
        where
            Filter to select the Tenant records to update

        Returns
        -------
        int
            The total number of Tenant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tenant records
        total = await Tenant.prisma().update_many(
            data={
                'slug': 'cacjdfhejh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'logoUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TenantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> types.TenantCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TenantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TenantWhereInput] = None,
        cursor: Optional[types.TenantWhereUniqueInput] = None,
    ) -> Union[int, types.TenantCountAggregateOutput]:
        """Count the number of Tenant records present in the database

        Parameters
        ----------
        select
            Select the Tenant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tenant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TenantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tenant.prisma().count()

        # results: prisma.types.TenantCountAggregateOutput
        results = await Tenant.prisma().count(
            select={
                '_all': True,
                'databaseUrl': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TenantCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TenantWhereInput] = None
    ) -> int:
        """Delete multiple Tenant records.

        Parameters
        ----------
        where
            Optional Tenant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tenant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tenant records
        total = await Tenant.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TenantScalarFieldKeysT'],
        *,
        where: Optional['types.TenantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TenantAvgAggregateInput'] = None,
        sum: Optional['types.TenantSumAggregateInput'] = None,
        min: Optional['types.TenantMinAggregateInput'] = None,
        max: Optional['types.TenantMaxAggregateInput'] = None,
        having: Optional['types.TenantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TenantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TenantScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.TenantScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.TenantGroupByOutput']:
        """Group Tenant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tenant fields to group records by
        where
            Tenant filter to select records
        take
            Limit the maximum number of Tenant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TenantGroupByOutput]
            A list of dictionaries representing the Tenant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tenant records by planId values
        # and count how many records are in each group
        results = await Tenant.prisma().group_by(
            ['planId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PlanActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Plan]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Plan.prisma().query_raw(
            'SELECT * FROM Plan WHERE id = $1',
            'bdbifjhbbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Plan
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Plan.prisma().query_first(
            'SELECT * FROM Plan WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PlanCreateInput,
        include: Optional[types.PlanInclude] = None
    ) -> _PrismaModelT:
        """Create a new Plan record.

        Parameters
        ----------
        data
            Plan record data
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The created Plan record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Plan record from just the required fields
        plan = await Plan.prisma().create(
            data={
                # data to create a Plan record
                'status': enums.StatusEnum.Active,
                'name': 'cbccbbcdfb',
                'type': enums.PlanTypeEnum.Free,
                'price': 1024943020,
                'tenantId': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PlanCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Plan records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Plan record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Plan.prisma().create_many(
            data=[
                {
                    # data to create a Plan record
                    'status': enums.StatusEnum.Active,
                    'name': 'bfjibceaec',
                    'type': enums.PlanTypeEnum.Free,
                    'price': 817623163,
                    'tenantId': 'badaffhddg',
                },
                {
                    # data to create a Plan record
                    'status': enums.StatusEnum.Active,
                    'name': 'bbdbfcfihd',
                    'type': enums.PlanTypeEnum.Free,
                    'price': 210666198,
                    'tenantId': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Plan record.

        Parameters
        ----------
        where
            Plan filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The deleted Plan record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Plan record.

        Parameters
        ----------
        where
            Plan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The found Plan record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Plan record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Plan filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The found Plan record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Plan records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Plan records returned
        skip
            Ignore the first N results
        where
            Plan filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Plan]
            The list of all Plan records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Plan records
        plans = await Plan.prisma().find_many(take=10)

        # find the first 5 Plan records ordered by the updatedAt field
        plans = await Plan.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Plan record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plan
            The first Plan record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plan record ordered by the status field
        plan = await Plan.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
        include: Optional[types.PlanInclude] = None,
        order: Optional[Union[types.PlanOrderByInput, List[types.PlanOrderByInput]]] = None,
        distinct: Optional[List[types.PlanScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Plan record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Plan filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Plan model
        order
            Order the returned Plan records by any field
        distinct
            Filter Plan records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Plan
            The first Plan record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Plan record ordered by the name field
        plan = await Plan.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PlanUpdateInput,
        where: types.PlanWhereUniqueInput,
        include: Optional[types.PlanInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Plan record.

        Parameters
        ----------
        data
            Plan record data specifying what to update
        where
            Plan filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The updated Plan record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        plan = await Plan.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the Plan record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PlanWhereUniqueInput,
        data: types.PlanUpsertInput,
        include: Optional[types.PlanInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Plan filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Plan model

        Returns
        -------
        prisma.models.Plan
            The created or updated Plan record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        plan = await Plan.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'status': enums.StatusEnum.Active,
                    'name': 'bbdbfcfihd',
                    'type': enums.PlanTypeEnum.Free,
                    'price': 210666198,
                    'tenantId': 'bchgafhjed',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'name': 'bbdbfcfihd',
                    'type': enums.PlanTypeEnum.Free,
                    'price': 210666198,
                    'tenantId': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PlanUpdateManyMutationInput,
        where: types.PlanWhereInput,
    ) -> int:
        """Update multiple Plan records

        Parameters
        ----------
        data
            Plan data to update the selected Plan records to
        where
            Filter to select the Plan records to update

        Returns
        -------
        int
            The total number of Plan records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Plan records
        total = await Plan.prisma().update_many(
            data={
                'description': 'bfbdafajcb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Plan records present in the database

        Parameters
        ----------
        select
            Select the Plan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plan.prisma().count()

        # results: prisma.types.PlanCountAggregateOutput
        results = await Plan.prisma().count(
            select={
                '_all': True,
                'type': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PlanCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> types.PlanCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PlanCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PlanWhereInput] = None,
        cursor: Optional[types.PlanWhereUniqueInput] = None,
    ) -> Union[int, types.PlanCountAggregateOutput]:
        """Count the number of Plan records present in the database

        Parameters
        ----------
        select
            Select the Plan fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Plan filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PlanCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Plan.prisma().count()

        # results: prisma.types.PlanCountAggregateOutput
        results = await Plan.prisma().count(
            select={
                '_all': True,
                'price': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PlanCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PlanWhereInput] = None
    ) -> int:
        """Delete multiple Plan records.

        Parameters
        ----------
        where
            Optional Plan filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Plan records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Plan records
        total = await Plan.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PlanScalarFieldKeysT'],
        *,
        where: Optional['types.PlanWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PlanAvgAggregateInput'] = None,
        sum: Optional['types.PlanSumAggregateInput'] = None,
        min: Optional['types.PlanMinAggregateInput'] = None,
        max: Optional['types.PlanMaxAggregateInput'] = None,
        having: Optional['types.PlanScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PlanCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PlanScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.PlanScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.PlanGroupByOutput']:
        """Group Plan records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Plan fields to group records by
        where
            Plan filter to select records
        take
            Limit the maximum number of Plan records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PlanGroupByOutput]
            A list of dictionaries representing the Plan record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Plan records by features values
        # and count how many records are in each group
        results = await Plan.prisma().group_by(
            ['features'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'caeghehde',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'status': enums.StatusEnum.Active,
                'email': 'caghgfbggd',
                'name': 'bbidjbbjaa',
                'tenantId': 'bfijhaejdd',
                'hashedPassword': 'bcedehfiji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'status': enums.StatusEnum.Active,
                    'email': 'bdgjicijhb',
                    'name': 'bghifjdeia',
                    'tenantId': 'eadfcbbcb',
                    'hashedPassword': 'geihgahba',
                },
                {
                    # data to create a User record
                    'status': enums.StatusEnum.Active,
                    'email': 'gahdcdhbj',
                    'name': 'begiijahea',
                    'tenantId': 'gcjadjaaf',
                    'hashedPassword': 'bcbebgiaic',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'ijigbdcbj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'gfidhicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'jfegcaafh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the updatedAt field
        users = await User.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the status field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the email field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bcbeiajjfa',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'baehicaajf',
            },
            data={
                'create': {
                    'id': 'baehicaajf',
                    'status': enums.StatusEnum.Active,
                    'email': 'gahdcdhbj',
                    'name': 'begiijahea',
                    'tenantId': 'gcjadjaaf',
                    'hashedPassword': 'bcbebgiaic',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'email': 'gahdcdhbj',
                    'name': 'begiijahea',
                    'tenantId': 'gcjadjaaf',
                    'hashedPassword': 'bcbebgiaic',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'name': 'bdachdeiga'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'tenantId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'hashedPassword': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeysT'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by isEmailVerified values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['isEmailVerified'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            'ijdafccef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'status': enums.StatusEnum.Active,
                'role': 'ciaaiddag',
                'content': 'fejggijff',
                'chatId': 'hghjaaai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'status': enums.StatusEnum.Active,
                    'role': 'cajicjjdef',
                    'content': 'cefjaadec',
                    'chatId': 'ibbigdigd',
                },
                {
                    # data to create a Message record
                    'status': enums.StatusEnum.Active,
                    'role': 'bdiiiabbii',
                    'content': 'hfcfhhadh',
                    'chatId': 'bbihggdcji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'hgjgibdgd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'bcbecjfice',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'bacbebhjjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the updatedAt field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the status field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the role field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'dfbfaddhe',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'bdcbbieibf',
            },
            data={
                'create': {
                    'id': 'bdcbbieibf',
                    'status': enums.StatusEnum.Active,
                    'role': 'bdiiiabbii',
                    'content': 'hfcfhhadh',
                    'chatId': 'bbihggdcji',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'role': 'bdiiiabbii',
                    'content': 'hfcfhhadh',
                    'chatId': 'bbihggdcji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'content': 'dgjhdcggi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'rawJson': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'messageType': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeysT'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by tokensUsed values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['tokensUsed'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Chat]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Chat.prisma().query_raw(
            'SELECT * FROM Chat WHERE id = $1',
            'bbjbcdfabd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Chat
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Chat.prisma().query_first(
            'SELECT * FROM Chat WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatCreateInput,
        include: Optional[types.ChatInclude] = None
    ) -> _PrismaModelT:
        """Create a new Chat record.

        Parameters
        ----------
        data
            Chat record data
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The created Chat record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Chat record from just the required fields
        chat = await Chat.prisma().create(
            data={
                # data to create a Chat record
                'status': enums.StatusEnum.Active,
                'userId': 'gchfgbcec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Chat records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Chat record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Chat.prisma().create_many(
            data=[
                {
                    # data to create a Chat record
                    'status': enums.StatusEnum.Active,
                    'userId': 'bihcjfcjah',
                },
                {
                    # data to create a Chat record
                    'status': enums.StatusEnum.Active,
                    'userId': 'bhjdcicaii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatWhereUniqueInput,
        include: Optional[types.ChatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Chat record.

        Parameters
        ----------
        where
            Chat filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The deleted Chat record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chat = await Chat.prisma().delete(
            where={
                'id': 'bibedjhcej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatWhereUniqueInput,
        include: Optional[types.ChatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Chat record.

        Parameters
        ----------
        where
            Chat filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The found Chat record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chat = await Chat.prisma().find_unique(
            where={
                'id': 'bjcdajabfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatWhereUniqueInput,
        include: Optional[types.ChatInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Chat record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Chat filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The found Chat record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chat = await Chat.prisma().find_unique_or_raise(
            where={
                'id': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
        include: Optional[types.ChatInclude] = None,
        order: Optional[Union[types.ChatOrderByInput, List[types.ChatOrderByInput]]] = None,
        distinct: Optional[List[types.ChatScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Chat records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Chat records returned
        skip
            Ignore the first N results
        where
            Chat filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chat model
        order
            Order the returned Chat records by any field
        distinct
            Filter Chat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Chat]
            The list of all Chat records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Chat records
        chats = await Chat.prisma().find_many(take=10)

        # find the first 5 Chat records ordered by the updatedAt field
        chats = await Chat.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
        include: Optional[types.ChatInclude] = None,
        order: Optional[Union[types.ChatOrderByInput, List[types.ChatOrderByInput]]] = None,
        distinct: Optional[List[types.ChatScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Chat record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Chat filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chat model
        order
            Order the returned Chat records by any field
        distinct
            Filter Chat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Chat
            The first Chat record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Chat record ordered by the status field
        chat = await Chat.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
        include: Optional[types.ChatInclude] = None,
        order: Optional[Union[types.ChatOrderByInput, List[types.ChatOrderByInput]]] = None,
        distinct: Optional[List[types.ChatScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Chat record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Chat filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Chat model
        order
            Order the returned Chat records by any field
        distinct
            Filter Chat records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Chat
            The first Chat record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Chat record ordered by the title field
        chat = await Chat.prisma().find_first_or_raise(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatUpdateInput,
        where: types.ChatWhereUniqueInput,
        include: Optional[types.ChatInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Chat record.

        Parameters
        ----------
        data
            Chat record data specifying what to update
        where
            Chat filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The updated Chat record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chat = await Chat.prisma().update(
            where={
                'id': 'bbgaifhdaa',
            },
            data={
                # data to update the Chat record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatWhereUniqueInput,
        data: types.ChatUpsertInput,
        include: Optional[types.ChatInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Chat filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Chat model

        Returns
        -------
        prisma.models.Chat
            The created or updated Chat record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chat = await Chat.prisma().upsert(
            where={
                'id': 'dgbcdaegb',
            },
            data={
                'create': {
                    'id': 'dgbcdaegb',
                    'status': enums.StatusEnum.Active,
                    'userId': 'bhjdcicaii',
                },
                'update': {
                    'status': enums.StatusEnum.Active,
                    'userId': 'bhjdcicaii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatUpdateManyMutationInput,
        where: types.ChatWhereInput,
    ) -> int:
        """Update multiple Chat records

        Parameters
        ----------
        data
            Chat data to update the selected Chat records to
        where
            Filter to select the Chat records to update

        Returns
        -------
        int
            The total number of Chat records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Chat records
        total = await Chat.prisma().update_many(
            data={
                'userId': 'beagfbbjig'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Chat records present in the database

        Parameters
        ----------
        select
            Select the Chat fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Chat filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Chat.prisma().count()

        # results: prisma.types.ChatCountAggregateOutput
        results = await Chat.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
    ) -> types.ChatCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatWhereInput] = None,
        cursor: Optional[types.ChatWhereUniqueInput] = None,
    ) -> Union[int, types.ChatCountAggregateOutput]:
        """Count the number of Chat records present in the database

        Parameters
        ----------
        select
            Select the Chat fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Chat filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Chat.prisma().count()

        # results: prisma.types.ChatCountAggregateOutput
        results = await Chat.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatWhereInput] = None
    ) -> int:
        """Delete multiple Chat records.

        Parameters
        ----------
        where
            Optional Chat filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Chat records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Chat records
        total = await Chat.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatScalarFieldKeysT'],
        *,
        where: Optional['types.ChatWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatAvgAggregateInput'] = None,
        sum: Optional['types.ChatSumAggregateInput'] = None,
        min: Optional['types.ChatMinAggregateInput'] = None,
        max: Optional['types.ChatMaxAggregateInput'] = None,
        having: Optional['types.ChatScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatScalarFieldKeysT', 'types.SortOrder'], List[Mapping['types.ChatScalarFieldKeysT', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatGroupByOutput']:
        """Group Chat records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Chat fields to group records by
        where
            Chat filter to select records
        take
            Limit the maximum number of Chat records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatGroupByOutput]
            A list of dictionaries representing the Chat record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Chat records by createdAt values
        # and count how many records are in each group
        results = await Chat.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models