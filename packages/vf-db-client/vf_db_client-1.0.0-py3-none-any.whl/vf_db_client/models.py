# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Filing(bases.BaseFiling):
    """Represents a Filing record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    stateTrackingNumber: Optional[_str] = None
    companyTrackingNumber: Optional[_str] = None
    product: Optional[_str] = None
    typeOfInsurance: 'enums.ProductEnum'
    subTypeOfInsurance: Optional[_str] = None
    filingType: Optional[_str] = None
    submissionDate: Optional[datetime.datetime] = None
    filingStatus: Optional[_str] = None
    serffStatus: Optional[_str] = None
    dispositionDate: Optional[datetime.datetime] = None
    dispositionStatus: Optional[_str] = None
    stateStatusLastChanged: Optional[datetime.datetime] = None
    state: 'enums.StateEnum'
    metadataJson: Optional['fields.Json'] = None
    filingDescription: Optional[_str] = None
    filingSummary: Optional[_str] = None
    documents: Optional[List['models.Document']] = None
    companies: Optional[List['models.FilingToCompany']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FilingKeys']] = None,
        exclude: Optional[Iterable['types.FilingKeys']] = None,
        required: Optional[Iterable['types.FilingKeys']] = None,
        optional: Optional[Iterable['types.FilingKeys']] = None,
        relations: Optional[Mapping['types.FilingRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FilingKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Filing_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Filing_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Filing_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Filing_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Filing_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Filing_relational_fields:
                        raise errors.UnknownRelationalFieldError('Filing', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Filing / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Filing',
            }
        )
        _created_partial_types.add(name)


class FilingCompany(bases.BaseFilingCompany):
    """Represents a FilingCompany record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    companyName: _str
    companyCode: _str
    companyGroupName: Optional[_str] = None
    companyGroupCode: _str
    state: Optional[_str] = None
    statement: Optional[_str] = None
    companyStatus: Optional[_str] = None
    filings: Optional[List['models.FilingToCompany']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FilingCompanyKeys']] = None,
        exclude: Optional[Iterable['types.FilingCompanyKeys']] = None,
        required: Optional[Iterable['types.FilingCompanyKeys']] = None,
        optional: Optional[Iterable['types.FilingCompanyKeys']] = None,
        relations: Optional[Mapping['types.FilingCompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FilingCompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FilingCompany_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FilingCompany_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FilingCompany_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FilingCompany_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _FilingCompany_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _FilingCompany_relational_fields:
                        raise errors.UnknownRelationalFieldError('FilingCompany', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FilingCompany / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FilingCompany',
            }
        )
        _created_partial_types.add(name)


class FilingToCompany(bases.BaseFilingToCompany):
    """Represents a FilingToCompany record"""

    filingId: _str
    companyId: _str
    Filing: Optional['models.Filing'] = None
    FilingCompany: Optional['models.FilingCompany'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FilingToCompanyKeys']] = None,
        exclude: Optional[Iterable['types.FilingToCompanyKeys']] = None,
        required: Optional[Iterable['types.FilingToCompanyKeys']] = None,
        optional: Optional[Iterable['types.FilingToCompanyKeys']] = None,
        relations: Optional[Mapping['types.FilingToCompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FilingToCompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FilingToCompany_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FilingToCompany_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FilingToCompany_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FilingToCompany_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _FilingToCompany_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _FilingToCompany_relational_fields:
                        raise errors.UnknownRelationalFieldError('FilingToCompany', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FilingToCompany / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FilingToCompany',
            }
        )
        _created_partial_types.add(name)


class Document(bases.BaseDocument):
    """Represents a Document record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    documentType: Optional[_str] = None
    documentName: Optional[_str] = None
    fileName: Optional[_str] = None
    formNumber: Optional[_str] = None
    path: Optional[_str] = None
    fileType: Optional[_str] = None
    totalPages: Optional[_int] = None
    tableOfContents: Optional[_str] = None
    header: Optional[_str] = None
    footer: Optional[_str] = None
    version: Optional[_str] = None
    dateSubmitted: Optional[datetime.datetime] = None
    Filing: Optional['models.Filing'] = None
    pages: Optional[List['models.Page']] = None
    chunks: Optional[List['models.Chunk']] = None
    blocks: Optional[List['models.Block']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DocumentKeys']] = None,
        exclude: Optional[Iterable['types.DocumentKeys']] = None,
        required: Optional[Iterable['types.DocumentKeys']] = None,
        optional: Optional[Iterable['types.DocumentKeys']] = None,
        relations: Optional[Mapping['types.DocumentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DocumentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Document_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Document_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Document_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Document_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Document_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Document_relational_fields:
                        raise errors.UnknownRelationalFieldError('Document', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Document / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Document',
            }
        )
        _created_partial_types.add(name)


class Page(bases.BasePage):
    """Represents a Page record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    pageNumber: _int
    rawContent: _str
    aoi: Optional['fields.Json'] = None
    tokenCount: _int
    documentId: _str
    Document: Optional['models.Document'] = None
    chunks: Optional[List['models.Chunk']] = None
    blocks: Optional[List['models.Block']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PageKeys']] = None,
        exclude: Optional[Iterable['types.PageKeys']] = None,
        required: Optional[Iterable['types.PageKeys']] = None,
        optional: Optional[Iterable['types.PageKeys']] = None,
        relations: Optional[Mapping['types.PageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Page_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Page_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Page_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Page_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Page_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Page_relational_fields:
                        raise errors.UnknownRelationalFieldError('Page', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Page / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Page',
            }
        )
        _created_partial_types.add(name)


class Chunk(bases.BaseChunk):
    """Represents a Chunk record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    chunkNumber: _int
    text: _str
    tokenCount: _int
    bbox: Optional['fields.Json'] = None
    version: _str
    documentId: _str
    Document: Optional['models.Document'] = None
    pages: Optional[List['models.Page']] = None
    blocks: Optional[List['models.Block']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ChunkKeys']] = None,
        exclude: Optional[Iterable['types.ChunkKeys']] = None,
        required: Optional[Iterable['types.ChunkKeys']] = None,
        optional: Optional[Iterable['types.ChunkKeys']] = None,
        relations: Optional[Mapping['types.ChunkRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ChunkKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Chunk_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Chunk_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Chunk_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Chunk_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Chunk_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Chunk_relational_fields:
                        raise errors.UnknownRelationalFieldError('Chunk', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Chunk / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Chunk',
            }
        )
        _created_partial_types.add(name)


class Block(bases.BaseBlock):
    """Represents a Block record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    serffTrackingNumber: _str
    blockNumber: _int
    pageNumber: _int
    text: _str
    bbox: List[_float]
    chunkId: _str
    documentId: _str
    pageId: _str
    Chunk: Optional['models.Chunk'] = None
    Document: Optional['models.Document'] = None
    Page: Optional['models.Page'] = None


    @field_validator('bbox', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.BlockKeys']] = None,
        exclude: Optional[Iterable['types.BlockKeys']] = None,
        required: Optional[Iterable['types.BlockKeys']] = None,
        optional: Optional[Iterable['types.BlockKeys']] = None,
        relations: Optional[Mapping['types.BlockRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.BlockKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Block_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Block_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Block_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Block_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Block_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Block_relational_fields:
                        raise errors.UnknownRelationalFieldError('Block', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Block / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Block',
            }
        )
        _created_partial_types.add(name)


class Tenant(bases.BaseTenant):
    """Represents a Tenant record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    slug: _str
    logoUrl: Optional[_str] = None
    databaseUrl: Optional[_str] = None
    planId: _str
    users: Optional[List['models.User']] = None
    plan: Optional['models.Plan'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TenantKeys']] = None,
        exclude: Optional[Iterable['types.TenantKeys']] = None,
        required: Optional[Iterable['types.TenantKeys']] = None,
        optional: Optional[Iterable['types.TenantKeys']] = None,
        relations: Optional[Mapping['types.TenantRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TenantKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Tenant_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Tenant_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Tenant_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Tenant_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Tenant_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Tenant_relational_fields:
                        raise errors.UnknownRelationalFieldError('Tenant', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Tenant / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Tenant',
            }
        )
        _created_partial_types.add(name)


class Plan(bases.BasePlan):
    """Represents a Plan record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    name: _str
    description: Optional[_str] = None
    type: 'enums.PlanTypeEnum'
    price: _int
    features: Optional['fields.Json'] = None
    tenantId: _str
    tenants: Optional[List['models.Tenant']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PlanKeys']] = None,
        exclude: Optional[Iterable['types.PlanKeys']] = None,
        required: Optional[Iterable['types.PlanKeys']] = None,
        optional: Optional[Iterable['types.PlanKeys']] = None,
        relations: Optional[Mapping['types.PlanRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PlanKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Plan_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Plan_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Plan_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Plan_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Plan_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Plan_relational_fields:
                        raise errors.UnknownRelationalFieldError('Plan', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Plan / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Plan',
            }
        )
        _created_partial_types.add(name)


class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    email: _str
    name: _str
    tenantId: _str
    hashedPassword: _str
    isEmailVerified: _bool
    lastLoginAt: Optional[datetime.datetime] = None
    chats: Optional[List['models.Chat']] = None
    tenant: Optional['models.Tenant'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Message(bases.BaseMessage):
    """Represents a Message record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    role: _str
    content: _str
    rawJson: Optional[_str] = None
    messageType: Optional[_str] = None
    tokensUsed: Optional[_int] = None
    processingTime: Optional[_int] = None
    chatId: _str
    chats: Optional['models.Chat'] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MessageKeys']] = None,
        exclude: Optional[Iterable['types.MessageKeys']] = None,
        required: Optional[Iterable['types.MessageKeys']] = None,
        optional: Optional[Iterable['types.MessageKeys']] = None,
        relations: Optional[Mapping['types.MessageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Message_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Message_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Message_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Message_relational_fields:
                        raise errors.UnknownRelationalFieldError('Message', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Message / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Message',
            }
        )
        _created_partial_types.add(name)


class Chat(bases.BaseChat):
    """Represents a Chat record"""

    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    status: 'enums.StatusEnum'
    title: Optional[_str] = None
    userId: _str
    isActive: _bool
    user: Optional['models.User'] = None
    messages: Optional[List['models.Message']] = None



    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ChatKeys']] = None,
        exclude: Optional[Iterable['types.ChatKeys']] = None,
        required: Optional[Iterable['types.ChatKeys']] = None,
        optional: Optional[Iterable['types.ChatKeys']] = None,
        relations: Optional[Mapping['types.ChatRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ChatKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Chat_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Chat_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Chat_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Chat_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Chat_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Chat_relational_fields:
                        raise errors.UnknownRelationalFieldError('Chat', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Chat / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Chat',
            }
        )
        _created_partial_types.add(name)



_Filing_relational_fields: Set[str] = {
        'documents',
        'companies',
    }
_Filing_fields: Dict['types.FilingKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffTrackingNumber', {
            'name': 'serffTrackingNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stateTrackingNumber', {
            'name': 'stateTrackingNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyTrackingNumber', {
            'name': 'companyTrackingNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('product', {
            'name': 'product',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('typeOfInsurance', {
            'name': 'typeOfInsurance',
            'is_list': False,
            'optional': False,
            'type': 'enums.ProductEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('subTypeOfInsurance', {
            'name': 'subTypeOfInsurance',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filingType', {
            'name': 'filingType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('submissionDate', {
            'name': 'submissionDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('filingStatus', {
            'name': 'filingStatus',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffStatus', {
            'name': 'serffStatus',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dispositionDate', {
            'name': 'dispositionDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('dispositionStatus', {
            'name': 'dispositionStatus',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('stateStatusLastChanged', {
            'name': 'stateStatusLastChanged',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('state', {
            'name': 'state',
            'is_list': False,
            'optional': False,
            'type': 'enums.StateEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadataJson', {
            'name': 'metadataJson',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('filingDescription', {
            'name': 'filingDescription',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filingSummary', {
            'name': 'filingSummary',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documents', {
            'name': 'documents',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Document\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('companies', {
            'name': 'companies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.FilingToCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_FilingCompany_relational_fields: Set[str] = {
        'filings',
    }
_FilingCompany_fields: Dict['types.FilingCompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyName', {
            'name': 'companyName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyCode', {
            'name': 'companyCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyGroupName', {
            'name': 'companyGroupName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyGroupCode', {
            'name': 'companyGroupCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('state', {
            'name': 'state',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('statement', {
            'name': 'statement',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyStatus', {
            'name': 'companyStatus',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filings', {
            'name': 'filings',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.FilingToCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_FilingToCompany_relational_fields: Set[str] = {
        'Filing',
        'FilingCompany',
    }
_FilingToCompany_fields: Dict['types.FilingToCompanyKeys', PartialModelField] = OrderedDict(
    [
        ('filingId', {
            'name': 'filingId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Filing', {
            'name': 'Filing',
            'is_list': False,
            'optional': True,
            'type': 'models.Filing',
            'is_relational': True,
            'documentation': None,
        }),
        ('FilingCompany', {
            'name': 'FilingCompany',
            'is_list': False,
            'optional': True,
            'type': 'models.FilingCompany',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Document_relational_fields: Set[str] = {
        'Filing',
        'pages',
        'chunks',
        'blocks',
    }
_Document_fields: Dict['types.DocumentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffTrackingNumber', {
            'name': 'serffTrackingNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentType', {
            'name': 'documentType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentName', {
            'name': 'documentName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileName', {
            'name': 'fileName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('formNumber', {
            'name': 'formNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('path', {
            'name': 'path',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('fileType', {
            'name': 'fileType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalPages', {
            'name': 'totalPages',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tableOfContents', {
            'name': 'tableOfContents',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('header', {
            'name': 'header',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('footer', {
            'name': 'footer',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('version', {
            'name': 'version',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateSubmitted', {
            'name': 'dateSubmitted',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Filing', {
            'name': 'Filing',
            'is_list': False,
            'optional': True,
            'type': 'models.Filing',
            'is_relational': True,
            'documentation': None,
        }),
        ('pages', {
            'name': 'pages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Page\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('chunks', {
            'name': 'chunks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Chunk\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('blocks', {
            'name': 'blocks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Block\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Page_relational_fields: Set[str] = {
        'Document',
        'chunks',
        'blocks',
    }
_Page_fields: Dict['types.PageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffTrackingNumber', {
            'name': 'serffTrackingNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pageNumber', {
            'name': 'pageNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rawContent', {
            'name': 'rawContent',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('aoi', {
            'name': 'aoi',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenCount', {
            'name': 'tokenCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentId', {
            'name': 'documentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Document', {
            'name': 'Document',
            'is_list': False,
            'optional': True,
            'type': 'models.Document',
            'is_relational': True,
            'documentation': None,
        }),
        ('chunks', {
            'name': 'chunks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Chunk\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('blocks', {
            'name': 'blocks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Block\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Chunk_relational_fields: Set[str] = {
        'Document',
        'pages',
        'blocks',
    }
_Chunk_fields: Dict['types.ChunkKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffTrackingNumber', {
            'name': 'serffTrackingNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('chunkNumber', {
            'name': 'chunkNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenCount', {
            'name': 'tokenCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('bbox', {
            'name': 'bbox',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('version', {
            'name': 'version',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentId', {
            'name': 'documentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Document', {
            'name': 'Document',
            'is_list': False,
            'optional': True,
            'type': 'models.Document',
            'is_relational': True,
            'documentation': None,
        }),
        ('pages', {
            'name': 'pages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Page\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('blocks', {
            'name': 'blocks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Block\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Block_relational_fields: Set[str] = {
        'Chunk',
        'Document',
        'Page',
    }
_Block_fields: Dict['types.BlockKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('serffTrackingNumber', {
            'name': 'serffTrackingNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('blockNumber', {
            'name': 'blockNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('pageNumber', {
            'name': 'pageNumber',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('text', {
            'name': 'text',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('bbox', {
            'name': 'bbox',
            'is_list': True,
            'optional': False,
            'type': 'List[_float]',
            'is_relational': False,
            'documentation': None,
        }),
        ('chunkId', {
            'name': 'chunkId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('documentId', {
            'name': 'documentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('pageId', {
            'name': 'pageId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Chunk', {
            'name': 'Chunk',
            'is_list': False,
            'optional': True,
            'type': 'models.Chunk',
            'is_relational': True,
            'documentation': None,
        }),
        ('Document', {
            'name': 'Document',
            'is_list': False,
            'optional': True,
            'type': 'models.Document',
            'is_relational': True,
            'documentation': None,
        }),
        ('Page', {
            'name': 'Page',
            'is_list': False,
            'optional': True,
            'type': 'models.Page',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Tenant_relational_fields: Set[str] = {
        'users',
        'plan',
    }
_Tenant_fields: Dict['types.TenantKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('slug', {
            'name': 'slug',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('logoUrl', {
            'name': 'logoUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('databaseUrl', {
            'name': 'databaseUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('planId', {
            'name': 'planId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('users', {
            'name': 'users',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('plan', {
            'name': 'plan',
            'is_list': False,
            'optional': True,
            'type': 'models.Plan',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Plan_relational_fields: Set[str] = {
        'tenants',
    }
_Plan_fields: Dict['types.PlanKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.PlanTypeEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('features', {
            'name': 'features',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('tenantId', {
            'name': 'tenantId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tenants', {
            'name': 'tenants',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Tenant\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_User_relational_fields: Set[str] = {
        'chats',
        'tenant',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tenantId', {
            'name': 'tenantId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hashedPassword', {
            'name': 'hashedPassword',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isEmailVerified', {
            'name': 'isEmailVerified',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastLoginAt', {
            'name': 'lastLoginAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('chats', {
            'name': 'chats',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Chat\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tenant', {
            'name': 'tenant',
            'is_list': False,
            'optional': True,
            'type': 'models.Tenant',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Message_relational_fields: Set[str] = {
        'chats',
    }
_Message_fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rawJson', {
            'name': 'rawJson',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('messageType', {
            'name': 'messageType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokensUsed', {
            'name': 'tokensUsed',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('processingTime', {
            'name': 'processingTime',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('chatId', {
            'name': 'chatId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('chats', {
            'name': 'chats',
            'is_list': False,
            'optional': True,
            'type': 'models.Chat',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Chat_relational_fields: Set[str] = {
        'user',
        'messages',
    }
_Chat_fields: Dict['types.ChatKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.StatusEnum',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(Filing)
model_rebuild(FilingCompany)
model_rebuild(FilingToCompany)
model_rebuild(Document)
model_rebuild(Page)
model_rebuild(Chunk)
model_rebuild(Block)
model_rebuild(Tenant)
model_rebuild(Plan)
model_rebuild(User)
model_rebuild(Message)
model_rebuild(Chat)
