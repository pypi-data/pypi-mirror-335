Metadata-Version: 2.3
Name: quackquack
Version: 1.3.0
Summary: Quack Quack: A simple application initializator
License: MIT
Author: Dominik Dlugajczyk
Author-email: msocek@gmail.com
Requires-Python: >=3.8,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Python :: 3.13
Provides-Extra: alembic
Provides-Extra: celery
Provides-Extra: developer
Provides-Extra: redis
Provides-Extra: sqlalchemy
Requires-Dist: alembic (>=1.0.9,<2.0.0) ; extra == "alembic" or extra == "developer"
Requires-Dist: celery (>=5.2.2) ; extra == "celery" or extra == "developer"
Requires-Dist: python-dateutil (>=2.8.2,<3.0.0)
Requires-Dist: redis (>=3.2.1,<5.0.0) ; extra == "redis" or extra == "developer"
Requires-Dist: sqlalchemy (>=1.3.3,<2.0.0) ; extra == "sqlalchemy" or extra == "developer"
Project-URL: Homepage, https://github.com/socek/quackquack
Description-Content-Type: text/x-rst

About
=====

`Documentation <https://qqpy.org/>`_


Overview
--------

This project aims to resolve problem of configuring an application, which needs to
have initialization step (for example: for gathering settings or establishing
connections) and use Python style code (context managers and decorators) with
dependency injection to get those data.

For example, normally you would need to use two separate mechanism for connection
to the database (one for web, and one for celery). Mostly it uses the web framework
configuration, to use in the celery code. It is fine, until a third sub-application
arrives. Or you have many microservices, where web frameworks are different
depending on the microservice purpose.

Second goal was to make synchronized code without any globals or magic. That is
why using Quack Quack you know when the application is initialized (started),
or where to look for code you are using.

In order to use QQ, you don't need to use hacks in some starting files, like
importing something from django, starting the application, and the import the
rest.

Quick Using Example
-------------------

To use Quack Quack you need to create the application class (inherited from
``qq.Application``\ ) in which you need to add plugins. After configuring, you
need to "start" (initialize)
the application. After that you can use the application as context manager.
Also, you can make simple decorator, so you can use injectors (dependency
injection) in function's arguments.

.. code-block:: python

    from qq import Application
    from qq import Context
    from qq import SimpleInjector
    from qq.plugins import SettingsPlugin
    from qq.plugins.types import Settings
    from qq.injectors import SetApplication
    from qq.injectors import SetInjector


    class MyApplication(Application):
        def create_plugins(self):
            self.plugins["settings"] = SettingsPlugin("settings")


    application = MyApplication()
    application.start("application")

    with Context(application) as ctx:
        print(ctx["settings"])

    app = SetApplication(application)


    @app
    @SetInjector("settings", SimpleInjector("settings"))
    def samplefun(settings: Settings):
        print(settings)


    samplefun()
    samplefun({"info": "fake settings"})  # dependency injection !!


``context["settings"]`` in above example, is a variable made by the SettingsPlugin.
If you would like to know more, please go to the `Tutorial <docs/tutorial.md>`_

Installation
------------

.. code-block:: bash

   pip install quackquack

