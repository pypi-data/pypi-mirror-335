# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictBool
from cohesity_sdk.cluster.models.associate_entity_metadata_request import AssociateEntityMetadataRequest
from cohesity_sdk.cluster.models.associate_entity_metadata_result import AssociateEntityMetadataResult
from cohesity_sdk.cluster.models.cancel_object_runs_request import CancelObjectRunsRequest
from cohesity_sdk.cluster.models.cancel_object_runs_results import CancelObjectRunsResults
from cohesity_sdk.cluster.models.common_object_snapshot_volume_params import CommonObjectSnapshotVolumeParams
from cohesity_sdk.cluster.models.construct_meta_info_request import ConstructMetaInfoRequest
from cohesity_sdk.cluster.models.construct_meta_info_result import ConstructMetaInfoResult
from cohesity_sdk.cluster.models.file_folder_info import FileFolderInfo
from cohesity_sdk.cluster.models.filter_objects_request import FilterObjectsRequest
from cohesity_sdk.cluster.models.filtered_objects_response_body import FilteredObjectsResponseBody
from cohesity_sdk.cluster.models.get_entity_metadata_result import GetEntityMetadataResult
from cohesity_sdk.cluster.models.get_indexed_object_snapshots_response_body import GetIndexedObjectSnapshotsResponseBody
from cohesity_sdk.cluster.models.get_object_runs_response_body import GetObjectRunsResponseBody
from cohesity_sdk.cluster.models.get_object_snapshots_response_body import GetObjectSnapshotsResponseBody
from cohesity_sdk.cluster.models.get_pit_ranges_protected_object_response_body import GetPITRangesProtectedObjectResponseBody
from cohesity_sdk.cluster.models.get_protected_objects_response import GetProtectedObjectsResponse
from cohesity_sdk.cluster.models.object_action_request import ObjectActionRequest
from cohesity_sdk.cluster.models.object_browse_request import ObjectBrowseRequest
from cohesity_sdk.cluster.models.object_protection_run_summary import ObjectProtectionRunSummary
from cohesity_sdk.cluster.models.object_snapshot import ObjectSnapshot
from cohesity_sdk.cluster.models.object_stats import ObjectStats
from cohesity_sdk.cluster.models.object_with_children import ObjectWithChildren
from cohesity_sdk.cluster.models.objects_action_request import ObjectsActionRequest
from cohesity_sdk.cluster.models.objects_last_run import ObjectsLastRun
from cohesity_sdk.cluster.models.protected_object_info import ProtectedObjectInfo
from cohesity_sdk.cluster.models.snapshot_diff_params import SnapshotDiffParams
from cohesity_sdk.cluster.models.snapshot_diff_result import SnapshotDiffResult
from cohesity_sdk.cluster.models.source_hierarchy_object_summaries import SourceHierarchyObjectSummaries
from cohesity_sdk.cluster.models.update_object_snapshot_request import UpdateObjectSnapshotRequest

from cohesity_sdk.cluster.api_client import ApiClient, RequestSerialized
from cohesity_sdk.cluster.api_response import ApiResponse
from cohesity_sdk.cluster.rest import RESTResponseType


class ObjectApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def associate_entity_metadata(
        self,
        body: Annotated[AssociateEntityMetadataRequest, Field(description="Specifies the parameters to associate metadata with entities in the entity hierarchy.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssociateEntityMetadataResult:
        """Associate Metadata with Entity

        Associates metadata with entities in the entity hierarchy. This metadata can be of various types (eg. Credentials). Returns a list of entity id and corresponding errors encountered (if any) while associating metadata with that entity. Note that a partial success response is possible where we succeed in associating metadata with some of the entities but fail for others. The API also expects the entities being updated belong to same source.

        :param body: Specifies the parameters to associate metadata with entities in the entity hierarchy. (required)
        :type body: AssociateEntityMetadataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_entity_metadata_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "AssociateEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def associate_entity_metadata_with_http_info(
        self,
        body: Annotated[AssociateEntityMetadataRequest, Field(description="Specifies the parameters to associate metadata with entities in the entity hierarchy.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssociateEntityMetadataResult]:
        """Associate Metadata with Entity

        Associates metadata with entities in the entity hierarchy. This metadata can be of various types (eg. Credentials). Returns a list of entity id and corresponding errors encountered (if any) while associating metadata with that entity. Note that a partial success response is possible where we succeed in associating metadata with some of the entities but fail for others. The API also expects the entities being updated belong to same source.

        :param body: Specifies the parameters to associate metadata with entities in the entity hierarchy. (required)
        :type body: AssociateEntityMetadataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_entity_metadata_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "AssociateEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def associate_entity_metadata_without_preload_content(
        self,
        body: Annotated[AssociateEntityMetadataRequest, Field(description="Specifies the parameters to associate metadata with entities in the entity hierarchy.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Associate Metadata with Entity

        Associates metadata with entities in the entity hierarchy. This metadata can be of various types (eg. Credentials). Returns a list of entity id and corresponding errors encountered (if any) while associating metadata with that entity. Note that a partial success response is possible where we succeed in associating metadata with some of the entities but fail for others. The API also expects the entities being updated belong to same source.

        :param body: Specifies the parameters to associate metadata with entities in the entity hierarchy. (required)
        :type body: AssociateEntityMetadataRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._associate_entity_metadata_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "AssociateEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _associate_entity_metadata_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-protect/objects/metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def browse_object_contents(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectBrowseRequest, Field(description="Specifies the parameters to fetch contents of an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FileFolderInfo:
        """Fetch the contents (files & folders) for the specified object.

        Fetch the contents (files & folders) of the specified path inside the specified object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to fetch contents of an object. (required)
        :type body: ObjectBrowseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browse_object_contents_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFolderInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def browse_object_contents_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectBrowseRequest, Field(description="Specifies the parameters to fetch contents of an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FileFolderInfo]:
        """Fetch the contents (files & folders) for the specified object.

        Fetch the contents (files & folders) of the specified path inside the specified object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to fetch contents of an object. (required)
        :type body: ObjectBrowseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browse_object_contents_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFolderInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def browse_object_contents_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectBrowseRequest, Field(description="Specifies the parameters to fetch contents of an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetch the contents (files & folders) for the specified object.

        Fetch the contents (files & folders) of the specified path inside the specified object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to fetch contents of an object. (required)
        :type body: ObjectBrowseRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._browse_object_contents_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FileFolderInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _browse_object_contents_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/objects/{id}/browse',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cancel_object_runs(
        self,
        body: Annotated[CancelObjectRunsRequest, Field(description="Specifies the parameters to cancel object runs.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CancelObjectRunsResults:
        """Cancel object runs.

        Cancel object runs for object based protection. This does not apply to Group based protection.

        :param body: Specifies the parameters to cancel object runs. (required)
        :type body: CancelObjectRunsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_object_runs_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "CancelObjectRunsResults",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cancel_object_runs_with_http_info(
        self,
        body: Annotated[CancelObjectRunsRequest, Field(description="Specifies the parameters to cancel object runs.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CancelObjectRunsResults]:
        """Cancel object runs.

        Cancel object runs for object based protection. This does not apply to Group based protection.

        :param body: Specifies the parameters to cancel object runs. (required)
        :type body: CancelObjectRunsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_object_runs_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "CancelObjectRunsResults",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cancel_object_runs_without_preload_content(
        self,
        body: Annotated[CancelObjectRunsRequest, Field(description="Specifies the parameters to cancel object runs.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cancel object runs.

        Cancel object runs for object based protection. This does not apply to Group based protection.

        :param body: Specifies the parameters to cancel object runs. (required)
        :type body: CancelObjectRunsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cancel_object_runs_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "CancelObjectRunsResults",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cancel_object_runs_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/objects/runs/cancel',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def construct_meta_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        body: Annotated[ConstructMetaInfoRequest, Field(description="Specifies the parameters to construct meta info for desired workflow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConstructMetaInfoResult:
        """Construct meta info for any workflow from object snapshot and some other information.

        Construct meta info from object snapshot and some additional params.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters to construct meta info for desired workflow. (required)
        :type body: ConstructMetaInfoRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._construct_meta_info_serialize(
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConstructMetaInfoResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def construct_meta_info_with_http_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        body: Annotated[ConstructMetaInfoRequest, Field(description="Specifies the parameters to construct meta info for desired workflow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConstructMetaInfoResult]:
        """Construct meta info for any workflow from object snapshot and some other information.

        Construct meta info from object snapshot and some additional params.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters to construct meta info for desired workflow. (required)
        :type body: ConstructMetaInfoRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._construct_meta_info_serialize(
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConstructMetaInfoResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def construct_meta_info_without_preload_content(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        body: Annotated[ConstructMetaInfoRequest, Field(description="Specifies the parameters to construct meta info for desired workflow.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Construct meta info for any workflow from object snapshot and some other information.

        Construct meta info from object snapshot and some additional params.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters to construct meta info for desired workflow. (required)
        :type body: ConstructMetaInfoRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._construct_meta_info_serialize(
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConstructMetaInfoResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _construct_meta_info_serialize(
        self,
        snapshot_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if snapshot_id is not None:
            _path_params['snapshotId'] = snapshot_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/snapshots/{snapshotId}/meta-info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def filter_objects(
        self,
        body: Annotated[FilterObjectsRequest, Field(description="Specifies the parameters to filter objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilteredObjectsResponseBody:
        """List all the filtered objects.

        List all the filtered objects using given regular expressions and wildcard supported search strings. We are currenly supporting this for only SQL adapter.

        :param body: Specifies the parameters to filter objects. (required)
        :type body: FilterObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filter_objects_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredObjectsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def filter_objects_with_http_info(
        self,
        body: Annotated[FilterObjectsRequest, Field(description="Specifies the parameters to filter objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilteredObjectsResponseBody]:
        """List all the filtered objects.

        List all the filtered objects using given regular expressions and wildcard supported search strings. We are currenly supporting this for only SQL adapter.

        :param body: Specifies the parameters to filter objects. (required)
        :type body: FilterObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filter_objects_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredObjectsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def filter_objects_without_preload_content(
        self,
        body: Annotated[FilterObjectsRequest, Field(description="Specifies the parameters to filter objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List all the filtered objects.

        List all the filtered objects using given regular expressions and wildcard supported search strings. We are currenly supporting this for only SQL adapter.

        :param body: Specifies the parameters to filter objects. (required)
        :type body: FilterObjectsRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filter_objects_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilteredObjectsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _filter_objects_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/filter/objects',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_all_indexed_object_snapshots(
        self,
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        protection_group_id: Annotated[Optional[StrictStr], Field(description="Specifies the protection group id.")] = None,
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetIndexedObjectSnapshotsResponseBody:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param protection_group_id: Specifies the protection group id.
        :type protection_group_id: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_indexed_object_snapshots_serialize(
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            protection_group_id=protection_group_id,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_all_indexed_object_snapshots_with_http_info(
        self,
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        protection_group_id: Annotated[Optional[StrictStr], Field(description="Specifies the protection group id.")] = None,
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetIndexedObjectSnapshotsResponseBody]:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param protection_group_id: Specifies the protection group id.
        :type protection_group_id: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_indexed_object_snapshots_serialize(
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            protection_group_id=protection_group_id,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_all_indexed_object_snapshots_without_preload_content(
        self,
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        protection_group_id: Annotated[Optional[StrictStr], Field(description="Specifies the protection group id.")] = None,
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param protection_group_id: Specifies the protection group id.
        :type protection_group_id: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshot files are guaranteed to exist, while in a non-indexed snapshot files may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_all_indexed_object_snapshots_serialize(
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            protection_group_id=protection_group_id,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_all_indexed_object_snapshots_serialize(
        self,
        object_id,
        indexed_object_name,
        protection_group_id,
        include_indexed_snapshots_only,
        from_time_usecs,
        to_time_usecs,
        run_types,
        use_cached_data,
        object_action_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'runTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        if indexed_object_name is not None:
            
            _query_params.append(('indexedObjectName', indexed_object_name))
            
        if protection_group_id is not None:
            
            _query_params.append(('protectionGroupId', protection_group_id))
            
        if include_indexed_snapshots_only is not None:
            
            _query_params.append(('includeIndexedSnapshotsOnly', include_indexed_snapshots_only))
            
        if from_time_usecs is not None:
            
            _query_params.append(('fromTimeUsecs', from_time_usecs))
            
        if to_time_usecs is not None:
            
            _query_params.append(('toTimeUsecs', to_time_usecs))
            
        if run_types is not None:
            
            _query_params.append(('runTypes', run_types))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        if object_action_key is not None:
            
            _query_params.append(('objectActionKey', object_action_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{objectId}/indexed-objects/snapshots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_entity_metadata(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        entity_ids: Annotated[Optional[List[StrictInt]], Field(description="EntityIds contains ids of the entities for which objects are to be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetEntityMetadataResult:
        """Get Metadata of Entities

        Gets entity metadata for entities. This can be used as a input for the PUT API. 

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param entity_ids: EntityIds contains ids of the entities for which objects are to be returned.
        :type entity_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_metadata_serialize(
            source_id=source_id,
            entity_ids=entity_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_entity_metadata_with_http_info(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        entity_ids: Annotated[Optional[List[StrictInt]], Field(description="EntityIds contains ids of the entities for which objects are to be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetEntityMetadataResult]:
        """Get Metadata of Entities

        Gets entity metadata for entities. This can be used as a input for the PUT API. 

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param entity_ids: EntityIds contains ids of the entities for which objects are to be returned.
        :type entity_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_metadata_serialize(
            source_id=source_id,
            entity_ids=entity_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_entity_metadata_without_preload_content(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        entity_ids: Annotated[Optional[List[StrictInt]], Field(description="EntityIds contains ids of the entities for which objects are to be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Metadata of Entities

        Gets entity metadata for entities. This can be used as a input for the PUT API. 

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param entity_ids: EntityIds contains ids of the entities for which objects are to be returned.
        :type entity_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_entity_metadata_serialize(
            source_id=source_id,
            entity_ids=entity_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetEntityMetadataResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_entity_metadata_serialize(
        self,
        source_id,
        entity_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'entityIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_id is not None:
            _path_params['sourceId'] = source_id
        # process the query parameters
        if entity_ids is not None:
            
            _query_params.append(('entityIds', entity_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{sourceId}/metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_indexed_object_snapshots(
        self,
        protection_group_id: Annotated[StrictStr, Field(description="Specifies the protection group id.")],
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetIndexedObjectSnapshotsResponseBody:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param protection_group_id: Specifies the protection group id. (required)
        :type protection_group_id: str
        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indexed_object_snapshots_serialize(
            protection_group_id=protection_group_id,
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_indexed_object_snapshots_with_http_info(
        self,
        protection_group_id: Annotated[StrictStr, Field(description="Specifies the protection group id.")],
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetIndexedObjectSnapshotsResponseBody]:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param protection_group_id: Specifies the protection group id. (required)
        :type protection_group_id: str
        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indexed_object_snapshots_serialize(
            protection_group_id=protection_group_id,
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_indexed_object_snapshots_without_preload_content(
        self,
        protection_group_id: Annotated[StrictStr, Field(description="Specifies the protection group id.")],
        object_id: Annotated[StrictInt, Field(description="Specifies the object id.")],
        indexed_object_name: Annotated[StrictStr, Field(description="Specifies the indexed object name.")],
        include_indexed_snapshots_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.")] = None,
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        object_action_key: Annotated[Optional[StrictStr], Field(description="Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get snapshots of indexed object.

        Get snapshots of indexed object.

        :param protection_group_id: Specifies the protection group id. (required)
        :type protection_group_id: str
        :param object_id: Specifies the object id. (required)
        :type object_id: int
        :param indexed_object_name: Specifies the indexed object name. (required)
        :type indexed_object_name: str
        :param include_indexed_snapshots_only: Specifies whether to only return snapshots which are indexed. In an indexed snapshots file are guaranteed to exist, while in a non-indexed snapshots file may not exist.
        :type include_indexed_snapshots_only: bool
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter indexed object's snapshots which are taken before this value.
        :type to_time_usecs: int
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param object_action_key: Filter by ObjectActionKey, which uniquely represents backup type for a given version. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey and ObjectId. When specified, only versions of given ObjectActionKey are returned for corresponding object id.
        :type object_action_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_indexed_object_snapshots_serialize(
            protection_group_id=protection_group_id,
            object_id=object_id,
            indexed_object_name=indexed_object_name,
            include_indexed_snapshots_only=include_indexed_snapshots_only,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_types=run_types,
            use_cached_data=use_cached_data,
            object_action_key=object_action_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetIndexedObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_indexed_object_snapshots_serialize(
        self,
        protection_group_id,
        object_id,
        indexed_object_name,
        include_indexed_snapshots_only,
        from_time_usecs,
        to_time_usecs,
        run_types,
        use_cached_data,
        object_action_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'runTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if protection_group_id is not None:
            _path_params['protectionGroupId'] = protection_group_id
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        if indexed_object_name is not None:
            
            _query_params.append(('indexedObjectName', indexed_object_name))
            
        if include_indexed_snapshots_only is not None:
            
            _query_params.append(('includeIndexedSnapshotsOnly', include_indexed_snapshots_only))
            
        if from_time_usecs is not None:
            
            _query_params.append(('fromTimeUsecs', from_time_usecs))
            
        if to_time_usecs is not None:
            
            _query_params.append(('toTimeUsecs', to_time_usecs))
            
        if run_types is not None:
            
            _query_params.append(('runTypes', run_types))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        if object_action_key is not None:
            
            _query_params.append(('objectActionKey', object_action_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{objectId}/protection-groups/{protectionGroupId}/indexed-objects/snapshots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_run_by_run_id(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[StrictStr, Field(description="Specifies the id of the run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectProtectionRunSummary:
        """Get a run for an object.

        Get a run for an object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies the id of the run. (required)
        :type run_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_run_by_run_id_serialize(
            id=id,
            run_id=run_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectProtectionRunSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_run_by_run_id_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[StrictStr, Field(description="Specifies the id of the run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectProtectionRunSummary]:
        """Get a run for an object.

        Get a run for an object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies the id of the run. (required)
        :type run_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_run_by_run_id_serialize(
            id=id,
            run_id=run_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectProtectionRunSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_run_by_run_id_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[StrictStr, Field(description="Specifies the id of the run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a run for an object.

        Get a run for an object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies the id of the run. (required)
        :type run_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_run_by_run_id_serialize(
            id=id,
            run_id=run_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectProtectionRunSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_run_by_run_id_serialize(
        self,
        id,
        run_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/runs/{runId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_runs(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[Optional[StrictStr], Field(description="Specifies a unique id of the run.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        local_backup_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the backup run.")] = None,
        replication_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the replication run.")] = None,
        archival_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the archival run.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the cloud spin run.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetObjectRunsResponseBody:
        """Get the list of runs for an object.

        Get the runs for a particular object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies a unique id of the run.
        :type run_id: str
        :param start_time_usecs: Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param local_backup_object_status: Specifies a list of status for the object in the backup run.
        :type local_backup_object_status: List[str]
        :param replication_object_status: Specifies a list of status for the object in the replication run.
        :type replication_object_status: List[str]
        :param archival_object_status: Specifies a list of status for the object in the archival run.
        :type archival_object_status: List[str]
        :param cloud_spin_run_status: Specifies a list of status for the object in the cloud spin run.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs
        :type pagination_cookie: str
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_runs_serialize(
            id=id,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            local_backup_object_status=local_backup_object_status,
            replication_object_status=replication_object_status,
            archival_object_status=archival_object_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            pagination_cookie=pagination_cookie,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectRunsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_runs_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[Optional[StrictStr], Field(description="Specifies a unique id of the run.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        local_backup_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the backup run.")] = None,
        replication_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the replication run.")] = None,
        archival_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the archival run.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the cloud spin run.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetObjectRunsResponseBody]:
        """Get the list of runs for an object.

        Get the runs for a particular object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies a unique id of the run.
        :type run_id: str
        :param start_time_usecs: Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param local_backup_object_status: Specifies a list of status for the object in the backup run.
        :type local_backup_object_status: List[str]
        :param replication_object_status: Specifies a list of status for the object in the replication run.
        :type replication_object_status: List[str]
        :param archival_object_status: Specifies a list of status for the object in the archival run.
        :type archival_object_status: List[str]
        :param cloud_spin_run_status: Specifies a list of status for the object in the cloud spin run.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs
        :type pagination_cookie: str
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_runs_serialize(
            id=id,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            local_backup_object_status=local_backup_object_status,
            replication_object_status=replication_object_status,
            archival_object_status=archival_object_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            pagination_cookie=pagination_cookie,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectRunsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_runs_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies a unique id of the object.")],
        run_id: Annotated[Optional[StrictStr], Field(description="Specifies a unique id of the run.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        local_backup_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the backup run.")] = None,
        replication_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the replication run.")] = None,
        archival_object_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the archival run.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status for the object in the cloud spin run.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of runs for an object.

        Get the runs for a particular object.

        :param id: Specifies a unique id of the object. (required)
        :type id: int
        :param run_id: Specifies a unique id of the run.
        :type run_id: str
        :param start_time_usecs: Filter by a start time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Filter by a end time when the run starts. Specify the start time as a Unix epoch Timestamp (in microseconds).
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param local_backup_object_status: Specifies a list of status for the object in the backup run.
        :type local_backup_object_status: List[str]
        :param replication_object_status: Specifies a list of status for the object in the replication run.
        :type replication_object_status: List[str]
        :param archival_object_status: Specifies a list of status for the object in the archival run.
        :type archival_object_status: List[str]
        :param cloud_spin_run_status: Specifies a list of status for the object in the cloud spin run.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched. Users can use this to get next runs
        :type pagination_cookie: str
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is at least one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_runs_serialize(
            id=id,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            local_backup_object_status=local_backup_object_status,
            replication_object_status=replication_object_status,
            archival_object_status=archival_object_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            pagination_cookie=pagination_cookie,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectRunsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_runs_serialize(
        self,
        id,
        run_id,
        start_time_usecs,
        end_time_usecs,
        tenant_ids,
        include_tenants,
        run_types,
        local_backup_object_status,
        replication_object_status,
        archival_object_status,
        cloud_spin_run_status,
        num_runs,
        pagination_cookie,
        exclude_non_restorable_runs,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tenantIds': 'csv',
            'runTypes': 'csv',
            'localBackupObjectStatus': 'csv',
            'replicationObjectStatus': 'csv',
            'archivalObjectStatus': 'csv',
            'cloudSpinRunStatus': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if run_id is not None:
            
            _query_params.append(('runId', run_id))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if run_types is not None:
            
            _query_params.append(('runTypes', run_types))
            
        if local_backup_object_status is not None:
            
            _query_params.append(('localBackupObjectStatus', local_backup_object_status))
            
        if replication_object_status is not None:
            
            _query_params.append(('replicationObjectStatus', replication_object_status))
            
        if archival_object_status is not None:
            
            _query_params.append(('archivalObjectStatus', archival_object_status))
            
        if cloud_spin_run_status is not None:
            
            _query_params.append(('cloudSpinRunStatus', cloud_spin_run_status))
            
        if num_runs is not None:
            
            _query_params.append(('numRuns', num_runs))
            
        if pagination_cookie is not None:
            
            _query_params.append(('paginationCookie', pagination_cookie))
            
        if exclude_non_restorable_runs is not None:
            
            _query_params.append(('excludeNonRestorableRuns', exclude_non_restorable_runs))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/runs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_snapshot_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectSnapshot:
        """Get details of object snapshot.

        Get details of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_info_serialize(
            snapshot_id=snapshot_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_snapshot_info_with_http_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectSnapshot]:
        """Get details of object snapshot.

        Get details of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_info_serialize(
            snapshot_id=snapshot_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_snapshot_info_without_preload_content(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get details of object snapshot.

        Get details of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_info_serialize(
            snapshot_id=snapshot_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_snapshot_info_serialize(
        self,
        snapshot_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if snapshot_id is not None:
            _path_params['snapshotId'] = snapshot_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/snapshots/{snapshotId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_snapshot_volume_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        include_supported_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return supported volumes.")] = None,
        point_in_time_usecs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CommonObjectSnapshotVolumeParams:
        """Get volume info of object snapshot.

        Get volume info of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param include_supported_only: Specifies whether to only return supported volumes.
        :type include_supported_only: bool
        :param point_in_time_usecs: Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.
        :type point_in_time_usecs: float
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_volume_info_serialize(
            snapshot_id=snapshot_id,
            include_supported_only=include_supported_only,
            point_in_time_usecs=point_in_time_usecs,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonObjectSnapshotVolumeParams",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_snapshot_volume_info_with_http_info(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        include_supported_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return supported volumes.")] = None,
        point_in_time_usecs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CommonObjectSnapshotVolumeParams]:
        """Get volume info of object snapshot.

        Get volume info of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param include_supported_only: Specifies whether to only return supported volumes.
        :type include_supported_only: bool
        :param point_in_time_usecs: Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.
        :type point_in_time_usecs: float
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_volume_info_serialize(
            snapshot_id=snapshot_id,
            include_supported_only=include_supported_only,
            point_in_time_usecs=point_in_time_usecs,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonObjectSnapshotVolumeParams",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_snapshot_volume_info_without_preload_content(
        self,
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the snapshot id.")],
        include_supported_only: Annotated[Optional[StrictBool], Field(description="Specifies whether to only return supported volumes.")] = None,
        point_in_time_usecs: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get volume info of object snapshot.

        Get volume info of object snapshot.

        :param snapshot_id: Specifies the snapshot id. (required)
        :type snapshot_id: str
        :param include_supported_only: Specifies whether to only return supported volumes.
        :type include_supported_only: bool
        :param point_in_time_usecs: Specifies the point-in-time timestamp (in usecs from epoch) between snapshots for which the volume info is to be returned.
        :type point_in_time_usecs: float
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshot_volume_info_serialize(
            snapshot_id=snapshot_id,
            include_supported_only=include_supported_only,
            point_in_time_usecs=point_in_time_usecs,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonObjectSnapshotVolumeParams",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_snapshot_volume_info_serialize(
        self,
        snapshot_id,
        include_supported_only,
        point_in_time_usecs,
        use_cached_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if snapshot_id is not None:
            _path_params['snapshotId'] = snapshot_id
        # process the query parameters
        if include_supported_only is not None:
            
            _query_params.append(('includeSupportedOnly', include_supported_only))
            
        if point_in_time_usecs is not None:
            
            _query_params.append(('pointInTimeUsecs', point_in_time_usecs))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/snapshots/{snapshotId}/volume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_snapshots(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.")] = None,
        run_start_from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.")] = None,
        run_start_to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.")] = None,
        snapshot_actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.")] = None,
        run_instance_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetObjectSnapshotsResponseBody:
        """List the snapshots for a given object.

        List the snapshots for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.
        :type to_time_usecs: int
        :param run_start_from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.
        :type run_start_from_time_usecs: int
        :param run_start_to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.
        :type run_start_to_time_usecs: int
        :param snapshot_actions: Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
        :type snapshot_actions: List[str]
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param protection_group_ids: If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.
        :type protection_group_ids: List[str]
        :param run_instance_ids: Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.
        :type run_instance_ids: List[int]
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param object_action_keys: Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.
        :type object_action_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshots_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_start_from_time_usecs=run_start_from_time_usecs,
            run_start_to_time_usecs=run_start_to_time_usecs,
            snapshot_actions=snapshot_actions,
            run_types=run_types,
            protection_group_ids=protection_group_ids,
            run_instance_ids=run_instance_ids,
            region_ids=region_ids,
            object_action_keys=object_action_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_snapshots_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.")] = None,
        run_start_from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.")] = None,
        run_start_to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.")] = None,
        snapshot_actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.")] = None,
        run_instance_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetObjectSnapshotsResponseBody]:
        """List the snapshots for a given object.

        List the snapshots for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.
        :type to_time_usecs: int
        :param run_start_from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.
        :type run_start_from_time_usecs: int
        :param run_start_to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.
        :type run_start_to_time_usecs: int
        :param snapshot_actions: Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
        :type snapshot_actions: List[str]
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param protection_group_ids: If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.
        :type protection_group_ids: List[str]
        :param run_instance_ids: Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.
        :type run_instance_ids: List[int]
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param object_action_keys: Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.
        :type object_action_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshots_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_start_from_time_usecs=run_start_from_time_usecs,
            run_start_to_time_usecs=run_start_to_time_usecs,
            snapshot_actions=snapshot_actions,
            run_types=run_types,
            protection_group_ids=protection_group_ids,
            run_instance_ids=run_instance_ids,
            region_ids=region_ids,
            object_action_keys=object_action_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_snapshots_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.")] = None,
        run_start_from_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.")] = None,
        run_start_to_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.")] = None,
        snapshot_actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.")] = None,
        run_instance_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List the snapshots for a given object.

        List the snapshots for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken after this value.
        :type from_time_usecs: int
        :param to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were taken before this value.
        :type to_time_usecs: int
        :param run_start_from_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run after this value.
        :type run_start_from_time_usecs: int
        :param run_start_to_time_usecs: Specifies the timestamp in Unix time epoch in microseconds to filter Object's snapshots which were run before this value.
        :type run_start_to_time_usecs: int
        :param snapshot_actions: Specifies a list of recovery actions. Only snapshots that applies to these actions will be returned.
        :type snapshot_actions: List[str]
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned. By default, CDP hydration snapshots are not included, unless explicitly queried using this field.
        :type run_types: List[str]
        :param protection_group_ids: If specified, this returns only the snapshots of the specified object ID, which belong to the provided protection group IDs.
        :type protection_group_ids: List[str]
        :param run_instance_ids: Filter by a list run instance ids. If specified, only snapshots created by these protection runs will be returned.
        :type run_instance_ids: List[int]
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param object_action_keys: Filter by ObjectActionKey, which uniquely represents protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey. When specified, only snapshots matching given action keys are returned for corresponding object.
        :type object_action_keys: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_snapshots_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            run_start_from_time_usecs=run_start_from_time_usecs,
            run_start_to_time_usecs=run_start_to_time_usecs,
            snapshot_actions=snapshot_actions,
            run_types=run_types,
            protection_group_ids=protection_group_ids,
            run_instance_ids=run_instance_ids,
            region_ids=region_ids,
            object_action_keys=object_action_keys,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetObjectSnapshotsResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_snapshots_serialize(
        self,
        id,
        from_time_usecs,
        to_time_usecs,
        run_start_from_time_usecs,
        run_start_to_time_usecs,
        snapshot_actions,
        run_types,
        protection_group_ids,
        run_instance_ids,
        region_ids,
        object_action_keys,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'snapshotActions': 'csv',
            'runTypes': 'csv',
            'protectionGroupIds': 'csv',
            'runInstanceIds': 'csv',
            'regionIds': 'csv',
            'objectActionKeys': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if from_time_usecs is not None:
            
            _query_params.append(('fromTimeUsecs', from_time_usecs))
            
        if to_time_usecs is not None:
            
            _query_params.append(('toTimeUsecs', to_time_usecs))
            
        if run_start_from_time_usecs is not None:
            
            _query_params.append(('runStartFromTimeUsecs', run_start_from_time_usecs))
            
        if run_start_to_time_usecs is not None:
            
            _query_params.append(('runStartToTimeUsecs', run_start_to_time_usecs))
            
        if snapshot_actions is not None:
            
            _query_params.append(('snapshotActions', snapshot_actions))
            
        if run_types is not None:
            
            _query_params.append(('runTypes', run_types))
            
        if protection_group_ids is not None:
            
            _query_params.append(('protectionGroupIds', protection_group_ids))
            
        if run_instance_ids is not None:
            
            _query_params.append(('runInstanceIds', run_instance_ids))
            
        if region_ids is not None:
            
            _query_params.append(('regionIds', region_ids))
            
        if object_action_keys is not None:
            
            _query_params.append(('objectActionKeys', object_action_keys))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/snapshots',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_stats(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectStats:
        """Get stats for a given object.

        Get stats for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_stats_serialize(
            id=id,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_stats_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectStats]:
        """Get stats for a given object.

        Get stats for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_stats_serialize(
            id=id,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_stats_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get stats for a given object.

        Get stats for a given object.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_stats_serialize(
            id=id,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectStats",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_stats_serialize(
        self,
        id,
        region_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'regionIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if region_ids is not None:
            
            _query_params.append(('regionIds', region_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_object_tree(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectWithChildren:
        """Get the objects tree hierarchy for for an Object.

        Get the objects tree hierarchy for for an Object. If the object does not have a hierarchy then a single object will be returned.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_tree_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWithChildren",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_object_tree_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectWithChildren]:
        """Get the objects tree hierarchy for for an Object.

        Get the objects tree hierarchy for for an Object. If the object does not have a hierarchy then a single object will be returned.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_tree_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWithChildren",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_object_tree_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the objects tree hierarchy for for an Object.

        Get the objects tree hierarchy for for an Object. If the object does not have a hierarchy then a single object will be returned.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_object_tree_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectWithChildren",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_object_tree_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/tree',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_objects_last_run(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Specifies a list of object ids, only last runs for these objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of objects to be fetched for the specified pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectsLastRun:
        """Get last protection run of objects.

        Get last protection run of objects.

        :param ids: Specifies a list of object ids, only last runs for these objects will be returned.
        :type ids: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched.
        :type pagination_cookie: str
        :param count: Specifies the number of objects to be fetched for the specified pagination cookie.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_objects_last_run_serialize(
            ids=ids,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            pagination_cookie=pagination_cookie,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectsLastRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_objects_last_run_with_http_info(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Specifies a list of object ids, only last runs for these objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of objects to be fetched for the specified pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectsLastRun]:
        """Get last protection run of objects.

        Get last protection run of objects.

        :param ids: Specifies a list of object ids, only last runs for these objects will be returned.
        :type ids: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched.
        :type pagination_cookie: str
        :param count: Specifies the number of objects to be fetched for the specified pagination cookie.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_objects_last_run_serialize(
            ids=ids,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            pagination_cookie=pagination_cookie,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectsLastRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_objects_last_run_without_preload_content(
        self,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Specifies a list of object ids, only last runs for these objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie with which subsequent parts of the response can be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of objects to be fetched for the specified pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get last protection run of objects.

        Get last protection run of objects.

        :param ids: Specifies a list of object ids, only last runs for these objects will be returned.
        :type ids: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param pagination_cookie: Specifies the pagination cookie with which subsequent parts of the response can be fetched.
        :type pagination_cookie: str
        :param count: Specifies the number of objects to be fetched for the specified pagination cookie.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_objects_last_run_serialize(
            ids=ids,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            pagination_cookie=pagination_cookie,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectsLastRun",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_objects_last_run_serialize(
        self,
        ids,
        tenant_ids,
        include_tenants,
        pagination_cookie,
        count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'tenantIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if pagination_cookie is not None:
            
            _query_params.append(('paginationCookie', pagination_cookie))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/last-run',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_pit_ranges_for_protected_object(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the ID of the protected object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, return only the points in time corresponding to these protection group IDs.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetPITRangesProtectedObjectResponseBody:
        """Get PIT ranges for an object

        Returns the ranges in various types like time, SCN etc. within which the specified protected object can be restored to any Point in time.

        :param id: Specifies the ID of the protected object. (required)
        :type id: int
        :param from_time_usecs: If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type from_time_usecs: int
        :param to_time_usecs: If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type to_time_usecs: int
        :param protection_group_ids: If specified, return only the points in time corresponding to these protection group IDs.
        :type protection_group_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pit_ranges_for_protected_object_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            protection_group_ids=protection_group_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPITRangesProtectedObjectResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_pit_ranges_for_protected_object_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the ID of the protected object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, return only the points in time corresponding to these protection group IDs.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetPITRangesProtectedObjectResponseBody]:
        """Get PIT ranges for an object

        Returns the ranges in various types like time, SCN etc. within which the specified protected object can be restored to any Point in time.

        :param id: Specifies the ID of the protected object. (required)
        :type id: int
        :param from_time_usecs: If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type from_time_usecs: int
        :param to_time_usecs: If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type to_time_usecs: int
        :param protection_group_ids: If specified, return only the points in time corresponding to these protection group IDs.
        :type protection_group_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pit_ranges_for_protected_object_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            protection_group_ids=protection_group_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPITRangesProtectedObjectResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_pit_ranges_for_protected_object_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the ID of the protected object.")],
        from_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        to_time_usecs: Annotated[Optional[StrictInt], Field(description="If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.")] = None,
        protection_group_ids: Annotated[Optional[List[StrictStr]], Field(description="If specified, return only the points in time corresponding to these protection group IDs.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get PIT ranges for an object

        Returns the ranges in various types like time, SCN etc. within which the specified protected object can be restored to any Point in time.

        :param id: Specifies the ID of the protected object. (required)
        :type id: int
        :param from_time_usecs: If specified, return the restore ranges that lie after this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type from_time_usecs: int
        :param to_time_usecs: If specified, return the restore ranges that lie before this timestamp. This parameter is specified as the timestamp in Unix time epoch in microseconds.
        :type to_time_usecs: int
        :param protection_group_ids: If specified, return only the points in time corresponding to these protection group IDs.
        :type protection_group_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_pit_ranges_for_protected_object_serialize(
            id=id,
            from_time_usecs=from_time_usecs,
            to_time_usecs=to_time_usecs,
            protection_group_ids=protection_group_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetPITRangesProtectedObjectResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_pit_ranges_for_protected_object_serialize(
        self,
        id,
        from_time_usecs,
        to_time_usecs,
        protection_group_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'protectionGroupIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if from_time_usecs is not None:
            
            _query_params.append(('fromTimeUsecs', from_time_usecs))
            
        if to_time_usecs is not None:
            
            _query_params.append(('toTimeUsecs', to_time_usecs))
            
        if protection_group_ids is not None:
            
            _query_params.append(('protectionGroupIds', protection_group_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}/pit-ranges',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protected_object_of_any_type_by_id(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        object_action_key: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectedObjectInfo:
        """Get an Object.

        Get Object configurations for given object id.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param object_action_key: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.
        :type object_action_key: List[str]
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_object_of_any_type_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            object_action_key=object_action_key,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectedObjectInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protected_object_of_any_type_by_id_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        object_action_key: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectedObjectInfo]:
        """Get an Object.

        Get Object configurations for given object id.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param object_action_key: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.
        :type object_action_key: List[str]
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_object_of_any_type_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            object_action_key=object_action_key,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectedObjectInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protected_object_of_any_type_by_id_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        object_action_key: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get an Object.

        Get Object configurations for given object id.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param object_action_key: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id and this vec's size needs to be same as 'id'.
        :type object_action_key: List[str]
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_object_of_any_type_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            object_action_key=object_action_key,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectedObjectInfo",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protected_object_of_any_type_by_id_serialize(
        self,
        id,
        request_initiator_type,
        object_action_key,
        only_protected_objects,
        storage_domain_id,
        environments,
        tenant_ids,
        include_tenants,
        include_last_run_info,
        only_auto_protected_objects,
        only_leaf_objects,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'objectActionKey': 'csv',
            'environments': 'csv',
            'tenantIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if object_action_key is not None:
            
            _query_params.append(('objectActionKey', object_action_key))
            
        if only_protected_objects is not None:
            
            _query_params.append(('onlyProtectedObjects', only_protected_objects))
            
        if storage_domain_id is not None:
            
            _query_params.append(('storageDomainId', storage_domain_id))
            
        if environments is not None:
            
            _query_params.append(('environments', environments))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_last_run_info is not None:
            
            _query_params.append(('includeLastRunInfo', include_last_run_info))
            
        if only_auto_protected_objects is not None:
            
            _query_params.append(('onlyAutoProtectedObjects', only_auto_protected_objects))
            
        if only_leaf_objects is not None:
            
            _query_params.append(('onlyLeafObjects', only_leaf_objects))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protected_objects_of_any_type(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list of Object ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protected Objects.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        max_count: Annotated[Optional[StrictInt], Field(description="Specifies the max number of objects to return.")] = None,
        cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetProtectedObjectsResponse:
        """Get Objects.

        Get Objects Configurations.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Object ids.
        :type ids: List[int]
        :param object_action_keys: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.
        :type object_action_keys: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protected Objects.
        :type policy_ids: List[str]
        :param parent_id: Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.
        :type parent_id: int
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param max_count: Specifies the max number of objects to return.
        :type max_count: int
        :param cookie: Specifies the pagination cookie.
        :type cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_objects_of_any_type_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            object_action_keys=object_action_keys,
            policy_ids=policy_ids,
            parent_id=parent_id,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            region_ids=region_ids,
            max_count=max_count,
            cookie=cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectedObjectsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protected_objects_of_any_type_with_http_info(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list of Object ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protected Objects.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        max_count: Annotated[Optional[StrictInt], Field(description="Specifies the max number of objects to return.")] = None,
        cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetProtectedObjectsResponse]:
        """Get Objects.

        Get Objects Configurations.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Object ids.
        :type ids: List[int]
        :param object_action_keys: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.
        :type object_action_keys: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protected Objects.
        :type policy_ids: List[str]
        :param parent_id: Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.
        :type parent_id: int
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param max_count: Specifies the max number of objects to return.
        :type max_count: int
        :param cookie: Specifies the pagination cookie.
        :type cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_objects_of_any_type_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            object_action_keys=object_action_keys,
            policy_ids=policy_ids,
            parent_id=parent_id,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            region_ids=region_ids,
            max_count=max_count,
            cookie=cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectedObjectsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protected_objects_of_any_type_without_preload_content(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by a list of Object ids.")] = None,
        object_action_keys: Annotated[Optional[List[StrictStr]], Field(description="Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protected Objects.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.")] = None,
        only_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only objects which have been protected.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include information about the last protection run on this object.")] = None,
        only_auto_protected_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the auto protected objects.")] = None,
        only_leaf_objects: Annotated[Optional[StrictBool], Field(description="If true, the response will include only the leaf level objects.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of region ids.")] = None,
        max_count: Annotated[Optional[StrictInt], Field(description="Specifies the max number of objects to return.")] = None,
        cookie: Annotated[Optional[StrictStr], Field(description="Specifies the pagination cookie.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Objects.

        Get Objects Configurations.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Object ids.
        :type ids: List[int]
        :param object_action_keys: Filter by ObjectActionKey, uniquely represent protection of an object. An object can be protected in multiple ways but atmost once for a given combination of ObjectActionKey, when specified Only objects of given action_key are returned for corresponding object id. The vec's size needs to be of either length one or same as the length of 'ids'. If the length of objectActionKey is one, it will be repeated as many number of times equal to the length of objectIds, as mandated by backend validation. If the length of objectActionKey and object ids are same then it will be passed as it is.
        :type object_action_keys: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protected Objects.
        :type policy_ids: List[str]
        :param parent_id: Filter by Parent Id. Parent id is a unique object Id which may contain protected objects underneath in the source tree.
        :type parent_id: int
        :param only_protected_objects: If true, the response will include only objects which have been protected.
        :type only_protected_objects: bool
        :param storage_domain_id: Filter by Storage Domain id. Only Objects protected to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protected objects protecting the specified environment types are returned.
        :type environments: List[str]
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which were protected by all tenants which the current user has permission to see. If false, then only objects protected by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include information about the last protection run on this object.
        :type include_last_run_info: bool
        :param only_auto_protected_objects: If true, the response will include only the auto protected objects.
        :type only_auto_protected_objects: bool
        :param only_leaf_objects: If true, the response will include only the leaf level objects.
        :type only_leaf_objects: bool
        :param region_ids: Filter by a list of region ids.
        :type region_ids: List[str]
        :param max_count: Specifies the max number of objects to return.
        :type max_count: int
        :param cookie: Specifies the pagination cookie.
        :type cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protected_objects_of_any_type_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            object_action_keys=object_action_keys,
            policy_ids=policy_ids,
            parent_id=parent_id,
            only_protected_objects=only_protected_objects,
            storage_domain_id=storage_domain_id,
            environments=environments,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            only_auto_protected_objects=only_auto_protected_objects,
            only_leaf_objects=only_leaf_objects,
            region_ids=region_ids,
            max_count=max_count,
            cookie=cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectedObjectsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protected_objects_of_any_type_serialize(
        self,
        request_initiator_type,
        ids,
        object_action_keys,
        policy_ids,
        parent_id,
        only_protected_objects,
        storage_domain_id,
        environments,
        tenant_ids,
        include_tenants,
        include_last_run_info,
        only_auto_protected_objects,
        only_leaf_objects,
        region_ids,
        max_count,
        cookie,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'objectActionKeys': 'csv',
            'policyIds': 'csv',
            'environments': 'csv',
            'tenantIds': 'csv',
            'regionIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if object_action_keys is not None:
            
            _query_params.append(('objectActionKeys', object_action_keys))
            
        if policy_ids is not None:
            
            _query_params.append(('policyIds', policy_ids))
            
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if only_protected_objects is not None:
            
            _query_params.append(('onlyProtectedObjects', only_protected_objects))
            
        if storage_domain_id is not None:
            
            _query_params.append(('storageDomainId', storage_domain_id))
            
        if environments is not None:
            
            _query_params.append(('environments', environments))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_last_run_info is not None:
            
            _query_params.append(('includeLastRunInfo', include_last_run_info))
            
        if only_auto_protected_objects is not None:
            
            _query_params.append(('onlyAutoProtectedObjects', only_auto_protected_objects))
            
        if only_leaf_objects is not None:
            
            _query_params.append(('onlyLeafObjects', only_leaf_objects))
            
        if region_ids is not None:
            
            _query_params.append(('regionIds', region_ids))
            
        if max_count is not None:
            
            _query_params.append(('maxCount', max_count))
            
        if cookie is not None:
            
            _query_params.append(('cookie', cookie))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/objects',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_snapshot_diff(
        self,
        id: StrictInt,
        body: SnapshotDiffParams,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SnapshotDiffResult:
        """Get diff between two snapshots of a given object.

        Get diff (files added/deleted) between two snapshots of a given object.

        :param id: (required)
        :type id: int
        :param body: (required)
        :type body: SnapshotDiffParams
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_snapshot_diff_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SnapshotDiffResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_snapshot_diff_with_http_info(
        self,
        id: StrictInt,
        body: SnapshotDiffParams,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SnapshotDiffResult]:
        """Get diff between two snapshots of a given object.

        Get diff (files added/deleted) between two snapshots of a given object.

        :param id: (required)
        :type id: int
        :param body: (required)
        :type body: SnapshotDiffParams
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_snapshot_diff_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SnapshotDiffResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_snapshot_diff_without_preload_content(
        self,
        id: StrictInt,
        body: SnapshotDiffParams,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get diff between two snapshots of a given object.

        Get diff (files added/deleted) between two snapshots of a given object.

        :param id: (required)
        :type id: int
        :param body: (required)
        :type body: SnapshotDiffParams
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_snapshot_diff_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SnapshotDiffResult",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_snapshot_diff_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/objects/{id}/snapshot-diff',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_source_hierarchy_objects(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        parent_id: Annotated[Optional[StrictInt], Field(description="Specifies the parent ID under which objects should be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        vmware_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the VMware object types to filter objects.")] = None,
        netapp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Netapp object types to filter objects.")] = None,
        o365_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Office 365 object types to filter objects.")] = None,
        cassandra_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Cassandra object types to filter objects.")] = None,
        mongodb_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Mongo DB object types to filter objects.")] = None,
        couchbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Couchbase object types to filter objects.")] = None,
        hdfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HDFS object types to filter objects.")] = None,
        hbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hbase object types to filter objects.")] = None,
        hive_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hive object types to filter objects.")] = None,
        hyperv_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HyperV object types to filter objects.")] = None,
        azure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Azure object types to filter objects.")] = None,
        kvm_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the KVM object types to filter objects.")] = None,
        aws_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AWS object types to filter objects.")] = None,
        gcp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GCP object types to filter objects.")] = None,
        acropolis_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Acropolis object types to filter objects.")] = None,
        generic_nas_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the generic NAS object types to filter objects.")] = None,
        isilon_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Isilon object types to filter objects.")] = None,
        flashblade_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Flashblade object types to filter objects.")] = None,
        elastifile_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Elastifile object types to filter objects.")] = None,
        gpfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GPFS object types to filter objects.")] = None,
        pure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Pure object types to filter objects.")] = None,
        nimble_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Nimble object types to filter objects.")] = None,
        physical_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Physical object types to filter objects.")] = None,
        kubernetes_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Kubernetes object types to filter objects.")] = None,
        exchange_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Exchange object types to filter objects.")] = None,
        ad_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AD object types to filter objects.")] = None,
        mssql_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the MSSQL object types to filter objects.")] = None,
        oracle_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Oracle object types to filter objects.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SourceHierarchyObjectSummaries:
        """List objects on a source which can be used for data protection.

        List objects which can be used for data protection.

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param parent_id: Specifies the parent ID under which objects should be returned.
        :type parent_id: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param vmware_object_types: Specifies the VMware object types to filter objects.
        :type vmware_object_types: List[str]
        :param netapp_object_types: Specifies the Netapp object types to filter objects.
        :type netapp_object_types: List[str]
        :param o365_object_types: Specifies the Office 365 object types to filter objects.
        :type o365_object_types: List[str]
        :param cassandra_object_types: Specifies the Cassandra object types to filter objects.
        :type cassandra_object_types: List[str]
        :param mongodb_object_types: Specifies the Mongo DB object types to filter objects.
        :type mongodb_object_types: List[str]
        :param couchbase_object_types: Specifies the Couchbase object types to filter objects.
        :type couchbase_object_types: List[str]
        :param hdfs_object_types: Specifies the HDFS object types to filter objects.
        :type hdfs_object_types: List[str]
        :param hbase_object_types: Specifies the Hbase object types to filter objects.
        :type hbase_object_types: List[str]
        :param hive_object_types: Specifies the Hive object types to filter objects.
        :type hive_object_types: List[str]
        :param hyperv_object_types: Specifies the HyperV object types to filter objects.
        :type hyperv_object_types: List[str]
        :param azure_object_types: Specifies the Azure object types to filter objects.
        :type azure_object_types: List[str]
        :param kvm_object_types: Specifies the KVM object types to filter objects.
        :type kvm_object_types: List[str]
        :param aws_object_types: Specifies the AWS object types to filter objects.
        :type aws_object_types: List[str]
        :param gcp_object_types: Specifies the GCP object types to filter objects.
        :type gcp_object_types: List[str]
        :param acropolis_object_types: Specifies the Acropolis object types to filter objects.
        :type acropolis_object_types: List[str]
        :param generic_nas_object_types: Specifies the generic NAS object types to filter objects.
        :type generic_nas_object_types: List[str]
        :param isilon_object_types: Specifies the Isilon object types to filter objects.
        :type isilon_object_types: List[str]
        :param flashblade_object_types: Specifies the Flashblade object types to filter objects.
        :type flashblade_object_types: List[str]
        :param elastifile_object_types: Specifies the Elastifile object types to filter objects.
        :type elastifile_object_types: List[str]
        :param gpfs_object_types: Specifies the GPFS object types to filter objects.
        :type gpfs_object_types: List[str]
        :param pure_object_types: Specifies the Pure object types to filter objects.
        :type pure_object_types: List[str]
        :param nimble_object_types: Specifies the Nimble object types to filter objects.
        :type nimble_object_types: List[str]
        :param physical_object_types: Specifies the Physical object types to filter objects.
        :type physical_object_types: List[str]
        :param kubernetes_object_types: Specifies the Kubernetes object types to filter objects.
        :type kubernetes_object_types: List[str]
        :param exchange_object_types: Specifies the Exchange object types to filter objects.
        :type exchange_object_types: List[str]
        :param ad_object_types: Specifies the AD object types to filter objects.
        :type ad_object_types: List[str]
        :param mssql_object_types: Specifies the MSSQL object types to filter objects.
        :type mssql_object_types: List[str]
        :param oracle_object_types: Specifies the Oracle object types to filter objects.
        :type oracle_object_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_source_hierarchy_objects_serialize(
            source_id=source_id,
            parent_id=parent_id,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            vmware_object_types=vmware_object_types,
            netapp_object_types=netapp_object_types,
            o365_object_types=o365_object_types,
            cassandra_object_types=cassandra_object_types,
            mongodb_object_types=mongodb_object_types,
            couchbase_object_types=couchbase_object_types,
            hdfs_object_types=hdfs_object_types,
            hbase_object_types=hbase_object_types,
            hive_object_types=hive_object_types,
            hyperv_object_types=hyperv_object_types,
            azure_object_types=azure_object_types,
            kvm_object_types=kvm_object_types,
            aws_object_types=aws_object_types,
            gcp_object_types=gcp_object_types,
            acropolis_object_types=acropolis_object_types,
            generic_nas_object_types=generic_nas_object_types,
            isilon_object_types=isilon_object_types,
            flashblade_object_types=flashblade_object_types,
            elastifile_object_types=elastifile_object_types,
            gpfs_object_types=gpfs_object_types,
            pure_object_types=pure_object_types,
            nimble_object_types=nimble_object_types,
            physical_object_types=physical_object_types,
            kubernetes_object_types=kubernetes_object_types,
            exchange_object_types=exchange_object_types,
            ad_object_types=ad_object_types,
            mssql_object_types=mssql_object_types,
            oracle_object_types=oracle_object_types,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SourceHierarchyObjectSummaries",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_source_hierarchy_objects_with_http_info(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        parent_id: Annotated[Optional[StrictInt], Field(description="Specifies the parent ID under which objects should be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        vmware_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the VMware object types to filter objects.")] = None,
        netapp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Netapp object types to filter objects.")] = None,
        o365_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Office 365 object types to filter objects.")] = None,
        cassandra_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Cassandra object types to filter objects.")] = None,
        mongodb_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Mongo DB object types to filter objects.")] = None,
        couchbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Couchbase object types to filter objects.")] = None,
        hdfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HDFS object types to filter objects.")] = None,
        hbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hbase object types to filter objects.")] = None,
        hive_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hive object types to filter objects.")] = None,
        hyperv_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HyperV object types to filter objects.")] = None,
        azure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Azure object types to filter objects.")] = None,
        kvm_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the KVM object types to filter objects.")] = None,
        aws_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AWS object types to filter objects.")] = None,
        gcp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GCP object types to filter objects.")] = None,
        acropolis_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Acropolis object types to filter objects.")] = None,
        generic_nas_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the generic NAS object types to filter objects.")] = None,
        isilon_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Isilon object types to filter objects.")] = None,
        flashblade_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Flashblade object types to filter objects.")] = None,
        elastifile_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Elastifile object types to filter objects.")] = None,
        gpfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GPFS object types to filter objects.")] = None,
        pure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Pure object types to filter objects.")] = None,
        nimble_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Nimble object types to filter objects.")] = None,
        physical_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Physical object types to filter objects.")] = None,
        kubernetes_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Kubernetes object types to filter objects.")] = None,
        exchange_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Exchange object types to filter objects.")] = None,
        ad_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AD object types to filter objects.")] = None,
        mssql_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the MSSQL object types to filter objects.")] = None,
        oracle_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Oracle object types to filter objects.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SourceHierarchyObjectSummaries]:
        """List objects on a source which can be used for data protection.

        List objects which can be used for data protection.

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param parent_id: Specifies the parent ID under which objects should be returned.
        :type parent_id: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param vmware_object_types: Specifies the VMware object types to filter objects.
        :type vmware_object_types: List[str]
        :param netapp_object_types: Specifies the Netapp object types to filter objects.
        :type netapp_object_types: List[str]
        :param o365_object_types: Specifies the Office 365 object types to filter objects.
        :type o365_object_types: List[str]
        :param cassandra_object_types: Specifies the Cassandra object types to filter objects.
        :type cassandra_object_types: List[str]
        :param mongodb_object_types: Specifies the Mongo DB object types to filter objects.
        :type mongodb_object_types: List[str]
        :param couchbase_object_types: Specifies the Couchbase object types to filter objects.
        :type couchbase_object_types: List[str]
        :param hdfs_object_types: Specifies the HDFS object types to filter objects.
        :type hdfs_object_types: List[str]
        :param hbase_object_types: Specifies the Hbase object types to filter objects.
        :type hbase_object_types: List[str]
        :param hive_object_types: Specifies the Hive object types to filter objects.
        :type hive_object_types: List[str]
        :param hyperv_object_types: Specifies the HyperV object types to filter objects.
        :type hyperv_object_types: List[str]
        :param azure_object_types: Specifies the Azure object types to filter objects.
        :type azure_object_types: List[str]
        :param kvm_object_types: Specifies the KVM object types to filter objects.
        :type kvm_object_types: List[str]
        :param aws_object_types: Specifies the AWS object types to filter objects.
        :type aws_object_types: List[str]
        :param gcp_object_types: Specifies the GCP object types to filter objects.
        :type gcp_object_types: List[str]
        :param acropolis_object_types: Specifies the Acropolis object types to filter objects.
        :type acropolis_object_types: List[str]
        :param generic_nas_object_types: Specifies the generic NAS object types to filter objects.
        :type generic_nas_object_types: List[str]
        :param isilon_object_types: Specifies the Isilon object types to filter objects.
        :type isilon_object_types: List[str]
        :param flashblade_object_types: Specifies the Flashblade object types to filter objects.
        :type flashblade_object_types: List[str]
        :param elastifile_object_types: Specifies the Elastifile object types to filter objects.
        :type elastifile_object_types: List[str]
        :param gpfs_object_types: Specifies the GPFS object types to filter objects.
        :type gpfs_object_types: List[str]
        :param pure_object_types: Specifies the Pure object types to filter objects.
        :type pure_object_types: List[str]
        :param nimble_object_types: Specifies the Nimble object types to filter objects.
        :type nimble_object_types: List[str]
        :param physical_object_types: Specifies the Physical object types to filter objects.
        :type physical_object_types: List[str]
        :param kubernetes_object_types: Specifies the Kubernetes object types to filter objects.
        :type kubernetes_object_types: List[str]
        :param exchange_object_types: Specifies the Exchange object types to filter objects.
        :type exchange_object_types: List[str]
        :param ad_object_types: Specifies the AD object types to filter objects.
        :type ad_object_types: List[str]
        :param mssql_object_types: Specifies the MSSQL object types to filter objects.
        :type mssql_object_types: List[str]
        :param oracle_object_types: Specifies the Oracle object types to filter objects.
        :type oracle_object_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_source_hierarchy_objects_serialize(
            source_id=source_id,
            parent_id=parent_id,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            vmware_object_types=vmware_object_types,
            netapp_object_types=netapp_object_types,
            o365_object_types=o365_object_types,
            cassandra_object_types=cassandra_object_types,
            mongodb_object_types=mongodb_object_types,
            couchbase_object_types=couchbase_object_types,
            hdfs_object_types=hdfs_object_types,
            hbase_object_types=hbase_object_types,
            hive_object_types=hive_object_types,
            hyperv_object_types=hyperv_object_types,
            azure_object_types=azure_object_types,
            kvm_object_types=kvm_object_types,
            aws_object_types=aws_object_types,
            gcp_object_types=gcp_object_types,
            acropolis_object_types=acropolis_object_types,
            generic_nas_object_types=generic_nas_object_types,
            isilon_object_types=isilon_object_types,
            flashblade_object_types=flashblade_object_types,
            elastifile_object_types=elastifile_object_types,
            gpfs_object_types=gpfs_object_types,
            pure_object_types=pure_object_types,
            nimble_object_types=nimble_object_types,
            physical_object_types=physical_object_types,
            kubernetes_object_types=kubernetes_object_types,
            exchange_object_types=exchange_object_types,
            ad_object_types=ad_object_types,
            mssql_object_types=mssql_object_types,
            oracle_object_types=oracle_object_types,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SourceHierarchyObjectSummaries",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_source_hierarchy_objects_without_preload_content(
        self,
        source_id: Annotated[StrictInt, Field(description="Specifies the source ID for which objects should be returned.")],
        parent_id: Annotated[Optional[StrictInt], Field(description="Specifies the parent ID under which objects should be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Objects which belongs to all tenants which the current user has permission to see.")] = None,
        vmware_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the VMware object types to filter objects.")] = None,
        netapp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Netapp object types to filter objects.")] = None,
        o365_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Office 365 object types to filter objects.")] = None,
        cassandra_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Cassandra object types to filter objects.")] = None,
        mongodb_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Mongo DB object types to filter objects.")] = None,
        couchbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Couchbase object types to filter objects.")] = None,
        hdfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HDFS object types to filter objects.")] = None,
        hbase_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hbase object types to filter objects.")] = None,
        hive_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Hive object types to filter objects.")] = None,
        hyperv_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the HyperV object types to filter objects.")] = None,
        azure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Azure object types to filter objects.")] = None,
        kvm_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the KVM object types to filter objects.")] = None,
        aws_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AWS object types to filter objects.")] = None,
        gcp_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GCP object types to filter objects.")] = None,
        acropolis_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Acropolis object types to filter objects.")] = None,
        generic_nas_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the generic NAS object types to filter objects.")] = None,
        isilon_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Isilon object types to filter objects.")] = None,
        flashblade_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Flashblade object types to filter objects.")] = None,
        elastifile_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Elastifile object types to filter objects.")] = None,
        gpfs_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the GPFS object types to filter objects.")] = None,
        pure_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Pure object types to filter objects.")] = None,
        nimble_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Nimble object types to filter objects.")] = None,
        physical_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Physical object types to filter objects.")] = None,
        kubernetes_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Kubernetes object types to filter objects.")] = None,
        exchange_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Exchange object types to filter objects.")] = None,
        ad_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the AD object types to filter objects.")] = None,
        mssql_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the MSSQL object types to filter objects.")] = None,
        oracle_object_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the Oracle object types to filter objects.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List objects on a source which can be used for data protection.

        List objects which can be used for data protection.

        :param source_id: Specifies the source ID for which objects should be returned. (required)
        :type source_id: int
        :param parent_id: Specifies the parent ID under which objects should be returned.
        :type parent_id: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Objects which belongs to all tenants which the current user has permission to see.
        :type include_tenants: bool
        :param vmware_object_types: Specifies the VMware object types to filter objects.
        :type vmware_object_types: List[str]
        :param netapp_object_types: Specifies the Netapp object types to filter objects.
        :type netapp_object_types: List[str]
        :param o365_object_types: Specifies the Office 365 object types to filter objects.
        :type o365_object_types: List[str]
        :param cassandra_object_types: Specifies the Cassandra object types to filter objects.
        :type cassandra_object_types: List[str]
        :param mongodb_object_types: Specifies the Mongo DB object types to filter objects.
        :type mongodb_object_types: List[str]
        :param couchbase_object_types: Specifies the Couchbase object types to filter objects.
        :type couchbase_object_types: List[str]
        :param hdfs_object_types: Specifies the HDFS object types to filter objects.
        :type hdfs_object_types: List[str]
        :param hbase_object_types: Specifies the Hbase object types to filter objects.
        :type hbase_object_types: List[str]
        :param hive_object_types: Specifies the Hive object types to filter objects.
        :type hive_object_types: List[str]
        :param hyperv_object_types: Specifies the HyperV object types to filter objects.
        :type hyperv_object_types: List[str]
        :param azure_object_types: Specifies the Azure object types to filter objects.
        :type azure_object_types: List[str]
        :param kvm_object_types: Specifies the KVM object types to filter objects.
        :type kvm_object_types: List[str]
        :param aws_object_types: Specifies the AWS object types to filter objects.
        :type aws_object_types: List[str]
        :param gcp_object_types: Specifies the GCP object types to filter objects.
        :type gcp_object_types: List[str]
        :param acropolis_object_types: Specifies the Acropolis object types to filter objects.
        :type acropolis_object_types: List[str]
        :param generic_nas_object_types: Specifies the generic NAS object types to filter objects.
        :type generic_nas_object_types: List[str]
        :param isilon_object_types: Specifies the Isilon object types to filter objects.
        :type isilon_object_types: List[str]
        :param flashblade_object_types: Specifies the Flashblade object types to filter objects.
        :type flashblade_object_types: List[str]
        :param elastifile_object_types: Specifies the Elastifile object types to filter objects.
        :type elastifile_object_types: List[str]
        :param gpfs_object_types: Specifies the GPFS object types to filter objects.
        :type gpfs_object_types: List[str]
        :param pure_object_types: Specifies the Pure object types to filter objects.
        :type pure_object_types: List[str]
        :param nimble_object_types: Specifies the Nimble object types to filter objects.
        :type nimble_object_types: List[str]
        :param physical_object_types: Specifies the Physical object types to filter objects.
        :type physical_object_types: List[str]
        :param kubernetes_object_types: Specifies the Kubernetes object types to filter objects.
        :type kubernetes_object_types: List[str]
        :param exchange_object_types: Specifies the Exchange object types to filter objects.
        :type exchange_object_types: List[str]
        :param ad_object_types: Specifies the AD object types to filter objects.
        :type ad_object_types: List[str]
        :param mssql_object_types: Specifies the MSSQL object types to filter objects.
        :type mssql_object_types: List[str]
        :param oracle_object_types: Specifies the Oracle object types to filter objects.
        :type oracle_object_types: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request to the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_source_hierarchy_objects_serialize(
            source_id=source_id,
            parent_id=parent_id,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            vmware_object_types=vmware_object_types,
            netapp_object_types=netapp_object_types,
            o365_object_types=o365_object_types,
            cassandra_object_types=cassandra_object_types,
            mongodb_object_types=mongodb_object_types,
            couchbase_object_types=couchbase_object_types,
            hdfs_object_types=hdfs_object_types,
            hbase_object_types=hbase_object_types,
            hive_object_types=hive_object_types,
            hyperv_object_types=hyperv_object_types,
            azure_object_types=azure_object_types,
            kvm_object_types=kvm_object_types,
            aws_object_types=aws_object_types,
            gcp_object_types=gcp_object_types,
            acropolis_object_types=acropolis_object_types,
            generic_nas_object_types=generic_nas_object_types,
            isilon_object_types=isilon_object_types,
            flashblade_object_types=flashblade_object_types,
            elastifile_object_types=elastifile_object_types,
            gpfs_object_types=gpfs_object_types,
            pure_object_types=pure_object_types,
            nimble_object_types=nimble_object_types,
            physical_object_types=physical_object_types,
            kubernetes_object_types=kubernetes_object_types,
            exchange_object_types=exchange_object_types,
            ad_object_types=ad_object_types,
            mssql_object_types=mssql_object_types,
            oracle_object_types=oracle_object_types,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SourceHierarchyObjectSummaries",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_source_hierarchy_objects_serialize(
        self,
        source_id,
        parent_id,
        tenant_ids,
        include_tenants,
        vmware_object_types,
        netapp_object_types,
        o365_object_types,
        cassandra_object_types,
        mongodb_object_types,
        couchbase_object_types,
        hdfs_object_types,
        hbase_object_types,
        hive_object_types,
        hyperv_object_types,
        azure_object_types,
        kvm_object_types,
        aws_object_types,
        gcp_object_types,
        acropolis_object_types,
        generic_nas_object_types,
        isilon_object_types,
        flashblade_object_types,
        elastifile_object_types,
        gpfs_object_types,
        pure_object_types,
        nimble_object_types,
        physical_object_types,
        kubernetes_object_types,
        exchange_object_types,
        ad_object_types,
        mssql_object_types,
        oracle_object_types,
        use_cached_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tenantIds': 'csv',
            'vmwareObjectTypes': 'csv',
            'netappObjectTypes': 'csv',
            'o365ObjectTypes': 'csv',
            'cassandraObjectTypes': 'csv',
            'mongodbObjectTypes': 'csv',
            'couchbaseObjectTypes': 'csv',
            'hdfsObjectTypes': 'csv',
            'hbaseObjectTypes': 'csv',
            'hiveObjectTypes': 'csv',
            'hypervObjectTypes': 'csv',
            'azureObjectTypes': 'csv',
            'kvmObjectTypes': 'csv',
            'awsObjectTypes': 'csv',
            'gcpObjectTypes': 'csv',
            'acropolisObjectTypes': 'csv',
            'genericNasObjectTypes': 'csv',
            'isilonObjectTypes': 'csv',
            'flashbladeObjectTypes': 'csv',
            'elastifileObjectTypes': 'csv',
            'gpfsObjectTypes': 'csv',
            'pureObjectTypes': 'csv',
            'nimbleObjectTypes': 'csv',
            'physicalObjectTypes': 'csv',
            'kubernetesObjectTypes': 'csv',
            'exchangeObjectTypes': 'csv',
            'adObjectTypes': 'csv',
            'mssqlObjectTypes': 'csv',
            'oracleObjectTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if source_id is not None:
            _path_params['sourceId'] = source_id
        # process the query parameters
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if vmware_object_types is not None:
            
            _query_params.append(('vmwareObjectTypes', vmware_object_types))
            
        if netapp_object_types is not None:
            
            _query_params.append(('netappObjectTypes', netapp_object_types))
            
        if o365_object_types is not None:
            
            _query_params.append(('o365ObjectTypes', o365_object_types))
            
        if cassandra_object_types is not None:
            
            _query_params.append(('cassandraObjectTypes', cassandra_object_types))
            
        if mongodb_object_types is not None:
            
            _query_params.append(('mongodbObjectTypes', mongodb_object_types))
            
        if couchbase_object_types is not None:
            
            _query_params.append(('couchbaseObjectTypes', couchbase_object_types))
            
        if hdfs_object_types is not None:
            
            _query_params.append(('hdfsObjectTypes', hdfs_object_types))
            
        if hbase_object_types is not None:
            
            _query_params.append(('hbaseObjectTypes', hbase_object_types))
            
        if hive_object_types is not None:
            
            _query_params.append(('hiveObjectTypes', hive_object_types))
            
        if hyperv_object_types is not None:
            
            _query_params.append(('hypervObjectTypes', hyperv_object_types))
            
        if azure_object_types is not None:
            
            _query_params.append(('azureObjectTypes', azure_object_types))
            
        if kvm_object_types is not None:
            
            _query_params.append(('kvmObjectTypes', kvm_object_types))
            
        if aws_object_types is not None:
            
            _query_params.append(('awsObjectTypes', aws_object_types))
            
        if gcp_object_types is not None:
            
            _query_params.append(('gcpObjectTypes', gcp_object_types))
            
        if acropolis_object_types is not None:
            
            _query_params.append(('acropolisObjectTypes', acropolis_object_types))
            
        if generic_nas_object_types is not None:
            
            _query_params.append(('genericNasObjectTypes', generic_nas_object_types))
            
        if isilon_object_types is not None:
            
            _query_params.append(('isilonObjectTypes', isilon_object_types))
            
        if flashblade_object_types is not None:
            
            _query_params.append(('flashbladeObjectTypes', flashblade_object_types))
            
        if elastifile_object_types is not None:
            
            _query_params.append(('elastifileObjectTypes', elastifile_object_types))
            
        if gpfs_object_types is not None:
            
            _query_params.append(('gpfsObjectTypes', gpfs_object_types))
            
        if pure_object_types is not None:
            
            _query_params.append(('pureObjectTypes', pure_object_types))
            
        if nimble_object_types is not None:
            
            _query_params.append(('nimbleObjectTypes', nimble_object_types))
            
        if physical_object_types is not None:
            
            _query_params.append(('physicalObjectTypes', physical_object_types))
            
        if kubernetes_object_types is not None:
            
            _query_params.append(('kubernetesObjectTypes', kubernetes_object_types))
            
        if exchange_object_types is not None:
            
            _query_params.append(('exchangeObjectTypes', exchange_object_types))
            
        if ad_object_types is not None:
            
            _query_params.append(('adObjectTypes', ad_object_types))
            
        if mssql_object_types is not None:
            
            _query_params.append(('mssqlObjectTypes', mssql_object_types))
            
        if oracle_object_types is not None:
            
            _query_params.append(('oracleObjectTypes', oracle_object_types))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/sources/{sourceId}/objects',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def objects_actions(
        self,
        body: Annotated[ObjectsActionRequest, Field(description="Specifies the parameters to execute actions on given list of objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Actions on Objects

        Specifies the request to perform various actions on multiple objects.

        :param body: Specifies the parameters to execute actions on given list of objects. (required)
        :type body: ObjectsActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._objects_actions_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def objects_actions_with_http_info(
        self,
        body: Annotated[ObjectsActionRequest, Field(description="Specifies the parameters to execute actions on given list of objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Actions on Objects

        Specifies the request to perform various actions on multiple objects.

        :param body: Specifies the parameters to execute actions on given list of objects. (required)
        :type body: ObjectsActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._objects_actions_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def objects_actions_without_preload_content(
        self,
        body: Annotated[ObjectsActionRequest, Field(description="Specifies the parameters to execute actions on given list of objects.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Actions on Objects

        Specifies the request to perform various actions on multiple objects.

        :param body: Specifies the parameters to execute actions on given list of objects. (required)
        :type body: ObjectsActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._objects_actions_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _objects_actions_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/objects/actions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def perform_action_on_object(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectActionRequest, Field(description="Specifies the parameters to perform an action on an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Perform an action on an object.

        Perform an action on an object. Depending on the object environment type, different actions are available.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to perform an action on an object. (required)
        :type body: ObjectActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_object_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def perform_action_on_object_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectActionRequest, Field(description="Specifies the parameters to perform an action on an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Perform an action on an object.

        Perform an action on an object. Depending on the object environment type, different actions are available.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to perform an action on an object. (required)
        :type body: ObjectActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_object_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def perform_action_on_object_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        body: Annotated[ObjectActionRequest, Field(description="Specifies the parameters to perform an action on an object.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Perform an action on an object.

        Perform an action on an object. Depending on the object environment type, different actions are available.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param body: Specifies the parameters to perform an action on an object. (required)
        :type body: ObjectActionRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_object_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _perform_action_on_object_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/objects/{id}/actions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_object_snapshot(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot.")],
        body: Annotated[UpdateObjectSnapshotRequest, Field(description="Specifies the parameters update an object snapshot.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ObjectSnapshot:
        """Update an object snapshot.

        Update an object snapshot.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param snapshot_id: Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters update an object snapshot. (required)
        :type body: UpdateObjectSnapshotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_object_snapshot_serialize(
            id=id,
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_object_snapshot_with_http_info(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot.")],
        body: Annotated[UpdateObjectSnapshotRequest, Field(description="Specifies the parameters update an object snapshot.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ObjectSnapshot]:
        """Update an object snapshot.

        Update an object snapshot.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param snapshot_id: Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters update an object snapshot. (required)
        :type body: UpdateObjectSnapshotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_object_snapshot_serialize(
            id=id,
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_object_snapshot_without_preload_content(
        self,
        id: Annotated[StrictInt, Field(description="Specifies the id of the Object.")],
        snapshot_id: Annotated[StrictStr, Field(description="Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot.")],
        body: Annotated[UpdateObjectSnapshotRequest, Field(description="Specifies the parameters update an object snapshot.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update an object snapshot.

        Update an object snapshot.

        :param id: Specifies the id of the Object. (required)
        :type id: int
        :param snapshot_id: Specifies the id of the snapshot.<br> Note: 1. If the snapshotid of one of the apps is specified, it applies for all the databases in the Protection Run.<br> 2. In case of volume based jobs, please specify the snapshotid of the source not the database. if source snapshot is specified, applied to source snapshot. if database snapshotid is specified in case of volume based jobs, then it is applicable for host's snapshot. (required)
        :type snapshot_id: str
        :param body: Specifies the parameters update an object snapshot. (required)
        :type body: UpdateObjectSnapshotRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_object_snapshot_serialize(
            id=id,
            snapshot_id=snapshot_id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ObjectSnapshot",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_object_snapshot_serialize(
        self,
        id,
        snapshot_id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if snapshot_id is not None:
            _path_params['snapshotId'] = snapshot_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-protect/objects/{id}/snapshots/{snapshotId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


