# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictBool
from cohesity_sdk.cluster.models.common_protection_group_run_response_parameters import CommonProtectionGroupRunResponseParameters
from cohesity_sdk.cluster.models.create_or_update_protection_group_request import CreateOrUpdateProtectionGroupRequest
from cohesity_sdk.cluster.models.create_protection_group_run_request import CreateProtectionGroupRunRequest
from cohesity_sdk.cluster.models.create_protection_group_run_response_body import CreateProtectionGroupRunResponseBody
from cohesity_sdk.cluster.models.get_protection_run_progress_body import GetProtectionRunProgressBody
from cohesity_sdk.cluster.models.get_protection_run_stats_body import GetProtectionRunStatsBody
from cohesity_sdk.cluster.models.perform_action_on_protection_group_run_request import PerformActionOnProtectionGroupRunRequest
from cohesity_sdk.cluster.models.perform_run_action_response import PerformRunActionResponse
from cohesity_sdk.cluster.models.protection_group import ProtectionGroup
from cohesity_sdk.cluster.models.protection_group_runs import ProtectionGroupRuns
from cohesity_sdk.cluster.models.protection_groups import ProtectionGroups
from cohesity_sdk.cluster.models.protection_runs_summary import ProtectionRunsSummary
from cohesity_sdk.cluster.models.update_protection_group_run_request_body import UpdateProtectionGroupRunRequestBody
from cohesity_sdk.cluster.models.update_protection_group_run_response_body import UpdateProtectionGroupRunResponseBody
from cohesity_sdk.cluster.models.update_protection_groups_state import UpdateProtectionGroupsState
from cohesity_sdk.cluster.models.update_protection_groups_state_request import UpdateProtectionGroupsStateRequest

from cohesity_sdk.cluster.api_client import ApiClient, RequestSerialized
from cohesity_sdk.cluster.api_response import ApiResponse
from cohesity_sdk.cluster.rest import RESTResponseType


class ProtectionGroupApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_protection_group(
        self,
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to create a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionGroup:
        """Create a Protection Group.

        Create a Protection Group.

        :param body: Specifies the parameters to create a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_protection_group_with_http_info(
        self,
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to create a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionGroup]:
        """Create a Protection Group.

        Create a Protection Group.

        :param body: Specifies the parameters to create a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_protection_group_without_preload_content(
        self,
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to create a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a Protection Group.

        Create a Protection Group.

        :param body: Specifies the parameters to create a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_protection_group_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/protection-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_protection_group_run(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[CreateProtectionGroupRunRequest, Field(description="Specifies the parameters to start a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateProtectionGroupRunResponseBody:
        """Create a new protection run.

        Create a new protection run. This can be used to start a run for a Protection Group on demand, ignoring the schedule and retention specified in the protection policy.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to start a protection run. (required)
        :type body: CreateProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "CreateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_protection_group_run_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[CreateProtectionGroupRunRequest, Field(description="Specifies the parameters to start a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateProtectionGroupRunResponseBody]:
        """Create a new protection run.

        Create a new protection run. This can be used to start a run for a Protection Group on demand, ignoring the schedule and retention specified in the protection policy.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to start a protection run. (required)
        :type body: CreateProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "CreateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_protection_group_run_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[CreateProtectionGroupRunRequest, Field(description="Specifies the parameters to start a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a new protection run.

        Create a new protection run. This can be used to start a run for a Protection Group on demand, ignoring the schedule and retention specified in the protection policy.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to start a protection run. (required)
        :type body: CreateProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "CreateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_protection_group_run_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/protection-groups/{id}/runs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_protection_group(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        delete_snapshots: Annotated[Optional[StrictBool], Field(description="Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Delete a Protection Group.

        Returns Success if the Protection Group is deleted.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param delete_snapshots: Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.
        :type delete_snapshots: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_protection_group_serialize(
            id=id,
            delete_snapshots=delete_snapshots,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_protection_group_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        delete_snapshots: Annotated[Optional[StrictBool], Field(description="Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Delete a Protection Group.

        Returns Success if the Protection Group is deleted.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param delete_snapshots: Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.
        :type delete_snapshots: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_protection_group_serialize(
            id=id,
            delete_snapshots=delete_snapshots,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_protection_group_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        delete_snapshots: Annotated[Optional[StrictBool], Field(description="Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a Protection Group.

        Returns Success if the Protection Group is deleted.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param delete_snapshots: Specifies if Snapshots generated by the Protection Group should also be deleted when the Protection Group is deleted.
        :type delete_snapshots: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_protection_group_serialize(
            id=id,
            delete_snapshots=delete_snapshots,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '204': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_protection_group_serialize(
        self,
        id,
        delete_snapshots,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if delete_snapshots is not None:
            
            _query_params.append(('deleteSnapshots', delete_snapshots))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='DELETE',
            resource_path='/data-protect/protection-groups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_group_by_id(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionGroup:
        """List details about single Protection Group.

        Returns the Protection Group corresponding to the specified Group id.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_group_by_id_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionGroup]:
        """List details about single Protection Group.

        Returns the Protection Group corresponding to the specified Group id.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_group_by_id_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List details about single Protection Group.

        Returns the Protection Group corresponding to the specified Group id.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_by_id_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_group_by_id_serialize(
        self,
        id,
        request_initiator_type,
        include_last_run_info,
        prune_excluded_source_ids,
        prune_source_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if include_last_run_info is not None:
            
            _query_params.append(('includeLastRunInfo', include_last_run_info))
            
        if prune_excluded_source_ids is not None:
            
            _query_params.append(('pruneExcludedSourceIds', prune_excluded_source_ids))
            
        if prune_source_ids is not None:
            
            _query_params.append(('pruneSourceIds', prune_source_ids))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_group_run(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CommonProtectionGroupRunResponseParameters:
        """Get a run for a Protection Group.

        Get a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_object_details: Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_run_serialize(
            id=id,
            run_id=run_id,
            request_initiator_type=request_initiator_type,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_object_details=include_object_details,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonProtectionGroupRunResponseParameters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_group_run_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CommonProtectionGroupRunResponseParameters]:
        """Get a run for a Protection Group.

        Get a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_object_details: Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_run_serialize(
            id=id,
            run_id=run_id,
            request_initiator_type=request_initiator_type,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_object_details=include_object_details,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonProtectionGroupRunResponseParameters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_group_run_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a run for a Protection Group.

        Get a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_object_details: Specifies if the result includes the object details for a protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_run_serialize(
            id=id,
            run_id=run_id,
            request_initiator_type=request_initiator_type,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_object_details=include_object_details,
            use_cached_data=use_cached_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CommonProtectionGroupRunResponseParameters",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_group_run_serialize(
        self,
        id,
        run_id,
        request_initiator_type,
        tenant_ids,
        include_tenants,
        include_object_details,
        use_cached_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tenantIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        # process the query parameters
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_object_details is not None:
            
            _query_params.append(('includeObjectDetails', include_object_details))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs/{runId}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_group_runs(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        run_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Specifies the protection run id.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        local_backup_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        replication_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        archival_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        run_tags: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        filter_by_end_time: Annotated[Optional[StrictBool], Field(description="If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.")] = None,
        snapshot_target_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        only_return_successful_copy_run: Annotated[Optional[StrictBool], Field(description="If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        filter_by_copy_task_end_time: Annotated[Optional[StrictBool], Field(description="If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the next page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionGroupRuns:
        """Get the list of runs for a Protection Group.

        Get the runs for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param run_id: Specifies the protection run id.
        :type run_id: str
        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param include_object_details: Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param local_backup_run_status: Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type local_backup_run_status: List[str]
        :param replication_run_status: Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type replication_run_status: List[str]
        :param archival_run_status: Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type archival_run_status: List[str]
        :param cloud_spin_run_status: Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param run_tags: Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.
        :type run_tags: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param filter_by_end_time: If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.
        :type filter_by_end_time: bool
        :param snapshot_target_types: Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type snapshot_target_types: List[str]
        :param only_return_successful_copy_run: If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type only_return_successful_copy_run: bool
        :param filter_by_copy_task_end_time: If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.
        :type filter_by_copy_task_end_time: bool
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the next page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_runs_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            include_object_details=include_object_details,
            local_backup_run_status=local_backup_run_status,
            replication_run_status=replication_run_status,
            archival_run_status=archival_run_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            run_tags=run_tags,
            use_cached_data=use_cached_data,
            filter_by_end_time=filter_by_end_time,
            snapshot_target_types=snapshot_target_types,
            only_return_successful_copy_run=only_return_successful_copy_run,
            filter_by_copy_task_end_time=filter_by_copy_task_end_time,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroupRuns",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_group_runs_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        run_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Specifies the protection run id.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        local_backup_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        replication_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        archival_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        run_tags: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        filter_by_end_time: Annotated[Optional[StrictBool], Field(description="If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.")] = None,
        snapshot_target_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        only_return_successful_copy_run: Annotated[Optional[StrictBool], Field(description="If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        filter_by_copy_task_end_time: Annotated[Optional[StrictBool], Field(description="If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the next page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionGroupRuns]:
        """Get the list of runs for a Protection Group.

        Get the runs for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param run_id: Specifies the protection run id.
        :type run_id: str
        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param include_object_details: Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param local_backup_run_status: Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type local_backup_run_status: List[str]
        :param replication_run_status: Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type replication_run_status: List[str]
        :param archival_run_status: Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type archival_run_status: List[str]
        :param cloud_spin_run_status: Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param run_tags: Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.
        :type run_tags: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param filter_by_end_time: If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.
        :type filter_by_end_time: bool
        :param snapshot_target_types: Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type snapshot_target_types: List[str]
        :param only_return_successful_copy_run: If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type only_return_successful_copy_run: bool
        :param filter_by_copy_task_end_time: If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.
        :type filter_by_copy_task_end_time: bool
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the next page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_runs_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            include_object_details=include_object_details,
            local_backup_run_status=local_backup_run_status,
            replication_run_status=replication_run_status,
            archival_run_status=archival_run_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            run_tags=run_tags,
            use_cached_data=use_cached_data,
            filter_by_end_time=filter_by_end_time,
            snapshot_target_types=snapshot_target_types,
            only_return_successful_copy_run=only_return_successful_copy_run,
            filter_by_copy_task_end_time=filter_by_copy_task_end_time,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroupRuns",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_group_runs_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        run_id: Annotated[Optional[Annotated[str, Field(strict=True)]], Field(description="Specifies the protection run id.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.")] = None,
        run_types: Annotated[Optional[List[StrictStr]], Field(description="Filter by run type. Only protection run matching the specified types will be returned.")] = None,
        include_object_details: Annotated[Optional[StrictBool], Field(description="Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.")] = None,
        local_backup_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        replication_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        archival_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        cloud_spin_run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        num_runs: Annotated[Optional[StrictInt], Field(description="Specifies the max number of runs. If not specified, at most 100 runs will be returned.")] = None,
        exclude_non_restorable_runs: Annotated[Optional[StrictBool], Field(description="Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.")] = None,
        run_tags: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        filter_by_end_time: Annotated[Optional[StrictBool], Field(description="If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.")] = None,
        snapshot_target_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        only_return_successful_copy_run: Annotated[Optional[StrictBool], Field(description="If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.")] = None,
        filter_by_copy_task_end_time: Annotated[Optional[StrictBool], Field(description="If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the next page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of runs for a Protection Group.

        Get the runs for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param run_id: Specifies the protection run id.
        :type run_id: str
        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Group Runs created by the current user will be returned.
        :type include_tenants: bool
        :param run_types: Filter by run type. Only protection run matching the specified types will be returned.
        :type run_types: List[str]
        :param include_object_details: Specifies if the result includes the object details for each protection run. If set to true, details of the protected object will be returned. If set to false or not specified, details will not be returned.
        :type include_object_details: bool
        :param local_backup_run_status: Specifies a list of local backup status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type local_backup_run_status: List[str]
        :param replication_run_status: Specifies a list of replication status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type replication_run_status: List[str]
        :param archival_run_status: Specifies a list of archival status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type archival_run_status: List[str]
        :param cloud_spin_run_status: Specifies a list of cloud spin status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type cloud_spin_run_status: List[str]
        :param num_runs: Specifies the max number of runs. If not specified, at most 100 runs will be returned.
        :type num_runs: int
        :param exclude_non_restorable_runs: Specifies whether to exclude non restorable runs. Run is treated restorable only if there is atleast one object snapshot (which may be either a local or an archival snapshot) which is not deleted or expired. Default value is false.
        :type exclude_non_restorable_runs: bool
        :param run_tags: Specifies a list of tags for protection runs. If this is specified, only the runs which match these tags will be returned.
        :type run_tags: List[str]
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param filter_by_end_time: If true, the runs with backup end time within the specified time range will be returned. Otherwise, the runs with start time in the time range are returned.
        :type filter_by_end_time: bool
        :param snapshot_target_types: Specifies the snapshot's target type which should be filtered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type snapshot_target_types: List[str]
        :param only_return_successful_copy_run: If set to false, all copy_tasks in any given valid state will be considered. If left empty or set to true, only successful copy_tasks would be considered. Note: this field is only considered when, filterByCopyTaskEndTime is set to true, or else it is ignored.
        :type only_return_successful_copy_run: bool
        :param filter_by_copy_task_end_time: If true, then the details of the runs for which any copyTask completed in the given timerange will be returned. Only one of filterByEndTime and filterByCopyTaskEndTime can be set.
        :type filter_by_copy_task_end_time: bool
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the next page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_group_runs_serialize(
            id=id,
            request_initiator_type=request_initiator_type,
            run_id=run_id,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            run_types=run_types,
            include_object_details=include_object_details,
            local_backup_run_status=local_backup_run_status,
            replication_run_status=replication_run_status,
            archival_run_status=archival_run_status,
            cloud_spin_run_status=cloud_spin_run_status,
            num_runs=num_runs,
            exclude_non_restorable_runs=exclude_non_restorable_runs,
            run_tags=run_tags,
            use_cached_data=use_cached_data,
            filter_by_end_time=filter_by_end_time,
            snapshot_target_types=snapshot_target_types,
            only_return_successful_copy_run=only_return_successful_copy_run,
            filter_by_copy_task_end_time=filter_by_copy_task_end_time,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroupRuns",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_group_runs_serialize(
        self,
        id,
        request_initiator_type,
        run_id,
        start_time_usecs,
        end_time_usecs,
        tenant_ids,
        include_tenants,
        run_types,
        include_object_details,
        local_backup_run_status,
        replication_run_status,
        archival_run_status,
        cloud_spin_run_status,
        num_runs,
        exclude_non_restorable_runs,
        run_tags,
        use_cached_data,
        filter_by_end_time,
        snapshot_target_types,
        only_return_successful_copy_run,
        filter_by_copy_task_end_time,
        max_result_count,
        pagination_cookie,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'tenantIds': 'csv',
            'runTypes': 'csv',
            'localBackupRunStatus': 'csv',
            'replicationRunStatus': 'csv',
            'archivalRunStatus': 'csv',
            'cloudSpinRunStatus': 'csv',
            'runTags': 'csv',
            'snapshotTargetTypes': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        if run_id is not None:
            
            _query_params.append(('runId', run_id))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if run_types is not None:
            
            _query_params.append(('runTypes', run_types))
            
        if include_object_details is not None:
            
            _query_params.append(('includeObjectDetails', include_object_details))
            
        if local_backup_run_status is not None:
            
            _query_params.append(('localBackupRunStatus', local_backup_run_status))
            
        if replication_run_status is not None:
            
            _query_params.append(('replicationRunStatus', replication_run_status))
            
        if archival_run_status is not None:
            
            _query_params.append(('archivalRunStatus', archival_run_status))
            
        if cloud_spin_run_status is not None:
            
            _query_params.append(('cloudSpinRunStatus', cloud_spin_run_status))
            
        if num_runs is not None:
            
            _query_params.append(('numRuns', num_runs))
            
        if exclude_non_restorable_runs is not None:
            
            _query_params.append(('excludeNonRestorableRuns', exclude_non_restorable_runs))
            
        if run_tags is not None:
            
            _query_params.append(('runTags', run_tags))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        if filter_by_end_time is not None:
            
            _query_params.append(('filterByEndTime', filter_by_end_time))
            
        if snapshot_target_types is not None:
            
            _query_params.append(('snapshotTargetTypes', snapshot_target_types))
            
        if only_return_successful_copy_run is not None:
            
            _query_params.append(('onlyReturnSuccessfulCopyRun', only_return_successful_copy_run))
            
        if filter_by_copy_task_end_time is not None:
            
            _query_params.append(('filterByCopyTaskEndTime', filter_by_copy_task_end_time))
            
        if max_result_count is not None:
            
            _query_params.append(('maxResultCount', max_result_count))
            
        if pagination_cookie is not None:
            
            _query_params.append(('paginationCookie', pagination_cookie))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_groups(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group ids.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.")] = None,
        include_groups_with_datalock_only: Annotated[Optional[StrictBool], Field(description="Whether to only return Protection Groups with a datalock.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.")] = None,
        office365_workloads: Optional[List[StrictStr]] = None,
        is_active: Annotated[Optional[StrictBool], Field(description="Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.")] = None,
        is_deleted: Annotated[Optional[StrictBool], Field(description="If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.")] = None,
        is_paused: Annotated[Optional[StrictBool], Field(description="Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.")] = None,
        last_run_local_backup_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_replication_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_archival_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_cloud_spin_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_any_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        is_last_run_sla_violated: Annotated[Optional[StrictBool], Field(description="If true, return Protection Groups for which last run SLA was violated.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        source_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the set page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionGroups:
        """Get the list of Protection Groups.

        Get the list of Protection Groups.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Protection Group ids.
        :type ids: List[str]
        :param names: Filter by a list of Protection Group names.
        :type names: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.
        :type policy_ids: List[str]
        :param storage_domain_id: Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param include_groups_with_datalock_only: Whether to only return Protection Groups with a datalock.
        :type include_groups_with_datalock_only: bool
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.
        :type environments: List[str]
        :param office365_workloads:
        :type office365_workloads: List[str]
        :param is_active: Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.
        :type is_active: bool
        :param is_deleted: If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.
        :type is_deleted: bool
        :param is_paused: Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.
        :type is_paused: bool
        :param last_run_local_backup_status: Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_local_backup_status: List[str]
        :param last_run_replication_status: Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_replication_status: List[str]
        :param last_run_archival_status: Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_archival_status: List[str]
        :param last_run_cloud_spin_status: Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_cloud_spin_status: List[str]
        :param last_run_any_status: Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_any_status: List[str]
        :param is_last_run_sla_violated: If true, return Protection Groups for which last run SLA was violated.
        :type is_last_run_sla_violated: bool
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param source_ids: Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.
        :type source_ids: List[int]
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the set page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_groups_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            names=names,
            policy_ids=policy_ids,
            storage_domain_id=storage_domain_id,
            include_groups_with_datalock_only=include_groups_with_datalock_only,
            environments=environments,
            office365_workloads=office365_workloads,
            is_active=is_active,
            is_deleted=is_deleted,
            is_paused=is_paused,
            last_run_local_backup_status=last_run_local_backup_status,
            last_run_replication_status=last_run_replication_status,
            last_run_archival_status=last_run_archival_status,
            last_run_cloud_spin_status=last_run_cloud_spin_status,
            last_run_any_status=last_run_any_status,
            is_last_run_sla_violated=is_last_run_sla_violated,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            use_cached_data=use_cached_data,
            source_ids=source_ids,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_groups_with_http_info(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group ids.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.")] = None,
        include_groups_with_datalock_only: Annotated[Optional[StrictBool], Field(description="Whether to only return Protection Groups with a datalock.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.")] = None,
        office365_workloads: Optional[List[StrictStr]] = None,
        is_active: Annotated[Optional[StrictBool], Field(description="Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.")] = None,
        is_deleted: Annotated[Optional[StrictBool], Field(description="If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.")] = None,
        is_paused: Annotated[Optional[StrictBool], Field(description="Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.")] = None,
        last_run_local_backup_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_replication_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_archival_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_cloud_spin_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_any_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        is_last_run_sla_violated: Annotated[Optional[StrictBool], Field(description="If true, return Protection Groups for which last run SLA was violated.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        source_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the set page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionGroups]:
        """Get the list of Protection Groups.

        Get the list of Protection Groups.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Protection Group ids.
        :type ids: List[str]
        :param names: Filter by a list of Protection Group names.
        :type names: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.
        :type policy_ids: List[str]
        :param storage_domain_id: Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param include_groups_with_datalock_only: Whether to only return Protection Groups with a datalock.
        :type include_groups_with_datalock_only: bool
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.
        :type environments: List[str]
        :param office365_workloads:
        :type office365_workloads: List[str]
        :param is_active: Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.
        :type is_active: bool
        :param is_deleted: If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.
        :type is_deleted: bool
        :param is_paused: Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.
        :type is_paused: bool
        :param last_run_local_backup_status: Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_local_backup_status: List[str]
        :param last_run_replication_status: Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_replication_status: List[str]
        :param last_run_archival_status: Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_archival_status: List[str]
        :param last_run_cloud_spin_status: Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_cloud_spin_status: List[str]
        :param last_run_any_status: Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_any_status: List[str]
        :param is_last_run_sla_violated: If true, return Protection Groups for which last run SLA was violated.
        :type is_last_run_sla_violated: bool
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param source_ids: Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.
        :type source_ids: List[int]
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the set page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_groups_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            names=names,
            policy_ids=policy_ids,
            storage_domain_id=storage_domain_id,
            include_groups_with_datalock_only=include_groups_with_datalock_only,
            environments=environments,
            office365_workloads=office365_workloads,
            is_active=is_active,
            is_deleted=is_deleted,
            is_paused=is_paused,
            last_run_local_backup_status=last_run_local_backup_status,
            last_run_replication_status=last_run_replication_status,
            last_run_archival_status=last_run_archival_status,
            last_run_cloud_spin_status=last_run_cloud_spin_status,
            last_run_any_status=last_run_any_status,
            is_last_run_sla_violated=is_last_run_sla_violated,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            use_cached_data=use_cached_data,
            source_ids=source_ids,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_groups_without_preload_content(
        self,
        request_initiator_type: Annotated[Optional[StrictStr], Field(description="Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.")] = None,
        ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group ids.")] = None,
        names: Annotated[Optional[List[StrictStr]], Field(description="Filter by a list of Protection Group names.")] = None,
        policy_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.")] = None,
        storage_domain_id: Annotated[Optional[StrictInt], Field(description="Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.")] = None,
        include_groups_with_datalock_only: Annotated[Optional[StrictBool], Field(description="Whether to only return Protection Groups with a datalock.")] = None,
        environments: Annotated[Optional[List[StrictStr]], Field(description="Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.")] = None,
        office365_workloads: Optional[List[StrictStr]] = None,
        is_active: Annotated[Optional[StrictBool], Field(description="Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.")] = None,
        is_deleted: Annotated[Optional[StrictBool], Field(description="If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.")] = None,
        is_paused: Annotated[Optional[StrictBool], Field(description="Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.")] = None,
        last_run_local_backup_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_replication_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_archival_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_cloud_spin_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        last_run_any_status: Annotated[Optional[List[StrictStr]], Field(description="Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.")] = None,
        is_last_run_sla_violated: Annotated[Optional[StrictBool], Field(description="If true, return Protection Groups for which last run SLA was violated.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which objects are to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        include_last_run_info: Annotated[Optional[StrictBool], Field(description="If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.")] = None,
        prune_excluded_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.")] = None,
        prune_source_ids: Annotated[Optional[StrictBool], Field(description="If true, the response will exclude the list of source IDs within the group specified.")] = None,
        use_cached_data: Annotated[Optional[StrictBool], Field(description="Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.")] = None,
        source_ids: Annotated[Optional[List[StrictInt]], Field(description="Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.")] = None,
        max_result_count: Annotated[Optional[StrictInt], Field(description="Identifies the max number of items to be returned. This is specifically to be used with pagination.")] = None,
        pagination_cookie: Annotated[Optional[StrictStr], Field(description="Specifies the cookie to fetch the set page of results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of Protection Groups.

        Get the list of Protection Groups.

        :param request_initiator_type: Specifies the type of request from UI, which is used for services like magneto to determine the priority of requests.
        :type request_initiator_type: str
        :param ids: Filter by a list of Protection Group ids.
        :type ids: List[str]
        :param names: Filter by a list of Protection Group names.
        :type names: List[str]
        :param policy_ids: Filter by Policy ids that are associated with Protection Groups. Only Protection Groups associated with the specified Policy ids, are returned.
        :type policy_ids: List[str]
        :param storage_domain_id: Filter by Storage Domain id. Only Protection Groups writing data to this Storage Domain will be returned.
        :type storage_domain_id: int
        :param include_groups_with_datalock_only: Whether to only return Protection Groups with a datalock.
        :type include_groups_with_datalock_only: bool
        :param environments: Filter by environment types such as 'kVMware', 'kView', etc. Only Protection Groups protecting the specified environment types are returned.
        :type environments: List[str]
        :param office365_workloads:
        :type office365_workloads: List[str]
        :param is_active: Filter by Inactive or Active Protection Groups. If not set, all Inactive and Active Protection Groups are returned. If true, only Active Protection Groups are returned. If false, only Inactive Protection Groups are returned. When you create a Protection Group on a Primary Cluster with a replication schedule, the Cluster creates an Inactive copy of the Protection Group on the Remote Cluster. In addition, when an Active and running Protection Group is deactivated, the Protection Group becomes Inactive.
        :type is_active: bool
        :param is_deleted: If true, return only Protection Groups that have been deleted but still have Snapshots associated with them. If false, return all Protection Groups except those Protection Groups that have been deleted and still have Snapshots associated with them. A Protection Group that is deleted with all its Snapshots is not returned for either of these cases.
        :type is_deleted: bool
        :param is_paused: Filter by paused or non paused Protection Groups, If not set, all paused and non paused Protection Groups are returned. If true, only paused Protection Groups are returned. If false, only non paused Protection Groups are returned.
        :type is_paused: bool
        :param last_run_local_backup_status: Filter by last local backup run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_local_backup_status: List[str]
        :param last_run_replication_status: Filter by last remote replication run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_replication_status: List[str]
        :param last_run_archival_status: Filter by last cloud archival run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_archival_status: List[str]
        :param last_run_cloud_spin_status: Filter by last cloud spin run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_cloud_spin_status: List[str]
        :param last_run_any_status: Filter by last any run status.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Paused' indicates that the ongoing run has been paused.<br> 'Skipped' indicates that the run was skipped.
        :type last_run_any_status: List[str]
        :param is_last_run_sla_violated: If true, return Protection Groups for which last run SLA was violated.
        :type is_last_run_sla_violated: bool
        :param tenant_ids: TenantIds contains ids of the tenants for which objects are to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param include_last_run_info: If true, the response will include last run info. If it is false or not specified, the last run info won't be returned.
        :type include_last_run_info: bool
        :param prune_excluded_source_ids: If true, the response will not include the list of excluded source IDs in groups that contain this field. This can be set to true in order to improve performance if excluded source IDs are not needed by the user.
        :type prune_excluded_source_ids: bool
        :param prune_source_ids: If true, the response will exclude the list of source IDs within the group specified.
        :type prune_source_ids: bool
        :param use_cached_data: Specifies whether we can serve the GET request from the read replica cache. There is a lag of 15 seconds between the read replica and primary data source.
        :type use_cached_data: bool
        :param source_ids: Filter by Source ids that are associated with Protection Groups. Only Protection Groups associated with the specified Source ids, are returned.
        :type source_ids: List[int]
        :param max_result_count: Identifies the max number of items to be returned. This is specifically to be used with pagination.
        :type max_result_count: int
        :param pagination_cookie: Specifies the cookie to fetch the set page of results
        :type pagination_cookie: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_groups_serialize(
            request_initiator_type=request_initiator_type,
            ids=ids,
            names=names,
            policy_ids=policy_ids,
            storage_domain_id=storage_domain_id,
            include_groups_with_datalock_only=include_groups_with_datalock_only,
            environments=environments,
            office365_workloads=office365_workloads,
            is_active=is_active,
            is_deleted=is_deleted,
            is_paused=is_paused,
            last_run_local_backup_status=last_run_local_backup_status,
            last_run_replication_status=last_run_replication_status,
            last_run_archival_status=last_run_archival_status,
            last_run_cloud_spin_status=last_run_cloud_spin_status,
            last_run_any_status=last_run_any_status,
            is_last_run_sla_violated=is_last_run_sla_violated,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_last_run_info=include_last_run_info,
            prune_excluded_source_ids=prune_excluded_source_ids,
            prune_source_ids=prune_source_ids,
            use_cached_data=use_cached_data,
            source_ids=source_ids,
            max_result_count=max_result_count,
            pagination_cookie=pagination_cookie,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroups",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_groups_serialize(
        self,
        request_initiator_type,
        ids,
        names,
        policy_ids,
        storage_domain_id,
        include_groups_with_datalock_only,
        environments,
        office365_workloads,
        is_active,
        is_deleted,
        is_paused,
        last_run_local_backup_status,
        last_run_replication_status,
        last_run_archival_status,
        last_run_cloud_spin_status,
        last_run_any_status,
        is_last_run_sla_violated,
        tenant_ids,
        include_tenants,
        include_last_run_info,
        prune_excluded_source_ids,
        prune_source_ids,
        use_cached_data,
        source_ids,
        max_result_count,
        pagination_cookie,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'ids': 'csv',
            'names': 'csv',
            'policyIds': 'csv',
            'environments': 'csv',
            'office365Workloads': 'csv',
            'lastRunLocalBackupStatus': 'csv',
            'lastRunReplicationStatus': 'csv',
            'lastRunArchivalStatus': 'csv',
            'lastRunCloudSpinStatus': 'csv',
            'lastRunAnyStatus': 'csv',
            'tenantIds': 'csv',
            'sourceIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ids is not None:
            
            _query_params.append(('ids', ids))
            
        if names is not None:
            
            _query_params.append(('names', names))
            
        if policy_ids is not None:
            
            _query_params.append(('policyIds', policy_ids))
            
        if storage_domain_id is not None:
            
            _query_params.append(('storageDomainId', storage_domain_id))
            
        if include_groups_with_datalock_only is not None:
            
            _query_params.append(('includeGroupsWithDatalockOnly', include_groups_with_datalock_only))
            
        if environments is not None:
            
            _query_params.append(('environments', environments))
            
        if office365_workloads is not None:
            
            _query_params.append(('office365Workloads', office365_workloads))
            
        if is_active is not None:
            
            _query_params.append(('isActive', is_active))
            
        if is_deleted is not None:
            
            _query_params.append(('isDeleted', is_deleted))
            
        if is_paused is not None:
            
            _query_params.append(('isPaused', is_paused))
            
        if last_run_local_backup_status is not None:
            
            _query_params.append(('lastRunLocalBackupStatus', last_run_local_backup_status))
            
        if last_run_replication_status is not None:
            
            _query_params.append(('lastRunReplicationStatus', last_run_replication_status))
            
        if last_run_archival_status is not None:
            
            _query_params.append(('lastRunArchivalStatus', last_run_archival_status))
            
        if last_run_cloud_spin_status is not None:
            
            _query_params.append(('lastRunCloudSpinStatus', last_run_cloud_spin_status))
            
        if last_run_any_status is not None:
            
            _query_params.append(('lastRunAnyStatus', last_run_any_status))
            
        if is_last_run_sla_violated is not None:
            
            _query_params.append(('isLastRunSlaViolated', is_last_run_sla_violated))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_last_run_info is not None:
            
            _query_params.append(('includeLastRunInfo', include_last_run_info))
            
        if prune_excluded_source_ids is not None:
            
            _query_params.append(('pruneExcludedSourceIds', prune_excluded_source_ids))
            
        if prune_source_ids is not None:
            
            _query_params.append(('pruneSourceIds', prune_source_ids))
            
        if use_cached_data is not None:
            
            _query_params.append(('useCachedData', use_cached_data))
            
        if source_ids is not None:
            
            _query_params.append(('sourceIds', source_ids))
            
        if max_result_count is not None:
            
            _query_params.append(('maxResultCount', max_result_count))
            
        if pagination_cookie is not None:
            
            _query_params.append(('paginationCookie', pagination_cookie))
            
        # process the header parameters
        if request_initiator_type is not None:
            _header_params['requestInitiatorType'] = request_initiator_type
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_run_progress(
        self,
        run_id: Annotated[StrictStr, Field(description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        include_event_logs: Annotated[Optional[StrictBool], Field(description="Specifies whether to include event logs")] = None,
        max_log_level: Annotated[Optional[StrictInt], Field(description="Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetProtectionRunProgressBody:
        """Get the progress of a run.

        Get the progress of a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param include_event_logs: Specifies whether to include event logs
        :type include_event_logs: bool
        :param max_log_level: Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.
        :type max_log_level: int
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_progress_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            include_event_logs=include_event_logs,
            max_log_level=max_log_level,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunProgressBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_run_progress_with_http_info(
        self,
        run_id: Annotated[StrictStr, Field(description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        include_event_logs: Annotated[Optional[StrictBool], Field(description="Specifies whether to include event logs")] = None,
        max_log_level: Annotated[Optional[StrictInt], Field(description="Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetProtectionRunProgressBody]:
        """Get the progress of a run.

        Get the progress of a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param include_event_logs: Specifies whether to include event logs
        :type include_event_logs: bool
        :param max_log_level: Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.
        :type max_log_level: int
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_progress_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            include_event_logs=include_event_logs,
            max_log_level=max_log_level,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunProgressBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_run_progress_without_preload_content(
        self,
        run_id: Annotated[StrictStr, Field(description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        include_event_logs: Annotated[Optional[StrictBool], Field(description="Specifies whether to include event logs")] = None,
        max_log_level: Annotated[Optional[StrictInt], Field(description="Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the progress of a run.

        Get the progress of a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose progress will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run progress will not be returned and only the progress of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the progress task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the progress task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param include_event_logs: Specifies whether to include event logs
        :type include_event_logs: bool
        :param max_log_level: Specifies the number of levels till which to fetch the event logs. This is applicable only when includeEventLogs is true.
        :type max_log_level: int
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if progress of a protection group with one or more object is required.If provided this will be used to fetch progress details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch progress details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_progress_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            include_event_logs=include_event_logs,
            max_log_level=max_log_level,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunProgressBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_run_progress_serialize(
        self,
        run_id,
        objects,
        tenant_ids,
        include_tenants,
        include_finished_tasks,
        start_time_usecs,
        end_time_usecs,
        max_tasks_num,
        exclude_object_details,
        include_event_logs,
        max_log_level,
        run_task_path,
        object_task_paths,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'objects': 'csv',
            'tenantIds': 'csv',
            'objectTaskPaths': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if run_id is not None:
            _path_params['runId'] = run_id
        # process the query parameters
        if objects is not None:
            
            _query_params.append(('objects', objects))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_finished_tasks is not None:
            
            _query_params.append(('includeFinishedTasks', include_finished_tasks))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if max_tasks_num is not None:
            
            _query_params.append(('maxTasksNum', max_tasks_num))
            
        if exclude_object_details is not None:
            
            _query_params.append(('excludeObjectDetails', exclude_object_details))
            
        if include_event_logs is not None:
            
            _query_params.append(('includeEventLogs', include_event_logs))
            
        if max_log_level is not None:
            
            _query_params.append(('maxLogLevel', max_log_level))
            
        if run_task_path is not None:
            
            _query_params.append(('runTaskPath', run_task_path))
            
        if object_task_paths is not None:
            
            _query_params.append(('objectTaskPaths', object_task_paths))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/runs/{runId}/progress',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_run_stats(
        self,
        run_id: Annotated[str, Field(strict=True, max_length=255, description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GetProtectionRunStatsBody:
        """Get the stats for a run.

        Get the stats for a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_stats_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunStatsBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_run_stats_with_http_info(
        self,
        run_id: Annotated[str, Field(strict=True, max_length=255, description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GetProtectionRunStatsBody]:
        """Get the stats for a run.

        Get the stats for a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_stats_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunStatsBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_run_stats_without_preload_content(
        self,
        run_id: Annotated[str, Field(strict=True, max_length=255, description="Specifies a unique run id of the Protection Run.")],
        objects: Annotated[Optional[List[StrictInt]], Field(description="Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="TenantIds contains ids of the tenants for which the run is to be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.")] = None,
        include_finished_tasks: Annotated[Optional[StrictBool], Field(description="Specifies whether to return finished tasks. By default only active tasks are returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).")] = None,
        max_tasks_num: Annotated[Optional[StrictInt], Field(description="Specifies the maximum number of tasks to return.")] = None,
        exclude_object_details: Annotated[Optional[StrictBool], Field(description="Specifies whether to return objects. By default all the task tree are returned.")] = None,
        run_task_path: Annotated[Optional[StrictStr], Field(description="Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.")] = None,
        object_task_paths: Annotated[Optional[List[StrictStr]], Field(description="Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the stats for a run.

        Get the stats for a run.

        :param run_id: Specifies a unique run id of the Protection Run. (required)
        :type run_id: str
        :param objects: Specifies the objects whose stats will be returned. This only applies to protection group runs and will be ignored for object runs. If the objects are specified, the run stats will not be returned and only the stats of the specified objects will be returned.
        :type objects: List[int]
        :param tenant_ids: TenantIds contains ids of the tenants for which the run is to be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Group Runs which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned. If it's not specified, it is true by default.
        :type include_tenants: bool
        :param include_finished_tasks: Specifies whether to return finished tasks. By default only active tasks are returned.
        :type include_finished_tasks: bool
        :param start_time_usecs: Specifies the time after which the stats task starts in Unix epoch Timestamp(in microseconds).
        :type start_time_usecs: int
        :param end_time_usecs: Specifies the time before which the stats task ends in Unix epoch Timestamp(in microseconds).
        :type end_time_usecs: int
        :param max_tasks_num: Specifies the maximum number of tasks to return.
        :type max_tasks_num: int
        :param exclude_object_details: Specifies whether to return objects. By default all the task tree are returned.
        :type exclude_object_details: bool
        :param run_task_path: Specifies the task path of the run or object run. This is applicable only if stats of a protection group with one or more object is required. If provided this will be used to fetch stats details directly without looking actual task path of the object. Objects field is stil expected else it changes the response format.
        :type run_task_path: str
        :param object_task_paths: Specifies the object level task path. This relates to the objectID. If provided this will take precedence over the objects, and will be used to fetch stats details directly without looking actuall task path of the object.
        :type object_task_paths: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_run_stats_serialize(
            run_id=run_id,
            objects=objects,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            include_finished_tasks=include_finished_tasks,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            max_tasks_num=max_tasks_num,
            exclude_object_details=exclude_object_details,
            run_task_path=run_task_path,
            object_task_paths=object_task_paths,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GetProtectionRunStatsBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_run_stats_serialize(
        self,
        run_id,
        objects,
        tenant_ids,
        include_tenants,
        include_finished_tasks,
        start_time_usecs,
        end_time_usecs,
        max_tasks_num,
        exclude_object_details,
        run_task_path,
        object_task_paths,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'objects': 'csv',
            'tenantIds': 'csv',
            'objectTaskPaths': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if run_id is not None:
            _path_params['runId'] = run_id
        # process the query parameters
        if objects is not None:
            
            _query_params.append(('objects', objects))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if include_finished_tasks is not None:
            
            _query_params.append(('includeFinishedTasks', include_finished_tasks))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if max_tasks_num is not None:
            
            _query_params.append(('maxTasksNum', max_tasks_num))
            
        if exclude_object_details is not None:
            
            _query_params.append(('excludeObjectDetails', exclude_object_details))
            
        if run_task_path is not None:
            
            _query_params.append(('runTaskPath', run_task_path))
            
        if object_task_paths is not None:
            
            _query_params.append(('objectTaskPaths', object_task_paths))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/runs/{runId}/stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_protection_runs(
        self,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionRunsSummary:
        """Get the list of runs.

        Get a list of protection runs.

        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param run_status: Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.
        :type run_status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_runs_serialize(
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            run_status=run_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionRunsSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_protection_runs_with_http_info(
        self,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionRunsSummary]:
        """Get the list of runs.

        Get a list of protection runs.

        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param run_status: Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.
        :type run_status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_runs_serialize(
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            run_status=run_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionRunsSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_protection_runs_without_preload_content(
        self,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.")] = None,
        run_status: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the list of runs.

        Get a list of protection runs.

        :param start_time_usecs: Start time for time range filter. Specify the start time as a Unix epoch Timestamp (in microseconds), only runs executing after this time will be returned. By default it is endTimeUsecs minus an hour.
        :type start_time_usecs: int
        :param end_time_usecs: End time for time range filter. Specify the end time as a Unix epoch Timestamp (in microseconds), only runs executing before this time will be returned. By default it is current time.
        :type end_time_usecs: int
        :param run_status: Specifies a list of status, runs matching the status will be returned.<br> 'Running' indicates that the run is still running.<br> 'Canceled' indicates that the run has been canceled.<br> 'Canceling' indicates that the run is in the process of being canceled.<br> 'Failed' indicates that the run has failed.<br> 'Missed' indicates that the run was unable to take place at the scheduled time because the previous run was still happening.<br> 'Succeeded' indicates that the run has finished successfully.<br> 'SucceededWithWarning' indicates that the run finished successfully, but there were some warning messages.<br> 'Skipped' indicates that the run was skipped.
        :type run_status: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_protection_runs_serialize(
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            run_status=run_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionRunsSummary",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_protection_runs_serialize(
        self,
        start_time_usecs,
        end_time_usecs,
        run_status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'runStatus': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if run_status is not None:
            
            _query_params.append(('runStatus', run_status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/runs/summary',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_run_debug_logs(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[Optional[StrictStr], Field(description="Specifies the id of the object for which debug logs are to be returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get the debug logs for a run from a Protection Group.

        Get the debug logs for all objects of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned. 
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_run_debug_logs_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[Optional[StrictStr], Field(description="Specifies the id of the object for which debug logs are to be returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get the debug logs for a run from a Protection Group.

        Get the debug logs for all objects of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned. 
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_run_debug_logs_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[Optional[StrictStr], Field(description="Specifies the id of the object for which debug logs are to be returned. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the debug logs for a run from a Protection Group.

        Get the debug logs for all objects of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned. 
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_run_debug_logs_serialize(
        self,
        id,
        run_id,
        object_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        # process the query parameters
        if object_id is not None:
            
            _query_params.append(('objectId', object_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs/{runId}/debug-logs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_run_debug_logs_for_object(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which debug logs are to be returned. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get the debug logs for a particular object in a run from a Protection Group.

        Get the debug logs for a particular object of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned.  (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_for_object_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_run_debug_logs_for_object_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which debug logs are to be returned. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get the debug logs for a particular object in a run from a Protection Group.

        Get the debug logs for a particular object of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned.  (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_for_object_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_run_debug_logs_for_object_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which debug logs are to be returned. ")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the debug logs for a particular object in a run from a Protection Group.

        Get the debug logs for a particular object of a run for a particular Protection Group.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which debug logs are to be returned.  (required)
        :type object_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_debug_logs_for_object_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_run_debug_logs_for_object_serialize(
        self,
        id,
        run_id,
        object_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/debug-logs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_run_messages_report(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get the CSV of various Proto Messages for a given run and an object.

        Get an CSV report for given objectId and run id. Each row in CSV report contains the fields from correspoinding proto message.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_messages_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_run_messages_report_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get the CSV of various Proto Messages for a given run and an object.

        Get an CSV report for given objectId and run id. Each row in CSV report contains the fields from correspoinding proto message.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_messages_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_run_messages_report_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the CSV of various Proto Messages for a given run and an object.

        Get an CSV report for given objectId and run id. Each row in CSV report contains the fields from correspoinding proto message.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: inclusion_exclusion_reports, error_files_list. default: error_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_run_messages_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_run_messages_report_serialize(
        self,
        id,
        run_id,
        object_id,
        file_type,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        if file_type is not None:
            
            _query_params.append(('fileType', file_type))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/download-messages',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_runs_report(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: success_files_list, default: success_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Get the CSV of errors/warnings for a given run and an object.

        Get an CSV report for given objectId and run id. Report will depend on the query parameter fileType, default will be: success_files_list where each row contains the name of file backedup successfully.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: success_files_list, default: success_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_runs_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_runs_report_with_http_info(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: success_files_list, default: success_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Get the CSV of errors/warnings for a given run and an object.

        Get an CSV report for given objectId and run id. Report will depend on the query parameter fileType, default will be: success_files_list where each row contains the name of file backedup successfully.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: success_files_list, default: success_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_runs_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_runs_report_without_preload_content(
        self,
        id: Annotated[str, Field(strict=True, description="Specifies a unique id of the Protection Group.")],
        run_id: Annotated[str, Field(strict=True, description="Specifies a unique run id of the Protection Group run.")],
        object_id: Annotated[StrictStr, Field(description="Specifies the id of the object for which errors/warnings are to be returned. ")],
        file_type: Annotated[Optional[StrictStr], Field(description="Specifies the downloaded type, i.e: success_files_list, default: success_files_list")] = None,
        name: Annotated[Optional[StrictStr], Field(description="Specifies the name of the source being backed up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the CSV of errors/warnings for a given run and an object.

        Get an CSV report for given objectId and run id. Report will depend on the query parameter fileType, default will be: success_files_list where each row contains the name of file backedup successfully.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param run_id: Specifies a unique run id of the Protection Group run. (required)
        :type run_id: str
        :param object_id: Specifies the id of the object for which errors/warnings are to be returned.  (required)
        :type object_id: str
        :param file_type: Specifies the downloaded type, i.e: success_files_list, default: success_files_list
        :type file_type: str
        :param name: Specifies the name of the source being backed up
        :type name: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_runs_report_serialize(
            id=id,
            run_id=run_id,
            object_id=object_id,
            file_type=file_type,
            name=name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_runs_report_serialize(
        self,
        id,
        run_id,
        object_id,
        file_type,
        name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        if run_id is not None:
            _path_params['runId'] = run_id
        if object_id is not None:
            _path_params['objectId'] = object_id
        # process the query parameters
        if file_type is not None:
            
            _query_params.append(('fileType', file_type))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/data-protect/protection-groups/{id}/runs/{runId}/objects/{objectId}/downloadFiles',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def perform_action_on_protection_group_run(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[PerformActionOnProtectionGroupRunRequest, Field(description="Specifies the parameters to perform an action on a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PerformRunActionResponse:
        """Actions on protection group run.

        Perform various actions on a Protection Group run.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to perform an action on a protection run. (required)
        :type body: PerformActionOnProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "PerformRunActionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def perform_action_on_protection_group_run_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[PerformActionOnProtectionGroupRunRequest, Field(description="Specifies the parameters to perform an action on a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PerformRunActionResponse]:
        """Actions on protection group run.

        Perform various actions on a Protection Group run.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to perform an action on a protection run. (required)
        :type body: PerformActionOnProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "PerformRunActionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def perform_action_on_protection_group_run_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[PerformActionOnProtectionGroupRunRequest, Field(description="Specifies the parameters to perform an action on a protection run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Actions on protection group run.

        Perform various actions on a Protection Group run.

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to perform an action on a protection run. (required)
        :type body: PerformActionOnProtectionGroupRunRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._perform_action_on_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '202': "PerformRunActionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _perform_action_on_protection_group_run_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/protection-groups/{id}/runs/actions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_protection_group(
        self,
        id: Annotated[StrictStr, Field(description="Specifies the id of the Protection Group.")],
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to update a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProtectionGroup:
        """Update a Protection Group.

        Update the specified Protection Group.

        :param id: Specifies the id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_protection_group_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies the id of the Protection Group.")],
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to update a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProtectionGroup]:
        """Update a Protection Group.

        Update the specified Protection Group.

        :param id: Specifies the id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_protection_group_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies the id of the Protection Group.")],
        body: Annotated[CreateOrUpdateProtectionGroupRequest, Field(description="Specifies the parameters to update a Protection Group.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a Protection Group.

        Update the specified Protection Group.

        :param id: Specifies the id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group. (required)
        :type body: CreateOrUpdateProtectionGroupRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProtectionGroup",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_protection_group_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-protect/protection-groups/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_protection_group_run(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[UpdateProtectionGroupRunRequestBody, Field(description="Specifies the parameters to update a Protection Group Run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateProtectionGroupRunResponseBody:
        """Update runs for a particular Protection Group.

        Update runs for a particular Protection Group. A user can perform the following actions: 1. Extend or reduce retention of a local, replication and archival snapshots. 2. Can perform resync operation on failed copy snapshots attempts in this Run. 3. Add new replication and archival snapshot targets to the Run. 4. Add or remove legal hold on the snapshots. Only a user with DSO role can perform this operation. 5. Delete the snapshots that were created as a part of this Run. 6. Apply datalock on existing snapshots where a user cannot manually delete snapshots before the expiry time. 

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group Run. (required)
        :type body: UpdateProtectionGroupRunRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "UpdateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_protection_group_run_with_http_info(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[UpdateProtectionGroupRunRequestBody, Field(description="Specifies the parameters to update a Protection Group Run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateProtectionGroupRunResponseBody]:
        """Update runs for a particular Protection Group.

        Update runs for a particular Protection Group. A user can perform the following actions: 1. Extend or reduce retention of a local, replication and archival snapshots. 2. Can perform resync operation on failed copy snapshots attempts in this Run. 3. Add new replication and archival snapshot targets to the Run. 4. Add or remove legal hold on the snapshots. Only a user with DSO role can perform this operation. 5. Delete the snapshots that were created as a part of this Run. 6. Apply datalock on existing snapshots where a user cannot manually delete snapshots before the expiry time. 

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group Run. (required)
        :type body: UpdateProtectionGroupRunRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "UpdateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_protection_group_run_without_preload_content(
        self,
        id: Annotated[StrictStr, Field(description="Specifies a unique id of the Protection Group.")],
        body: Annotated[UpdateProtectionGroupRunRequestBody, Field(description="Specifies the parameters to update a Protection Group Run.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update runs for a particular Protection Group.

        Update runs for a particular Protection Group. A user can perform the following actions: 1. Extend or reduce retention of a local, replication and archival snapshots. 2. Can perform resync operation on failed copy snapshots attempts in this Run. 3. Add new replication and archival snapshot targets to the Run. 4. Add or remove legal hold on the snapshots. Only a user with DSO role can perform this operation. 5. Delete the snapshots that were created as a part of this Run. 6. Apply datalock on existing snapshots where a user cannot manually delete snapshots before the expiry time. 

        :param id: Specifies a unique id of the Protection Group. (required)
        :type id: str
        :param body: Specifies the parameters to update a Protection Group Run. (required)
        :type body: UpdateProtectionGroupRunRequestBody
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_group_run_serialize(
            id=id,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '207': "UpdateProtectionGroupRunResponseBody",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_protection_group_run_serialize(
        self,
        id,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/data-protect/protection-groups/{id}/runs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_protection_groups_state(
        self,
        body: Annotated[UpdateProtectionGroupsStateRequest, Field(description="Specifies the parameters to perform an action of list of Protection Groups.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateProtectionGroupsState:
        """Perform an action like pause, resume, active, deactivate on all specified Protection Groups.

        Perform an action like pause, resume, active, deactivate on all specified Protection Groups. Note that the pause or resume actions will take effect from next Protection Run. Also, user can specify only one type of action on all the Protection Groups. Deactivate and activate actions are independent of pause and resume state. Deactivate and activate actions are useful in case of failover situations. Returns success if the state of all the Protection Groups state is changed successfully.

        :param body: Specifies the parameters to perform an action of list of Protection Groups. (required)
        :type body: UpdateProtectionGroupsStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_groups_state_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateProtectionGroupsState",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_protection_groups_state_with_http_info(
        self,
        body: Annotated[UpdateProtectionGroupsStateRequest, Field(description="Specifies the parameters to perform an action of list of Protection Groups.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateProtectionGroupsState]:
        """Perform an action like pause, resume, active, deactivate on all specified Protection Groups.

        Perform an action like pause, resume, active, deactivate on all specified Protection Groups. Note that the pause or resume actions will take effect from next Protection Run. Also, user can specify only one type of action on all the Protection Groups. Deactivate and activate actions are independent of pause and resume state. Deactivate and activate actions are useful in case of failover situations. Returns success if the state of all the Protection Groups state is changed successfully.

        :param body: Specifies the parameters to perform an action of list of Protection Groups. (required)
        :type body: UpdateProtectionGroupsStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_groups_state_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateProtectionGroupsState",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_protection_groups_state_without_preload_content(
        self,
        body: Annotated[UpdateProtectionGroupsStateRequest, Field(description="Specifies the parameters to perform an action of list of Protection Groups.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Perform an action like pause, resume, active, deactivate on all specified Protection Groups.

        Perform an action like pause, resume, active, deactivate on all specified Protection Groups. Note that the pause or resume actions will take effect from next Protection Run. Also, user can specify only one type of action on all the Protection Groups. Deactivate and activate actions are independent of pause and resume state. Deactivate and activate actions are useful in case of failover situations. Returns success if the state of all the Protection Groups state is changed successfully.

        :param body: Specifies the parameters to perform an action of list of Protection Groups. (required)
        :type body: UpdateProtectionGroupsStateRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_protection_groups_state_serialize(
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UpdateProtectionGroupsState",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_protection_groups_state_serialize(
        self,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader', 
            'SessionIdHeader', 
            'Bearer'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/data-protect/protection-groups/states',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


