# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from typing_extensions import Self

class Subnet(BaseModel):
    """
    Defines a Subnet (Subnetwork). The netmask can be specified by setting netmaskBits or netmaskIp4. The netmask can only be set using netmaskIp4 if the IP address is an IPv4 address.
    """ # noqa: E501
    component: Optional[StrictStr] = Field(default=None, description="Component that has reserved the subnet.")
    description: Optional[StrictStr] = Field(default=None, description="Description of the subnet.")
    gateway: Optional[StrictStr] = Field(default=None, description="Gateway for the subnet.")
    id: Optional[StrictInt] = Field(default=None, description="ID of the subnet.")
    ip: Optional[StrictStr] = Field(default=None, description="Specifies either an IPv6 address or an IPv4 address.")
    netmask_bits: Optional[StrictInt] = Field(default=None, description="Specifies the netmask using bits.", alias="netmaskBits")
    netmask_ip4: Optional[StrictStr] = Field(default=None, description="Specifies the netmask using an IP4 address. The netmask can only be set using netmaskIp4 if the IP address is an IPv4 address.", alias="netmaskIp4")
    nfs_access: Optional[StrictStr] = Field(default=None, description="Specifies whether clients from this subnet can mount using NFS protocol. Protocol access level. 'kDisabled' indicates Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite' indicates Protocol access level 'ReadWrite'", alias="nfsAccess")
    nfs_squash: Optional[StrictStr] = Field(default=None, description="Specifies which nfsSquash Mounted. 'kNone' mounts none. 'kRootSquash' mounts nfsRootSquash. Whether clients from this subnet can mount as root on NFS. 'kAllSquash' mounts nfsAllSquash. Whether all clients from this subnet can map view with view_all_squash_uid/view_all_squash_gid configured in the view.", alias="nfsSquash")
    s3_access: Optional[StrictStr] = Field(default=None, description="Specifies whether clients from this subnet can access using S3 protocol. Protocol access level. 'kDisabled' indicates Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite' indicates Protocol access level 'ReadWrite'", alias="s3Access")
    smb_access: Optional[StrictStr] = Field(default=None, description="Specifies whether clients from this subnet can mount using SMB protocol. Protocol access level. 'kDisabled' indicates Protocol access level 'Disabled' 'kReadOnly' indicates Protocol access level 'ReadOnly' 'kReadWrite' indicates Protocol access level 'ReadWrite'", alias="smbAccess")
    __properties: ClassVar[List[str]] = ["component", "description", "gateway", "id", "ip", "netmaskBits", "netmaskIp4", "nfsAccess", "nfsSquash", "s3Access", "smbAccess"]

    @field_validator('nfs_access')
    def nfs_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kDisabled', 'kReadOnly', 'kReadWrite']):
            raise ValueError("must be one of enum values ('kDisabled', 'kReadOnly', 'kReadWrite')")
        return value

    @field_validator('nfs_squash')
    def nfs_squash_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kNone', 'kRootSquash', 'kAllSquash']):
            raise ValueError("must be one of enum values ('kNone', 'kRootSquash', 'kAllSquash')")
        return value

    @field_validator('s3_access')
    def s3_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kDisabled', 'kReadOnly', 'kReadWrite']):
            raise ValueError("must be one of enum values ('kDisabled', 'kReadOnly', 'kReadWrite')")
        return value

    @field_validator('smb_access')
    def smb_access_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kDisabled', 'kReadOnly', 'kReadWrite']):
            raise ValueError("must be one of enum values ('kDisabled', 'kReadOnly', 'kReadWrite')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Subnet from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if component (nullable) is None
        # and model_fields_set contains the field
        if self.component is None and "component" in self.model_fields_set:
            _dict['component'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if gateway (nullable) is None
        # and model_fields_set contains the field
        if self.gateway is None and "gateway" in self.model_fields_set:
            _dict['gateway'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if ip (nullable) is None
        # and model_fields_set contains the field
        if self.ip is None and "ip" in self.model_fields_set:
            _dict['ip'] = None

        # set to None if netmask_bits (nullable) is None
        # and model_fields_set contains the field
        if self.netmask_bits is None and "netmask_bits" in self.model_fields_set:
            _dict['netmaskBits'] = None

        # set to None if netmask_ip4 (nullable) is None
        # and model_fields_set contains the field
        if self.netmask_ip4 is None and "netmask_ip4" in self.model_fields_set:
            _dict['netmaskIp4'] = None

        # set to None if nfs_access (nullable) is None
        # and model_fields_set contains the field
        if self.nfs_access is None and "nfs_access" in self.model_fields_set:
            _dict['nfsAccess'] = None

        # set to None if nfs_squash (nullable) is None
        # and model_fields_set contains the field
        if self.nfs_squash is None and "nfs_squash" in self.model_fields_set:
            _dict['nfsSquash'] = None

        # set to None if s3_access (nullable) is None
        # and model_fields_set contains the field
        if self.s3_access is None and "s3_access" in self.model_fields_set:
            _dict['s3Access'] = None

        # set to None if smb_access (nullable) is None
        # and model_fields_set contains the field
        if self.smb_access is None and "smb_access" in self.model_fields_set:
            _dict['smbAccess'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Subnet from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "component": obj.get("component"),
            "description": obj.get("description"),
            "gateway": obj.get("gateway"),
            "id": obj.get("id"),
            "ip": obj.get("ip"),
            "netmaskBits": obj.get("netmaskBits"),
            "netmaskIp4": obj.get("netmaskIp4"),
            "nfsAccess": obj.get("nfsAccess"),
            "nfsSquash": obj.get("nfsSquash"),
            "s3Access": obj.get("s3Access"),
            "smbAccess": obj.get("smbAccess")
        })
        return _obj


