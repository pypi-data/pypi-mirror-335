# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from typing_extensions import Self

class CommonCsrResponseParams(BaseModel):
    """
    Specifies the common response params for a CSR.
    """ # noqa: E501
    city: Optional[StrictStr] = Field(description="Specifies the locality attribute, which is part of the distinguished name definition. It is used to identify the city where the company is located or the Cluster is installed.")
    common_name: Optional[StrictStr] = Field(default=None, description="Specifies the common name attribute, which is part of the distinguished name definition. Common name is used to specify a context for the certificate, for example, the name of the Cluster to which the certificate is to be assigned. Default value is the name of the Cluster.", alias="commonName")
    country_code: Optional[StrictStr] = Field(description="Specifies the country attribute, which is part of the distinguished name definition. It is used to identify the country where the state is located. It is specified as two letter code defined by the ISO standard.", alias="countryCode")
    dns_names: Optional[List[StrictStr]] = Field(default=None, description="Specifies an alternative subject name component to be included in the certificate. It is used to identify the ways the Cluster will be accessed. It is given as a comma separated list of FQDNs. The default value is the Cluster's VIP hostname.", alias="dnsNames")
    email_address: Optional[StrictStr] = Field(default=None, description="Specifies an alternative subject name component to be included in the certificate. Format is a standard e-mail address, for example joe@company.com.", alias="emailAddress")
    host_ips: Optional[List[StrictStr]] = Field(default=None, description="Specifies an alternative subject name component to be included in the certificate. It is used to identify the ways the Cluster will be accessed. It is given as a comma separated list of IP addresses. The default value is the Cluster's VIP addresses.", alias="hostIps")
    key_size_bits: Optional[StrictInt] = Field(default=None, description="Specifies the size of the keys in bits. The default is 2048 bits for the RSA keys and 256 bits for ECDSA.", alias="keySizeBits")
    key_type: Optional[StrictStr] = Field(default='rsa', description="Specifies the algorithm to be used to generate the key pair. RSA is the default value.", alias="keyType")
    organization: Optional[StrictStr] = Field(description="Specifies the organization attribute, which is part of the distinguished name definition. It is used to specify the name of the company.")
    organization_unit: Optional[StrictStr] = Field(description="Specifies the organization unit attribute, which is part of the distinguished name definition. It is used to identify the specific department or business unit in the company that is owning the Cluster.", alias="organizationUnit")
    service_name: Optional[StrictStr] = Field(default='iris', description="Specifies the Cohesity service name for which the CSR is generated. Default service name is iris.", alias="serviceName")
    state: Optional[StrictStr] = Field(description="Specifies the state attribute, which is part of the distinguished name definition. It is used to identify the state where the city is located.")
    csr: Optional[StrictStr] = Field(default=None, description="Specifies the CSR generated for the service.")
    id: Optional[StrictStr] = Field(default=None, description="Specifies the id of the CSR.")
    public_key: Optional[StrictStr] = Field(default=None, description="Specifies the public key generated for this CSR.", alias="publicKey")
    __properties: ClassVar[List[str]] = ["city", "commonName", "countryCode", "dnsNames", "emailAddress", "hostIps", "keySizeBits", "keyType", "organization", "organizationUnit", "serviceName", "state", "csr", "id", "publicKey"]

    @field_validator('key_type')
    def key_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['rsa', 'ecdsa']):
            raise ValueError("must be one of enum values ('rsa', 'ecdsa')")
        return value

    @field_validator('service_name')
    def service_name_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['iris']):
            raise ValueError("must be one of enum values ('iris')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CommonCsrResponseParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if city (nullable) is None
        # and model_fields_set contains the field
        if self.city is None and "city" in self.model_fields_set:
            _dict['city'] = None

        # set to None if common_name (nullable) is None
        # and model_fields_set contains the field
        if self.common_name is None and "common_name" in self.model_fields_set:
            _dict['commonName'] = None

        # set to None if country_code (nullable) is None
        # and model_fields_set contains the field
        if self.country_code is None and "country_code" in self.model_fields_set:
            _dict['countryCode'] = None

        # set to None if dns_names (nullable) is None
        # and model_fields_set contains the field
        if self.dns_names is None and "dns_names" in self.model_fields_set:
            _dict['dnsNames'] = None

        # set to None if email_address (nullable) is None
        # and model_fields_set contains the field
        if self.email_address is None and "email_address" in self.model_fields_set:
            _dict['emailAddress'] = None

        # set to None if host_ips (nullable) is None
        # and model_fields_set contains the field
        if self.host_ips is None and "host_ips" in self.model_fields_set:
            _dict['hostIps'] = None

        # set to None if key_size_bits (nullable) is None
        # and model_fields_set contains the field
        if self.key_size_bits is None and "key_size_bits" in self.model_fields_set:
            _dict['keySizeBits'] = None

        # set to None if key_type (nullable) is None
        # and model_fields_set contains the field
        if self.key_type is None and "key_type" in self.model_fields_set:
            _dict['keyType'] = None

        # set to None if organization (nullable) is None
        # and model_fields_set contains the field
        if self.organization is None and "organization" in self.model_fields_set:
            _dict['organization'] = None

        # set to None if organization_unit (nullable) is None
        # and model_fields_set contains the field
        if self.organization_unit is None and "organization_unit" in self.model_fields_set:
            _dict['organizationUnit'] = None

        # set to None if service_name (nullable) is None
        # and model_fields_set contains the field
        if self.service_name is None and "service_name" in self.model_fields_set:
            _dict['serviceName'] = None

        # set to None if state (nullable) is None
        # and model_fields_set contains the field
        if self.state is None and "state" in self.model_fields_set:
            _dict['state'] = None

        # set to None if csr (nullable) is None
        # and model_fields_set contains the field
        if self.csr is None and "csr" in self.model_fields_set:
            _dict['csr'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if public_key (nullable) is None
        # and model_fields_set contains the field
        if self.public_key is None and "public_key" in self.model_fields_set:
            _dict['publicKey'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CommonCsrResponseParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "city": obj.get("city"),
            "commonName": obj.get("commonName"),
            "countryCode": obj.get("countryCode"),
            "dnsNames": obj.get("dnsNames"),
            "emailAddress": obj.get("emailAddress"),
            "hostIps": obj.get("hostIps"),
            "keySizeBits": obj.get("keySizeBits"),
            "keyType": obj.get("keyType") if obj.get("keyType") is not None else 'rsa',
            "organization": obj.get("organization"),
            "organizationUnit": obj.get("organizationUnit"),
            "serviceName": obj.get("serviceName") if obj.get("serviceName") is not None else 'iris',
            "state": obj.get("state"),
            "csr": obj.get("csr"),
            "id": obj.get("id"),
            "publicKey": obj.get("publicKey")
        })
        return _obj


