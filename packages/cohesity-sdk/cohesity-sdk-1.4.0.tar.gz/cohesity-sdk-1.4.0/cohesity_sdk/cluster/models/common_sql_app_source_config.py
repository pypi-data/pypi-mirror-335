# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from cohesity_sdk.cluster.models.filename_pattern_to_directory import FilenamePatternToDirectory
from cohesity_sdk.cluster.models.multi_stage_restore_options import MultiStageRestoreOptions
from typing import Set
from typing_extensions import Self

class CommonSqlAppSourceConfig(BaseModel):
    """
    Specifies a common parameters used when restroring back to original or new source.
    """ # noqa: E501
    keep_cdc: Optional[StrictBool] = Field(default=None, description="Specifies whether to keep CDC (Change Data Capture) on recovered databases or not. If not passed, this is assumed to be true. If withNoRecovery is passed as true, then this field must not be set to true. Passing this field as true in this scenario will be a invalid request.", alias="keepCdc")
    multi_stage_restore_options: Optional[MultiStageRestoreOptions] = Field(default=None, alias="multiStageRestoreOptions")
    native_recovery_with_clause: Optional[StrictStr] = Field(default=None, description="'with_clause' contains 'with clause' to be used in native sql restore command. This is only applicable for database restore of native sql backup. Here user can specify multiple restore options. Example: 'WITH BUFFERCOUNT = 575, MAXTRANSFERSIZE = 2097152'.", alias="nativeRecoveryWithClause")
    overwriting_policy: Optional[StrictStr] = Field(default=None, description="Specifies a policy to be used while recovering existing databases.", alias="overwritingPolicy")
    replay_entire_last_log: Optional[StrictBool] = Field(default=None, description="Specifies the option to set replay last log bit while creating the sql restore task and doing restore to latest point-in-time. If this is set to true, we will replay the entire last log without STOPAT.", alias="replayEntireLastLog")
    restore_time_usecs: Optional[StrictInt] = Field(default=None, description="Specifies the time in the past to which the Sql database needs to be restored. This allows for granular recovery of Sql databases. If this is not set, the Sql database will be restored from the full/incremental snapshot.", alias="restoreTimeUsecs")
    secondary_data_files_dir_list: Optional[List[FilenamePatternToDirectory]] = Field(default=None, description="Specifies the secondary data filename pattern and corresponding direcories of the DB. Secondary data files are optional and are user defined. The recommended file extention for secondary files is \".ndf\". If this option is specified and the destination folders do not exist they will be automatically created.", alias="secondaryDataFilesDirList")
    with_no_recovery: Optional[StrictBool] = Field(default=None, description="Specifies the flag to bring DBs online or not after successful recovery. If this is passed as true, then it means DBs won't be brought online.", alias="withNoRecovery")
    __properties: ClassVar[List[str]] = ["keepCdc", "multiStageRestoreOptions", "nativeRecoveryWithClause", "overwritingPolicy", "replayEntireLastLog", "restoreTimeUsecs", "secondaryDataFilesDirList", "withNoRecovery"]

    @field_validator('overwriting_policy')
    def overwriting_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['FailIfExists', 'Overwrite']):
            raise ValueError("must be one of enum values ('FailIfExists', 'Overwrite')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CommonSqlAppSourceConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of multi_stage_restore_options
        if self.multi_stage_restore_options:
            _dict['multiStageRestoreOptions'] = self.multi_stage_restore_options.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in secondary_data_files_dir_list (list)
        _items = []
        if self.secondary_data_files_dir_list:
            for _item_secondary_data_files_dir_list in self.secondary_data_files_dir_list:
                if _item_secondary_data_files_dir_list:
                    _items.append(_item_secondary_data_files_dir_list.to_dict())
            _dict['secondaryDataFilesDirList'] = _items
        # set to None if keep_cdc (nullable) is None
        # and model_fields_set contains the field
        if self.keep_cdc is None and "keep_cdc" in self.model_fields_set:
            _dict['keepCdc'] = None

        # set to None if native_recovery_with_clause (nullable) is None
        # and model_fields_set contains the field
        if self.native_recovery_with_clause is None and "native_recovery_with_clause" in self.model_fields_set:
            _dict['nativeRecoveryWithClause'] = None

        # set to None if overwriting_policy (nullable) is None
        # and model_fields_set contains the field
        if self.overwriting_policy is None and "overwriting_policy" in self.model_fields_set:
            _dict['overwritingPolicy'] = None

        # set to None if replay_entire_last_log (nullable) is None
        # and model_fields_set contains the field
        if self.replay_entire_last_log is None and "replay_entire_last_log" in self.model_fields_set:
            _dict['replayEntireLastLog'] = None

        # set to None if restore_time_usecs (nullable) is None
        # and model_fields_set contains the field
        if self.restore_time_usecs is None and "restore_time_usecs" in self.model_fields_set:
            _dict['restoreTimeUsecs'] = None

        # set to None if secondary_data_files_dir_list (nullable) is None
        # and model_fields_set contains the field
        if self.secondary_data_files_dir_list is None and "secondary_data_files_dir_list" in self.model_fields_set:
            _dict['secondaryDataFilesDirList'] = None

        # set to None if with_no_recovery (nullable) is None
        # and model_fields_set contains the field
        if self.with_no_recovery is None and "with_no_recovery" in self.model_fields_set:
            _dict['withNoRecovery'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CommonSqlAppSourceConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "keepCdc": obj.get("keepCdc"),
            "multiStageRestoreOptions": MultiStageRestoreOptions.from_dict(obj["multiStageRestoreOptions"]) if obj.get("multiStageRestoreOptions") is not None else None,
            "nativeRecoveryWithClause": obj.get("nativeRecoveryWithClause"),
            "overwritingPolicy": obj.get("overwritingPolicy"),
            "replayEntireLastLog": obj.get("replayEntireLastLog"),
            "restoreTimeUsecs": obj.get("restoreTimeUsecs"),
            "secondaryDataFilesDirList": [FilenamePatternToDirectory.from_dict(_item) for _item in obj["secondaryDataFilesDirList"]] if obj.get("secondaryDataFilesDirList") is not None else None,
            "withNoRecovery": obj.get("withNoRecovery")
        })
        return _obj


