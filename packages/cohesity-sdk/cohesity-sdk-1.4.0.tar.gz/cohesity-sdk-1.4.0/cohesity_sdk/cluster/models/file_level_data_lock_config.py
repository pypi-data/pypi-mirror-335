# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from typing_extensions import Self

class FileLevelDataLockConfig(BaseModel):
    """
    Specifies a config to lock files in a view - to protect from malicious or an accidental attempt to delete or modify the files in this view.
    """ # noqa: E501
    auto_lock_after_duration_idle_msecs: Optional[StrictInt] = Field(default=None, description="Specifies the duration to lock a file that has not been accessed or modified (ie. has been idle) for a certain duration of time in milliseconds. Do not set if it is required to disable auto lock.", alias="autoLockAfterDurationIdleMsecs")
    coexisting_lock_mode: Optional[StrictBool] = Field(default=None, description="Specified if files in the View can be locked in different modes. This property is immutable and can only be set when enabling File level datalock. If this property is set for an S3 View, S3 bucket Versioning should also be enabled.", alias="coexistingLockMode")
    default_retention_duration_msecs: Optional[StrictInt] = Field(default=None, description="Specifies a global default retention duration for files in this view, if file lock is enabled for this view. Also, it is a required field if file lock is enabled. Set to -1 if the required default retention period is forever.", alias="defaultRetentionDurationMsecs")
    default_retention_duration_years: Optional[StrictInt] = Field(default=None, description="Specifies a global default retention duration in years for files in this view, if file/object lock is enabled for this view.", alias="defaultRetentionDurationYears")
    expiry_timestamp_msecs: Optional[StrictInt] = Field(default=None, description="Specifies a definite timestamp in milliseconds for retaining the file.", alias="expiryTimestampMsecs")
    locking_protocol: Optional[StrictStr] = Field(default=None, description="Specifies the supported mechanisms to explicity lock a file from NFS/SMB interface. Supported locking protocols: SetReadOnly, SetAtime. 'SetReadOnly' is compatible with Isilon/Netapp behaviour. This locks the file and the retention duration is determined in this order: 1) atime, if set by user/application and within min and max retention duration. 2) Min retention duration, if set. 3) Otherwise, file is switched to expired data automatically. 'SetAtime' is compatible with Data Domain behaviour.", alias="lockingProtocol")
    max_retention_duration_msecs: Optional[StrictInt] = Field(default=None, description="Specifies a maximum duration in milliseconds for which any file in this view can be retained for. Set to -1 if the required retention duration is forever. If set, it should be greater than or equal to the default retention period as well as the min retention period.", alias="maxRetentionDurationMsecs")
    min_retention_duration_msecs: Optional[StrictInt] = Field(default=None, description="Specifies a minimum retention duration in milliseconds after a file gets locked. The file cannot be modified or deleted during this timeframe. Set to -1 if the required retention duration is forever. This should be set less than or equal to the default retention duration.", alias="minRetentionDurationMsecs")
    mode: Optional[StrictStr] = Field(default=None, description="Specifies the mode of file level datalock. Enterprise mode can be upgraded to Compliance mode, but Compliance mode cannot be downgraded to Enterprise mode. Compliance: This mode would disallow all user to delete/modify file or view under any condition when it 's in locked status except for deleting view when the view is empty. Enterprise: This mode would follow the rules as compliance mode for normal users. But it would allow the storage admin (1) to delete view or file anytime no matter it is in locked status or expired. (2) to rename the view (3) to bring back the retention period when it's in locked mode A lock mode of a file in a view can be in one of the following: 'Compliance': Default mode of datalock, in this mode, Data Security Admin cannot modify/delete this view when datalock is in effect. Data Security Admin can delete this view when datalock is expired. 'kEnterprise' : In this mode, Data Security Admin can change view name or delete view when datalock is in effect. Datalock in this mode can be upgraded to 'Compliance' mode.")
    __properties: ClassVar[List[str]] = ["autoLockAfterDurationIdleMsecs", "coexistingLockMode", "defaultRetentionDurationMsecs", "defaultRetentionDurationYears", "expiryTimestampMsecs", "lockingProtocol", "maxRetentionDurationMsecs", "minRetentionDurationMsecs", "mode"]

    @field_validator('locking_protocol')
    def locking_protocol_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['SetReadOnly', 'SetAtime']):
            raise ValueError("must be one of enum values ('SetReadOnly', 'SetAtime')")
        return value

    @field_validator('mode')
    def mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Compliance', 'Enterprise']):
            raise ValueError("must be one of enum values ('Compliance', 'Enterprise')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FileLevelDataLockConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if auto_lock_after_duration_idle_msecs (nullable) is None
        # and model_fields_set contains the field
        if self.auto_lock_after_duration_idle_msecs is None and "auto_lock_after_duration_idle_msecs" in self.model_fields_set:
            _dict['autoLockAfterDurationIdleMsecs'] = None

        # set to None if coexisting_lock_mode (nullable) is None
        # and model_fields_set contains the field
        if self.coexisting_lock_mode is None and "coexisting_lock_mode" in self.model_fields_set:
            _dict['coexistingLockMode'] = None

        # set to None if default_retention_duration_msecs (nullable) is None
        # and model_fields_set contains the field
        if self.default_retention_duration_msecs is None and "default_retention_duration_msecs" in self.model_fields_set:
            _dict['defaultRetentionDurationMsecs'] = None

        # set to None if default_retention_duration_years (nullable) is None
        # and model_fields_set contains the field
        if self.default_retention_duration_years is None and "default_retention_duration_years" in self.model_fields_set:
            _dict['defaultRetentionDurationYears'] = None

        # set to None if expiry_timestamp_msecs (nullable) is None
        # and model_fields_set contains the field
        if self.expiry_timestamp_msecs is None and "expiry_timestamp_msecs" in self.model_fields_set:
            _dict['expiryTimestampMsecs'] = None

        # set to None if locking_protocol (nullable) is None
        # and model_fields_set contains the field
        if self.locking_protocol is None and "locking_protocol" in self.model_fields_set:
            _dict['lockingProtocol'] = None

        # set to None if max_retention_duration_msecs (nullable) is None
        # and model_fields_set contains the field
        if self.max_retention_duration_msecs is None and "max_retention_duration_msecs" in self.model_fields_set:
            _dict['maxRetentionDurationMsecs'] = None

        # set to None if min_retention_duration_msecs (nullable) is None
        # and model_fields_set contains the field
        if self.min_retention_duration_msecs is None and "min_retention_duration_msecs" in self.model_fields_set:
            _dict['minRetentionDurationMsecs'] = None

        # set to None if mode (nullable) is None
        # and model_fields_set contains the field
        if self.mode is None and "mode" in self.model_fields_set:
            _dict['mode'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FileLevelDataLockConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "autoLockAfterDurationIdleMsecs": obj.get("autoLockAfterDurationIdleMsecs"),
            "coexistingLockMode": obj.get("coexistingLockMode"),
            "defaultRetentionDurationMsecs": obj.get("defaultRetentionDurationMsecs"),
            "defaultRetentionDurationYears": obj.get("defaultRetentionDurationYears"),
            "expiryTimestampMsecs": obj.get("expiryTimestampMsecs"),
            "lockingProtocol": obj.get("lockingProtocol"),
            "maxRetentionDurationMsecs": obj.get("maxRetentionDurationMsecs"),
            "minRetentionDurationMsecs": obj.get("minRetentionDurationMsecs"),
            "mode": obj.get("mode")
        })
        return _obj


