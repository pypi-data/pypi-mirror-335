# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from cohesity_sdk.cluster.models.smb_permission import SmbPermission
from typing import Set
from typing_extensions import Self

class AliasSmbConfig(BaseModel):
    """
    Message defining SMB config for IRIS. SMB config contains SMB encryption flags, SMB discoverable flag and Share level permissions.
    """ # noqa: E501
    caching_enabled: Optional[StrictBool] = Field(default=None, description="Indicate if offline file caching is supported.", alias="cachingEnabled")
    continuous_availability: Optional[StrictBool] = Field(default=None, description="Whether file open handles are persisted to scribe to survive bridge process crash. When set to false, open handles will be kept in memory until the current node has exclusive ticket for the entity handle. When the entity is opened from another node, the exclusive ticket would be revoked from the node. In revoke control flow, the current node would persist the state to scribe. On acquiring the exclusive ticket,another node would read the file open handles from scribe and resume the handling of operation.", alias="continuousAvailability")
    discovery_enabled: Optional[StrictBool] = Field(default=None, description="Whether the share is discoverable.", alias="discoveryEnabled")
    encryption_enabled: Optional[StrictBool] = Field(default=None, description="Whether SMB encryption is enabled for this share. Encryption is supported only by SMB 3.x dialects. Dialects that do not support would still access data in unencrypted format.", alias="encryptionEnabled")
    encryption_required: Optional[StrictBool] = Field(default=None, description="Whether to enforce encryption for all the sessions for this view. When enabled all unencrypted sessions are disallowed.", alias="encryptionRequired")
    is_share_level_permission_empty: Optional[StrictBool] = Field(default=None, description="Indicate if share level permission is cleared by user.", alias="isShareLevelPermissionEmpty")
    oplock_enabled: Optional[StrictBool] = Field(default=None, description="Indicate the operation lock is enabled by this view.", alias="oplockEnabled")
    permissions: Optional[List[SmbPermission]] = Field(default=None, description="Share level permissions. Note: Supported Access: FullControl, Modify, ReadOnly. Supported type: Allow, Deny.")
    super_user_sids: Optional[List[StrictStr]] = Field(default=None, description="Specifies a list of super user sids.", alias="superUserSids")
    __properties: ClassVar[List[str]] = ["cachingEnabled", "continuousAvailability", "discoveryEnabled", "encryptionEnabled", "encryptionRequired", "isShareLevelPermissionEmpty", "oplockEnabled", "permissions", "superUserSids"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AliasSmbConfig from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in permissions (list)
        _items = []
        if self.permissions:
            for _item_permissions in self.permissions:
                if _item_permissions:
                    _items.append(_item_permissions.to_dict())
            _dict['permissions'] = _items
        # set to None if caching_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.caching_enabled is None and "caching_enabled" in self.model_fields_set:
            _dict['cachingEnabled'] = None

        # set to None if continuous_availability (nullable) is None
        # and model_fields_set contains the field
        if self.continuous_availability is None and "continuous_availability" in self.model_fields_set:
            _dict['continuousAvailability'] = None

        # set to None if discovery_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.discovery_enabled is None and "discovery_enabled" in self.model_fields_set:
            _dict['discoveryEnabled'] = None

        # set to None if encryption_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.encryption_enabled is None and "encryption_enabled" in self.model_fields_set:
            _dict['encryptionEnabled'] = None

        # set to None if encryption_required (nullable) is None
        # and model_fields_set contains the field
        if self.encryption_required is None and "encryption_required" in self.model_fields_set:
            _dict['encryptionRequired'] = None

        # set to None if is_share_level_permission_empty (nullable) is None
        # and model_fields_set contains the field
        if self.is_share_level_permission_empty is None and "is_share_level_permission_empty" in self.model_fields_set:
            _dict['isShareLevelPermissionEmpty'] = None

        # set to None if oplock_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.oplock_enabled is None and "oplock_enabled" in self.model_fields_set:
            _dict['oplockEnabled'] = None

        # set to None if permissions (nullable) is None
        # and model_fields_set contains the field
        if self.permissions is None and "permissions" in self.model_fields_set:
            _dict['permissions'] = None

        # set to None if super_user_sids (nullable) is None
        # and model_fields_set contains the field
        if self.super_user_sids is None and "super_user_sids" in self.model_fields_set:
            _dict['superUserSids'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AliasSmbConfig from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cachingEnabled": obj.get("cachingEnabled"),
            "continuousAvailability": obj.get("continuousAvailability"),
            "discoveryEnabled": obj.get("discoveryEnabled"),
            "encryptionEnabled": obj.get("encryptionEnabled"),
            "encryptionRequired": obj.get("encryptionRequired"),
            "isShareLevelPermissionEmpty": obj.get("isShareLevelPermissionEmpty"),
            "oplockEnabled": obj.get("oplockEnabled"),
            "permissions": [SmbPermission.from_dict(_item) for _item in obj["permissions"]] if obj.get("permissions") is not None else None,
            "superUserSids": obj.get("superUserSids")
        })
        return _obj


