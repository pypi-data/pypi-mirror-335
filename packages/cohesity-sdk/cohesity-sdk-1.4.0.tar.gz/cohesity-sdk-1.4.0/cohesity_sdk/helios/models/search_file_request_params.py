# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from typing_extensions import Self

class SearchFileRequestParams(BaseModel):
    """
    Specifies the request parameters to search for files and file folders.
    """ # noqa: E501
    search_string: Optional[StrictStr] = Field(default=None, description="Specifies the search string to filter the files. User can specify a wildcard character '*' as a suffix to a string where all files name are matched with the prefix string.", alias="searchString")
    source_environments: Optional[List[StrictStr]] = Field(default=None, description="Specifies a list of the source environments. Only files from these types of source will be returned.", alias="sourceEnvironments")
    types: Optional[List[StrictStr]] = Field(default=None, description="Specifies a list of file types. Only files within the given types will be returned.")
    source_ids: Optional[List[StrictInt]] = Field(default=None, description="Specifies a list of source ids. Only files found in these sources will be returned.", alias="sourceIds")
    object_ids: Optional[List[StrictInt]] = Field(default=None, description="Specifies a list of object ids. Only files found in these objects will be returned.", alias="objectIds")
    __properties: ClassVar[List[str]] = ["searchString", "sourceEnvironments", "types", "sourceIds", "objectIds"]

    @field_validator('source_environments')
    def source_environments_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['kVMware', 'kHyperV', 'kSQL', 'kView', 'kRemoteAdapter', 'kPhysical', 'kPhysicalFiles', 'kPure', 'kIbmFlashSystem', 'kAzure', 'kNetapp', 'kGenericNas', 'kAcropolis', 'kIsilon', 'kGPFS', 'kKVM', 'kAWS', 'kExchange', 'kOracle', 'kGCP', 'kFlashBlade', 'kO365', 'kHyperFlex', 'kKubernetes', 'kElastifile', 'kUDA', 'kSfdc']):
                raise ValueError("each list item must be one of ('kVMware', 'kHyperV', 'kSQL', 'kView', 'kRemoteAdapter', 'kPhysical', 'kPhysicalFiles', 'kPure', 'kIbmFlashSystem', 'kAzure', 'kNetapp', 'kGenericNas', 'kAcropolis', 'kIsilon', 'kGPFS', 'kKVM', 'kAWS', 'kExchange', 'kOracle', 'kGCP', 'kFlashBlade', 'kO365', 'kHyperFlex', 'kKubernetes', 'kElastifile', 'kUDA', 'kSfdc')")
        return value

    @field_validator('types')
    def types_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['File', 'Directory', 'Symlink']):
                raise ValueError("each list item must be one of ('File', 'Directory', 'Symlink')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SearchFileRequestParams from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if search_string (nullable) is None
        # and model_fields_set contains the field
        if self.search_string is None and "search_string" in self.model_fields_set:
            _dict['searchString'] = None

        # set to None if source_environments (nullable) is None
        # and model_fields_set contains the field
        if self.source_environments is None and "source_environments" in self.model_fields_set:
            _dict['sourceEnvironments'] = None

        # set to None if types (nullable) is None
        # and model_fields_set contains the field
        if self.types is None and "types" in self.model_fields_set:
            _dict['types'] = None

        # set to None if source_ids (nullable) is None
        # and model_fields_set contains the field
        if self.source_ids is None and "source_ids" in self.model_fields_set:
            _dict['sourceIds'] = None

        # set to None if object_ids (nullable) is None
        # and model_fields_set contains the field
        if self.object_ids is None and "object_ids" in self.model_fields_set:
            _dict['objectIds'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SearchFileRequestParams from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "searchString": obj.get("searchString"),
            "sourceEnvironments": obj.get("sourceEnvironments"),
            "types": obj.get("types"),
            "sourceIds": obj.get("sourceIds"),
            "objectIds": obj.get("objectIds")
        })
        return _obj


