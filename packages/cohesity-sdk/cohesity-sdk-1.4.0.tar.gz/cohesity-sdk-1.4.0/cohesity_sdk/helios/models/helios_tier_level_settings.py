# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from cohesity_sdk.helios.models.helios_aws_tiers import HeliosAWSTiers
from cohesity_sdk.helios.models.helios_azure_tiers import HeliosAzureTiers
from cohesity_sdk.helios.models.helios_google_tiers import HeliosGoogleTiers
from cohesity_sdk.helios.models.helios_oracle_tiers import HeliosOracleTiers
from typing import Set
from typing_extensions import Self

class HeliosTierLevelSettings(BaseModel):
    """
    Specifies the settings tier levels configured with each archival target. The tier settings need to be applied in specific order and default tier should always be passed as first entry in tiers array. The following example illustrates how to configure tiering input for AWS tiering. Same type of input structure applied to other cloud platforms also. <br>If user wants to achieve following tiering for backup, <br>User Desired Tiering- <br><t>1.Archive Full back up for 12 Months <br><t>2.Tier Levels <br><t><t>[1,12] [ <br><t><t><t>s3 (1 to 2 months), (default tier) <br><t><t><t>s3 Intelligent tiering (3 to 6 months), <br><t><t><t>s3 One Zone (7 to 9 months) <br><t><t><t>Glacier (10 to 12 months)] <br><t>API Input <br><t><t>1.tiers-[ <br><t><t><t>{'tierType': 'S3','moveAfterUnit':'months', <br><t><t><t>'moveAfter':2 - move from s3 to s3Inte after 2 months}, <br><t><t><t>{'tierType': 'S3Inte','moveAfterUnit':'months', <br><t><t><t>'moveAfter':4 - move from S3Inte to Glacier after 4 months}, <br><t><t><t>{'tierType': 'Glacier', 'moveAfterUnit':'months', <br><t><t><t>'moveAfter': 3 - move from Glacier to S3 One Zone after 3 months }, <br><t><t><t>{'tierType': 'S3 One Zone', 'moveAfterUnit': nil, <br><t><t><t>'moveAfter': nil - For the last record, 'moveAfter' and 'moveAfterUnit' <br><t><t><t>will be ignored since there are no further tier for data movement } <br><t><t><t>}]
    """ # noqa: E501
    aws_tiering: Optional[HeliosAWSTiers] = Field(default=None, alias="awsTiering")
    azure_tiering: Optional[HeliosAzureTiers] = Field(default=None, alias="azureTiering")
    cloud_platform: Optional[StrictStr] = Field(description="Specifies the cloud platform to enable tiering.", alias="cloudPlatform")
    google_tiering: Optional[HeliosGoogleTiers] = Field(default=None, alias="googleTiering")
    oracle_tiering: Optional[HeliosOracleTiers] = Field(default=None, alias="oracleTiering")
    __properties: ClassVar[List[str]] = ["awsTiering", "azureTiering", "cloudPlatform", "googleTiering", "oracleTiering"]

    @field_validator('cloud_platform')
    def cloud_platform_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['AWS', 'Azure', 'Oracle', 'Google']):
            raise ValueError("must be one of enum values ('AWS', 'Azure', 'Oracle', 'Google')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HeliosTierLevelSettings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of aws_tiering
        if self.aws_tiering:
            _dict['awsTiering'] = self.aws_tiering.to_dict()
        # override the default output from pydantic by calling `to_dict()` of azure_tiering
        if self.azure_tiering:
            _dict['azureTiering'] = self.azure_tiering.to_dict()
        # override the default output from pydantic by calling `to_dict()` of google_tiering
        if self.google_tiering:
            _dict['googleTiering'] = self.google_tiering.to_dict()
        # override the default output from pydantic by calling `to_dict()` of oracle_tiering
        if self.oracle_tiering:
            _dict['oracleTiering'] = self.oracle_tiering.to_dict()
        # set to None if cloud_platform (nullable) is None
        # and model_fields_set contains the field
        if self.cloud_platform is None and "cloud_platform" in self.model_fields_set:
            _dict['cloudPlatform'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HeliosTierLevelSettings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "awsTiering": HeliosAWSTiers.from_dict(obj["awsTiering"]) if obj.get("awsTiering") is not None else None,
            "azureTiering": HeliosAzureTiers.from_dict(obj["azureTiering"]) if obj.get("azureTiering") is not None else None,
            "cloudPlatform": obj.get("cloudPlatform"),
            "googleTiering": HeliosGoogleTiers.from_dict(obj["googleTiering"]) if obj.get("googleTiering") is not None else None,
            "oracleTiering": HeliosOracleTiers.from_dict(obj["oracleTiering"]) if obj.get("oracleTiering") is not None else None
        })
        return _obj


