# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Set
from typing_extensions import Self

class SmbActiveOpen(BaseModel):
    """
    Specifies an active open of an SMB file, its access and sharing information.
    """ # noqa: E501
    access_info_list: Optional[List[StrictStr]] = Field(default=None, description="Specifies the File Access Type. Following documentation was taken from MSDN. https://msdn.microsoft.com/en-us/library/Cc246802.aspx  'FileReadData' indicates the right to read data from the file or named   pipe. 'FileWriteData' indicates the right to write data into the file or named   pipe beyond the end of the file. 'FileAppendData' indicates the right to append data into the file or named   pipe. 'FileReadEa' indicates the right to read the extended attributes of the   file or named pipe. 'FileWriteEa' indicates the right to write or change the extended   attributes to the file or named pipe. 'FileExecute' indicates the right to delete entries within a directory. 'FileDeleteChild' indicates the right to execute the file. 'FileReadAttributes' indicates the right to read the attributes of the   file. 'FileWriteAttributes' indicates the right to change the attributes of the   file. 'Delete' indicates the right to delete the file. 'ReadControl' indicates the right to read the security descriptor for the   file or named pipe. 'WriteDac' indicates the right to change the discretionary access control   list (DACL) in the security descriptor for the file or named pipe. For   the DACL data structure, see ACL in [MS-DTYP]. 'WriteOwner' indicates the right to change the owner in the security   descriptor for the file or named pipe. 'Synchronize' is used only by SMB2 clients. 'AccessSystemSecurity' indicates the right to read or change the system   access control list (SACL) in the security descriptor for the file or   named pipe. For the SACL data structure, see ACL in [MS-DTYP].<42> 'MaximumAllowed' indicates that the client is requesting an open to the   file with the highest level of access the client has on this file.   If no access is granted for the client on this file, the server MUST   fail the open with STATUS_ACCESS_DENIED. 'GenericAll' indicates a request for all the access flags that are   previously listed except MaximumAllowed and AccessSystemSecurity. 'GenericExecute' indicates a request for the following combination of   access flags listed above:   FileReadAttributes| FileExecute| Synchronize| ReadControl. 'GenericWrite' indicates a request for the following combination of   access flags listed above:   FileWriteData| FileAppendData| FileWriteAttributes| FileWriteEa|   Synchronize| ReadControl. 'GenericRead' indicates a request for the following combination of   access flags listed above:   FileReadData| FileReadAttributes| FileReadEa| Synchronize|   ReadControl.", alias="accessInfoList")
    access_privilege: Optional[List[StrictStr]] = Field(default=None, description="Specifies whether access privilege of others if they're allowed to read/write/delete.", alias="accessPrivilege")
    open_id: Optional[StrictInt] = Field(default=None, description="Specifies the id of the active open.", alias="openId")
    __properties: ClassVar[List[str]] = ["accessInfoList", "accessPrivilege", "openId"]

    @field_validator('access_info_list')
    def access_info_list_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['FileReadData', 'FileWriteData', 'FileAppendData', 'FileReadEa', 'FileWriteEa', 'FileExecute', 'FileDeleteChild', 'FileReadAttributes', 'FileWriteAttributes', 'Delete', 'ReadControl', 'WriteDac', 'WriteOwner', 'Synchronize', 'AccessSystemSecurity', 'MaximumAllowed', 'GenericAll', 'GenericExecute', 'GenericWrite', 'GenericRead']):
                raise ValueError("each list item must be one of ('FileReadData', 'FileWriteData', 'FileAppendData', 'FileReadEa', 'FileWriteEa', 'FileExecute', 'FileDeleteChild', 'FileReadAttributes', 'FileWriteAttributes', 'Delete', 'ReadControl', 'WriteDac', 'WriteOwner', 'Synchronize', 'AccessSystemSecurity', 'MaximumAllowed', 'GenericAll', 'GenericExecute', 'GenericWrite', 'GenericRead')")
        return value

    @field_validator('access_privilege')
    def access_privilege_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in set(['Read', 'Write', 'Delete']):
                raise ValueError("each list item must be one of ('Read', 'Write', 'Delete')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SmbActiveOpen from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if access_info_list (nullable) is None
        # and model_fields_set contains the field
        if self.access_info_list is None and "access_info_list" in self.model_fields_set:
            _dict['accessInfoList'] = None

        # set to None if access_privilege (nullable) is None
        # and model_fields_set contains the field
        if self.access_privilege is None and "access_privilege" in self.model_fields_set:
            _dict['accessPrivilege'] = None

        # set to None if open_id (nullable) is None
        # and model_fields_set contains the field
        if self.open_id is None and "open_id" in self.model_fields_set:
            _dict['openId'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SmbActiveOpen from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accessInfoList": obj.get("accessInfoList"),
            "accessPrivilege": obj.get("accessPrivilege"),
            "openId": obj.get("openId")
        })
        return _obj


