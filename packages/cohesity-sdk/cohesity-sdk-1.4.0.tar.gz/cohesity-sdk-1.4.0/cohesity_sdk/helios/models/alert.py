# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from cohesity_sdk.helios.models.alert_document import AlertDocument
from cohesity_sdk.helios.models.vault import Vault
from typing import Set
from typing_extensions import Self

class Alert(BaseModel):
    """
    Specifies the fields of an alert.
    """ # noqa: E501
    alert_category: Optional[StrictStr] = Field(default=None, description="Specifies the alert category.", alias="alertCategory")
    alert_code: Optional[StrictStr] = Field(default=None, description="Specifies a unique code that categorizes the Alert, for example: CE00200014, where CE stands for Cohesity Error, the alert state next 3 digits is the id of the Alert Category (e.g. 002 for 'kNode') and the last 5 digits is the id of the Alert Type (e.g. 00014 for 'kNodeHighCpuUsage').", alias="alertCode")
    alert_document: Optional[AlertDocument] = Field(default=None, alias="alertDocument")
    alert_state: Optional[StrictStr] = Field(default=None, description="Specifies the alert state.", alias="alertState")
    alert_type: Optional[StrictInt] = Field(default=None, description="Specifies the alert type.", alias="alertType")
    alert_type_bucket: Optional[StrictStr] = Field(default=None, description="Specifies the Alert type bucket.", alias="alertTypeBucket")
    cluster_name: Optional[StrictStr] = Field(default=None, description="Specifies the name of cluster which alert is raised from.", alias="clusterName")
    dedup_count: Optional[StrictInt] = Field(default=None, description="Specifies the dedup count of alert.", alias="dedupCount")
    dedup_timestamps: Optional[List[StrictInt]] = Field(default=None, description="Specifies Unix epoch Timestamps (in microseconds) for the last 25 occurrences of duplicated Alerts that are stored with the original/primary Alert. Alerts are grouped into one Alert if the Alerts are the same type, are reporting on the same Object and occur within one hour. 'dedupCount' always reports the total count of duplicated Alerts even if there are more than 25 occurrences. For example, if there are 100 occurrences of this Alert, dedupTimestamps stores the timestamps of the last 25 occurrences and dedupCount equals 100.", alias="dedupTimestamps")
    first_timestamp_usecs: Optional[StrictInt] = Field(default=None, description="SpeSpecifies Unix epoch Timestamp (in microseconds) of the first occurrence of the Alert.", alias="firstTimestampUsecs")
    id: Optional[StrictStr] = Field(default=None, description="Specifies unique id of the alert.")
    latest_timestamp_usecs: Optional[StrictInt] = Field(default=None, description="SpeSpecifies Unix epoch Timestamp (in microseconds) of the most recent occurrence of the Alert.", alias="latestTimestampUsecs")
    region_id: Optional[StrictStr] = Field(default=None, description="Specifies the region id of the alert.", alias="regionId")
    severity: Optional[StrictStr] = Field(default=None, description="Specifies the alert severity.")
    vaults: Optional[List[Vault]] = Field(default=None, description="Specifies information about vaults where source object associated with alert is vaulted. This could be empty if alert is not related to any source object or it is not vaulted.")
    __properties: ClassVar[List[str]] = ["alertCategory", "alertCode", "alertDocument", "alertState", "alertType", "alertTypeBucket", "clusterName", "dedupCount", "dedupTimestamps", "firstTimestampUsecs", "id", "latestTimestampUsecs", "regionId", "severity", "vaults"]

    @field_validator('alert_category')
    def alert_category_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kDisk', 'kNode', 'kCluster', 'kChassis', 'kPowerSupply', 'kCPU', 'kMemory', 'kTemperature', 'kFan', 'kNIC', 'kFirmware', 'kNodeHealth', 'kOperatingSystem', 'kDataPath', 'kMetadata', 'kIndexing', 'kHelios', 'kAppMarketPlace', 'kSystemService', 'kLicense', 'kSecurity', 'kUpgrade', 'kClusterManagement', 'kAuditLog', 'kNetworking', 'kConfiguration', 'kStorageUsage', 'kFaultTolerance', 'kBackupRestore', 'kArchivalRestore', 'kRemoteReplication', 'kQuota', 'kCDP', 'kViewFailover', 'kDisasterRecovery']):
            raise ValueError("must be one of enum values ('kDisk', 'kNode', 'kCluster', 'kChassis', 'kPowerSupply', 'kCPU', 'kMemory', 'kTemperature', 'kFan', 'kNIC', 'kFirmware', 'kNodeHealth', 'kOperatingSystem', 'kDataPath', 'kMetadata', 'kIndexing', 'kHelios', 'kAppMarketPlace', 'kSystemService', 'kLicense', 'kSecurity', 'kUpgrade', 'kClusterManagement', 'kAuditLog', 'kNetworking', 'kConfiguration', 'kStorageUsage', 'kFaultTolerance', 'kBackupRestore', 'kArchivalRestore', 'kRemoteReplication', 'kQuota', 'kCDP', 'kViewFailover', 'kDisasterRecovery')")
        return value

    @field_validator('alert_state')
    def alert_state_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kResolved', 'kOpen', 'kNote', 'kSuppressed']):
            raise ValueError("must be one of enum values ('kResolved', 'kOpen', 'kNote', 'kSuppressed')")
        return value

    @field_validator('alert_type_bucket')
    def alert_type_bucket_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kHardware', 'kSoftware', 'kDataService', 'kMaintenance']):
            raise ValueError("must be one of enum values ('kHardware', 'kSoftware', 'kDataService', 'kMaintenance')")
        return value

    @field_validator('severity')
    def severity_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['kCritical', 'kWarning', 'kInfo']):
            raise ValueError("must be one of enum values ('kCritical', 'kWarning', 'kInfo')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Alert from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of alert_document
        if self.alert_document:
            _dict['alertDocument'] = self.alert_document.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in vaults (list)
        _items = []
        if self.vaults:
            for _item_vaults in self.vaults:
                if _item_vaults:
                    _items.append(_item_vaults.to_dict())
            _dict['vaults'] = _items
        # set to None if alert_category (nullable) is None
        # and model_fields_set contains the field
        if self.alert_category is None and "alert_category" in self.model_fields_set:
            _dict['alertCategory'] = None

        # set to None if alert_code (nullable) is None
        # and model_fields_set contains the field
        if self.alert_code is None and "alert_code" in self.model_fields_set:
            _dict['alertCode'] = None

        # set to None if alert_state (nullable) is None
        # and model_fields_set contains the field
        if self.alert_state is None and "alert_state" in self.model_fields_set:
            _dict['alertState'] = None

        # set to None if alert_type (nullable) is None
        # and model_fields_set contains the field
        if self.alert_type is None and "alert_type" in self.model_fields_set:
            _dict['alertType'] = None

        # set to None if alert_type_bucket (nullable) is None
        # and model_fields_set contains the field
        if self.alert_type_bucket is None and "alert_type_bucket" in self.model_fields_set:
            _dict['alertTypeBucket'] = None

        # set to None if cluster_name (nullable) is None
        # and model_fields_set contains the field
        if self.cluster_name is None and "cluster_name" in self.model_fields_set:
            _dict['clusterName'] = None

        # set to None if dedup_count (nullable) is None
        # and model_fields_set contains the field
        if self.dedup_count is None and "dedup_count" in self.model_fields_set:
            _dict['dedupCount'] = None

        # set to None if dedup_timestamps (nullable) is None
        # and model_fields_set contains the field
        if self.dedup_timestamps is None and "dedup_timestamps" in self.model_fields_set:
            _dict['dedupTimestamps'] = None

        # set to None if first_timestamp_usecs (nullable) is None
        # and model_fields_set contains the field
        if self.first_timestamp_usecs is None and "first_timestamp_usecs" in self.model_fields_set:
            _dict['firstTimestampUsecs'] = None

        # set to None if id (nullable) is None
        # and model_fields_set contains the field
        if self.id is None and "id" in self.model_fields_set:
            _dict['id'] = None

        # set to None if latest_timestamp_usecs (nullable) is None
        # and model_fields_set contains the field
        if self.latest_timestamp_usecs is None and "latest_timestamp_usecs" in self.model_fields_set:
            _dict['latestTimestampUsecs'] = None

        # set to None if region_id (nullable) is None
        # and model_fields_set contains the field
        if self.region_id is None and "region_id" in self.model_fields_set:
            _dict['regionId'] = None

        # set to None if severity (nullable) is None
        # and model_fields_set contains the field
        if self.severity is None and "severity" in self.model_fields_set:
            _dict['severity'] = None

        # set to None if vaults (nullable) is None
        # and model_fields_set contains the field
        if self.vaults is None and "vaults" in self.model_fields_set:
            _dict['vaults'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Alert from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alertCategory": obj.get("alertCategory"),
            "alertCode": obj.get("alertCode"),
            "alertDocument": AlertDocument.from_dict(obj["alertDocument"]) if obj.get("alertDocument") is not None else None,
            "alertState": obj.get("alertState"),
            "alertType": obj.get("alertType"),
            "alertTypeBucket": obj.get("alertTypeBucket"),
            "clusterName": obj.get("clusterName"),
            "dedupCount": obj.get("dedupCount"),
            "dedupTimestamps": obj.get("dedupTimestamps"),
            "firstTimestampUsecs": obj.get("firstTimestampUsecs"),
            "id": obj.get("id"),
            "latestTimestampUsecs": obj.get("latestTimestampUsecs"),
            "regionId": obj.get("regionId"),
            "severity": obj.get("severity"),
            "vaults": [Vault.from_dict(_item) for _item in obj["vaults"]] if obj.get("vaults") is not None else None
        })
        return _obj


