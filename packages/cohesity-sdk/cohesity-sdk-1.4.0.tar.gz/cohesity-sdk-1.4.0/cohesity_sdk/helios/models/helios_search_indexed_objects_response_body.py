# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from cohesity_sdk.helios.models.helios_cassandra_objects_inner import HeliosCassandraObjectsInner
from cohesity_sdk.helios.models.helios_couchbase_objects_inner import HeliosCouchbaseObjectsInner
from cohesity_sdk.helios.models.helios_emails_inner import HeliosEmailsInner
from cohesity_sdk.helios.models.helios_exchange_objects_inner import HeliosExchangeObjectsInner
from cohesity_sdk.helios.models.helios_files_inner import HeliosFilesInner
from cohesity_sdk.helios.models.helios_hbase_objects_inner import HeliosHbaseObjectsInner
from cohesity_sdk.helios.models.helios_hdfs_objects_inner import HeliosHdfsObjectsInner
from cohesity_sdk.helios.models.helios_hive_objects_inner import HeliosHiveObjectsInner
from cohesity_sdk.helios.models.helios_mongo_objects_inner import HeliosMongoObjectsInner
from cohesity_sdk.helios.models.helios_public_folder_items_inner import HeliosPublicFolderItemsInner
from cohesity_sdk.helios.models.helios_search_indexed_objects_cluster_error import HeliosSearchIndexedObjectsClusterError
from cohesity_sdk.helios.models.sfdc_records import SfdcRecords
from typing import Set
from typing_extensions import Self

class HeliosSearchIndexedObjectsResponseBody(BaseModel):
    """
    Specifies the search indexed objects response body.
    """ # noqa: E501
    cluster_errors: Optional[List[HeliosSearchIndexedObjectsClusterError]] = Field(default=None, description="A List of errors that occured on a subset of clusters.", alias="clusterErrors")
    count: Optional[StrictInt] = Field(default=None, description="Specifies the total number of indexed objects that match the filter and search criteria. Use this value to determine how many additional requests are required to get the full result.")
    object_type: Optional[StrictStr] = Field(default=None, description="Specifies the object type.", alias="objectType")
    cassandra_objects: Optional[List[HeliosCassandraObjectsInner]] = Field(default=None, description="Specifies the indexed Cassandra objects.", alias="cassandraObjects")
    couchbase_objects: Optional[List[HeliosCouchbaseObjectsInner]] = Field(default=None, description="Specifies the indexed Couchbase objects.", alias="couchbaseObjects")
    emails: Optional[List[HeliosEmailsInner]] = Field(default=None, description="Specifies the indexed emails and email folders.")
    exchange_objects: Optional[List[HeliosExchangeObjectsInner]] = Field(default=None, description="Specifies the indexed HDFS objects.", alias="exchangeObjects")
    files: Optional[List[HeliosFilesInner]] = Field(default=None, description="Specifies the indexed files and file folders.")
    hbase_objects: Optional[List[HeliosHbaseObjectsInner]] = Field(default=None, description="Specifies the indexed Hbase objects.", alias="hbaseObjects")
    hdfs_objects: Optional[List[HeliosHdfsObjectsInner]] = Field(default=None, description="Specifies the indexed HDFS objects.", alias="hdfsObjects")
    hive_objects: Optional[List[HeliosHiveObjectsInner]] = Field(default=None, description="Specifies the indexed Hive objects.", alias="hiveObjects")
    mongo_objects: Optional[List[HeliosMongoObjectsInner]] = Field(default=None, description="Specifies the indexed Mongo objects.", alias="mongoObjects")
    public_folder_items: Optional[List[HeliosPublicFolderItemsInner]] = Field(default=None, description="Specifies the indexed Public folder items.", alias="publicFolderItems")
    sfdc_records: Optional[SfdcRecords] = Field(default=None, alias="sfdcRecords")
    __properties: ClassVar[List[str]] = ["clusterErrors", "count", "objectType", "cassandraObjects", "couchbaseObjects", "emails", "exchangeObjects", "files", "hbaseObjects", "hdfsObjects", "hiveObjects", "mongoObjects", "publicFolderItems", "sfdcRecords"]

    @field_validator('object_type')
    def object_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Emails', 'Files', 'CassandraObjects', 'CouchbaseObjects', 'HbaseObjects', 'HiveObjects', 'MongoObjects', 'HDFSObjects', 'ExchangeObjects', 'PublicFolders', 'GroupsObjects', 'TeamsObjects', 'SharepointObjects', 'OneDriveObjects', 'UdaObjects', 'SfdcRecords']):
            raise ValueError("must be one of enum values ('Emails', 'Files', 'CassandraObjects', 'CouchbaseObjects', 'HbaseObjects', 'HiveObjects', 'MongoObjects', 'HDFSObjects', 'ExchangeObjects', 'PublicFolders', 'GroupsObjects', 'TeamsObjects', 'SharepointObjects', 'OneDriveObjects', 'UdaObjects', 'SfdcRecords')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HeliosSearchIndexedObjectsResponseBody from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in cluster_errors (list)
        _items = []
        if self.cluster_errors:
            for _item_cluster_errors in self.cluster_errors:
                if _item_cluster_errors:
                    _items.append(_item_cluster_errors.to_dict())
            _dict['clusterErrors'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in cassandra_objects (list)
        _items = []
        if self.cassandra_objects:
            for _item_cassandra_objects in self.cassandra_objects:
                if _item_cassandra_objects:
                    _items.append(_item_cassandra_objects.to_dict())
            _dict['cassandraObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in couchbase_objects (list)
        _items = []
        if self.couchbase_objects:
            for _item_couchbase_objects in self.couchbase_objects:
                if _item_couchbase_objects:
                    _items.append(_item_couchbase_objects.to_dict())
            _dict['couchbaseObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in emails (list)
        _items = []
        if self.emails:
            for _item_emails in self.emails:
                if _item_emails:
                    _items.append(_item_emails.to_dict())
            _dict['emails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in exchange_objects (list)
        _items = []
        if self.exchange_objects:
            for _item_exchange_objects in self.exchange_objects:
                if _item_exchange_objects:
                    _items.append(_item_exchange_objects.to_dict())
            _dict['exchangeObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in files (list)
        _items = []
        if self.files:
            for _item_files in self.files:
                if _item_files:
                    _items.append(_item_files.to_dict())
            _dict['files'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hbase_objects (list)
        _items = []
        if self.hbase_objects:
            for _item_hbase_objects in self.hbase_objects:
                if _item_hbase_objects:
                    _items.append(_item_hbase_objects.to_dict())
            _dict['hbaseObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hdfs_objects (list)
        _items = []
        if self.hdfs_objects:
            for _item_hdfs_objects in self.hdfs_objects:
                if _item_hdfs_objects:
                    _items.append(_item_hdfs_objects.to_dict())
            _dict['hdfsObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in hive_objects (list)
        _items = []
        if self.hive_objects:
            for _item_hive_objects in self.hive_objects:
                if _item_hive_objects:
                    _items.append(_item_hive_objects.to_dict())
            _dict['hiveObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in mongo_objects (list)
        _items = []
        if self.mongo_objects:
            for _item_mongo_objects in self.mongo_objects:
                if _item_mongo_objects:
                    _items.append(_item_mongo_objects.to_dict())
            _dict['mongoObjects'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in public_folder_items (list)
        _items = []
        if self.public_folder_items:
            for _item_public_folder_items in self.public_folder_items:
                if _item_public_folder_items:
                    _items.append(_item_public_folder_items.to_dict())
            _dict['publicFolderItems'] = _items
        # override the default output from pydantic by calling `to_dict()` of sfdc_records
        if self.sfdc_records:
            _dict['sfdcRecords'] = self.sfdc_records.to_dict()
        # set to None if count (nullable) is None
        # and model_fields_set contains the field
        if self.count is None and "count" in self.model_fields_set:
            _dict['count'] = None

        # set to None if object_type (nullable) is None
        # and model_fields_set contains the field
        if self.object_type is None and "object_type" in self.model_fields_set:
            _dict['objectType'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HeliosSearchIndexedObjectsResponseBody from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "clusterErrors": [HeliosSearchIndexedObjectsClusterError.from_dict(_item) for _item in obj["clusterErrors"]] if obj.get("clusterErrors") is not None else None,
            "count": obj.get("count"),
            "objectType": obj.get("objectType"),
            "cassandraObjects": [HeliosCassandraObjectsInner.from_dict(_item) for _item in obj["cassandraObjects"]] if obj.get("cassandraObjects") is not None else None,
            "couchbaseObjects": [HeliosCouchbaseObjectsInner.from_dict(_item) for _item in obj["couchbaseObjects"]] if obj.get("couchbaseObjects") is not None else None,
            "emails": [HeliosEmailsInner.from_dict(_item) for _item in obj["emails"]] if obj.get("emails") is not None else None,
            "exchangeObjects": [HeliosExchangeObjectsInner.from_dict(_item) for _item in obj["exchangeObjects"]] if obj.get("exchangeObjects") is not None else None,
            "files": [HeliosFilesInner.from_dict(_item) for _item in obj["files"]] if obj.get("files") is not None else None,
            "hbaseObjects": [HeliosHbaseObjectsInner.from_dict(_item) for _item in obj["hbaseObjects"]] if obj.get("hbaseObjects") is not None else None,
            "hdfsObjects": [HeliosHdfsObjectsInner.from_dict(_item) for _item in obj["hdfsObjects"]] if obj.get("hdfsObjects") is not None else None,
            "hiveObjects": [HeliosHiveObjectsInner.from_dict(_item) for _item in obj["hiveObjects"]] if obj.get("hiveObjects") is not None else None,
            "mongoObjects": [HeliosMongoObjectsInner.from_dict(_item) for _item in obj["mongoObjects"]] if obj.get("mongoObjects") is not None else None,
            "publicFolderItems": [HeliosPublicFolderItemsInner.from_dict(_item) for _item in obj["publicFolderItems"]] if obj.get("publicFolderItems") is not None else None,
            "sfdcRecords": SfdcRecords.from_dict(obj["sfdcRecords"]) if obj.get("sfdcRecords") is not None else None
        })
        return _obj


