# coding: utf-8

"""
    Cohesity REST API

    Cohesity API provides a RESTful interface to access the various data management operations on Cohesity cluster and Helios.

    The version of the OpenAPI document: 2.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictBool
from cohesity_sdk.helios.models.audit_log import AuditLog
from cohesity_sdk.helios.models.audit_logs import AuditLogs
from cohesity_sdk.helios.models.audit_logs_actions import AuditLogsActions
from cohesity_sdk.helios.models.audit_logs_entity_types import AuditLogsEntityTypes
from cohesity_sdk.helios.models.filer_audit_log_configs import FilerAuditLogConfigs
from cohesity_sdk.helios.models.helios_audit_log_settings import HeliosAuditLogSettings
from cohesity_sdk.helios.models.helios_audit_log_users import HeliosAuditLogUsers
from cohesity_sdk.helios.models.helios_audit_logs import HeliosAuditLogs
from cohesity_sdk.helios.models.helios_audit_logs_actions import HeliosAuditLogsActions
from cohesity_sdk.helios.models.helios_audit_logs_entity_types import HeliosAuditLogsEntityTypes

from cohesity_sdk.helios.api_client import ApiClient, RequestSerialized
from cohesity_sdk.helios.api_response import ApiResponse
from cohesity_sdk.helios.rest import RESTResponseType


class AuditLogApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_audit_logs(
        self,
        body: Annotated[AuditLog, Field(description="Request to create a audit log.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditLogsEntityTypes:
        """Create cluster audit logs.

        Create a cluster audit logs.

        :param body: Request to create a audit log. (required)
        :type body: AuditLog
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_logs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_audit_logs_with_http_info(
        self,
        body: Annotated[AuditLog, Field(description="Request to create a audit log.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditLogsEntityTypes]:
        """Create cluster audit logs.

        Create a cluster audit logs.

        :param body: Request to create a audit log. (required)
        :type body: AuditLog
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_logs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_audit_logs_without_preload_content(
        self,
        body: Annotated[AuditLog, Field(description="Request to create a audit log.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create cluster audit logs.

        Create a cluster audit logs.

        :param body: Request to create a audit log. (required)
        :type body: AuditLog
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audit_logs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_audit_logs_serialize(
        self,
        body,
        access_cluster_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/create-audit-logs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def download_helios_audit_logs(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> bytearray:
        """Download helios audit logs.

        Download helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index.
        :type include_dmaas_logs: bool
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            region_ids=region_ids,
            service_context=service_context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def download_helios_audit_logs_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[bytearray]:
        """Download helios audit logs.

        Download helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index.
        :type include_dmaas_logs: bool
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            region_ids=region_ids,
            service_context=service_context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def download_helios_audit_logs_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index.")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Download helios audit logs.

        Download helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index.
        :type include_dmaas_logs: bool
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._download_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            region_ids=region_ids,
            service_context=service_context,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "bytearray",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _download_helios_audit_logs_serialize(
        self,
        region_id,
        search_string,
        usernames,
        domains,
        entity_types,
        actions,
        start_time_usecs,
        end_time_usecs,
        tenant_ids,
        include_tenants,
        cluster_identifiers,
        start_index,
        count,
        include_helios_logs,
        include_dmaas_logs,
        region_ids,
        service_context,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'usernames': 'csv',
            'domains': 'csv',
            'entityTypes': 'csv',
            'actions': 'csv',
            'tenantIds': 'csv',
            'clusterIdentifiers': 'csv',
            'regionIds': 'csv',
            'serviceContext': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if search_string is not None:
            
            _query_params.append(('searchString', search_string))
            
        if usernames is not None:
            
            _query_params.append(('usernames', usernames))
            
        if domains is not None:
            
            _query_params.append(('domains', domains))
            
        if entity_types is not None:
            
            _query_params.append(('entityTypes', entity_types))
            
        if actions is not None:
            
            _query_params.append(('actions', actions))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if cluster_identifiers is not None:
            
            _query_params.append(('clusterIdentifiers', cluster_identifiers))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if include_helios_logs is not None:
            
            _query_params.append(('includeHeliosLogs', include_helios_logs))
            
        if include_dmaas_logs is not None:
            
            _query_params.append(('includeDmaasLogs', include_dmaas_logs))
            
        if region_ids is not None:
            
            _query_params.append(('regionIds', region_ids))
            
        if service_context is not None:
            
            _query_params.append(('serviceContext', service_context))
            
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/csv'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs/download',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audit_logs(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of indexed obejcts to be fetched from the specified start index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditLogs:
        """Get cluster audit logs.

        Get a cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed obejcts to be fetched from the specified start index.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            start_index=start_index,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audit_logs_with_http_info(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of indexed obejcts to be fetched from the specified start index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditLogs]:
        """Get cluster audit logs.

        Get a cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed obejcts to be fetched from the specified start index.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            start_index=start_index,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audit_logs_without_preload_content(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="Specifies the number of indexed obejcts to be fetched from the specified start index.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get cluster audit logs.

        Get a cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed obejcts to be fetched from the specified start index.
        :type count: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            start_index=start_index,
            count=count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audit_logs_serialize(
        self,
        access_cluster_id,
        region_id,
        search_string,
        usernames,
        domains,
        entity_types,
        actions,
        start_time_usecs,
        end_time_usecs,
        tenant_ids,
        include_tenants,
        start_index,
        count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'usernames': 'csv',
            'domains': 'csv',
            'entityTypes': 'csv',
            'actions': 'csv',
            'tenantIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if search_string is not None:
            
            _query_params.append(('searchString', search_string))
            
        if usernames is not None:
            
            _query_params.append(('usernames', usernames))
            
        if domains is not None:
            
            _query_params.append(('domains', domains))
            
        if entity_types is not None:
            
            _query_params.append(('entityTypes', entity_types))
            
        if actions is not None:
            
            _query_params.append(('actions', actions))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audit-logs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audit_logs_actions(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditLogsActions:
        """Get cluster audit logs actions.

        Get all actions of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_actions_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audit_logs_actions_with_http_info(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditLogsActions]:
        """Get cluster audit logs actions.

        Get all actions of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_actions_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audit_logs_actions_without_preload_content(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get cluster audit logs actions.

        Get all actions of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_actions_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audit_logs_actions_serialize(
        self,
        access_cluster_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audit-logs/actions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audit_logs_entity_types(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AuditLogsEntityTypes:
        """Get cluster audit logs entity types.

        Get all entity types of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_entity_types_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audit_logs_entity_types_with_http_info(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AuditLogsEntityTypes]:
        """Get cluster audit logs entity types.

        Get all entity types of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_entity_types_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audit_logs_entity_types_without_preload_content(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get cluster audit logs entity types.

        Get all entity types of cluster audit logs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audit_logs_entity_types_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audit_logs_entity_types_serialize(
        self,
        access_cluster_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audit-logs/entity-types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_filer_audit_log_configs(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilerAuditLogConfigs:
        """Get filer audit log configs.

        Get filer audit log configs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filer_audit_log_configs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_filer_audit_log_configs_with_http_info(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilerAuditLogConfigs]:
        """Get filer audit log configs.

        Get filer audit log configs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filer_audit_log_configs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_filer_audit_log_configs_without_preload_content(
        self,
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get filer audit log configs.

        Get filer audit log configs.

        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filer_audit_log_configs_serialize(
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_filer_audit_log_configs_serialize(
        self,
        access_cluster_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audit-logs/filer-configs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_helios_audit_log_settings(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogSettings:
        """Get Helios Audit Log Settings.

        Returns a list of Helios audit log settings.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_log_settings_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_helios_audit_log_settings_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogSettings]:
        """Get Helios Audit Log Settings.

        Returns a list of Helios audit log settings.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_log_settings_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_helios_audit_log_settings_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Helios Audit Log Settings.

        Returns a list of Helios audit log settings.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_log_settings_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_helios_audit_log_settings_serialize(
        self,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_helios_audit_logs(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        entity_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity ids, only audit logs containing these entity ids will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogs:
        """Get helios audit logs.

        Get helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param entity_ids: Specifies a list of entity ids, only audit logs containing these entity ids will be returned.
        :type entity_ids: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_dmaas_logs: bool
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            entity_ids=entity_ids,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            service_context=service_context,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_helios_audit_logs_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        entity_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity ids, only audit logs containing these entity ids will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogs]:
        """Get helios audit logs.

        Get helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param entity_ids: Specifies a list of entity ids, only audit logs containing these entity ids will be returned.
        :type entity_ids: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_dmaas_logs: bool
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            entity_ids=entity_ids,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            service_context=service_context,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_helios_audit_logs_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        search_string: Annotated[Optional[StrictStr], Field(description="Search audit logs by 'entityName' or 'details'.")] = None,
        usernames: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of usernames, only audit logs made by these users will be returned.")] = None,
        domains: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of domains, only audit logs made by user in these domains will be returned.")] = None,
        entity_types: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity types, only audit logs containing these entity types will be returned.")] = None,
        entity_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of entity ids, only audit logs containing these entity ids will be returned.")] = None,
        actions: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of actions, only audit logs containing these actions will be returned.")] = None,
        start_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.")] = None,
        end_time_usecs: Annotated[Optional[StrictInt], Field(description="Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.")] = None,
        tenant_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.")] = None,
        include_tenants: Annotated[Optional[StrictBool], Field(description="If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.")] = None,
        cluster_identifiers: Annotated[Optional[List[Annotated[str, Field(strict=True)]]], Field(description="Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.")] = None,
        start_index: Annotated[Optional[StrictInt], Field(description="Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.")] = None,
        count: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="Specifies the number of indexed objects to be fetched from the index.")] = None,
        include_helios_logs: Annotated[Optional[StrictBool], Field(description="Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        include_dmaas_logs: Annotated[Optional[StrictBool], Field(description="Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.")] = None,
        service_context: Annotated[Optional[List[StrictStr]], Field(description="Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now")] = None,
        region_ids: Annotated[Optional[List[StrictStr]], Field(description="Specifies the list of region ids to filter. ")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get helios audit logs.

        Get helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param search_string: Search audit logs by 'entityName' or 'details'.
        :type search_string: str
        :param usernames: Specifies a list of usernames, only audit logs made by these users will be returned.
        :type usernames: List[str]
        :param domains: Specifies a list of domains, only audit logs made by user in these domains will be returned.
        :type domains: List[str]
        :param entity_types: Specifies a list of entity types, only audit logs containing these entity types will be returned.
        :type entity_types: List[str]
        :param entity_ids: Specifies a list of entity ids, only audit logs containing these entity ids will be returned.
        :type entity_ids: List[str]
        :param actions: Specifies a list of actions, only audit logs containing these actions will be returned.
        :type actions: List[str]
        :param start_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made after this time will be returned.
        :type start_time_usecs: int
        :param end_time_usecs: Specifies a unix timestamp in microseconds, only audit logs made before this time will be returned.
        :type end_time_usecs: int
        :param tenant_ids: Specifies a list of tenant ids, only audit logs made by these tenants will be returned. These has to be local tenant Id.
        :type tenant_ids: List[str]
        :param include_tenants: If true, the response will include Protection Groups which were created by all tenants which the current user has permission to see. If false, then only Protection Groups created by the current user will be returned.
        :type include_tenants: bool
        :param cluster_identifiers: Specifies the list of cluster identifiers. The format is clusterId:clusterIncarnationId.
        :type cluster_identifiers: List[str]
        :param start_index: Specifies a start index. The oldest logs before this index will skipped, only audit logs from this index will be fetched.
        :type start_index: int
        :param count: Specifies the number of indexed objects to be fetched from the index.
        :type count: int
        :param include_helios_logs: Specifies if helios audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_helios_logs: bool
        :param include_dmaas_logs: Specifies if dmaas audit logs need to be fetched or not from the index. This is deprecated. Use serviceContext instead.
        :type include_dmaas_logs: bool
        :param service_context: Returns the audit logs for a list of filter service context. Passing service context only one at a time is supported as of now
        :type service_context: List[str]
        :param region_ids: Specifies the list of region ids to filter. 
        :type region_ids: List[str]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_serialize(
            region_id=region_id,
            search_string=search_string,
            usernames=usernames,
            domains=domains,
            entity_types=entity_types,
            entity_ids=entity_ids,
            actions=actions,
            start_time_usecs=start_time_usecs,
            end_time_usecs=end_time_usecs,
            tenant_ids=tenant_ids,
            include_tenants=include_tenants,
            cluster_identifiers=cluster_identifiers,
            start_index=start_index,
            count=count,
            include_helios_logs=include_helios_logs,
            include_dmaas_logs=include_dmaas_logs,
            service_context=service_context,
            region_ids=region_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_helios_audit_logs_serialize(
        self,
        region_id,
        search_string,
        usernames,
        domains,
        entity_types,
        entity_ids,
        actions,
        start_time_usecs,
        end_time_usecs,
        tenant_ids,
        include_tenants,
        cluster_identifiers,
        start_index,
        count,
        include_helios_logs,
        include_dmaas_logs,
        service_context,
        region_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'usernames': 'csv',
            'domains': 'csv',
            'entityTypes': 'csv',
            'entityIds': 'csv',
            'actions': 'csv',
            'tenantIds': 'csv',
            'clusterIdentifiers': 'csv',
            'serviceContext': 'csv',
            'regionIds': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if search_string is not None:
            
            _query_params.append(('searchString', search_string))
            
        if usernames is not None:
            
            _query_params.append(('usernames', usernames))
            
        if domains is not None:
            
            _query_params.append(('domains', domains))
            
        if entity_types is not None:
            
            _query_params.append(('entityTypes', entity_types))
            
        if entity_ids is not None:
            
            _query_params.append(('entityIds', entity_ids))
            
        if actions is not None:
            
            _query_params.append(('actions', actions))
            
        if start_time_usecs is not None:
            
            _query_params.append(('startTimeUsecs', start_time_usecs))
            
        if end_time_usecs is not None:
            
            _query_params.append(('endTimeUsecs', end_time_usecs))
            
        if tenant_ids is not None:
            
            _query_params.append(('tenantIds', tenant_ids))
            
        if include_tenants is not None:
            
            _query_params.append(('includeTenants', include_tenants))
            
        if cluster_identifiers is not None:
            
            _query_params.append(('clusterIdentifiers', cluster_identifiers))
            
        if start_index is not None:
            
            _query_params.append(('startIndex', start_index))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if include_helios_logs is not None:
            
            _query_params.append(('includeHeliosLogs', include_helios_logs))
            
        if include_dmaas_logs is not None:
            
            _query_params.append(('includeDmaasLogs', include_dmaas_logs))
            
        if service_context is not None:
            
            _query_params.append(('serviceContext', service_context))
            
        if region_ids is not None:
            
            _query_params.append(('regionIds', region_ids))
            
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_helios_audit_logs_actions(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs actions by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogsActions:
        """Get helios audit logs actions.

        Get all actions of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs actions by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_actions_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_helios_audit_logs_actions_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs actions by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogsActions]:
        """Get helios audit logs actions.

        Get all actions of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs actions by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_actions_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_helios_audit_logs_actions_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs actions by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get helios audit logs actions.

        Get all actions of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs actions by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_actions_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsActions",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_helios_audit_logs_actions_serialize(
        self,
        region_id,
        service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if service is not None:
            
            _query_params.append(('service', service))
            
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs/actions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_helios_audit_logs_cluster_users(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogUsers:
        """Get helios audit logs cluster users.

        Get all cluster users of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_cluster_users_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_helios_audit_logs_cluster_users_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogUsers]:
        """Get helios audit logs cluster users.

        Get all cluster users of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_cluster_users_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_helios_audit_logs_cluster_users_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get helios audit logs cluster users.

        Get all cluster users of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_cluster_users_serialize(
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogUsers",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_helios_audit_logs_cluster_users_serialize(
        self,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs/clusterUsers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_helios_audit_logs_entity_types(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs entity type by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogsEntityTypes:
        """Get helios audit logs entity types.

        Get all entity types of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs entity type by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_entity_types_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_helios_audit_logs_entity_types_with_http_info(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs entity type by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogsEntityTypes]:
        """Get helios audit logs entity types.

        Get all entity types of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs entity type by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_entity_types_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_helios_audit_logs_entity_types_without_preload_content(
        self,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        service: Annotated[Optional[StrictStr], Field(description="Get audit logs entity type by service.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get helios audit logs entity types.

        Get all entity types of helios audit logs.

        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param service: Get audit logs entity type by service.
        :type service: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_helios_audit_logs_entity_types_serialize(
            region_id=region_id,
            service=service,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogsEntityTypes",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_helios_audit_logs_entity_types_serialize(
        self,
        region_id,
        service,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if service is not None:
            
            _query_params.append(('service', service))
            
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/mcm/audit-logs/entity-types',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_filer_audit_log_configs(
        self,
        body: Annotated[FilerAuditLogConfigs, Field(description="Specifies the filer audit log config to update.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilerAuditLogConfigs:
        """Update filer audit log configs.

        Update filer audit log configs.

        :param body: Specifies the filer audit log config to update. (required)
        :type body: FilerAuditLogConfigs
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filer_audit_log_configs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_filer_audit_log_configs_with_http_info(
        self,
        body: Annotated[FilerAuditLogConfigs, Field(description="Specifies the filer audit log config to update.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilerAuditLogConfigs]:
        """Update filer audit log configs.

        Update filer audit log configs.

        :param body: Specifies the filer audit log config to update. (required)
        :type body: FilerAuditLogConfigs
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filer_audit_log_configs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_filer_audit_log_configs_without_preload_content(
        self,
        body: Annotated[FilerAuditLogConfigs, Field(description="Specifies the filer audit log config to update.")],
        access_cluster_id: Annotated[Optional[StrictInt], Field(description="This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.")] = None,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update filer audit log configs.

        Update filer audit log configs.

        :param body: Specifies the filer audit log config to update. (required)
        :type body: FilerAuditLogConfigs
        :param access_cluster_id: This field uniquely represents a Cohesity Cluster and is used for making on-prem calls from Helios.
        :type access_cluster_id: int
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filer_audit_log_configs_serialize(
            body=body,
            access_cluster_id=access_cluster_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilerAuditLogConfigs",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_filer_audit_log_configs_serialize(
        self,
        body,
        access_cluster_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if access_cluster_id is not None:
            _header_params['accessClusterId'] = access_cluster_id
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/audit-logs/filer-configs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_helios_audit_log_settings(
        self,
        body: HeliosAuditLogSettings,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> HeliosAuditLogSettings:
        """Update Helios Audit Log Settings.

        Updates Helios audit log settings.

        :param body: (required)
        :type body: HeliosAuditLogSettings
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_helios_audit_log_settings_serialize(
            body=body,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_helios_audit_log_settings_with_http_info(
        self,
        body: HeliosAuditLogSettings,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[HeliosAuditLogSettings]:
        """Update Helios Audit Log Settings.

        Updates Helios audit log settings.

        :param body: (required)
        :type body: HeliosAuditLogSettings
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_helios_audit_log_settings_serialize(
            body=body,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_helios_audit_log_settings_without_preload_content(
        self,
        body: HeliosAuditLogSettings,
        region_id: Annotated[Optional[StrictStr], Field(description="This field uniquely represents a region and is used for making Helios calls to a specific region.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Helios Audit Log Settings.

        Updates Helios audit log settings.

        :param body: (required)
        :type body: HeliosAuditLogSettings
        :param region_id: This field uniquely represents a region and is used for making Helios calls to a specific region.
        :type region_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_helios_audit_log_settings_serialize(
            body=body,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "HeliosAuditLogSettings",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_helios_audit_log_settings_serialize(
        self,
        body,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if region_id is not None:
            _header_params['regionId'] = region_id
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
            'APIKeyHeader'
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/mcm/audit-logs/settings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


