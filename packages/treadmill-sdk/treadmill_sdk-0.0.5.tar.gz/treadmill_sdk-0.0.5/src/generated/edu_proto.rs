// This file is @generated by prost-build.
/// APP配置设备信息内容
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfoConfig {
  #[prost(string, tag = "1")]
  pub model: ::prost::alloc::string::String,
  #[prost(string, tag = "2")]
  pub sn: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
  /// 设备类型
  #[prost(enumeration = "SensorType", tag = "1")]
  pub sensor_type: i32,
  /// 设备model name
  #[prost(string, tag = "2")]
  pub model: ::prost::alloc::string::String,
  /// 设备SN信息
  #[prost(string, tag = "3")]
  pub sn: ::prost::alloc::string::String,
  /// 固件版本号
  #[prost(string, tag = "4")]
  pub hw_version: ::prost::alloc::string::String,
  /// 硬件版本
  #[prost(string, tag = "5")]
  pub fw_version: ::prost::alloc::string::String,
  /// 编译时间
  #[prost(string, tag = "6")]
  pub build_time: ::prost::alloc::string::String,
  /// commit hash
  #[prost(string, tag = "7")]
  pub commit_hash: ::prost::alloc::string::String,
  /// 传感器具备功能项
  #[prost(uint32, tag = "8")]
  pub sensor_features: u32,
}
/// APP发起OTA
/// 固件进入OTA模式后，开始请求文件
/// APP和固件交互传输升级包
/// 固件接收完成后,自动重启
/// 重启后，会擦写Flash
/// 操作Flash完成后，新固件运行，上报OTA完成状态。
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaConfig {
  #[prost(enumeration = "ota_config::Cmd", tag = "1")]
  pub cmd: i32,
  #[prost(message, optional, tag = "2")]
  pub ota_data: ::core::option::Option<OtaData>,
  /// START 命令，带新固件信息
  #[prost(uint32, tag = "3")]
  pub file_size: u32,
  #[prost(string, tag = "4")]
  pub file_md5: ::prost::alloc::string::String,
  #[prost(string, tag = "5")]
  pub file_sha256: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OtaConfig`.
pub mod ota_config {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum Cmd {
    None = 0,
    /// 前台传输MCU升级文件
    OtaStart = 1,
    /// 重启升级MCU
    OtaReboot = 2,
  }
  impl Cmd {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::None => "NONE",
        Self::OtaStart => "OTA_START",
        Self::OtaReboot => "OTA_REBOOT",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "NONE" => Some(Self::None),
        "OTA_START" => Some(Self::OtaStart),
        "OTA_REBOOT" => Some(Self::OtaReboot),
        _ => None,
      }
    }
  }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OtaConfigResp {
  /// 如果没有错误，恢复空OtaConfigResp
  #[prost(enumeration = "ota_config_resp::State", tag = "1")]
  pub state: i32,
  /// 镜像的offset
  #[prost(uint32, tag = "2")]
  pub offset: u32,
}
/// Nested message and enum types in `OtaConfigResp`.
pub mod ota_config_resp {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum State {
    None = 0,
    /// entry为true，返回状态为Downloading
    Downloading = 1,
    /// 接收到最后一包数据，返回FINISHED
    DownloadFinished = 2,
    /// 如果收到reboot，返回该状态后，再重启
    Rebooting = 3,
    /// 重新运行会发送该状态
    Rebooted = 4,
    /// 设备端状态异常，终止本次OTA
    Abort = 5,
  }
  impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::None => "NONE",
        Self::Downloading => "DOWNLOADING",
        Self::DownloadFinished => "DOWNLOAD_FINISHED",
        Self::Rebooting => "REBOOTING",
        Self::Rebooted => "REBOOTED",
        Self::Abort => "ABORT",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "NONE" => Some(Self::None),
        "DOWNLOADING" => Some(Self::Downloading),
        "DOWNLOAD_FINISHED" => Some(Self::DownloadFinished),
        "REBOOTING" => Some(Self::Rebooting),
        "REBOOTED" => Some(Self::Rebooted),
        "ABORT" => Some(Self::Abort),
        _ => None,
      }
    }
  }
}
/// APP发送OTA文件数据
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtaData {
  #[prost(uint32, tag = "1")]
  pub offset: u32,
  #[prost(bytes = "vec", tag = "2")]
  pub data: ::prost::alloc::vec::Vec<u8>,
  /// 结束标志
  #[prost(bool, tag = "3")]
  pub finished: bool,
}
/// 设备类型
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SensorType {
  SensorNone = 0,
  /// 传感器控制盒
  SensorCtrlBox = 1,
  /// EMG设备
  SensorEmg = 2,
  /// EEG设备
  SensorEeg = 3,
  /// ECG设备
  SensorEcg = 4,
  /// PPG设备
  SensorPpg = 5,
  /// 手套设备
  SensorGlove = 6,
  /// 8通道臂环设备
  SensorArm8ch = 7,
}
impl SensorType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::SensorNone => "SENSOR_NONE",
      Self::SensorCtrlBox => "SENSOR_CTRL_BOX",
      Self::SensorEmg => "SENSOR_EMG",
      Self::SensorEeg => "SENSOR_EEG",
      Self::SensorEcg => "SENSOR_ECG",
      Self::SensorPpg => "SENSOR_PPG",
      Self::SensorGlove => "SENSOR_GLOVE",
      Self::SensorArm8ch => "SENSOR_ARM_8CH",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SENSOR_NONE" => Some(Self::SensorNone),
      "SENSOR_CTRL_BOX" => Some(Self::SensorCtrlBox),
      "SENSOR_EMG" => Some(Self::SensorEmg),
      "SENSOR_EEG" => Some(Self::SensorEeg),
      "SENSOR_ECG" => Some(Self::SensorEcg),
      "SENSOR_PPG" => Some(Self::SensorPpg),
      "SENSOR_GLOVE" => Some(Self::SensorGlove),
      "SENSOR_ARM_8CH" => Some(Self::SensorArm8ch),
      _ => None,
    }
  }
}
/// 传感器所具备功能
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SensorFeatureMask {
  FeatureNone = 0,
  /// IMU传感器 包含（ACC+GYRO）
  FeatureImu = 1,
  /// 只包含磁力计
  FeatureMag = 2,
  /// PPG模块功能
  FeaturePpg = 3,
  /// 只包含ACC模块
  FeatureAcc = 4,
  /// 手套及传感器主控盒涉及的6通道柔性传感器数据
  FeatureFlex = 5,
  /// AFE功能，EXG设备具备的功能项
  FeatureAfe = 6,
}
impl SensorFeatureMask {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::FeatureNone => "FEATURE_NONE",
      Self::FeatureImu => "FEATURE_IMU",
      Self::FeatureMag => "FEATURE_MAG",
      Self::FeaturePpg => "FEATURE_PPG",
      Self::FeatureAcc => "FEATURE_ACC",
      Self::FeatureFlex => "FEATURE_FLEX",
      Self::FeatureAfe => "FEATURE_AFE",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "FEATURE_NONE" => Some(Self::FeatureNone),
      "FEATURE_IMU" => Some(Self::FeatureImu),
      "FEATURE_MAG" => Some(Self::FeatureMag),
      "FEATURE_PPG" => Some(Self::FeaturePpg),
      "FEATURE_ACC" => Some(Self::FeatureAcc),
      "FEATURE_FLEX" => Some(Self::FeatureFlex),
      "FEATURE_AFE" => Some(Self::FeatureAfe),
      _ => None,
    }
  }
}
/// 设备端主动上报的事件
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeviceEvent {
  None = 0,
  /// 电极连通
  LeadOn = 1,
  /// 电极脱落，针对有AFE的设备事件
  LeadOff = 2,
  /// 按键控制关机
  ButtonPwoff = 3,
  /// 设备超时关机
  TimeoutPwoff = 4,
  /// 低电量
  LowPower = 5,
  /// 硬件错误
  HardwareErr = 6,
  /// 主控盒的端口有设备接入
  PortConnected = 7,
  /// 主控盒的端口有设备断开/拔出
  PortDisconnected = 8,
}
impl DeviceEvent {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::None => "NONE",
      Self::LeadOn => "LEAD_ON",
      Self::LeadOff => "LEAD_OFF",
      Self::ButtonPwoff => "BUTTON_PWOFF",
      Self::TimeoutPwoff => "TIMEOUT_PWOFF",
      Self::LowPower => "LOW_POWER",
      Self::HardwareErr => "HARDWARE_ERR",
      Self::PortConnected => "PORT_CONNECTED",
      Self::PortDisconnected => "PORT_DISCONNECTED",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "NONE" => Some(Self::None),
      "LEAD_ON" => Some(Self::LeadOn),
      "LEAD_OFF" => Some(Self::LeadOff),
      "BUTTON_PWOFF" => Some(Self::ButtonPwoff),
      "TIMEOUT_PWOFF" => Some(Self::TimeoutPwoff),
      "LOW_POWER" => Some(Self::LowPower),
      "HARDWARE_ERR" => Some(Self::HardwareErr),
      "PORT_CONNECTED" => Some(Self::PortConnected),
      "PORT_DISCONNECTED" => Some(Self::PortDisconnected),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigReqType {
  ReqNone = 0,
  /// 请求设备信息， 设备端上报：DeviceInfo
  GetDeviceInfo = 1,
  /// 设置设备信息
  SetDeviceInfo = 2,
  /// 请求端口状态， <主控盒> 上报
  GetPortStat = 3,
  /// 读取所有sensor config
  GetSensorConfig = 4,
  /// 按默认配置一键订阅传感器数据
  StartDataStream = 6,
  /// 停止全部订阅数据流
  StopDataStream = 7,
}
impl ConfigReqType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::ReqNone => "REQ_NONE",
      Self::GetDeviceInfo => "GET_DEVICE_INFO",
      Self::SetDeviceInfo => "SET_DEVICE_INFO",
      Self::GetPortStat => "GET_PORT_STAT",
      Self::GetSensorConfig => "GET_SENSOR_CONFIG",
      Self::StartDataStream => "START_DATA_STREAM",
      Self::StopDataStream => "STOP_DATA_STREAM",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "REQ_NONE" => Some(Self::ReqNone),
      "GET_DEVICE_INFO" => Some(Self::GetDeviceInfo),
      "SET_DEVICE_INFO" => Some(Self::SetDeviceInfo),
      "GET_PORT_STAT" => Some(Self::GetPortStat),
      "GET_SENSOR_CONFIG" => Some(Self::GetSensorConfig),
      "START_DATA_STREAM" => Some(Self::StartDataStream),
      "STOP_DATA_STREAM" => Some(Self::StopDataStream),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigRespError {
  ConfigErrSuccess = 0,
  /// 硬件错误
  ConfigErrHardware = 1,
  /// 参数错误
  ConfigErrParameter = 2,
  /// 未知错误
  ConfigErrUnknown = 3,
}
impl ConfigRespError {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::ConfigErrSuccess => "CONFIG_ERR_SUCCESS",
      Self::ConfigErrHardware => "CONFIG_ERR_HARDWARE",
      Self::ConfigErrParameter => "CONFIG_ERR_PARAMETER",
      Self::ConfigErrUnknown => "CONFIG_ERR_UNKNOWN",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "CONFIG_ERR_SUCCESS" => Some(Self::ConfigErrSuccess),
      "CONFIG_ERR_HARDWARE" => Some(Self::ConfigErrHardware),
      "CONFIG_ERR_PARAMETER" => Some(Self::ConfigErrParameter),
      "CONFIG_ERR_UNKNOWN" => Some(Self::ConfigErrUnknown),
      _ => None,
    }
  }
}
/// 通用传感器采样订阅
///
/// CommonSampleRate
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SamplingRate {
  /// 无采样
  None = 0,
  /// 关闭采样
  Off = 1,
  ///   25 Hz 采样率
  SamplingRate25 = 2,
  ///   50 Hz 采样率
  SamplingRate50 = 3,
  /// 100 Hz 采样率
  SamplingRate100 = 4,
  /// 200 Hz 采样率
  SamplingRate200 = 5,
}
impl SamplingRate {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::None => "SAMPLING_RATE_NONE",
      Self::Off => "SAMPLING_RATE_OFF",
      Self::SamplingRate25 => "SAMPLING_RATE_25",
      Self::SamplingRate50 => "SAMPLING_RATE_50",
      Self::SamplingRate100 => "SAMPLING_RATE_100",
      Self::SamplingRate200 => "SAMPLING_RATE_200",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SAMPLING_RATE_NONE" => Some(Self::None),
      "SAMPLING_RATE_OFF" => Some(Self::Off),
      "SAMPLING_RATE_25" => Some(Self::SamplingRate25),
      "SAMPLING_RATE_50" => Some(Self::SamplingRate50),
      "SAMPLING_RATE_100" => Some(Self::SamplingRate100),
      "SAMPLING_RATE_200" => Some(Self::SamplingRate200),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AfeSampleRate {
  AfeSrInvalid = 0,
  AfeSrOff = 1,
  AfeSr125 = 2,
  AfeSr250 = 3,
  AfeSr500 = 4,
  AfeSr1000 = 5,
  AfeSr2000 = 6,
}
impl AfeSampleRate {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::AfeSrInvalid => "AFE_SR_INVALID",
      Self::AfeSrOff => "AFE_SR_OFF",
      Self::AfeSr125 => "AFE_SR_125",
      Self::AfeSr250 => "AFE_SR_250",
      Self::AfeSr500 => "AFE_SR_500",
      Self::AfeSr1000 => "AFE_SR_1000",
      Self::AfeSr2000 => "AFE_SR_2000",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "AFE_SR_INVALID" => Some(Self::AfeSrInvalid),
      "AFE_SR_OFF" => Some(Self::AfeSrOff),
      "AFE_SR_125" => Some(Self::AfeSr125),
      "AFE_SR_250" => Some(Self::AfeSr250),
      "AFE_SR_500" => Some(Self::AfeSr500),
      "AFE_SR_1000" => Some(Self::AfeSr1000),
      "AFE_SR_2000" => Some(Self::AfeSr2000),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ImuSampleRate {
  ImuSrUnused = 0,
  /// IMU关闭采样
  ImuSrOff = 1,
  /// IMU订阅采样率25HZ
  ImuSr25 = 2,
  /// IMU订阅采样率50HZ
  ImuSr50 = 3,
  /// IMU订阅采样率100HZ
  ImuSr100 = 4,
  /// IMU订阅采样率400HZ
  ImuSr400 = 5,
}
impl ImuSampleRate {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::ImuSrUnused => "IMU_SR_UNUSED",
      Self::ImuSrOff => "IMU_SR_OFF",
      Self::ImuSr25 => "IMU_SR_25",
      Self::ImuSr50 => "IMU_SR_50",
      Self::ImuSr100 => "IMU_SR_100",
      Self::ImuSr400 => "IMU_SR_400",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "IMU_SR_UNUSED" => Some(Self::ImuSrUnused),
      "IMU_SR_OFF" => Some(Self::ImuSrOff),
      "IMU_SR_25" => Some(Self::ImuSr25),
      "IMU_SR_50" => Some(Self::ImuSr50),
      "IMU_SR_100" => Some(Self::ImuSr100),
      "IMU_SR_400" => Some(Self::ImuSr400),
      _ => None,
    }
  }
}
/// 磁力计采样订阅
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MagSampleRate {
  MagSrUnused = 0,
  MagSrOff = 1,
  MagSr10 = 2,
  MagSr20 = 3,
  MagSr50 = 4,
  MagSr100 = 5,
}
impl MagSampleRate {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::MagSrUnused => "MAG_SR_UNUSED",
      Self::MagSrOff => "MAG_SR_OFF",
      Self::MagSr10 => "MAG_SR_10",
      Self::MagSr20 => "MAG_SR_20",
      Self::MagSr50 => "MAG_SR_50",
      Self::MagSr100 => "MAG_SR_100",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "MAG_SR_UNUSED" => Some(Self::MagSrUnused),
      "MAG_SR_OFF" => Some(Self::MagSrOff),
      "MAG_SR_10" => Some(Self::MagSr10),
      "MAG_SR_20" => Some(Self::MagSr20),
      "MAG_SR_50" => Some(Self::MagSr50),
      "MAG_SR_100" => Some(Self::MagSr100),
      _ => None,
    }
  }
}
/// 主控盒外接端口编号，普通接口(A-E),多通道接口(F)
/// 只针对主控盒设备指定控制外接端口号
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CtrlBoxPort {
  /// 无端口
  PortNone = 0,
  /// 普通接口 A
  PortA = 1,
  /// 普通接口 B
  PortB = 2,
  /// 普通接口 C
  PortC = 3,
  /// 普通接口 D
  PortD = 4,
  /// 普通接口 E
  PortE = 5,
  /// 多通道接口 F（可接入手套传感器）
  PortF = 6,
}
impl CtrlBoxPort {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::PortNone => "PORT_NONE",
      Self::PortA => "PORT_A",
      Self::PortB => "PORT_B",
      Self::PortC => "PORT_C",
      Self::PortD => "PORT_D",
      Self::PortE => "PORT_E",
      Self::PortF => "PORT_F",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "PORT_NONE" => Some(Self::PortNone),
      "PORT_A" => Some(Self::PortA),
      "PORT_B" => Some(Self::PortB),
      "PORT_C" => Some(Self::PortC),
      "PORT_D" => Some(Self::PortD),
      "PORT_E" => Some(Self::PortE),
      "PORT_F" => Some(Self::PortF),
      _ => None,
    }
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceSetupInfo {
  #[prost(string, tag = "2")]
  pub model: ::prost::alloc::string::String,
  #[prost(string, tag = "3")]
  pub sn: ::prost::alloc::string::String,
  #[prost(bytes = "vec", tag = "4")]
  pub mac_address: ::prost::alloc::vec::Vec<u8>,
  #[prost(message, optional, tag = "5")]
  pub usb_info: ::core::option::Option<UsbInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UsbInfo {
  /// size = 2 bytes
  ///
  /// 产品 ID (Product ID)
  #[prost(uint32, tag = "1")]
  pub usb_pid: u32,
  /// size = 2 bytes
  ///
  /// 厂商 ID (Vendor ID)
  #[prost(uint32, tag = "2")]
  pub usb_vid: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppDongle {
  /// 消息 ID
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  /// 消息类型
  #[prost(enumeration = "app_dongle::MsgType", tag = "2")]
  pub msg_type: i32,
  /// 配置设备信息/获取相关数据 sn, model, hw_version
  #[prost(message, optional, tag = "3")]
  pub device_info: ::core::option::Option<DeviceInfoConfig>,
  /// 配置设备配对/获取相关数据 pair_key, model, sn, mac_address， model, sn
  #[prost(message, optional, tag = "4")]
  pub setup_info: ::core::option::Option<DeviceSetupInfo>,
  /// OTA 升级数据, 无需设置 MsgType
  #[prost(message, optional, tag = "5")]
  pub ota_cfg: ::core::option::Option<OtaConfig>,
}
/// Nested message and enum types in `AppDongle`.
pub mod app_dongle {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum MsgType {
    /// 无消息类型
    None = 0,
    /// 配置设置
    ConfigSet = 1,
    /// 配置获取
    ConfigGet = 2,
    /// 配对设置
    PairSet = 3,
    /// 配对获取
    PairGet = 4,
    /// 配对状态
    PairStat = 5,
  }
  impl MsgType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::None => "NONE",
        Self::ConfigSet => "CONFIG_SET",
        Self::ConfigGet => "CONFIG_GET",
        Self::PairSet => "PAIR_SET",
        Self::PairGet => "PAIR_GET",
        Self::PairStat => "PAIR_STAT",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "NONE" => Some(Self::None),
        "CONFIG_SET" => Some(Self::ConfigSet),
        "CONFIG_GET" => Some(Self::ConfigGet),
        "PAIR_SET" => Some(Self::PairSet),
        "PAIR_GET" => Some(Self::PairGet),
        "PAIR_STAT" => Some(Self::PairStat),
        _ => None,
      }
    }
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DongleApp {
  /// 消息ID
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  /// 消息错误代码
  #[prost(enumeration = "dongle_app::MsgErrorCode", tag = "2")]
  pub error: i32,
  /// 设备信息
  #[prost(message, optional, tag = "3")]
  pub device_info: ::core::option::Option<DeviceInfo>,
  /// 设备配对和配置相关信息
  #[prost(message, optional, tag = "4")]
  pub setup_info: ::core::option::Option<DeviceSetupInfo>,
  /// 配对状态
  #[prost(enumeration = "dongle_app::PairingStatus", tag = "5")]
  pub pairing_status: i32,
  /// OTA 升级配置
  #[prost(message, optional, tag = "6")]
  pub ota_resp: ::core::option::Option<OtaConfigResp>,
}
/// Nested message and enum types in `DongleApp`.
pub mod dongle_app {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum PairingStatus {
    /// 无配对状态
    None = 0,
    /// 空闲状态
    Idle = 1,
    /// 扫描状态
    Scanning = 2,
    /// 已连接
    Connected = 3,
    /// 已配对
    Paired = 4,
    /// 配对被拒绝
    PairRefused = 5,
  }
  impl PairingStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::None => "NONE",
        Self::Idle => "IDLE",
        Self::Scanning => "SCANNING",
        Self::Connected => "CONNECTED",
        Self::Paired => "PAIRED",
        Self::PairRefused => "PAIR_REFUSED",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "NONE" => Some(Self::None),
        "IDLE" => Some(Self::Idle),
        "SCANNING" => Some(Self::Scanning),
        "CONNECTED" => Some(Self::Connected),
        "PAIRED" => Some(Self::Paired),
        "PAIR_REFUSED" => Some(Self::PairRefused),
        _ => None,
      }
    }
  }
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum MsgErrorCode {
    /// 无错误
    ErrNone = 0,
    /// 成功
    Success = 1,
    /// 无效参数
    InvalidParam = 2,
    /// NVS 写入失败
    NvsWriteFailed = 3,
  }
  impl MsgErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::ErrNone => "ERR_NONE",
        Self::Success => "SUCCESS",
        Self::InvalidParam => "INVALID_PARAM",
        Self::NvsWriteFailed => "NVS_WRITE_FAILED",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "ERR_NONE" => Some(Self::ErrNone),
        "SUCCESS" => Some(Self::Success),
        "INVALID_PARAM" => Some(Self::InvalidParam),
        "NVS_WRITE_FAILED" => Some(Self::NvsWriteFailed),
        _ => None,
      }
    }
  }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AfeConfig {
  #[prost(enumeration = "AfeSampleRate", tag = "1")]
  pub sample_rate: i32,
  /// 32 bits channel mask
  #[prost(uint32, tag = "2")]
  pub channel_bits: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Xyz {
  #[prost(float, tag = "1")]
  pub x: f32,
  #[prost(float, tag = "2")]
  pub y: f32,
  #[prost(float, tag = "3")]
  pub z: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuCalibration {
  /// acceleration 3-asix offset
  #[prost(message, optional, tag = "2")]
  pub acc_correction: ::core::option::Option<Xyz>,
  /// gyroscope 3-asix offset
  #[prost(message, optional, tag = "3")]
  pub gyro_correction: ::core::option::Option<Xyz>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagCalibration {
  #[prost(message, optional, tag = "2")]
  pub mag_local_field: ::core::option::Option<Xyz>,
  /// hard iron calibration parameter
  #[prost(message, optional, tag = "3")]
  pub mag_hard_iron_correction: ::core::option::Option<Xyz>,
  /// soft iron calibration parameter
  #[prost(message, repeated, tag = "4")]
  pub mag_soft_iron_correction: ::prost::alloc::vec::Vec<Xyz>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuConfig {
  #[prost(enumeration = "imu_config::ImuMode", tag = "1")]
  pub imu_mode: i32,
  #[prost(enumeration = "ImuSampleRate", tag = "2")]
  pub imu_sr: i32,
  #[prost(enumeration = "CtrlBoxPort", tag = "3")]
  pub port: i32,
  /// request upload data stream type
  #[prost(enumeration = "UploadDataType", tag = "4")]
  pub data_type: i32,
  #[prost(message, optional, tag = "5")]
  pub imu_calibration: ::core::option::Option<ImuCalibration>,
}
/// Nested message and enum types in `ImuConfig`.
pub mod imu_config {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum ImuMode {
    NotSet = 0,
    Acc = 1,
    Gyro = 2,
    AccGyro = 3,
    Euler = 4,
  }
  impl ImuMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::NotSet => "NOT_SET",
        Self::Acc => "ACC",
        Self::Gyro => "GYRO",
        Self::AccGyro => "ACC_GYRO",
        Self::Euler => "EULER",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "NOT_SET" => Some(Self::NotSet),
        "ACC" => Some(Self::Acc),
        "GYRO" => Some(Self::Gyro),
        "ACC_GYRO" => Some(Self::AccGyro),
        "EULER" => Some(Self::Euler),
        _ => None,
      }
    }
  }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccConfig {
  #[prost(enumeration = "SamplingRate", tag = "1")]
  pub acc_sr: i32,
  #[prost(enumeration = "CtrlBoxPort", tag = "2")]
  pub port: i32,
  #[prost(enumeration = "UploadDataType", tag = "3")]
  pub data_type: i32,
  #[prost(message, optional, tag = "4")]
  pub imu_calibration: ::core::option::Option<ImuCalibration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagConfig {
  #[prost(enumeration = "MagSampleRate", tag = "1")]
  pub mag_sr: i32,
  #[prost(enumeration = "UploadDataType", tag = "2")]
  pub data_type: i32,
  #[prost(message, optional, tag = "3")]
  pub mag_calibration: ::core::option::Option<MagCalibration>,
}
/// flexible sensor configure
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlexConfig {
  #[prost(enumeration = "SamplingRate", tag = "1")]
  pub sample_rate: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UploadDataType {
  TypeUnspecified = 0,
  /// upload 16bit raw data
  RawData = 1,
  /// Upload physical values computed using calibration parameters
  CalibratedData = 2,
}
impl UploadDataType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::TypeUnspecified => "TYPE_UNSPECIFIED",
      Self::RawData => "RAW_DATA",
      Self::CalibratedData => "CALIBRATED_DATA",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "TYPE_UNSPECIFIED" => Some(Self::TypeUnspecified),
      "RAW_DATA" => Some(Self::RawData),
      "CALIBRATED_DATA" => Some(Self::CalibratedData),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AfeConfResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  /// 32 bits channel mask
  #[prost(uint32, tag = "2")]
  pub channel_subscriptions: u32,
  #[prost(message, optional, tag = "3")]
  pub config: ::core::option::Option<AfeConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuConfResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(enumeration = "CtrlBoxPort", tag = "2")]
  pub port: i32,
  #[prost(message, optional, tag = "3")]
  pub config: ::core::option::Option<ImuConfig>,
  /// coefficient for calculating acceleration, eg. acc value on the X-axis = RAW_ADC_x * acc_coefficient
  #[prost(float, tag = "4")]
  pub acc_coefficient: f32,
  /// coefficient for calculating Gyroscope, eg. Gyro value on the X-axis = RAW_ADC_x * gyro_coefficient
  #[prost(float, tag = "5")]
  pub gyro_coefficient: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccConfResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(enumeration = "CtrlBoxPort", tag = "2")]
  pub port: i32,
  #[prost(message, optional, tag = "3")]
  pub config: ::core::option::Option<AccConfig>,
  /// coefficient for calculating acceleration, value = RAW_ADC * acc_coefficient
  #[prost(float, tag = "4")]
  pub acc_coefficient: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagConfResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub resp_err: i32,
  #[prost(message, optional, tag = "2")]
  pub config: ::core::option::Option<MagConfig>,
  /// coefficient for calculating magnetometer, value = RAW_ADC * mag_coefficient
  #[prost(float, tag = "3")]
  pub mag_coefficient: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlexConfResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(message, optional, tag = "2")]
  pub config: ::core::option::Option<FlexConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AfeData {
  #[prost(uint32, tag = "1")]
  pub seq_num: u32,
  /// each bit represents the connection status of corresponding channel
  #[prost(uint32, tag = "2")]
  pub lead_off_bits: u32,
  /// n channels, m samples, 24-bit big endian
  #[prost(bytes = "vec", repeated, tag = "4")]
  pub channel_adc_value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImuData {
  #[prost(uint32, tag = "1")]
  pub seq_num: u32,
  /// 16-bit precision, sequence as x-y-z, little endian
  #[prost(bytes = "vec", tag = "4")]
  pub acc_raw_data: ::prost::alloc::vec::Vec<u8>,
  /// 16-bit precision, sequence as x-y-z, little endian
  #[prost(bytes = "vec", tag = "6")]
  pub gyro_raw_data: ::prost::alloc::vec::Vec<u8>,
  /// valid range is (-180, +180), sequence as yaw-pitch-roll
  #[prost(float, repeated, tag = "7")]
  pub eular_raw_data: ::prost::alloc::vec::Vec<f32>,
  #[prost(enumeration = "CtrlBoxPort", tag = "8")]
  pub port: i32,
  /// sequence as x-y-z , unit(g)
  #[prost(float, repeated, tag = "9")]
  pub acc_correction_data: ::prost::alloc::vec::Vec<f32>,
  /// sequence as x-y-z , unit(dps)
  #[prost(float, repeated, tag = "10")]
  pub gyro_correction_data: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccData {
  #[prost(uint32, tag = "1")]
  pub seq_num: u32,
  #[prost(enumeration = "CtrlBoxPort", tag = "2")]
  pub port: i32,
  /// acc raw data, 16-bit precision, sequence as x-y-z, little endian
  #[prost(bytes = "vec", tag = "5")]
  pub acc_raw_data: ::prost::alloc::vec::Vec<u8>,
  /// sequence as x-y-z , unit(g)
  #[prost(float, repeated, tag = "6")]
  pub acc_correction_data: ::prost::alloc::vec::Vec<f32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MagData {
  #[prost(uint32, tag = "1")]
  pub seq_num: u32,
  /// mag raw data, 16-bit precision, sequence as x-y-z, little endian
  #[prost(bytes = "vec", tag = "4")]
  pub mag_raw_data: ::prost::alloc::vec::Vec<u8>,
  /// sequence as x-y-z , unit(gauss)
  #[prost(float, repeated, tag = "5")]
  pub mag_correction_data: ::prost::alloc::vec::Vec<f32>,
}
/// flexible sensor data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlexData {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(uint32, tag = "2")]
  pub seq_num: u32,
  /// 12 bytes for one group, <int16><little endian>, 6 channels in one group
  #[prost(bytes = "vec", repeated, tag = "4")]
  pub channel_adc_value: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PortStat {
  /// sensor port conncet status, bitN reprents the port N is connected sensor or not
  #[prost(uint32, tag = "1")]
  pub port_connected_bits: u32,
  /// bytes size = 6, each value reprents the sensor type connected to port, (0-5)~(PORTA-PORTF)
  #[prost(enumeration = "BoxSensorType", repeated, tag = "2")]
  pub box_sensor_list: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HallConfig {
  #[prost(enumeration = "SamplingRate", tag = "1")]
  pub hall_sr: i32,
  #[prost(enumeration = "CtrlBoxPort", tag = "2")]
  pub port: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HallData {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(uint32, tag = "2")]
  pub seq_num: u32,
  #[prost(enumeration = "SamplingRate", tag = "3")]
  pub sample_rate: i32,
  /// data size  = 1byte , value = (0 or 1)
  #[prost(bytes = "vec", tag = "4")]
  pub hall_value: ::prost::alloc::vec::Vec<u8>,
  /// magnetic intensity, 16-bit precision, data number = len / 2
  #[prost(bytes = "vec", tag = "5")]
  pub magnetic_intensity: ::prost::alloc::vec::Vec<u8>,
  #[prost(enumeration = "CtrlBoxPort", tag = "6")]
  pub port: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HallResp {
  #[prost(enumeration = "ConfigRespError", tag = "1")]
  pub error: i32,
  #[prost(message, optional, tag = "2")]
  pub hall_conf: ::core::option::Option<HallConfig>,
  #[prost(enumeration = "CtrlBoxPort", tag = "3")]
  pub port: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppToControlBox {
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  #[prost(enumeration = "ConfigReqType", tag = "2")]
  pub msg_cmd: i32,
  #[prost(message, optional, tag = "3")]
  pub device_info_cfg: ::core::option::Option<DeviceInfoConfig>,
  /// dfu config
  #[prost(message, optional, tag = "5")]
  pub ota_cfg: ::core::option::Option<OtaConfig>,
  /// IMU & Mag Sensor 10 - 19
  #[prost(message, optional, tag = "10")]
  pub imu_config: ::core::option::Option<ImuConfig>,
  #[prost(message, optional, tag = "11")]
  pub mag_config: ::core::option::Option<MagConfig>,
  /// ExG Sensor 20 -29
  #[prost(message, optional, tag = "20")]
  pub afe_config: ::core::option::Option<AfeConfig>,
  #[prost(message, optional, tag = "21")]
  pub acc_config: ::core::option::Option<AccConfig>,
  #[prost(message, optional, tag = "23")]
  pub hall_config: ::core::option::Option<HallConfig>,
  #[prost(message, optional, tag = "25")]
  pub flex_config: ::core::option::Option<FlexConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlBoxToApp {
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  #[prost(message, optional, tag = "2")]
  pub device_info: ::core::option::Option<DeviceInfo>,
  #[prost(enumeration = "DeviceEvent", tag = "3")]
  pub device_event: i32,
  #[prost(message, optional, tag = "4")]
  pub port_stat: ::core::option::Option<PortStat>,
  /// dfu response
  #[prost(message, optional, tag = "5")]
  pub ota_resp: ::core::option::Option<OtaConfigResp>,
  /// IMU & Mag Sensor
  #[prost(message, optional, tag = "10")]
  pub imu_data: ::core::option::Option<ImuData>,
  #[prost(message, optional, tag = "11")]
  pub imu_resp: ::core::option::Option<ImuConfResp>,
  #[prost(message, optional, tag = "15")]
  pub acc_data: ::core::option::Option<AccData>,
  #[prost(message, optional, tag = "16")]
  pub acc_resp: ::core::option::Option<AccConfResp>,
  #[prost(message, optional, tag = "22")]
  pub flex_data: ::core::option::Option<FlexData>,
  #[prost(message, optional, tag = "23")]
  pub flex_resp: ::core::option::Option<FlexConfResp>,
  #[prost(message, optional, tag = "24")]
  pub hall_data: ::core::option::Option<HallData>,
  #[prost(message, optional, tag = "25")]
  pub hall_resp: ::core::option::Option<HallResp>,
}
/// private protocol for control box device
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BoxSensorType {
  SensNone = 0,
  /// IMU sensor
  SensImu = 1,
  /// ACC sensor
  SensAcc = 2,
  /// Hall sensor
  SensHall = 3,
  /// flexible sensor
  SensFlex = 4,
}
impl BoxSensorType {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::SensNone => "SENS_NONE",
      Self::SensImu => "SENS_IMU",
      Self::SensAcc => "SENS_ACC",
      Self::SensHall => "SENS_HALL",
      Self::SensFlex => "SENS_FLEX",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SENS_NONE" => Some(Self::SensNone),
      "SENS_IMU" => Some(Self::SensImu),
      "SENS_ACC" => Some(Self::SensAcc),
      "SENS_HALL" => Some(Self::SensHall),
      "SENS_FLEX" => Some(Self::SensFlex),
      _ => None,
    }
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PpgReport {
  #[prost(message, repeated, tag = "1")]
  pub raw: ::prost::alloc::vec::Vec<ppg_report::RawData>,
  #[prost(message, repeated, tag = "2")]
  pub algo: ::prost::alloc::vec::Vec<ppg_report::AlgoData>,
}
/// Nested message and enum types in `PpgReport`.
pub mod ppg_report {
  #[derive(Clone, Copy, PartialEq, ::prost::Message)]
  pub struct RawData {
    /// Green counter
    #[prost(int32, tag = "1")]
    pub green1: i32,
    /// Red counter
    #[prost(int32, tag = "2")]
    pub green2: i32,
    /// IR counter
    #[prost(int32, tag = "3")]
    pub ir: i32,
    /// Green2 counter
    #[prost(int32, tag = "4")]
    pub red: i32,
  }
  #[derive(Clone, Copy, PartialEq, ::prost::Message)]
  pub struct AlgoData {
    /// Current operation mode
    #[prost(enumeration = "super::PpgOpMode", tag = "1")]
    pub op_mode: i32,
    /// 10x last calculated heart rate
    #[prost(uint32, tag = "2")]
    pub hr: u32,
    /// Last calculated confidence level in %
    #[prost(uint32, tag = "3")]
    pub hr_conf: u32,
    /// 10x RR interbeat interval in ms, only shows a nonzero value when a new value is calculated.
    #[prost(uint32, tag = "4")]
    pub rr: u32,
    /// Calculated confidence level of RR in %, only shows a nonzero value when a new value is calculated.
    #[prost(uint32, tag = "5")]
    pub rr_conf: u32,
    /// Activity class
    #[prost(enumeration = "super::PpgActivity", tag = "6")]
    pub activity: i32,
    /// 1000x last calculated SpO2 R value
    #[prost(uint32, tag = "7")]
    pub r: u32,
    /// Last calculated SpO2 confidence level in %
    #[prost(uint32, tag = "8")]
    pub spo2_conf: u32,
    /// 10x last calculated SpO2 %
    #[prost(uint32, tag = "9")]
    pub spo2: u32,
    /// Calculation progress in % in one-shot mode of algorithm. In continuous mode, it is reported as zero and only jumps to 100 when the SpO2 value is updated.
    #[prost(uint32, tag = "10")]
    pub spo2_progress: u32,
    /// Shows the low quality of the PPG signal: 0: Good quality, 1: Low quality
    #[prost(bool, tag = "11")]
    pub spo2_lsq_flag: bool,
    /// Shows excessive motion: 0: No motion, 1: Excessive motion
    #[prost(bool, tag = "12")]
    pub spo2_mt_flag: bool,
    /// Shows the low perfusion index (PI) of the PPG signal: 0: Normal PI, 1: Low PI
    #[prost(bool, tag = "13")]
    pub spo2_lp_flag: bool,
    /// Shows the reliability of R: 0: Reliable, 1: Unreliable
    #[prost(bool, tag = "14")]
    pub spo2_ur_flag: bool,
    /// Reported status of the SpO2 algorithm:
    #[prost(enumeration = "super::PpgSpo2State", tag = "15")]
    pub spo2_state: i32,
    /// Skin contact state
    #[prost(enumeration = "super::PpgScdState", tag = "16")]
    pub scd_state: i32,
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PpgInfo {
  #[prost(enumeration = "ppg_info::DeviceError", tag = "1")]
  pub dev_err: i32,
  #[prost(enumeration = "PpgChip", tag = "2")]
  pub chip: i32,
  #[prost(string, tag = "3")]
  pub version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PpgInfo`.
pub mod ppg_info {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum DeviceError {
    ErrNone = 0,
    ErrHard = 1,
    ErrUnknown = 2,
    ErrParam = 3,
    ErrTimeout = 4,
  }
  impl DeviceError {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::ErrNone => "ERR_NONE",
        Self::ErrHard => "ERR_HARD",
        Self::ErrUnknown => "ERR_UNKNOWN",
        Self::ErrParam => "ERR_PARAM",
        Self::ErrTimeout => "ERR_TIMEOUT",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "ERR_NONE" => Some(Self::ErrNone),
        "ERR_HARD" => Some(Self::ErrHard),
        "ERR_UNKNOWN" => Some(Self::ErrUnknown),
        "ERR_PARAM" => Some(Self::ErrParam),
        "ERR_TIMEOUT" => Some(Self::ErrTimeout),
        _ => None,
      }
    }
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PpgData {
  #[prost(uint32, tag = "1")]
  pub seq_num: u32,
  #[prost(enumeration = "PpgUr", tag = "2")]
  pub report_rate: i32,
  #[prost(enumeration = "PpgMode", tag = "3")]
  pub mode: i32,
  #[prost(message, optional, tag = "4")]
  pub report: ::core::option::Option<PpgReport>,
  #[prost(bool, tag = "5")]
  pub seg_finished: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PpgConfig {
  #[prost(enumeration = "PpgMode", tag = "1")]
  pub ppg_mode: i32,
  /// set ppg report upload rate
  #[prost(enumeration = "PpgUr", tag = "2")]
  pub ppg_ur: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgChip {
  PpgMax32664 = 0,
  PpgGh3011 = 1,
}
impl PpgChip {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::PpgMax32664 => "PPG_MAX32664",
      Self::PpgGh3011 => "PPG_GH3011",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "PPG_MAX32664" => Some(Self::PpgMax32664),
      "PPG_GH3011" => Some(Self::PpgGh3011),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgUr {
  PpgInvalid = 0,
  PpgOff = 1,
  PpgUr1 = 2,
  PpgUr5 = 3,
  PpgUr25 = 4,
  PpgUr50 = 5,
  PpgUr100 = 6,
}
impl PpgUr {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::PpgInvalid => "PPG_INVALID",
      Self::PpgOff => "PPG_OFF",
      Self::PpgUr1 => "PPG_UR_1",
      Self::PpgUr5 => "PPG_UR_5",
      Self::PpgUr25 => "PPG_UR_25",
      Self::PpgUr50 => "PPG_UR_50",
      Self::PpgUr100 => "PPG_UR_100",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "PPG_INVALID" => Some(Self::PpgInvalid),
      "PPG_OFF" => Some(Self::PpgOff),
      "PPG_UR_1" => Some(Self::PpgUr1),
      "PPG_UR_5" => Some(Self::PpgUr5),
      "PPG_UR_25" => Some(Self::PpgUr25),
      "PPG_UR_50" => Some(Self::PpgUr50),
      "PPG_UR_100" => Some(Self::PpgUr100),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgMode {
  Invalid = 0,
  Raw = 1,
  Algo = 2,
  Spo2 = 3,
  Hr = 4,
  Hrv = 5,
}
impl PpgMode {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::Invalid => "PPG_MODE_INVALID",
      Self::Raw => "PPG_MODE_RAW",
      Self::Algo => "PPG_MODE_ALGO",
      Self::Spo2 => "PPG_MODE_SPO2",
      Self::Hr => "PPG_MODE_HR",
      Self::Hrv => "PPG_MODE_HRV",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "PPG_MODE_INVALID" => Some(Self::Invalid),
      "PPG_MODE_RAW" => Some(Self::Raw),
      "PPG_MODE_ALGO" => Some(Self::Algo),
      "PPG_MODE_SPO2" => Some(Self::Spo2),
      "PPG_MODE_HR" => Some(Self::Hr),
      "PPG_MODE_HRV" => Some(Self::Hrv),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgOpMode {
  /// 0: Continuous HRM and Continuous SpO2
  OpModeContHrmContSpo2 = 0,
  /// 1: Continuous HRM and One-Shot SpO2
  OpModeContHrmOnesSpo2 = 1,
  /// 2: Continuous HRM
  OpModeContHrm = 2,
  /// 3: Sampled HRM
  OpModeSampHrm = 3,
  /// 4: Sampled HRM and One-Shot SpO2
  OpModeSampHrmOnesSpo2 = 4,
  /// 5: Activity tracking
  OpModeActivityTracking = 5,
  /// 6: SpO2 calibration
  OpModeSpo2Calibration = 6,
}
impl PpgOpMode {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::OpModeContHrmContSpo2 => "OP_MODE_CONT_HRM_CONT_SPO2",
      Self::OpModeContHrmOnesSpo2 => "OP_MODE_CONT_HRM_ONES_SPO2",
      Self::OpModeContHrm => "OP_MODE_CONT_HRM",
      Self::OpModeSampHrm => "OP_MODE_SAMP_HRM",
      Self::OpModeSampHrmOnesSpo2 => "OP_MODE_SAMP_HRM_ONES_SPO2",
      Self::OpModeActivityTracking => "OP_MODE_ACTIVITY_TRACKING",
      Self::OpModeSpo2Calibration => "OP_MODE_SPO2_CALIBRATION",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "OP_MODE_CONT_HRM_CONT_SPO2" => Some(Self::OpModeContHrmContSpo2),
      "OP_MODE_CONT_HRM_ONES_SPO2" => Some(Self::OpModeContHrmOnesSpo2),
      "OP_MODE_CONT_HRM" => Some(Self::OpModeContHrm),
      "OP_MODE_SAMP_HRM" => Some(Self::OpModeSampHrm),
      "OP_MODE_SAMP_HRM_ONES_SPO2" => Some(Self::OpModeSampHrmOnesSpo2),
      "OP_MODE_ACTIVITY_TRACKING" => Some(Self::OpModeActivityTracking),
      "OP_MODE_SPO2_CALIBRATION" => Some(Self::OpModeSpo2Calibration),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgActivity {
  /// 0: Rest
  PpgActRest = 0,
  /// 1: Other
  PpgActOther = 1,
  /// 2: Walk
  PpgActWalk = 2,
  /// 3: Run
  PpgActRun = 3,
  /// 4: Bike
  PpgActBike = 4,
}
impl PpgActivity {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::PpgActRest => "PPG_ACT_REST",
      Self::PpgActOther => "PPG_ACT_OTHER",
      Self::PpgActWalk => "PPG_ACT_WALK",
      Self::PpgActRun => "PPG_ACT_RUN",
      Self::PpgActBike => "PPG_ACT_BIKE",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "PPG_ACT_REST" => Some(Self::PpgActRest),
      "PPG_ACT_OTHER" => Some(Self::PpgActOther),
      "PPG_ACT_WALK" => Some(Self::PpgActWalk),
      "PPG_ACT_RUN" => Some(Self::PpgActRun),
      "PPG_ACT_BIKE" => Some(Self::PpgActBike),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgSpo2State {
  /// 0: LED adjustment
  Spo2StateLedAdjustment = 0,
  /// 1: Computation
  Spo2StateComputation = 1,
  /// 2: Success
  Spo2StateRetSuccess = 2,
  /// 3: Timeout
  Spo2StateTimeout = 3,
}
impl PpgSpo2State {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::Spo2StateLedAdjustment => "SPO2_STATE_LED_ADJUSTMENT",
      Self::Spo2StateComputation => "SPO2_STATE_COMPUTATION",
      Self::Spo2StateRetSuccess => "SPO2_STATE_RET_SUCCESS",
      Self::Spo2StateTimeout => "SPO2_STATE_TIMEOUT",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SPO2_STATE_LED_ADJUSTMENT" => Some(Self::Spo2StateLedAdjustment),
      "SPO2_STATE_COMPUTATION" => Some(Self::Spo2StateComputation),
      "SPO2_STATE_RET_SUCCESS" => Some(Self::Spo2StateRetSuccess),
      "SPO2_STATE_TIMEOUT" => Some(Self::Spo2StateTimeout),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PpgScdState {
  /// 0: Undetected
  ScdStateUndetected = 0,
  /// 1: Off skin
  ScdStateOffSkin = 1,
  /// 2: On some subject
  ScdStateOnSomeSubject = 2,
  /// 3: On skin
  ScdStateOnSkin = 3,
}
impl PpgScdState {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::ScdStateUndetected => "SCD_STATE_UNDETECTED",
      Self::ScdStateOffSkin => "SCD_STATE_OFF_SKIN",
      Self::ScdStateOnSomeSubject => "SCD_STATE_ON_SOME_SUBJECT",
      Self::ScdStateOnSkin => "SCD_STATE_ON_SKIN",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SCD_STATE_UNDETECTED" => Some(Self::ScdStateUndetected),
      "SCD_STATE_OFF_SKIN" => Some(Self::ScdStateOffSkin),
      "SCD_STATE_ON_SOME_SUBJECT" => Some(Self::ScdStateOnSomeSubject),
      "SCD_STATE_ON_SKIN" => Some(Self::ScdStateOnSkin),
      _ => None,
    }
  }
}
/// protocol for EXG devices (include EMG,EEG,ECG,GLOVE,PPG)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BleConfig {
  #[prost(string, tag = "1")]
  pub device_name: ::prost::alloc::string::String,
  #[prost(bytes = "vec", tag = "2")]
  pub mac_address: ::prost::alloc::vec::Vec<u8>,
  #[prost(enumeration = "ble_config::PairCmd", tag = "3")]
  pub pair_cmd: i32,
  #[prost(string, tag = "4")]
  pub pair_key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BleConfig`.
pub mod ble_config {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum PairCmd {
    Unknown = 0,
    Pair = 1,
    Verify = 2,
  }
  impl PairCmd {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::Unknown => "PAIR_CMD_UNKNOWN",
        Self::Pair => "PAIR_CMD_PAIR",
        Self::Verify => "PAIR_CMD_VERIFY",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "PAIR_CMD_UNKNOWN" => Some(Self::Unknown),
        "PAIR_CMD_PAIR" => Some(Self::Pair),
        "PAIR_CMD_VERIFY" => Some(Self::Verify),
        _ => None,
      }
    }
  }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppSensor {
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  #[prost(enumeration = "ConfigReqType", tag = "2")]
  pub msg_cmd: i32,
  #[prost(message, optional, tag = "3")]
  pub device_info_cfg: ::core::option::Option<DeviceInfoConfig>,
  #[prost(message, optional, tag = "4")]
  pub ble_conf: ::core::option::Option<BleConfig>,
  #[prost(message, optional, tag = "5")]
  pub ota_cfg: ::core::option::Option<OtaConfig>,
  /// IMU & Mag Sensor 10 - 19
  #[prost(message, optional, tag = "10")]
  pub imu_config: ::core::option::Option<ImuConfig>,
  #[prost(message, optional, tag = "11")]
  pub mag_config: ::core::option::Option<MagConfig>,
  /// ExG Sensor 20 -29
  #[prost(message, optional, tag = "20")]
  pub afe_config: ::core::option::Option<AfeConfig>,
  #[prost(message, optional, tag = "21")]
  pub acc_config: ::core::option::Option<AccConfig>,
  #[prost(message, optional, tag = "25")]
  pub flex_config: ::core::option::Option<FlexConfig>,
  /// PPG Sensor 30 -39
  #[prost(message, optional, tag = "30")]
  pub ppg_config: ::core::option::Option<PpgConfig>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SensorApp {
  #[prost(uint32, tag = "1")]
  pub msg_id: u32,
  #[prost(message, optional, tag = "2")]
  pub device_info: ::core::option::Option<DeviceInfo>,
  #[prost(enumeration = "DeviceEvent", tag = "3")]
  pub device_event: i32,
  #[prost(message, optional, tag = "5")]
  pub ota_resp: ::core::option::Option<OtaConfigResp>,
  #[prost(message, optional, tag = "6")]
  pub ota_data: ::core::option::Option<OtaData>,
  /// IMU & Mag Sensor
  #[prost(message, optional, tag = "10")]
  pub imu_data: ::core::option::Option<ImuData>,
  /// Imu configure response
  #[prost(message, optional, tag = "11")]
  pub imu_resp: ::core::option::Option<ImuConfResp>,
  #[prost(message, optional, tag = "12")]
  pub mag_data: ::core::option::Option<MagData>,
  #[prost(message, optional, tag = "13")]
  pub mag_resp: ::core::option::Option<MagConfResp>,
  #[prost(message, optional, tag = "15")]
  pub acc_data: ::core::option::Option<AccData>,
  #[prost(message, optional, tag = "16")]
  pub acc_resp: ::core::option::Option<AccConfResp>,
  #[prost(message, optional, tag = "17")]
  pub imu_data2: ::core::option::Option<ImuData>,
  /// ExG Sensor
  #[prost(message, optional, tag = "20")]
  pub afe_data: ::core::option::Option<AfeData>,
  #[prost(message, optional, tag = "21")]
  pub afe_resp: ::core::option::Option<AfeConfResp>,
  #[prost(message, optional, tag = "22")]
  pub flex_data: ::core::option::Option<FlexData>,
  #[prost(message, optional, tag = "23")]
  pub flex_resp: ::core::option::Option<FlexConfResp>,
  /// PPG Sensor
  #[prost(message, optional, tag = "30")]
  pub ppg_data: ::core::option::Option<PpgData>,
  #[prost(message, optional, tag = "31")]
  pub ppg_info: ::core::option::Option<PpgInfo>,
}
