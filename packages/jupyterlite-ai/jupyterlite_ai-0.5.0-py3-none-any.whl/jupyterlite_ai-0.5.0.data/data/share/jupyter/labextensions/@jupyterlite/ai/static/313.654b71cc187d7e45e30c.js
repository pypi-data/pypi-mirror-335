"use strict";(self.webpackChunk_jupyterlite_ai=self.webpackChunk_jupyterlite_ai||[]).push([[313,694],{93313:(e,t,s)=>{s.r(t),s.d(t,{ISecretsConnector:()=>c,ISecretsManager:()=>r,InMemoryConnector:()=>o,LocalStorageConnector:()=>i,default:()=>h});class a{constructor(e){this._onchange=e=>{const t=e.target,s=t.dataset.secretsId;if(s){const e=s.split(":"),a=e.shift(),n=e.join(":");a&&n&&this.set(s,{namespace:a,id:n,value:t.value})}},this._attachedInputs=new Map,this._connector=e.connector}async get(e){if(this._connector.fetch)return this._connector.fetch(e)}async set(e,t){this._connector.save&&this._connector.save(e,t)}async remove(e){this._connector.remove&&this._connector.remove(e)}async list(e){if(this._connector.list)return await this._connector.list(e)}async attach(e,t,s,a){const n=`${e}:${t}`;this._attachedInputs.get(n)&&this.detach(e,t),this._attachedInputs.set(n,s),s.dataset.secretsId=n;const c=await this.get(n);!s.value&&c?(s.value=c.value,s.dispatchEvent(new Event("change")),a&&a(c.value)):s.value&&s.value!==(null==c?void 0:c.value)&&this.set(n,{namespace:e,id:t,value:s.value}),s.addEventListener("change",this._onchange)}detach(e,t){const s=`${e}:${t}`;this._detach(s)}async detachAll(e){for(const t of this._attachedInputs.keys())t.startsWith(`${e}:`)&&this._detach(t)}_detach(e){const t=this._attachedInputs.get(e);t&&t.removeEventListener("change",this._onchange),this._attachedInputs.delete(e)}}var n=s(67262);const c=new n.Token("jupyter-secret-manager:connector","The secrets manager connector"),r=new n.Token("jupyter-secret-manager:manager","The secrets manager");class o{constructor(){this._secrets=new Map}async fetch(e){return this._secrets.get(e)}async save(e,t){this._secrets.set(e,t)}async remove(e){this._secrets.delete(e)}async list(e){const t=[],s=[];return this._secrets.forEach(((a,n)=>{a.namespace===e&&(t.push(n),s.push(a))})),{ids:t,values:s}}}class i{constructor(){this.storage="jupyter-secrets:secrets",console.warn("\nThe secret connector used currently should not be used in production, since the\npasswords are stored as plain text in the local storage of the browser'\n    ")}async fetch(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");if(s&&s[e])return s[e]}async save(e,t){var s;const a=JSON.parse(null!==(s=localStorage.getItem(this.storage))&&void 0!==s?s:"{}");a[e]=t,localStorage.setItem(this.storage,JSON.stringify(a))}async remove(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");delete s[e],localStorage.setItem(this.storage,JSON.stringify(s))}async list(e){var t;const s=JSON.parse(null!==(t=localStorage.getItem(this.storage))&&void 0!==t?t:"{}");return Object.keys(s).filter((t=>s[t].namespace===e)).reduce(((e,t)=>(e.ids.push(t),e.values.push(s[t]),e)),{ids:[],values:[]})}}const h=[{id:"jupyter-secrets-manager:connector",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:c,activate:e=>new o},{id:"jupyter-secrets-manager:manager",description:"A JupyterLab extension to manage secrets.",autoStart:!0,provides:r,requires:[c],activate:(e,t)=>(console.log("JupyterLab extension jupyter-secrets-manager is activated!"),new a({connector:t}))}]}}]);