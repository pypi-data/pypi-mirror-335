# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AccessControlPolicyCategoryArgs',
    'AccessControlPolicyCategoryArgsDict',
    'AccessControlPolicyContextFilterListArgs',
    'AccessControlPolicyContextFilterListArgsDict',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListArgs',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListArgsDict',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgsDict',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs',
    'AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListArgs',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListArgsDict',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgsDict',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs',
    'AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict',
    'AccessControlPolicyOwnerReferenceArgs',
    'AccessControlPolicyOwnerReferenceArgsDict',
    'AccessControlPolicyRoleReferenceArgs',
    'AccessControlPolicyRoleReferenceArgsDict',
    'AccessControlPolicyUserGroupReferenceListArgs',
    'AccessControlPolicyUserGroupReferenceListArgsDict',
    'AccessControlPolicyUserReferenceListArgs',
    'AccessControlPolicyUserReferenceListArgsDict',
    'AddressGroupIpAddressBlockListArgs',
    'AddressGroupIpAddressBlockListArgsDict',
    'AddressGroupsV2IpRangeArgs',
    'AddressGroupsV2IpRangeArgsDict',
    'AddressGroupsV2Ipv4AddressArgs',
    'AddressGroupsV2Ipv4AddressArgsDict',
    'AddressGroupsV2LinkArgs',
    'AddressGroupsV2LinkArgsDict',
    'AuthorizationPolicyV2EntityArgs',
    'AuthorizationPolicyV2EntityArgsDict',
    'AuthorizationPolicyV2IdentityArgs',
    'AuthorizationPolicyV2IdentityArgsDict',
    'CategoryV2AssociationArgs',
    'CategoryV2AssociationArgsDict',
    'CategoryV2DetailedAssociationArgs',
    'CategoryV2DetailedAssociationArgsDict',
    'ClusterAddNodeV2ConfigParamArgs',
    'ClusterAddNodeV2ConfigParamArgsDict',
    'ClusterAddNodeV2ConfigParamHipervArgs',
    'ClusterAddNodeV2ConfigParamHipervArgsDict',
    'ClusterAddNodeV2ConfigParamHipervDomainDetailArgs',
    'ClusterAddNodeV2ConfigParamHipervDomainDetailArgsDict',
    'ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs',
    'ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgsDict',
    'ClusterAddNodeV2NodeParamArgs',
    'ClusterAddNodeV2NodeParamArgsDict',
    'ClusterAddNodeV2NodeParamBlockListArgs',
    'ClusterAddNodeV2NodeParamBlockListArgsDict',
    'ClusterAddNodeV2NodeParamBundleInfoArgs',
    'ClusterAddNodeV2NodeParamBundleInfoArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListArgs',
    'ClusterAddNodeV2NodeParamComputeNodeListArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgs',
    'ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgs',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4ArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args',
    'ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6ArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgs',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4ArgsDict',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args',
    'ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6ArgsDict',
    'ClusterAddNodeV2NodeParamHypervisorIsoArgs',
    'ClusterAddNodeV2NodeParamHypervisorIsoArgsDict',
    'ClusterAddNodeV2NodeParamNodeListArgs',
    'ClusterAddNodeV2NodeParamNodeListArgsDict',
    'ClusterAddNodeV2NodeParamNodeListCvmIpArgs',
    'ClusterAddNodeV2NodeParamNodeListCvmIpArgsDict',
    'ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args',
    'ClusterAddNodeV2NodeParamNodeListCvmIpIpv4ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args',
    'ClusterAddNodeV2NodeParamNodeListCvmIpIpv6ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs',
    'ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgsDict',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpArgsDict',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args',
    'ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpArgs',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpArgsDict',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args',
    'ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6ArgsDict',
    'ClusterAddNodeV2NodeParamNodeListNetworkArgs',
    'ClusterAddNodeV2NodeParamNodeListNetworkArgsDict',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgsDict',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgsDict',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs',
    'ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgsDict',
    'ClusterAddNodeV2RemoveNodeParamArgs',
    'ClusterAddNodeV2RemoveNodeParamArgsDict',
    'ClusterAddNodeV2RemoveNodeParamExtraParamArgs',
    'ClusterAddNodeV2RemoveNodeParamExtraParamArgsDict',
    'ClusterV2ConfigArgs',
    'ClusterV2ConfigArgsDict',
    'ClusterV2ConfigAuthorizedPublicKeyListArgs',
    'ClusterV2ConfigAuthorizedPublicKeyListArgsDict',
    'ClusterV2ConfigBuildInfoArgs',
    'ClusterV2ConfigBuildInfoArgsDict',
    'ClusterV2ConfigClusterSoftwareMapArgs',
    'ClusterV2ConfigClusterSoftwareMapArgsDict',
    'ClusterV2ConfigFaultToleranceStateArgs',
    'ClusterV2ConfigFaultToleranceStateArgsDict',
    'ClusterV2ConfigFaultToleranceStateRedundancyStatusArgs',
    'ClusterV2ConfigFaultToleranceStateRedundancyStatusArgsDict',
    'ClusterV2ConfigPulseStatusArgs',
    'ClusterV2ConfigPulseStatusArgsDict',
    'ClusterV2LinkArgs',
    'ClusterV2LinkArgsDict',
    'ClusterV2NetworkArgs',
    'ClusterV2NetworkArgsDict',
    'ClusterV2NetworkBackplaneArgs',
    'ClusterV2NetworkBackplaneArgsDict',
    'ClusterV2NetworkBackplaneNetmaskArgs',
    'ClusterV2NetworkBackplaneNetmaskArgsDict',
    'ClusterV2NetworkBackplaneSubnetArgs',
    'ClusterV2NetworkBackplaneSubnetArgsDict',
    'ClusterV2NetworkExternalAddressArgs',
    'ClusterV2NetworkExternalAddressArgsDict',
    'ClusterV2NetworkExternalAddressIpv4Args',
    'ClusterV2NetworkExternalAddressIpv4ArgsDict',
    'ClusterV2NetworkExternalAddressIpv6Args',
    'ClusterV2NetworkExternalAddressIpv6ArgsDict',
    'ClusterV2NetworkExternalDataServicesIpArgs',
    'ClusterV2NetworkExternalDataServicesIpArgsDict',
    'ClusterV2NetworkExternalDataServicesIpIpv4Args',
    'ClusterV2NetworkExternalDataServicesIpIpv4ArgsDict',
    'ClusterV2NetworkExternalDataServicesIpIpv6Args',
    'ClusterV2NetworkExternalDataServicesIpIpv6ArgsDict',
    'ClusterV2NetworkHttpProxyListArgs',
    'ClusterV2NetworkHttpProxyListArgsDict',
    'ClusterV2NetworkHttpProxyListIpAddressArgs',
    'ClusterV2NetworkHttpProxyListIpAddressArgsDict',
    'ClusterV2NetworkHttpProxyListIpAddressIpv4Args',
    'ClusterV2NetworkHttpProxyListIpAddressIpv4ArgsDict',
    'ClusterV2NetworkHttpProxyListIpAddressIpv6Args',
    'ClusterV2NetworkHttpProxyListIpAddressIpv6ArgsDict',
    'ClusterV2NetworkHttpProxyWhiteListArgs',
    'ClusterV2NetworkHttpProxyWhiteListArgsDict',
    'ClusterV2NetworkManagementServerArgs',
    'ClusterV2NetworkManagementServerArgsDict',
    'ClusterV2NetworkManagementServerIpArgs',
    'ClusterV2NetworkManagementServerIpArgsDict',
    'ClusterV2NetworkManagementServerIpIpv4Args',
    'ClusterV2NetworkManagementServerIpIpv4ArgsDict',
    'ClusterV2NetworkManagementServerIpIpv6Args',
    'ClusterV2NetworkManagementServerIpIpv6ArgsDict',
    'ClusterV2NetworkMasqueradingIpArgs',
    'ClusterV2NetworkMasqueradingIpArgsDict',
    'ClusterV2NetworkMasqueradingIpIpv4Args',
    'ClusterV2NetworkMasqueradingIpIpv4ArgsDict',
    'ClusterV2NetworkMasqueradingIpIpv6Args',
    'ClusterV2NetworkMasqueradingIpIpv6ArgsDict',
    'ClusterV2NetworkNameServerIpListArgs',
    'ClusterV2NetworkNameServerIpListArgsDict',
    'ClusterV2NetworkNameServerIpListFqdnArgs',
    'ClusterV2NetworkNameServerIpListFqdnArgsDict',
    'ClusterV2NetworkNameServerIpListIpv4Args',
    'ClusterV2NetworkNameServerIpListIpv4ArgsDict',
    'ClusterV2NetworkNameServerIpListIpv6Args',
    'ClusterV2NetworkNameServerIpListIpv6ArgsDict',
    'ClusterV2NetworkNtpServerIpListArgs',
    'ClusterV2NetworkNtpServerIpListArgsDict',
    'ClusterV2NetworkNtpServerIpListFqdnArgs',
    'ClusterV2NetworkNtpServerIpListFqdnArgsDict',
    'ClusterV2NetworkNtpServerIpListIpv4Args',
    'ClusterV2NetworkNtpServerIpListIpv4ArgsDict',
    'ClusterV2NetworkNtpServerIpListIpv6Args',
    'ClusterV2NetworkNtpServerIpListIpv6ArgsDict',
    'ClusterV2NetworkSmtpServerArgs',
    'ClusterV2NetworkSmtpServerArgsDict',
    'ClusterV2NetworkSmtpServerServerArgs',
    'ClusterV2NetworkSmtpServerServerArgsDict',
    'ClusterV2NetworkSmtpServerServerIpAddressArgs',
    'ClusterV2NetworkSmtpServerServerIpAddressArgsDict',
    'ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs',
    'ClusterV2NetworkSmtpServerServerIpAddressFqdnArgsDict',
    'ClusterV2NetworkSmtpServerServerIpAddressIpv4Args',
    'ClusterV2NetworkSmtpServerServerIpAddressIpv4ArgsDict',
    'ClusterV2NetworkSmtpServerServerIpAddressIpv6Args',
    'ClusterV2NetworkSmtpServerServerIpAddressIpv6ArgsDict',
    'ClusterV2NodeArgs',
    'ClusterV2NodeArgsDict',
    'ClusterV2NodeNodeListArgs',
    'ClusterV2NodeNodeListArgsDict',
    'ClusterV2NodeNodeListControllerVmIpArgs',
    'ClusterV2NodeNodeListControllerVmIpArgsDict',
    'ClusterV2NodeNodeListControllerVmIpIpv4Args',
    'ClusterV2NodeNodeListControllerVmIpIpv4ArgsDict',
    'ClusterV2NodeNodeListControllerVmIpIpv6Args',
    'ClusterV2NodeNodeListControllerVmIpIpv6ArgsDict',
    'ClusterV2NodeNodeListHostIpArgs',
    'ClusterV2NodeNodeListHostIpArgsDict',
    'ClusterV2NodeNodeListHostIpIpv4Args',
    'ClusterV2NodeNodeListHostIpIpv4ArgsDict',
    'ClusterV2NodeNodeListHostIpIpv6Args',
    'ClusterV2NodeNodeListHostIpIpv6ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListArgs',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args',
    'ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeArgs',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4ArgsDict',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args',
    'ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListArgs',
    'ClustersUnconfiguredNodeNetworksV2NodeListArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs',
    'ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args',
    'ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6ArgsDict',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs',
    'ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapArgs',
    'DeployTemplatesV2OverrideVmConfigMapArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgsDict',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgs',
    'DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgsDict',
    'DirectoryServicesV2OpenLdapConfigurationArgs',
    'DirectoryServicesV2OpenLdapConfigurationArgsDict',
    'DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs',
    'DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgsDict',
    'DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs',
    'DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgsDict',
    'DirectoryServicesV2ServiceAccountArgs',
    'DirectoryServicesV2ServiceAccountArgsDict',
    'FloatingIpV2AssociationArgs',
    'FloatingIpV2AssociationArgsDict',
    'FloatingIpV2AssociationPrivateIpAssociationArgs',
    'FloatingIpV2AssociationPrivateIpAssociationArgsDict',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgs',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgsDict',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4ArgsDict',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args',
    'FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6ArgsDict',
    'FloatingIpV2AssociationVmNicAssociationArgs',
    'FloatingIpV2AssociationVmNicAssociationArgsDict',
    'FloatingIpV2ExternalSubnetArgs',
    'FloatingIpV2ExternalSubnetArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionArgs',
    'FloatingIpV2ExternalSubnetDhcpOptionArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgs',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args',
    'FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgs',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args',
    'FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetDynamicIpAddressArgs',
    'FloatingIpV2ExternalSubnetDynamicIpAddressArgsDict',
    'FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args',
    'FloatingIpV2ExternalSubnetDynamicIpAddressIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args',
    'FloatingIpV2ExternalSubnetDynamicIpAddressIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigArgs',
    'FloatingIpV2ExternalSubnetIpConfigArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4Args',
    'FloatingIpV2ExternalSubnetIpConfigIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6Args',
    'FloatingIpV2ExternalSubnetIpConfigIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgsDict',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgs',
    'FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgsDict',
    'FloatingIpV2ExternalSubnetIpUsageArgs',
    'FloatingIpV2ExternalSubnetIpUsageArgsDict',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgs',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgsDict',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgs',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgsDict',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgs',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgsDict',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgs',
    'FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgsDict',
    'FloatingIpV2ExternalSubnetLinkArgs',
    'FloatingIpV2ExternalSubnetLinkArgsDict',
    'FloatingIpV2ExternalSubnetReservedIpAddressArgs',
    'FloatingIpV2ExternalSubnetReservedIpAddressArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchLinkArgsDict',
    'FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs',
    'FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgsDict',
    'FloatingIpV2ExternalSubnetVpcArgs',
    'FloatingIpV2ExternalSubnetVpcArgsDict',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgs',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgsDict',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgs',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgsDict',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args',
    'FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetArgs',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgs',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgs',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args',
    'FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgs',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgs',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6ArgsDict',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgs',
    'FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgsDict',
    'FloatingIpV2ExternalSubnetVpcLinkArgs',
    'FloatingIpV2ExternalSubnetVpcLinkArgsDict',
    'FloatingIpV2ExternalSubnetVpcMetadataArgs',
    'FloatingIpV2ExternalSubnetVpcMetadataArgsDict',
    'FloatingIpV2ExternalSubnetVpcSnatIpArgs',
    'FloatingIpV2ExternalSubnetVpcSnatIpArgsDict',
    'FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args',
    'FloatingIpV2ExternalSubnetVpcSnatIpIpv4ArgsDict',
    'FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args',
    'FloatingIpV2ExternalSubnetVpcSnatIpIpv6ArgsDict',
    'FloatingIpV2FloatingIpArgs',
    'FloatingIpV2FloatingIpArgsDict',
    'FloatingIpV2FloatingIpIpv4Args',
    'FloatingIpV2FloatingIpIpv4ArgsDict',
    'FloatingIpV2FloatingIpIpv6Args',
    'FloatingIpV2FloatingIpIpv6ArgsDict',
    'FloatingIpV2LinkArgs',
    'FloatingIpV2LinkArgsDict',
    'FloatingIpV2MetadataArgs',
    'FloatingIpV2MetadataArgsDict',
    'FloatingIpV2VmNicArgs',
    'FloatingIpV2VmNicArgsDict',
    'FloatingIpV2VpcArgs',
    'FloatingIpV2VpcArgsDict',
    'FloatingIpV2VpcCommonDhcpOptionArgs',
    'FloatingIpV2VpcCommonDhcpOptionArgsDict',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgs',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgsDict',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args',
    'FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict',
    'FloatingIpV2VpcExternalSubnetArgs',
    'FloatingIpV2VpcExternalSubnetArgsDict',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgs',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgsDict',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args',
    'FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict',
    'FloatingIpV2VpcExternalSubnetExternalIpArgs',
    'FloatingIpV2VpcExternalSubnetExternalIpArgsDict',
    'FloatingIpV2VpcExternalSubnetExternalIpIpv4Args',
    'FloatingIpV2VpcExternalSubnetExternalIpIpv4ArgsDict',
    'FloatingIpV2VpcExternalSubnetExternalIpIpv6Args',
    'FloatingIpV2VpcExternalSubnetExternalIpIpv6ArgsDict',
    'FloatingIpV2VpcExternallyRoutablePrefixArgs',
    'FloatingIpV2VpcExternallyRoutablePrefixArgsDict',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv4Args',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv4ArgsDict',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgs',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgsDict',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv6Args',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv6ArgsDict',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgs',
    'FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgsDict',
    'FloatingIpV2VpcLinkArgs',
    'FloatingIpV2VpcLinkArgsDict',
    'FloatingIpV2VpcMetadataArgs',
    'FloatingIpV2VpcMetadataArgsDict',
    'FloatingIpV2VpcSnatIpArgs',
    'FloatingIpV2VpcSnatIpArgsDict',
    'FloatingIpV2VpcSnatIpIpv4Args',
    'FloatingIpV2VpcSnatIpIpv4ArgsDict',
    'FloatingIpV2VpcSnatIpIpv6Args',
    'FloatingIpV2VpcSnatIpIpv6ArgsDict',
    'FoundationCentralImageClusterClusterStatusArgs',
    'FoundationCentralImageClusterClusterStatusArgsDict',
    'FoundationCentralImageClusterClusterStatusClusterProgressDetailArgs',
    'FoundationCentralImageClusterClusterStatusClusterProgressDetailArgsDict',
    'FoundationCentralImageClusterClusterStatusNodeProgressDetailArgs',
    'FoundationCentralImageClusterClusterStatusNodeProgressDetailArgsDict',
    'FoundationCentralImageClusterCommonNetworkSettingsArgs',
    'FoundationCentralImageClusterCommonNetworkSettingsArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigArgs',
    'FoundationCentralImageClusterFoundationInitConfigArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigBlockArgs',
    'FoundationCentralImageClusterFoundationInitConfigBlockArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigBlockNodeArgs',
    'FoundationCentralImageClusterFoundationInitConfigBlockNodeArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigClusterArgs',
    'FoundationCentralImageClusterFoundationInitConfigClusterArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgs',
    'FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgsDict',
    'FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgs',
    'FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgsDict',
    'FoundationCentralImageClusterHypervisorIsoDetailsArgs',
    'FoundationCentralImageClusterHypervisorIsoDetailsArgsDict',
    'FoundationCentralImageClusterNodeListArgs',
    'FoundationCentralImageClusterNodeListArgsDict',
    'FoundationImageNodesBlockArgs',
    'FoundationImageNodesBlockArgsDict',
    'FoundationImageNodesBlockNodeArgs',
    'FoundationImageNodesBlockNodeArgsDict',
    'FoundationImageNodesBlockNodeUcsmParamsArgs',
    'FoundationImageNodesBlockNodeUcsmParamsArgsDict',
    'FoundationImageNodesBlockNodeVswitchArgs',
    'FoundationImageNodesBlockNodeVswitchArgsDict',
    'FoundationImageNodesClusterArgs',
    'FoundationImageNodesClusterArgsDict',
    'FoundationImageNodesClusterUrlArgs',
    'FoundationImageNodesClusterUrlArgsDict',
    'FoundationImageNodesEosMetadataArgs',
    'FoundationImageNodesEosMetadataArgsDict',
    'FoundationImageNodesFcSettingsArgs',
    'FoundationImageNodesFcSettingsArgsDict',
    'FoundationImageNodesFcSettingsFcMetadataArgs',
    'FoundationImageNodesFcSettingsFcMetadataArgsDict',
    'FoundationImageNodesHypervisorIsoArgs',
    'FoundationImageNodesHypervisorIsoArgsDict',
    'FoundationImageNodesHypervisorIsoEsxArgs',
    'FoundationImageNodesHypervisorIsoEsxArgsDict',
    'FoundationImageNodesHypervisorIsoHypervArgs',
    'FoundationImageNodesHypervisorIsoHypervArgsDict',
    'FoundationImageNodesHypervisorIsoKvmArgs',
    'FoundationImageNodesHypervisorIsoKvmArgsDict',
    'FoundationImageNodesHypervisorIsoXenArgs',
    'FoundationImageNodesHypervisorIsoXenArgsDict',
    'FoundationImageNodesTestsArgs',
    'FoundationImageNodesTestsArgsDict',
    'FoundationIpmiConfigBlockArgs',
    'FoundationIpmiConfigBlockArgsDict',
    'FoundationIpmiConfigBlockNodeArgs',
    'FoundationIpmiConfigBlockNodeArgsDict',
    'ImageCategoryArgs',
    'ImageCategoryArgsDict',
    'ImageClusterReferenceArgs',
    'ImageClusterReferenceArgsDict',
    'ImageCurrentClusterReferenceListArgs',
    'ImageCurrentClusterReferenceListArgsDict',
    'ImagePlacementPolicyV2ClusterEntityFilterArgs',
    'ImagePlacementPolicyV2ClusterEntityFilterArgsDict',
    'ImagePlacementPolicyV2ImageEntityFilterArgs',
    'ImagePlacementPolicyV2ImageEntityFilterArgsDict',
    'ImagesV2ChecksumArgs',
    'ImagesV2ChecksumArgsDict',
    'ImagesV2PlacementPolicyStatusArgs',
    'ImagesV2PlacementPolicyStatusArgsDict',
    'ImagesV2SourceArgs',
    'ImagesV2SourceArgsDict',
    'ImagesV2SourceObjectLiteSourceArgs',
    'ImagesV2SourceObjectLiteSourceArgsDict',
    'ImagesV2SourceUrlSourceArgs',
    'ImagesV2SourceUrlSourceArgsDict',
    'ImagesV2SourceUrlSourceBasicAuthArgs',
    'ImagesV2SourceUrlSourceBasicAuthArgsDict',
    'ImagesV2SourceVmDiskSourceArgs',
    'ImagesV2SourceVmDiskSourceArgsDict',
    'KarbonClusterActivePassiveConfigArgs',
    'KarbonClusterActivePassiveConfigArgsDict',
    'KarbonClusterCniConfigArgs',
    'KarbonClusterCniConfigArgsDict',
    'KarbonClusterCniConfigCalicoConfigArgs',
    'KarbonClusterCniConfigCalicoConfigArgsDict',
    'KarbonClusterCniConfigCalicoConfigIpPoolConfigArgs',
    'KarbonClusterCniConfigCalicoConfigIpPoolConfigArgsDict',
    'KarbonClusterCniConfigFlannelConfigArgs',
    'KarbonClusterCniConfigFlannelConfigArgsDict',
    'KarbonClusterEtcdNodePoolArgs',
    'KarbonClusterEtcdNodePoolArgsDict',
    'KarbonClusterEtcdNodePoolAhvConfigArgs',
    'KarbonClusterEtcdNodePoolAhvConfigArgsDict',
    'KarbonClusterEtcdNodePoolNodeArgs',
    'KarbonClusterEtcdNodePoolNodeArgsDict',
    'KarbonClusterExternalLbConfigArgs',
    'KarbonClusterExternalLbConfigArgsDict',
    'KarbonClusterExternalLbConfigMasterNodesConfigArgs',
    'KarbonClusterExternalLbConfigMasterNodesConfigArgsDict',
    'KarbonClusterMasterNodePoolArgs',
    'KarbonClusterMasterNodePoolArgsDict',
    'KarbonClusterMasterNodePoolAhvConfigArgs',
    'KarbonClusterMasterNodePoolAhvConfigArgsDict',
    'KarbonClusterMasterNodePoolNodeArgs',
    'KarbonClusterMasterNodePoolNodeArgsDict',
    'KarbonClusterPrivateRegistryArgs',
    'KarbonClusterPrivateRegistryArgsDict',
    'KarbonClusterSingleMasterConfigArgs',
    'KarbonClusterSingleMasterConfigArgsDict',
    'KarbonClusterStorageClassConfigArgs',
    'KarbonClusterStorageClassConfigArgsDict',
    'KarbonClusterStorageClassConfigVolumesConfigArgs',
    'KarbonClusterStorageClassConfigVolumesConfigArgsDict',
    'KarbonClusterWorkerNodePoolArgs',
    'KarbonClusterWorkerNodePoolArgsDict',
    'KarbonClusterWorkerNodePoolAhvConfigArgs',
    'KarbonClusterWorkerNodePoolAhvConfigArgsDict',
    'KarbonClusterWorkerNodePoolNodeArgs',
    'KarbonClusterWorkerNodePoolNodeArgsDict',
    'KarbonWorkerNodepoolAhvConfigArgs',
    'KarbonWorkerNodepoolAhvConfigArgsDict',
    'KarbonWorkerNodepoolNodeArgs',
    'KarbonWorkerNodepoolNodeArgsDict',
    'NdbCloneActionargumentArgs',
    'NdbCloneActionargumentArgsDict',
    'NdbCloneDatabaseNodeArgs',
    'NdbCloneDatabaseNodeArgsDict',
    'NdbCloneDatabaseNodeInfoArgs',
    'NdbCloneDatabaseNodeInfoArgsDict',
    'NdbCloneDatabaseNodePropertyArgs',
    'NdbCloneDatabaseNodePropertyArgsDict',
    'NdbCloneDatabaseNodeProtectionDomainArgs',
    'NdbCloneDatabaseNodeProtectionDomainArgsDict',
    'NdbCloneDatabaseNodeProtectionDomainPropertyArgs',
    'NdbCloneDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbCloneDatabaseNodeTagArgs',
    'NdbCloneDatabaseNodeTagArgsDict',
    'NdbCloneInfoArgs',
    'NdbCloneInfoArgsDict',
    'NdbCloneInfoBpgConfigArgs',
    'NdbCloneInfoBpgConfigArgsDict',
    'NdbCloneInfoBpgConfigBpgDbParamArgs',
    'NdbCloneInfoBpgConfigBpgDbParamArgsDict',
    'NdbCloneInfoBpgConfigStorageArgs',
    'NdbCloneInfoBpgConfigStorageArgsDict',
    'NdbCloneInfoBpgConfigStorageArchiveStorageArgs',
    'NdbCloneInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbCloneInfoBpgConfigStorageDataDiskArgs',
    'NdbCloneInfoBpgConfigStorageDataDiskArgsDict',
    'NdbCloneInfoBpgConfigStorageLogDiskArgs',
    'NdbCloneInfoBpgConfigStorageLogDiskArgsDict',
    'NdbCloneInfoBpgConfigVmPropertyArgs',
    'NdbCloneInfoBpgConfigVmPropertyArgsDict',
    'NdbCloneLcmConfigArgs',
    'NdbCloneLcmConfigArgsDict',
    'NdbCloneLcmConfigDatabaseLcmConfigArgs',
    'NdbCloneLcmConfigDatabaseLcmConfigArgsDict',
    'NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgs',
    'NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgsDict',
    'NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgs',
    'NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgsDict',
    'NdbCloneLinkedDatabaseArgs',
    'NdbCloneLinkedDatabaseArgsDict',
    'NdbCloneLinkedDatabaseInfoArgs',
    'NdbCloneLinkedDatabaseInfoArgsDict',
    'NdbCloneNodeArgs',
    'NdbCloneNodeArgsDict',
    'NdbCloneNodePropertyArgs',
    'NdbCloneNodePropertyArgsDict',
    'NdbClonePostgresqlInfoArgs',
    'NdbClonePostgresqlInfoArgsDict',
    'NdbClonePropertyArgs',
    'NdbClonePropertyArgsDict',
    'NdbCloneTagArgs',
    'NdbCloneTagArgsDict',
    'NdbCloneTimeMachineArgs',
    'NdbCloneTimeMachineArgsDict',
    'NdbCloneTimeMachinePropertyArgs',
    'NdbCloneTimeMachinePropertyArgsDict',
    'NdbCloneTimeMachineScheduleArgs',
    'NdbCloneTimeMachineScheduleArgsDict',
    'NdbCloneTimeMachineScheduleContinuousScheduleArgs',
    'NdbCloneTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbCloneTimeMachineScheduleDailyScheduleArgs',
    'NdbCloneTimeMachineScheduleDailyScheduleArgsDict',
    'NdbCloneTimeMachineScheduleMonthlyScheduleArgs',
    'NdbCloneTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbCloneTimeMachineScheduleQuartelyScheduleArgs',
    'NdbCloneTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbCloneTimeMachineScheduleWeeklyScheduleArgs',
    'NdbCloneTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbCloneTimeMachineScheduleYearlyScheduleArgs',
    'NdbCloneTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbCloneTimeMachineSlaArgs',
    'NdbCloneTimeMachineSlaArgsDict',
    'NdbCloneTimeMachineTagArgs',
    'NdbCloneTimeMachineTagArgsDict',
    'NdbClusterAgentNetworkInfoArgs',
    'NdbClusterAgentNetworkInfoArgsDict',
    'NdbClusterEntityCountArgs',
    'NdbClusterEntityCountArgsDict',
    'NdbClusterEntityCountEngineCountArgs',
    'NdbClusterEntityCountEngineCountArgsDict',
    'NdbClusterEntityCountEngineCountMariadbDatabaseArgs',
    'NdbClusterEntityCountEngineCountMariadbDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountMongodbDatabaseArgs',
    'NdbClusterEntityCountEngineCountMongodbDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountMysqlDatabaseArgs',
    'NdbClusterEntityCountEngineCountMysqlDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountOracleDatabaseArgs',
    'NdbClusterEntityCountEngineCountOracleDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountOracleDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountOracleDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountPostgresDatabaseArgs',
    'NdbClusterEntityCountEngineCountPostgresDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountSaphanaDatabaseArgs',
    'NdbClusterEntityCountEngineCountSaphanaDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgsDict',
    'NdbClusterEntityCountEngineCountSqlserverDatabaseArgs',
    'NdbClusterEntityCountEngineCountSqlserverDatabaseArgsDict',
    'NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgs',
    'NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgsDict',
    'NdbClusterNetworksInfoArgs',
    'NdbClusterNetworksInfoArgsDict',
    'NdbClusterNetworksInfoNetworkInfoArgs',
    'NdbClusterNetworksInfoNetworkInfoArgsDict',
    'NdbClusterPropertyArgs',
    'NdbClusterPropertyArgsDict',
    'NdbClusterResourceConfigArgs',
    'NdbClusterResourceConfigArgsDict',
    'NdbDatabaseActionargumentArgs',
    'NdbDatabaseActionargumentArgsDict',
    'NdbDatabaseClusterInfoArgs',
    'NdbDatabaseClusterInfoArgsDict',
    'NdbDatabaseClusterInfoClusterIpInfoArgs',
    'NdbDatabaseClusterInfoClusterIpInfoArgsDict',
    'NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs',
    'NdbDatabaseClusterInfoClusterIpInfoIpInfoArgsDict',
    'NdbDatabaseDatabaseNodeArgs',
    'NdbDatabaseDatabaseNodeArgsDict',
    'NdbDatabaseDatabaseNodeInfoArgs',
    'NdbDatabaseDatabaseNodeInfoArgsDict',
    'NdbDatabaseDatabaseNodePropertyArgs',
    'NdbDatabaseDatabaseNodePropertyArgsDict',
    'NdbDatabaseDatabaseNodeProtectionDomainArgs',
    'NdbDatabaseDatabaseNodeProtectionDomainArgsDict',
    'NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs',
    'NdbDatabaseDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbDatabaseDatabaseNodeTagArgs',
    'NdbDatabaseDatabaseNodeTagArgsDict',
    'NdbDatabaseInfoArgs',
    'NdbDatabaseInfoArgsDict',
    'NdbDatabaseInfoBpgConfigArgs',
    'NdbDatabaseInfoBpgConfigArgsDict',
    'NdbDatabaseInfoBpgConfigBpgDbParamArgs',
    'NdbDatabaseInfoBpgConfigBpgDbParamArgsDict',
    'NdbDatabaseInfoBpgConfigStorageArgs',
    'NdbDatabaseInfoBpgConfigStorageArgsDict',
    'NdbDatabaseInfoBpgConfigStorageArchiveStorageArgs',
    'NdbDatabaseInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbDatabaseInfoBpgConfigStorageDataDiskArgs',
    'NdbDatabaseInfoBpgConfigStorageDataDiskArgsDict',
    'NdbDatabaseInfoBpgConfigStorageLogDiskArgs',
    'NdbDatabaseInfoBpgConfigStorageLogDiskArgsDict',
    'NdbDatabaseInfoBpgConfigVmPropertyArgs',
    'NdbDatabaseInfoBpgConfigVmPropertyArgsDict',
    'NdbDatabaseLcmConfigArgs',
    'NdbDatabaseLcmConfigArgsDict',
    'NdbDatabaseLcmConfigExpiryDetailArgs',
    'NdbDatabaseLcmConfigExpiryDetailArgsDict',
    'NdbDatabaseLcmConfigPostDeleteCommandArgs',
    'NdbDatabaseLcmConfigPostDeleteCommandArgsDict',
    'NdbDatabaseLcmConfigPreDeleteCommandArgs',
    'NdbDatabaseLcmConfigPreDeleteCommandArgsDict',
    'NdbDatabaseLcmConfigRefreshDetailArgs',
    'NdbDatabaseLcmConfigRefreshDetailArgsDict',
    'NdbDatabaseLinkedDatabaseArgs',
    'NdbDatabaseLinkedDatabaseArgsDict',
    'NdbDatabaseLinkedDatabaseInfoArgs',
    'NdbDatabaseLinkedDatabaseInfoArgsDict',
    'NdbDatabaseMaintenanceTasksArgs',
    'NdbDatabaseMaintenanceTasksArgsDict',
    'NdbDatabaseMaintenanceTasksTaskArgs',
    'NdbDatabaseMaintenanceTasksTaskArgsDict',
    'NdbDatabaseNodeArgs',
    'NdbDatabaseNodeArgsDict',
    'NdbDatabaseNodeIpInfoArgs',
    'NdbDatabaseNodeIpInfoArgsDict',
    'NdbDatabaseNodePropertyArgs',
    'NdbDatabaseNodePropertyArgsDict',
    'NdbDatabasePostgresqlInfoArgs',
    'NdbDatabasePostgresqlInfoArgsDict',
    'NdbDatabasePostgresqlInfoHaInstanceArgs',
    'NdbDatabasePostgresqlInfoHaInstanceArgsDict',
    'NdbDatabasePropertyArgs',
    'NdbDatabasePropertyArgsDict',
    'NdbDatabaseRestoreDatabaseNodeArgs',
    'NdbDatabaseRestoreDatabaseNodeArgsDict',
    'NdbDatabaseRestoreDatabaseNodeInfoArgs',
    'NdbDatabaseRestoreDatabaseNodeInfoArgsDict',
    'NdbDatabaseRestoreDatabaseNodePropertyArgs',
    'NdbDatabaseRestoreDatabaseNodePropertyArgsDict',
    'NdbDatabaseRestoreDatabaseNodeProtectionDomainArgs',
    'NdbDatabaseRestoreDatabaseNodeProtectionDomainArgsDict',
    'NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs',
    'NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbDatabaseRestoreDatabaseNodeTagArgs',
    'NdbDatabaseRestoreDatabaseNodeTagArgsDict',
    'NdbDatabaseRestoreInfoArgs',
    'NdbDatabaseRestoreInfoArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigArgs',
    'NdbDatabaseRestoreInfoBpgConfigArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgs',
    'NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigStorageArgs',
    'NdbDatabaseRestoreInfoBpgConfigStorageArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgs',
    'NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgs',
    'NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgs',
    'NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgsDict',
    'NdbDatabaseRestoreInfoBpgConfigVmPropertyArgs',
    'NdbDatabaseRestoreInfoBpgConfigVmPropertyArgsDict',
    'NdbDatabaseRestoreLcmConfigArgs',
    'NdbDatabaseRestoreLcmConfigArgsDict',
    'NdbDatabaseRestoreLcmConfigExpiryDetailArgs',
    'NdbDatabaseRestoreLcmConfigExpiryDetailArgsDict',
    'NdbDatabaseRestoreLcmConfigPostDeleteCommandArgs',
    'NdbDatabaseRestoreLcmConfigPostDeleteCommandArgsDict',
    'NdbDatabaseRestoreLcmConfigPreDeleteCommandArgs',
    'NdbDatabaseRestoreLcmConfigPreDeleteCommandArgsDict',
    'NdbDatabaseRestoreLcmConfigRefreshDetailArgs',
    'NdbDatabaseRestoreLcmConfigRefreshDetailArgsDict',
    'NdbDatabaseRestoreLinkedDatabaseArgs',
    'NdbDatabaseRestoreLinkedDatabaseArgsDict',
    'NdbDatabaseRestoreLinkedDatabaseInfoArgs',
    'NdbDatabaseRestoreLinkedDatabaseInfoArgsDict',
    'NdbDatabaseRestorePropertyArgs',
    'NdbDatabaseRestorePropertyArgsDict',
    'NdbDatabaseRestoreTagArgs',
    'NdbDatabaseRestoreTagArgsDict',
    'NdbDatabaseRestoreTimeMachineArgs',
    'NdbDatabaseRestoreTimeMachineArgsDict',
    'NdbDatabaseRestoreTimeMachinePropertyArgs',
    'NdbDatabaseRestoreTimeMachinePropertyArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgs',
    'NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbDatabaseRestoreTimeMachineSlaArgs',
    'NdbDatabaseRestoreTimeMachineSlaArgsDict',
    'NdbDatabaseRestoreTimeMachineTagArgs',
    'NdbDatabaseRestoreTimeMachineTagArgsDict',
    'NdbDatabaseScaleDatabaseNodeArgs',
    'NdbDatabaseScaleDatabaseNodeArgsDict',
    'NdbDatabaseScaleDatabaseNodeInfoArgs',
    'NdbDatabaseScaleDatabaseNodeInfoArgsDict',
    'NdbDatabaseScaleDatabaseNodePropertyArgs',
    'NdbDatabaseScaleDatabaseNodePropertyArgsDict',
    'NdbDatabaseScaleDatabaseNodeProtectionDomainArgs',
    'NdbDatabaseScaleDatabaseNodeProtectionDomainArgsDict',
    'NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs',
    'NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbDatabaseScaleDatabaseNodeTagArgs',
    'NdbDatabaseScaleDatabaseNodeTagArgsDict',
    'NdbDatabaseScaleInfoArgs',
    'NdbDatabaseScaleInfoArgsDict',
    'NdbDatabaseScaleInfoBpgConfigArgs',
    'NdbDatabaseScaleInfoBpgConfigArgsDict',
    'NdbDatabaseScaleInfoBpgConfigBpgDbParamArgs',
    'NdbDatabaseScaleInfoBpgConfigBpgDbParamArgsDict',
    'NdbDatabaseScaleInfoBpgConfigStorageArgs',
    'NdbDatabaseScaleInfoBpgConfigStorageArgsDict',
    'NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgs',
    'NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgs',
    'NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgsDict',
    'NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgs',
    'NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgsDict',
    'NdbDatabaseScaleInfoBpgConfigVmPropertyArgs',
    'NdbDatabaseScaleInfoBpgConfigVmPropertyArgsDict',
    'NdbDatabaseScaleLcmConfigArgs',
    'NdbDatabaseScaleLcmConfigArgsDict',
    'NdbDatabaseScaleLcmConfigExpiryDetailArgs',
    'NdbDatabaseScaleLcmConfigExpiryDetailArgsDict',
    'NdbDatabaseScaleLcmConfigPostDeleteCommandArgs',
    'NdbDatabaseScaleLcmConfigPostDeleteCommandArgsDict',
    'NdbDatabaseScaleLcmConfigPreDeleteCommandArgs',
    'NdbDatabaseScaleLcmConfigPreDeleteCommandArgsDict',
    'NdbDatabaseScaleLcmConfigRefreshDetailArgs',
    'NdbDatabaseScaleLcmConfigRefreshDetailArgsDict',
    'NdbDatabaseScaleLinkedDatabaseArgs',
    'NdbDatabaseScaleLinkedDatabaseArgsDict',
    'NdbDatabaseScaleLinkedDatabaseInfoArgs',
    'NdbDatabaseScaleLinkedDatabaseInfoArgsDict',
    'NdbDatabaseScalePropertyArgs',
    'NdbDatabaseScalePropertyArgsDict',
    'NdbDatabaseScaleTagArgs',
    'NdbDatabaseScaleTagArgsDict',
    'NdbDatabaseScaleTimeMachineArgs',
    'NdbDatabaseScaleTimeMachineArgsDict',
    'NdbDatabaseScaleTimeMachinePropertyArgs',
    'NdbDatabaseScaleTimeMachinePropertyArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgs',
    'NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbDatabaseScaleTimeMachineSlaArgs',
    'NdbDatabaseScaleTimeMachineSlaArgsDict',
    'NdbDatabaseScaleTimeMachineTagArgs',
    'NdbDatabaseScaleTimeMachineTagArgsDict',
    'NdbDatabaseSnapshotLcmConfigArgs',
    'NdbDatabaseSnapshotLcmConfigArgsDict',
    'NdbDatabaseSnapshotLcmConfigExpiryDetailArgs',
    'NdbDatabaseSnapshotLcmConfigExpiryDetailArgsDict',
    'NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgs',
    'NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgsDict',
    'NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgs',
    'NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgsDict',
    'NdbDatabaseSnapshotLcmConfigRefreshDetailArgs',
    'NdbDatabaseSnapshotLcmConfigRefreshDetailArgsDict',
    'NdbDatabaseSnapshotPropertyArgs',
    'NdbDatabaseSnapshotPropertyArgsDict',
    'NdbDatabaseSnapshotTagArgs',
    'NdbDatabaseSnapshotTagArgsDict',
    'NdbDatabaseTagArgs',
    'NdbDatabaseTagArgsDict',
    'NdbDatabaseTimeMachineArgs',
    'NdbDatabaseTimeMachineArgsDict',
    'NdbDatabaseTimeMachinePropertyArgs',
    'NdbDatabaseTimeMachinePropertyArgsDict',
    'NdbDatabaseTimeMachineScheduleArgs',
    'NdbDatabaseTimeMachineScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleContinuousScheduleArgs',
    'NdbDatabaseTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleDailyScheduleArgs',
    'NdbDatabaseTimeMachineScheduleDailyScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleMonthlyScheduleArgs',
    'NdbDatabaseTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleQuartelyScheduleArgs',
    'NdbDatabaseTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbDatabaseTimeMachineScheduleWeeklyScheduleArgs',
    'NdbDatabaseTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbDatabaseTimeMachineScheduleYearlyScheduleArgs',
    'NdbDatabaseTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbDatabaseTimeMachineSlaArgs',
    'NdbDatabaseTimeMachineSlaArgsDict',
    'NdbDatabaseTimeMachineTagArgs',
    'NdbDatabaseTimeMachineTagArgsDict',
    'NdbDatabaseTimemachineinfoArgs',
    'NdbDatabaseTimemachineinfoArgsDict',
    'NdbDatabaseTimemachineinfoScheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleArgsDict',
    'NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgsDict',
    'NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgsDict',
    'NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgsDict',
    'NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs',
    'NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgsDict',
    'NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgsDict',
    'NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs',
    'NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgsDict',
    'NdbDatabaseTimemachineinfoSlaDetailArgs',
    'NdbDatabaseTimemachineinfoSlaDetailArgsDict',
    'NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs',
    'NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgsDict',
    'NdbDatabaseTimemachineinfoTagArgs',
    'NdbDatabaseTimemachineinfoTagArgsDict',
    'NdbDbserverVmCredentialArgs',
    'NdbDbserverVmCredentialArgsDict',
    'NdbDbserverVmMaintenanceTasksArgs',
    'NdbDbserverVmMaintenanceTasksArgsDict',
    'NdbDbserverVmMaintenanceTasksTaskArgs',
    'NdbDbserverVmMaintenanceTasksTaskArgsDict',
    'NdbDbserverVmPostgresDatabaseArgs',
    'NdbDbserverVmPostgresDatabaseArgsDict',
    'NdbDbserverVmPropertyArgs',
    'NdbDbserverVmPropertyArgsDict',
    'NdbDbserverVmTagArgs',
    'NdbDbserverVmTagArgsDict',
    'NdbLinkedDatabasesInfoArgs',
    'NdbLinkedDatabasesInfoArgsDict',
    'NdbLinkedDatabasesInfoInfoArgs',
    'NdbLinkedDatabasesInfoInfoArgsDict',
    'NdbMaintenanceTaskEntityTaskAssociationArgs',
    'NdbMaintenanceTaskEntityTaskAssociationArgsDict',
    'NdbMaintenanceTaskEntityTaskAssociationPayloadArgs',
    'NdbMaintenanceTaskEntityTaskAssociationPayloadArgsDict',
    'NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs',
    'NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgsDict',
    'NdbMaintenanceTaskEntityTaskAssociationPropertyArgs',
    'NdbMaintenanceTaskEntityTaskAssociationPropertyArgsDict',
    'NdbMaintenanceTaskEntityTaskAssociationTagArgs',
    'NdbMaintenanceTaskEntityTaskAssociationTagArgsDict',
    'NdbMaintenanceTaskTaskArgs',
    'NdbMaintenanceTaskTaskArgsDict',
    'NdbMaintenanceWindowEntityTaskAssocArgs',
    'NdbMaintenanceWindowEntityTaskAssocArgsDict',
    'NdbMaintenanceWindowEntityTaskAssocPayloadArgs',
    'NdbMaintenanceWindowEntityTaskAssocPayloadArgsDict',
    'NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgs',
    'NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgsDict',
    'NdbMaintenanceWindowEntityTaskAssocPropertyArgs',
    'NdbMaintenanceWindowEntityTaskAssocPropertyArgsDict',
    'NdbMaintenanceWindowEntityTaskAssocTagArgs',
    'NdbMaintenanceWindowEntityTaskAssocTagArgsDict',
    'NdbMaintenanceWindowPropertyArgs',
    'NdbMaintenanceWindowPropertyArgsDict',
    'NdbMaintenanceWindowScheduleArgs',
    'NdbMaintenanceWindowScheduleArgsDict',
    'NdbMaintenanceWindowTagArgs',
    'NdbMaintenanceWindowTagArgsDict',
    'NdbNetworkIpPoolArgs',
    'NdbNetworkIpPoolArgsDict',
    'NdbNetworkIpPoolAddressArgs',
    'NdbNetworkIpPoolAddressArgsDict',
    'NdbNetworkPropertiesMapArgs',
    'NdbNetworkPropertiesMapArgsDict',
    'NdbNetworkPropertyArgs',
    'NdbNetworkPropertyArgsDict',
    'NdbProfileClusterAvailabilityArgs',
    'NdbProfileClusterAvailabilityArgsDict',
    'NdbProfileComputeProfileArgs',
    'NdbProfileComputeProfileArgsDict',
    'NdbProfileDatabaseParameterProfileArgs',
    'NdbProfileDatabaseParameterProfileArgsDict',
    'NdbProfileDatabaseParameterProfilePostgresDatabaseArgs',
    'NdbProfileDatabaseParameterProfilePostgresDatabaseArgsDict',
    'NdbProfileNetworkProfileArgs',
    'NdbProfileNetworkProfileArgsDict',
    'NdbProfileNetworkProfilePostgresDatabaseArgs',
    'NdbProfileNetworkProfilePostgresDatabaseArgsDict',
    'NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgs',
    'NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgsDict',
    'NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgs',
    'NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgsDict',
    'NdbProfileNetworkProfileVersionClusterAssociationArgs',
    'NdbProfileNetworkProfileVersionClusterAssociationArgsDict',
    'NdbProfileSoftwareProfileArgs',
    'NdbProfileSoftwareProfileArgsDict',
    'NdbProfileSoftwareProfilePostgresDatabaseArgs',
    'NdbProfileSoftwareProfilePostgresDatabaseArgsDict',
    'NdbProfileVersionArgs',
    'NdbProfileVersionArgsDict',
    'NdbProfileVersionPropertyArgs',
    'NdbProfileVersionPropertyArgsDict',
    'NdbProfileVersionVersionClusterAssociationArgs',
    'NdbProfileVersionVersionClusterAssociationArgsDict',
    'NdbProfileVersionVersionClusterAssociationPropertyArgs',
    'NdbProfileVersionVersionClusterAssociationPropertyArgsDict',
    'NdbRegisterDatabaseActionargumentArgs',
    'NdbRegisterDatabaseActionargumentArgsDict',
    'NdbRegisterDatabaseDatabaseNodeArgs',
    'NdbRegisterDatabaseDatabaseNodeArgsDict',
    'NdbRegisterDatabaseDatabaseNodeInfoArgs',
    'NdbRegisterDatabaseDatabaseNodeInfoArgsDict',
    'NdbRegisterDatabaseDatabaseNodePropertyArgs',
    'NdbRegisterDatabaseDatabaseNodePropertyArgsDict',
    'NdbRegisterDatabaseDatabaseNodeProtectionDomainArgs',
    'NdbRegisterDatabaseDatabaseNodeProtectionDomainArgsDict',
    'NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs',
    'NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbRegisterDatabaseDatabaseNodeTagArgs',
    'NdbRegisterDatabaseDatabaseNodeTagArgsDict',
    'NdbRegisterDatabaseInfoArgs',
    'NdbRegisterDatabaseInfoArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigArgs',
    'NdbRegisterDatabaseInfoBpgConfigArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgs',
    'NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigStorageArgs',
    'NdbRegisterDatabaseInfoBpgConfigStorageArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgs',
    'NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgs',
    'NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgs',
    'NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgsDict',
    'NdbRegisterDatabaseInfoBpgConfigVmPropertyArgs',
    'NdbRegisterDatabaseInfoBpgConfigVmPropertyArgsDict',
    'NdbRegisterDatabaseLcmConfigArgs',
    'NdbRegisterDatabaseLcmConfigArgsDict',
    'NdbRegisterDatabaseLcmConfigExpiryDetailArgs',
    'NdbRegisterDatabaseLcmConfigExpiryDetailArgsDict',
    'NdbRegisterDatabaseLcmConfigPostDeleteCommandArgs',
    'NdbRegisterDatabaseLcmConfigPostDeleteCommandArgsDict',
    'NdbRegisterDatabaseLcmConfigPreDeleteCommandArgs',
    'NdbRegisterDatabaseLcmConfigPreDeleteCommandArgsDict',
    'NdbRegisterDatabaseLcmConfigRefreshDetailArgs',
    'NdbRegisterDatabaseLcmConfigRefreshDetailArgsDict',
    'NdbRegisterDatabaseLinkedDatabaseArgs',
    'NdbRegisterDatabaseLinkedDatabaseArgsDict',
    'NdbRegisterDatabaseLinkedDatabaseInfoArgs',
    'NdbRegisterDatabaseLinkedDatabaseInfoArgsDict',
    'NdbRegisterDatabasePostgressInfoArgs',
    'NdbRegisterDatabasePostgressInfoArgsDict',
    'NdbRegisterDatabasePropertyArgs',
    'NdbRegisterDatabasePropertyArgsDict',
    'NdbRegisterDatabaseTagArgs',
    'NdbRegisterDatabaseTagArgsDict',
    'NdbRegisterDatabaseTimeMachineArgs',
    'NdbRegisterDatabaseTimeMachineArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoArgs',
    'NdbRegisterDatabaseTimeMachineInfoArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs',
    'NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs',
    'NdbRegisterDatabaseTimeMachineInfoSlaDetailArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs',
    'NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgsDict',
    'NdbRegisterDatabaseTimeMachineInfoTagArgs',
    'NdbRegisterDatabaseTimeMachineInfoTagArgsDict',
    'NdbRegisterDatabaseTimeMachinePropertyArgs',
    'NdbRegisterDatabaseTimeMachinePropertyArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgs',
    'NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbRegisterDatabaseTimeMachineSlaArgs',
    'NdbRegisterDatabaseTimeMachineSlaArgsDict',
    'NdbRegisterDatabaseTimeMachineTagArgs',
    'NdbRegisterDatabaseTimeMachineTagArgsDict',
    'NdbRegisterDbserverCredentialArgs',
    'NdbRegisterDbserverCredentialArgsDict',
    'NdbRegisterDbserverPostgresDatabaseArgs',
    'NdbRegisterDbserverPostgresDatabaseArgsDict',
    'NdbRegisterDbserverPropertyArgs',
    'NdbRegisterDbserverPropertyArgsDict',
    'NdbRegisterDbserverTagArgs',
    'NdbRegisterDbserverTagArgsDict',
    'NdbScaleDatabaseDatabaseNodeArgs',
    'NdbScaleDatabaseDatabaseNodeArgsDict',
    'NdbScaleDatabaseDatabaseNodeInfoArgs',
    'NdbScaleDatabaseDatabaseNodeInfoArgsDict',
    'NdbScaleDatabaseDatabaseNodePropertyArgs',
    'NdbScaleDatabaseDatabaseNodePropertyArgsDict',
    'NdbScaleDatabaseDatabaseNodeProtectionDomainArgs',
    'NdbScaleDatabaseDatabaseNodeProtectionDomainArgsDict',
    'NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs',
    'NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgsDict',
    'NdbScaleDatabaseDatabaseNodeTagArgs',
    'NdbScaleDatabaseDatabaseNodeTagArgsDict',
    'NdbScaleDatabaseInfoArgs',
    'NdbScaleDatabaseInfoArgsDict',
    'NdbScaleDatabaseInfoBpgConfigArgs',
    'NdbScaleDatabaseInfoBpgConfigArgsDict',
    'NdbScaleDatabaseInfoBpgConfigBpgDbParamArgs',
    'NdbScaleDatabaseInfoBpgConfigBpgDbParamArgsDict',
    'NdbScaleDatabaseInfoBpgConfigStorageArgs',
    'NdbScaleDatabaseInfoBpgConfigStorageArgsDict',
    'NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgs',
    'NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgsDict',
    'NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgs',
    'NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgsDict',
    'NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgs',
    'NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgsDict',
    'NdbScaleDatabaseInfoBpgConfigVmPropertyArgs',
    'NdbScaleDatabaseInfoBpgConfigVmPropertyArgsDict',
    'NdbScaleDatabaseLcmConfigArgs',
    'NdbScaleDatabaseLcmConfigArgsDict',
    'NdbScaleDatabaseLcmConfigExpiryDetailArgs',
    'NdbScaleDatabaseLcmConfigExpiryDetailArgsDict',
    'NdbScaleDatabaseLcmConfigPostDeleteCommandArgs',
    'NdbScaleDatabaseLcmConfigPostDeleteCommandArgsDict',
    'NdbScaleDatabaseLcmConfigPreDeleteCommandArgs',
    'NdbScaleDatabaseLcmConfigPreDeleteCommandArgsDict',
    'NdbScaleDatabaseLcmConfigRefreshDetailArgs',
    'NdbScaleDatabaseLcmConfigRefreshDetailArgsDict',
    'NdbScaleDatabaseLinkedDatabaseArgs',
    'NdbScaleDatabaseLinkedDatabaseArgsDict',
    'NdbScaleDatabaseLinkedDatabaseInfoArgs',
    'NdbScaleDatabaseLinkedDatabaseInfoArgsDict',
    'NdbScaleDatabasePropertyArgs',
    'NdbScaleDatabasePropertyArgsDict',
    'NdbScaleDatabaseTagArgs',
    'NdbScaleDatabaseTagArgsDict',
    'NdbScaleDatabaseTimeMachineArgs',
    'NdbScaleDatabaseTimeMachineArgsDict',
    'NdbScaleDatabaseTimeMachinePropertyArgs',
    'NdbScaleDatabaseTimeMachinePropertyArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs',
    'NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgs',
    'NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgsDict',
    'NdbScaleDatabaseTimeMachineSlaArgs',
    'NdbScaleDatabaseTimeMachineSlaArgsDict',
    'NdbScaleDatabaseTimeMachineTagArgs',
    'NdbScaleDatabaseTimeMachineTagArgsDict',
    'NdbSoftwareVersionProfilePostgresDatabaseArgs',
    'NdbSoftwareVersionProfilePostgresDatabaseArgsDict',
    'NdbSoftwareVersionProfilePropertyArgs',
    'NdbSoftwareVersionProfilePropertyArgsDict',
    'NdbSoftwareVersionProfileVersionClusterAssociationArgs',
    'NdbSoftwareVersionProfileVersionClusterAssociationArgsDict',
    'NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs',
    'NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgsDict',
    'NdbStretchedVlanMetadataArgs',
    'NdbStretchedVlanMetadataArgsDict',
    'NdbStretchedVlanVlansListArgs',
    'NdbStretchedVlanVlansListArgsDict',
    'NdbStretchedVlanVlansListPropertiesMapArgs',
    'NdbStretchedVlanVlansListPropertiesMapArgsDict',
    'NdbStretchedVlanVlansListPropertyArgs',
    'NdbStretchedVlanVlansListPropertyArgsDict',
    'NetworkSecurityPolicyV2LinkArgs',
    'NetworkSecurityPolicyV2LinkArgsDict',
    'NetworkSecurityPolicyV2RuleArgs',
    'NetworkSecurityPolicyV2RuleArgsDict',
    'NetworkSecurityPolicyV2RuleLinkArgs',
    'NetworkSecurityPolicyV2RuleLinkArgsDict',
    'NetworkSecurityPolicyV2RuleSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgsDict',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs',
    'NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgsDict',
    'NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgsDict',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgsDict',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgsDict',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgsDict',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs',
    'NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgsDict',
    'NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs',
    'NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgsDict',
    'NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgs',
    'NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgsDict',
    'NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgs',
    'NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgsDict',
    'NetworkSecurityRuleAdRuleTargetGroupFilterParamArgs',
    'NetworkSecurityRuleAdRuleTargetGroupFilterParamArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgsDict',
    'NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgs',
    'NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgsDict',
    'NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgs',
    'NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgsDict',
    'NetworkSecurityRuleAppRuleTargetGroupFilterParamArgs',
    'NetworkSecurityRuleAppRuleTargetGroupFilterParamArgsDict',
    'NetworkSecurityRuleCategoryArgs',
    'NetworkSecurityRuleCategoryArgsDict',
    'NetworkSecurityRuleIsolationRuleFirstEntityFilterParamArgs',
    'NetworkSecurityRuleIsolationRuleFirstEntityFilterParamArgsDict',
    'NetworkSecurityRuleIsolationRuleSecondEntityFilterParamArgs',
    'NetworkSecurityRuleIsolationRuleSecondEntityFilterParamArgsDict',
    'NgtInstallationV2CredentialArgs',
    'NgtInstallationV2CredentialArgsDict',
    'NgtInstallationV2RebootPreferenceArgs',
    'NgtInstallationV2RebootPreferenceArgsDict',
    'NgtInstallationV2RebootPreferenceScheduleArgs',
    'NgtInstallationV2RebootPreferenceScheduleArgsDict',
    'NgtUpgradeV2RebootPreferenceArgs',
    'NgtUpgradeV2RebootPreferenceArgsDict',
    'NgtUpgradeV2RebootPreferenceScheduleArgs',
    'NgtUpgradeV2RebootPreferenceScheduleArgsDict',
    'PbrDestinationArgs',
    'PbrDestinationArgsDict',
    'PbrProtocolParametersArgs',
    'PbrProtocolParametersArgsDict',
    'PbrProtocolParametersIcmpArgs',
    'PbrProtocolParametersIcmpArgsDict',
    'PbrProtocolParametersTcpArgs',
    'PbrProtocolParametersTcpArgsDict',
    'PbrProtocolParametersTcpDestinationPortRangeListArgs',
    'PbrProtocolParametersTcpDestinationPortRangeListArgsDict',
    'PbrProtocolParametersTcpSourcePortRangeListArgs',
    'PbrProtocolParametersTcpSourcePortRangeListArgsDict',
    'PbrProtocolParametersUdpArgs',
    'PbrProtocolParametersUdpArgsDict',
    'PbrProtocolParametersUdpDestinationPortRangeListArgs',
    'PbrProtocolParametersUdpDestinationPortRangeListArgsDict',
    'PbrProtocolParametersUdpSourcePortRangeListArgs',
    'PbrProtocolParametersUdpSourcePortRangeListArgsDict',
    'PbrSourceArgs',
    'PbrSourceArgsDict',
    'PbrV2LinkArgs',
    'PbrV2LinkArgsDict',
    'PbrV2MetadataArgs',
    'PbrV2MetadataArgsDict',
    'PbrV2PolicyArgs',
    'PbrV2PolicyArgsDict',
    'PbrV2PolicyPolicyActionArgs',
    'PbrV2PolicyPolicyActionArgsDict',
    'PbrV2PolicyPolicyActionNexthopIpAddressArgs',
    'PbrV2PolicyPolicyActionNexthopIpAddressArgsDict',
    'PbrV2PolicyPolicyActionNexthopIpAddressIpv4Args',
    'PbrV2PolicyPolicyActionNexthopIpAddressIpv4ArgsDict',
    'PbrV2PolicyPolicyActionNexthopIpAddressIpv6Args',
    'PbrV2PolicyPolicyActionNexthopIpAddressIpv6ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamArgs',
    'PbrV2PolicyPolicyActionRerouteParamArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgs',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4Args',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6Args',
    'PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgs',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4Args',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6Args',
    'PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpArgs',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4Args',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4ArgsDict',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6Args',
    'PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6ArgsDict',
    'PbrV2PolicyPolicyMatchArgs',
    'PbrV2PolicyPolicyMatchArgsDict',
    'PbrV2PolicyPolicyMatchDestinationArgs',
    'PbrV2PolicyPolicyMatchDestinationArgsDict',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgs',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgsDict',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Args',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4ArgsDict',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgs',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgsDict',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Args',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6ArgsDict',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgs',
    'PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgsDict',
    'PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgs',
    'PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgsDict',
    'PbrV2PolicyPolicyMatchSourceArgs',
    'PbrV2PolicyPolicyMatchSourceArgsDict',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixArgs',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixArgsDict',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Args',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4ArgsDict',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgs',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgsDict',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Args',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6ArgsDict',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgs',
    'PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgsDict',
    'PbrV2VpcArgs',
    'PbrV2VpcArgsDict',
    'PcRegistrationV2ConfigArgs',
    'PcRegistrationV2ConfigArgsDict',
    'PcRegistrationV2ConfigBootstrapConfigArgs',
    'PcRegistrationV2ConfigBootstrapConfigArgsDict',
    'PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgs',
    'PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgsDict',
    'PcRegistrationV2ConfigBuildInfoArgs',
    'PcRegistrationV2ConfigBuildInfoArgsDict',
    'PcRegistrationV2ConfigResourceConfigArgs',
    'PcRegistrationV2ConfigResourceConfigArgsDict',
    'PcRegistrationV2LinkArgs',
    'PcRegistrationV2LinkArgsDict',
    'PcRegistrationV2NetworkArgs',
    'PcRegistrationV2NetworkArgsDict',
    'PcRegistrationV2NetworkExternalAddressArgs',
    'PcRegistrationV2NetworkExternalAddressArgsDict',
    'PcRegistrationV2NetworkExternalAddressIpv4Args',
    'PcRegistrationV2NetworkExternalAddressIpv4ArgsDict',
    'PcRegistrationV2NetworkExternalAddressIpv6Args',
    'PcRegistrationV2NetworkExternalAddressIpv6ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkArgs',
    'PcRegistrationV2NetworkExternalNetworkArgsDict',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgs',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgsDict',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgsDict',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args',
    'PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeArgs',
    'PcRegistrationV2NetworkExternalNetworkIpRangeArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgs',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args',
    'PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndArgs',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args',
    'PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskArgs',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskArgsDict',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgsDict',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4ArgsDict',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args',
    'PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6ArgsDict',
    'PcRegistrationV2NetworkNameServerArgs',
    'PcRegistrationV2NetworkNameServerArgsDict',
    'PcRegistrationV2NetworkNameServerFqdnArgs',
    'PcRegistrationV2NetworkNameServerFqdnArgsDict',
    'PcRegistrationV2NetworkNameServerIpv4Args',
    'PcRegistrationV2NetworkNameServerIpv4ArgsDict',
    'PcRegistrationV2NetworkNameServerIpv6Args',
    'PcRegistrationV2NetworkNameServerIpv6ArgsDict',
    'PcRegistrationV2NetworkNtpServerArgs',
    'PcRegistrationV2NetworkNtpServerArgsDict',
    'PcRegistrationV2NetworkNtpServerFqdnArgs',
    'PcRegistrationV2NetworkNtpServerFqdnArgsDict',
    'PcRegistrationV2NetworkNtpServerIpv4Args',
    'PcRegistrationV2NetworkNtpServerIpv4ArgsDict',
    'PcRegistrationV2NetworkNtpServerIpv6Args',
    'PcRegistrationV2NetworkNtpServerIpv6ArgsDict',
    'PcRegistrationV2RemoteClusterArgs',
    'PcRegistrationV2RemoteClusterArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgsDict',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs',
    'PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict',
    'PcRegistrationV2RemoteClusterClusterReferenceArgs',
    'PcRegistrationV2RemoteClusterClusterReferenceArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgsDict',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs',
    'PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict',
    'ProjectAccountReferenceListArgs',
    'ProjectAccountReferenceListArgsDict',
    'ProjectAcpArgs',
    'ProjectAcpArgsDict',
    'ProjectAcpContextFilterListArgs',
    'ProjectAcpContextFilterListArgsDict',
    'ProjectAcpContextFilterListEntityFilterExpressionListArgs',
    'ProjectAcpContextFilterListEntityFilterExpressionListArgsDict',
    'ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs',
    'ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgsDict',
    'ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs',
    'ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict',
    'ProjectAcpContextFilterListScopeFilterExpressionListArgs',
    'ProjectAcpContextFilterListScopeFilterExpressionListArgsDict',
    'ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs',
    'ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgsDict',
    'ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs',
    'ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict',
    'ProjectAcpRoleReferenceArgs',
    'ProjectAcpRoleReferenceArgsDict',
    'ProjectAcpUserGroupReferenceListArgs',
    'ProjectAcpUserGroupReferenceListArgsDict',
    'ProjectAcpUserReferenceListArgs',
    'ProjectAcpUserReferenceListArgsDict',
    'ProjectCategoryArgs',
    'ProjectCategoryArgsDict',
    'ProjectClusterReferenceListArgs',
    'ProjectClusterReferenceListArgsDict',
    'ProjectDefaultEnvironmentReferenceArgs',
    'ProjectDefaultEnvironmentReferenceArgsDict',
    'ProjectDefaultSubnetReferenceArgs',
    'ProjectDefaultSubnetReferenceArgsDict',
    'ProjectEnvironmentReferenceListArgs',
    'ProjectEnvironmentReferenceListArgsDict',
    'ProjectExternalNetworkListArgs',
    'ProjectExternalNetworkListArgsDict',
    'ProjectExternalUserGroupReferenceListArgs',
    'ProjectExternalUserGroupReferenceListArgsDict',
    'ProjectResourceDomainArgs',
    'ProjectResourceDomainArgsDict',
    'ProjectResourceDomainResourceArgs',
    'ProjectResourceDomainResourceArgsDict',
    'ProjectSubnetReferenceListArgs',
    'ProjectSubnetReferenceListArgsDict',
    'ProjectTunnelReferenceListArgs',
    'ProjectTunnelReferenceListArgsDict',
    'ProjectUserGroupListArgs',
    'ProjectUserGroupListArgsDict',
    'ProjectUserGroupListDirectoryServiceOusArgs',
    'ProjectUserGroupListDirectoryServiceOusArgsDict',
    'ProjectUserGroupListDirectoryServiceUserGroupArgs',
    'ProjectUserGroupListDirectoryServiceUserGroupArgsDict',
    'ProjectUserGroupListSamlUserGroupArgs',
    'ProjectUserGroupListSamlUserGroupArgsDict',
    'ProjectUserListArgs',
    'ProjectUserListArgsDict',
    'ProjectUserListDirectoryServiceUserArgs',
    'ProjectUserListDirectoryServiceUserArgsDict',
    'ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgs',
    'ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgsDict',
    'ProjectUserListIdentityProviderUserArgs',
    'ProjectUserListIdentityProviderUserArgsDict',
    'ProjectUserListIdentityProviderUserIdentityProviderReferenceArgs',
    'ProjectUserListIdentityProviderUserIdentityProviderReferenceArgsDict',
    'ProjectUserReferenceListArgs',
    'ProjectUserReferenceListArgsDict',
    'ProjectVpcReferenceListArgs',
    'ProjectVpcReferenceListArgsDict',
    'ProtectionRuleAvailabilityZoneConnectivityListArgs',
    'ProtectionRuleAvailabilityZoneConnectivityListArgsDict',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgs',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgsDict',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgs',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgsDict',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgs',
    'ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgsDict',
    'ProtectionRuleCategoryArgs',
    'ProtectionRuleCategoryArgsDict',
    'ProtectionRuleCategoryFilterArgs',
    'ProtectionRuleCategoryFilterArgsDict',
    'ProtectionRuleCategoryFilterParamArgs',
    'ProtectionRuleCategoryFilterParamArgsDict',
    'ProtectionRuleOrderedAvailabilityZoneListArgs',
    'ProtectionRuleOrderedAvailabilityZoneListArgsDict',
    'ProtectionRuleOwnerReferenceArgs',
    'ProtectionRuleOwnerReferenceArgsDict',
    'ProtectionRuleProjectReferenceArgs',
    'ProtectionRuleProjectReferenceArgsDict',
    'RecoveryPlanCategoryArgs',
    'RecoveryPlanCategoryArgsDict',
    'RecoveryPlanOwnerReferenceArgs',
    'RecoveryPlanOwnerReferenceArgsDict',
    'RecoveryPlanParametersArgs',
    'RecoveryPlanParametersArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgsDict',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgs',
    'RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListArgs',
    'RecoveryPlanParametersNetworkMappingListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgsDict',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgs',
    'RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgsDict',
    'RecoveryPlanProjectReferenceArgs',
    'RecoveryPlanProjectReferenceArgsDict',
    'RecoveryPlanStageListArgs',
    'RecoveryPlanStageListArgsDict',
    'RecoveryPlanStageListStageWorkArgs',
    'RecoveryPlanStageListStageWorkArgsDict',
    'RecoveryPlanStageListStageWorkRecoverEntitiesArgs',
    'RecoveryPlanStageListStageWorkRecoverEntitiesArgsDict',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgs',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgsDict',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgs',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgsDict',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgs',
    'RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgsDict',
    'RecoveryPointRestoreV2VmRecoveryPointRestoreOverrideArgs',
    'RecoveryPointRestoreV2VmRecoveryPointRestoreOverrideArgsDict',
    'RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideArgs',
    'RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideArgsDict',
    'RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs',
    'RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgsDict',
    'RecoveryPointsV2LinkArgs',
    'RecoveryPointsV2LinkArgsDict',
    'RecoveryPointsV2LocationReferenceArgs',
    'RecoveryPointsV2LocationReferenceArgsDict',
    'RecoveryPointsV2VmRecoveryPointArgs',
    'RecoveryPointsV2VmRecoveryPointArgsDict',
    'RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs',
    'RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgsDict',
    'RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs',
    'RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgsDict',
    'RecoveryPointsV2VmRecoveryPointLinkArgs',
    'RecoveryPointsV2VmRecoveryPointLinkArgsDict',
    'RecoveryPointsV2VolumeGroupRecoveryPointArgs',
    'RecoveryPointsV2VolumeGroupRecoveryPointArgsDict',
    'RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs',
    'RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgsDict',
    'RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs',
    'RecoveryPointsV2VolumeGroupRecoveryPointLinkArgsDict',
    'RoleCategoryArgs',
    'RoleCategoryArgsDict',
    'RoleOwnerReferenceArgs',
    'RoleOwnerReferenceArgsDict',
    'RolePermissionReferenceListArgs',
    'RolePermissionReferenceListArgsDict',
    'RoleProjectReferenceArgs',
    'RoleProjectReferenceArgsDict',
    'RolesV2LinkArgs',
    'RolesV2LinkArgsDict',
    'RoutesV2DestinationArgs',
    'RoutesV2DestinationArgsDict',
    'RoutesV2DestinationIpv4Args',
    'RoutesV2DestinationIpv4ArgsDict',
    'RoutesV2DestinationIpv4IpArgs',
    'RoutesV2DestinationIpv4IpArgsDict',
    'RoutesV2DestinationIpv6Args',
    'RoutesV2DestinationIpv6ArgsDict',
    'RoutesV2DestinationIpv6IpArgs',
    'RoutesV2DestinationIpv6IpArgsDict',
    'RoutesV2LinkArgs',
    'RoutesV2LinkArgsDict',
    'RoutesV2MetadataArgs',
    'RoutesV2MetadataArgsDict',
    'RoutesV2NextHopArgs',
    'RoutesV2NextHopArgsDict',
    'RoutesV2NextHopNextHopIpAddressArgs',
    'RoutesV2NextHopNextHopIpAddressArgsDict',
    'RoutesV2NextHopNextHopIpAddressIpv4Args',
    'RoutesV2NextHopNextHopIpAddressIpv4ArgsDict',
    'RoutesV2NextHopNextHopIpAddressIpv6Args',
    'RoutesV2NextHopNextHopIpAddressIpv6ArgsDict',
    'SamlIdentityProvidersV2IdpMetadataArgs',
    'SamlIdentityProvidersV2IdpMetadataArgsDict',
    'ServiceGroupServiceListArgs',
    'ServiceGroupServiceListArgsDict',
    'ServiceGroupServiceListIcmpTypeCodeListArgs',
    'ServiceGroupServiceListIcmpTypeCodeListArgsDict',
    'ServiceGroupServiceListTcpPortRangeListArgs',
    'ServiceGroupServiceListTcpPortRangeListArgsDict',
    'ServiceGroupServiceListUdpPortRangeListArgs',
    'ServiceGroupServiceListUdpPortRangeListArgsDict',
    'ServiceGroupsV2IcmpServiceArgs',
    'ServiceGroupsV2IcmpServiceArgsDict',
    'ServiceGroupsV2LinkArgs',
    'ServiceGroupsV2LinkArgsDict',
    'ServiceGroupsV2TcpServiceArgs',
    'ServiceGroupsV2TcpServiceArgsDict',
    'ServiceGroupsV2UdpServiceArgs',
    'ServiceGroupsV2UdpServiceArgsDict',
    'StaticRoutesDefaultRouteNexthopArgs',
    'StaticRoutesDefaultRouteNexthopArgsDict',
    'StaticRoutesStaticRoutesListArgs',
    'StaticRoutesStaticRoutesListArgsDict',
    'StorageContainersV2LinkArgs',
    'StorageContainersV2LinkArgsDict',
    'StorageContainersV2NfsWhitelistAddressArgs',
    'StorageContainersV2NfsWhitelistAddressArgsDict',
    'StorageContainersV2NfsWhitelistAddressFqdnArgs',
    'StorageContainersV2NfsWhitelistAddressFqdnArgsDict',
    'StorageContainersV2NfsWhitelistAddressIpv4Args',
    'StorageContainersV2NfsWhitelistAddressIpv4ArgsDict',
    'StorageContainersV2NfsWhitelistAddressIpv6Args',
    'StorageContainersV2NfsWhitelistAddressIpv6ArgsDict',
    'SubnetCategoryArgs',
    'SubnetCategoryArgsDict',
    'SubnetV2DhcpOptionArgs',
    'SubnetV2DhcpOptionArgsDict',
    'SubnetV2DhcpOptionDomainNameServerArgs',
    'SubnetV2DhcpOptionDomainNameServerArgsDict',
    'SubnetV2DhcpOptionDomainNameServerIpv4Args',
    'SubnetV2DhcpOptionDomainNameServerIpv4ArgsDict',
    'SubnetV2DhcpOptionDomainNameServerIpv6Args',
    'SubnetV2DhcpOptionDomainNameServerIpv6ArgsDict',
    'SubnetV2DhcpOptionNtpServerArgs',
    'SubnetV2DhcpOptionNtpServerArgsDict',
    'SubnetV2DhcpOptionNtpServerIpv4Args',
    'SubnetV2DhcpOptionNtpServerIpv4ArgsDict',
    'SubnetV2DhcpOptionNtpServerIpv6Args',
    'SubnetV2DhcpOptionNtpServerIpv6ArgsDict',
    'SubnetV2DynamicIpAddressArgs',
    'SubnetV2DynamicIpAddressArgsDict',
    'SubnetV2DynamicIpAddressIpv4Args',
    'SubnetV2DynamicIpAddressIpv4ArgsDict',
    'SubnetV2DynamicIpAddressIpv6Args',
    'SubnetV2DynamicIpAddressIpv6ArgsDict',
    'SubnetV2IpConfigArgs',
    'SubnetV2IpConfigArgsDict',
    'SubnetV2IpConfigIpv4Args',
    'SubnetV2IpConfigIpv4ArgsDict',
    'SubnetV2IpConfigIpv4DefaultGatewayIpArgs',
    'SubnetV2IpConfigIpv4DefaultGatewayIpArgsDict',
    'SubnetV2IpConfigIpv4DhcpServerAddressArgs',
    'SubnetV2IpConfigIpv4DhcpServerAddressArgsDict',
    'SubnetV2IpConfigIpv4IpSubnetArgs',
    'SubnetV2IpConfigIpv4IpSubnetArgsDict',
    'SubnetV2IpConfigIpv4IpSubnetIpArgs',
    'SubnetV2IpConfigIpv4IpSubnetIpArgsDict',
    'SubnetV2IpConfigIpv4PoolListArgs',
    'SubnetV2IpConfigIpv4PoolListArgsDict',
    'SubnetV2IpConfigIpv4PoolListEndIpArgs',
    'SubnetV2IpConfigIpv4PoolListEndIpArgsDict',
    'SubnetV2IpConfigIpv4PoolListStartIpArgs',
    'SubnetV2IpConfigIpv4PoolListStartIpArgsDict',
    'SubnetV2IpConfigIpv6Args',
    'SubnetV2IpConfigIpv6ArgsDict',
    'SubnetV2IpConfigIpv6DefaultGatewayIpArgs',
    'SubnetV2IpConfigIpv6DefaultGatewayIpArgsDict',
    'SubnetV2IpConfigIpv6DhcpServerAddressArgs',
    'SubnetV2IpConfigIpv6DhcpServerAddressArgsDict',
    'SubnetV2IpConfigIpv6IpSubnetArgs',
    'SubnetV2IpConfigIpv6IpSubnetArgsDict',
    'SubnetV2IpConfigIpv6IpSubnetIpArgs',
    'SubnetV2IpConfigIpv6IpSubnetIpArgsDict',
    'SubnetV2IpConfigIpv6PoolListArgs',
    'SubnetV2IpConfigIpv6PoolListArgsDict',
    'SubnetV2IpConfigIpv6PoolListEndIpArgs',
    'SubnetV2IpConfigIpv6PoolListEndIpArgsDict',
    'SubnetV2IpConfigIpv6PoolListStartIpArgs',
    'SubnetV2IpConfigIpv6PoolListStartIpArgsDict',
    'SubnetV2IpUsageArgs',
    'SubnetV2IpUsageArgsDict',
    'SubnetV2IpUsageIpPoolUsageArgs',
    'SubnetV2IpUsageIpPoolUsageArgsDict',
    'SubnetV2IpUsageIpPoolUsageRangeArgs',
    'SubnetV2IpUsageIpPoolUsageRangeArgsDict',
    'SubnetV2IpUsageIpPoolUsageRangeEndIpArgs',
    'SubnetV2IpUsageIpPoolUsageRangeEndIpArgsDict',
    'SubnetV2IpUsageIpPoolUsageRangeStartIpArgs',
    'SubnetV2IpUsageIpPoolUsageRangeStartIpArgsDict',
    'SubnetV2LinkArgs',
    'SubnetV2LinkArgsDict',
    'SubnetV2ReservedIpAddressArgs',
    'SubnetV2ReservedIpAddressArgsDict',
    'SubnetV2VirtualSwitchArgs',
    'SubnetV2VirtualSwitchArgsDict',
    'SubnetV2VirtualSwitchClusterArgs',
    'SubnetV2VirtualSwitchClusterArgsDict',
    'SubnetV2VirtualSwitchClusterGatewayIpAddressArgs',
    'SubnetV2VirtualSwitchClusterGatewayIpAddressArgsDict',
    'SubnetV2VirtualSwitchClusterHostArgs',
    'SubnetV2VirtualSwitchClusterHostArgsDict',
    'SubnetV2VirtualSwitchClusterHostIpAddressArgs',
    'SubnetV2VirtualSwitchClusterHostIpAddressArgsDict',
    'SubnetV2VirtualSwitchClusterHostIpAddressIpArgs',
    'SubnetV2VirtualSwitchClusterHostIpAddressIpArgsDict',
    'SubnetV2VirtualSwitchLinkArgs',
    'SubnetV2VirtualSwitchLinkArgsDict',
    'SubnetV2VirtualSwitchMetadataArgs',
    'SubnetV2VirtualSwitchMetadataArgsDict',
    'SubnetV2VpcArgs',
    'SubnetV2VpcArgsDict',
    'SubnetV2VpcCommonDhcpOptionArgs',
    'SubnetV2VpcCommonDhcpOptionArgsDict',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerArgs',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerArgsDict',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4Args',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6Args',
    'SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict',
    'SubnetV2VpcExternalSubnetArgs',
    'SubnetV2VpcExternalSubnetArgsDict',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeArgs',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeArgsDict',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args',
    'SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict',
    'SubnetV2VpcExternalSubnetExternalIpArgs',
    'SubnetV2VpcExternalSubnetExternalIpArgsDict',
    'SubnetV2VpcExternalSubnetExternalIpIpv4Args',
    'SubnetV2VpcExternalSubnetExternalIpIpv4ArgsDict',
    'SubnetV2VpcExternalSubnetExternalIpIpv6Args',
    'SubnetV2VpcExternalSubnetExternalIpIpv6ArgsDict',
    'SubnetV2VpcExternallyRoutablePrefixArgs',
    'SubnetV2VpcExternallyRoutablePrefixArgsDict',
    'SubnetV2VpcExternallyRoutablePrefixIpv4Args',
    'SubnetV2VpcExternallyRoutablePrefixIpv4ArgsDict',
    'SubnetV2VpcExternallyRoutablePrefixIpv4IpArgs',
    'SubnetV2VpcExternallyRoutablePrefixIpv4IpArgsDict',
    'SubnetV2VpcExternallyRoutablePrefixIpv6Args',
    'SubnetV2VpcExternallyRoutablePrefixIpv6ArgsDict',
    'SubnetV2VpcExternallyRoutablePrefixIpv6IpArgs',
    'SubnetV2VpcExternallyRoutablePrefixIpv6IpArgsDict',
    'SubnetV2VpcLinkArgs',
    'SubnetV2VpcLinkArgsDict',
    'SubnetV2VpcMetadataArgs',
    'SubnetV2VpcMetadataArgsDict',
    'SubnetV2VpcSnatIpArgs',
    'SubnetV2VpcSnatIpArgsDict',
    'SubnetV2VpcSnatIpIpv4Args',
    'SubnetV2VpcSnatIpIpv4ArgsDict',
    'SubnetV2VpcSnatIpIpv6Args',
    'SubnetV2VpcSnatIpIpv6ArgsDict',
    'TemplateV2CreatedByArgs',
    'TemplateV2CreatedByArgsDict',
    'TemplateV2CreatedByAdditionalAttributeArgs',
    'TemplateV2CreatedByAdditionalAttributeArgsDict',
    'TemplateV2CreatedByAdditionalAttributeValueArgs',
    'TemplateV2CreatedByAdditionalAttributeValueArgsDict',
    'TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgs',
    'TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgsDict',
    'TemplateV2GuestUpdateStatusArgs',
    'TemplateV2GuestUpdateStatusArgsDict',
    'TemplateV2LinkArgs',
    'TemplateV2LinkArgsDict',
    'TemplateV2TemplateVersionSpecArgs',
    'TemplateV2TemplateVersionSpecArgsDict',
    'TemplateV2TemplateVersionSpecCreatedByArgs',
    'TemplateV2TemplateVersionSpecCreatedByArgsDict',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgs',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgsDict',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgs',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgsDict',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecLinkArgs',
    'TemplateV2TemplateVersionSpecLinkArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceArgs',
    'TemplateV2TemplateVersionSpecVersionSourceArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecArgs',
    'TemplateV2TemplateVersionSpecVmSpecArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecApcConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecApcConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgs',
    'TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgs',
    'TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs',
    'TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCategoryArgs',
    'TemplateV2TemplateVersionSpecVmSpecCategoryArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecClusterArgs',
    'TemplateV2TemplateVersionSpecVmSpecClusterArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecDiskLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecDiskLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGpusArgs',
    'TemplateV2TemplateVersionSpecVmSpecGpusArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGpusLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecGpusLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecGuestToolArgs',
    'TemplateV2TemplateVersionSpecVmSpecGuestToolArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecHostArgs',
    'TemplateV2TemplateVersionSpecVmSpecHostArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgs',
    'TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgs',
    'TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgs',
    'TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgs',
    'TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecSerialPortArgs',
    'TemplateV2TemplateVersionSpecVmSpecSerialPortArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgs',
    'TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecSourceArgs',
    'TemplateV2TemplateVersionSpecVmSpecSourceArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecStorageConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecStorageConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgsDict',
    'TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgs',
    'TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgsDict',
    'TemplateV2UpdatedByArgs',
    'TemplateV2UpdatedByArgsDict',
    'TemplateV2UpdatedByAdditionalAttributeArgs',
    'TemplateV2UpdatedByAdditionalAttributeArgsDict',
    'TemplateV2UpdatedByAdditionalAttributeValueArgs',
    'TemplateV2UpdatedByAdditionalAttributeValueArgsDict',
    'TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgs',
    'TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgsDict',
    'UserAccessControlPolicyReferenceListArgs',
    'UserAccessControlPolicyReferenceListArgsDict',
    'UserCategoryArgs',
    'UserCategoryArgsDict',
    'UserDirectoryServiceUserArgs',
    'UserDirectoryServiceUserArgsDict',
    'UserDirectoryServiceUserDirectoryServiceReferenceArgs',
    'UserDirectoryServiceUserDirectoryServiceReferenceArgsDict',
    'UserGroupsCategoryArgs',
    'UserGroupsCategoryArgsDict',
    'UserGroupsDirectoryServiceOusArgs',
    'UserGroupsDirectoryServiceOusArgsDict',
    'UserGroupsDirectoryServiceUserGroupArgs',
    'UserGroupsDirectoryServiceUserGroupArgsDict',
    'UserGroupsSamlUserGroupArgs',
    'UserGroupsSamlUserGroupArgsDict',
    'UserIdentityProviderUserArgs',
    'UserIdentityProviderUserArgsDict',
    'UserIdentityProviderUserIdentityProviderReferenceArgs',
    'UserIdentityProviderUserIdentityProviderReferenceArgsDict',
    'UserProjectReferenceListArgs',
    'UserProjectReferenceListArgsDict',
    'UsersV2AdditionalAttributeArgs',
    'UsersV2AdditionalAttributeArgsDict',
    'UsersV2BucketsAccessKeyArgs',
    'UsersV2BucketsAccessKeyArgsDict',
    'UsersV2BucketsAccessKeyLinkArgs',
    'UsersV2BucketsAccessKeyLinkArgsDict',
    'UsersV2LinkArgs',
    'UsersV2LinkArgsDict',
    'VirtualMachineCategoryArgs',
    'VirtualMachineCategoryArgsDict',
    'VirtualMachineDiskListArgs',
    'VirtualMachineDiskListArgsDict',
    'VirtualMachineDiskListDevicePropertiesArgs',
    'VirtualMachineDiskListDevicePropertiesArgsDict',
    'VirtualMachineDiskListStorageConfigArgs',
    'VirtualMachineDiskListStorageConfigArgsDict',
    'VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs',
    'VirtualMachineDiskListStorageConfigStorageContainerReferenceArgsDict',
    'VirtualMachineGpuListArgs',
    'VirtualMachineGpuListArgsDict',
    'VirtualMachineNicListArgs',
    'VirtualMachineNicListArgsDict',
    'VirtualMachineNicListIpEndpointListArgs',
    'VirtualMachineNicListIpEndpointListArgsDict',
    'VirtualMachineNicListStatusArgs',
    'VirtualMachineNicListStatusArgsDict',
    'VirtualMachineNicListStatusIpEndpointListArgs',
    'VirtualMachineNicListStatusIpEndpointListArgsDict',
    'VirtualMachineSerialPortListArgs',
    'VirtualMachineSerialPortListArgsDict',
    'VirtualMachineV2ApcConfigArgs',
    'VirtualMachineV2ApcConfigArgsDict',
    'VirtualMachineV2ApcConfigCpuModelArgs',
    'VirtualMachineV2ApcConfigCpuModelArgsDict',
    'VirtualMachineV2AvailabilityZoneArgs',
    'VirtualMachineV2AvailabilityZoneArgsDict',
    'VirtualMachineV2BootConfigArgs',
    'VirtualMachineV2BootConfigArgsDict',
    'VirtualMachineV2BootConfigLegacyBootArgs',
    'VirtualMachineV2BootConfigLegacyBootArgsDict',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceArgs',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceArgsDict',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs',
    'VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict',
    'VirtualMachineV2BootConfigUefiBootArgs',
    'VirtualMachineV2BootConfigUefiBootArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs',
    'VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict',
    'VirtualMachineV2CategoryArgs',
    'VirtualMachineV2CategoryArgsDict',
    'VirtualMachineV2CdRomArgs',
    'VirtualMachineV2CdRomArgsDict',
    'VirtualMachineV2CdRomBackingInfoArgs',
    'VirtualMachineV2CdRomBackingInfoArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VirtualMachineV2CdRomBackingInfoStorageConfigArgs',
    'VirtualMachineV2CdRomBackingInfoStorageConfigArgsDict',
    'VirtualMachineV2CdRomBackingInfoStorageContainerArgs',
    'VirtualMachineV2CdRomBackingInfoStorageContainerArgsDict',
    'VirtualMachineV2CdRomDiskAddressArgs',
    'VirtualMachineV2CdRomDiskAddressArgsDict',
    'VirtualMachineV2ClusterArgs',
    'VirtualMachineV2ClusterArgsDict',
    'VirtualMachineV2DiskArgs',
    'VirtualMachineV2DiskArgsDict',
    'VirtualMachineV2DiskBackingInfoArgs',
    'VirtualMachineV2DiskBackingInfoArgsDict',
    'VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgs',
    'VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgsDict',
    'VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgs',
    'VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgsDict',
    'VirtualMachineV2DiskDiskAddressArgs',
    'VirtualMachineV2DiskDiskAddressArgsDict',
    'VirtualMachineV2GpusArgs',
    'VirtualMachineV2GpusArgsDict',
    'VirtualMachineV2GpusLinkArgs',
    'VirtualMachineV2GpusLinkArgsDict',
    'VirtualMachineV2GpusPciAddressArgs',
    'VirtualMachineV2GpusPciAddressArgsDict',
    'VirtualMachineV2GuestCustomizationArgs',
    'VirtualMachineV2GuestCustomizationArgsDict',
    'VirtualMachineV2GuestCustomizationConfigArgs',
    'VirtualMachineV2GuestCustomizationConfigArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'VirtualMachineV2GuestToolArgs',
    'VirtualMachineV2GuestToolArgsDict',
    'VirtualMachineV2HostArgs',
    'VirtualMachineV2HostArgsDict',
    'VirtualMachineV2NicArgs',
    'VirtualMachineV2NicArgsDict',
    'VirtualMachineV2NicBackingInfoArgs',
    'VirtualMachineV2NicBackingInfoArgsDict',
    'VirtualMachineV2NicNetworkInfoArgs',
    'VirtualMachineV2NicNetworkInfoArgsDict',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigArgs',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigArgsDict',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgs',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgsDict',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs',
    'VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict',
    'VirtualMachineV2NicNetworkInfoIpv4InfoArgs',
    'VirtualMachineV2NicNetworkInfoIpv4InfoArgsDict',
    'VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgs',
    'VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgsDict',
    'VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs',
    'VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgsDict',
    'VirtualMachineV2NicNetworkInfoSubnetArgs',
    'VirtualMachineV2NicNetworkInfoSubnetArgsDict',
    'VirtualMachineV2OwnershipInfoArgs',
    'VirtualMachineV2OwnershipInfoArgsDict',
    'VirtualMachineV2OwnershipInfoOwnerArgs',
    'VirtualMachineV2OwnershipInfoOwnerArgsDict',
    'VirtualMachineV2ProtectionPolicyStateArgs',
    'VirtualMachineV2ProtectionPolicyStateArgsDict',
    'VirtualMachineV2ProtectionPolicyStatePolicyArgs',
    'VirtualMachineV2ProtectionPolicyStatePolicyArgsDict',
    'VirtualMachineV2SerialPortArgs',
    'VirtualMachineV2SerialPortArgsDict',
    'VirtualMachineV2SourceArgs',
    'VirtualMachineV2SourceArgsDict',
    'VirtualMachineV2StorageConfigArgs',
    'VirtualMachineV2StorageConfigArgsDict',
    'VirtualMachineV2StorageConfigQosConfigArgs',
    'VirtualMachineV2StorageConfigQosConfigArgsDict',
    'VirtualMachineV2VtpmConfigArgs',
    'VirtualMachineV2VtpmConfigArgsDict',
    'VmCdromInsertEjectV2BackingInfoArgs',
    'VmCdromInsertEjectV2BackingInfoArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VmCdromInsertEjectV2BackingInfoStorageConfigArgs',
    'VmCdromInsertEjectV2BackingInfoStorageConfigArgsDict',
    'VmCdromInsertEjectV2BackingInfoStorageContainerArgs',
    'VmCdromInsertEjectV2BackingInfoStorageContainerArgsDict',
    'VmCloneV2ApcConfigArgs',
    'VmCloneV2ApcConfigArgsDict',
    'VmCloneV2ApcConfigCpuModelArgs',
    'VmCloneV2ApcConfigCpuModelArgsDict',
    'VmCloneV2BootConfigArgs',
    'VmCloneV2BootConfigArgsDict',
    'VmCloneV2BootConfigLegacyBootArgs',
    'VmCloneV2BootConfigLegacyBootArgsDict',
    'VmCloneV2BootConfigLegacyBootBootDeviceArgs',
    'VmCloneV2BootConfigLegacyBootBootDeviceArgsDict',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs',
    'VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict',
    'VmCloneV2BootConfigUefiBootArgs',
    'VmCloneV2BootConfigUefiBootArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs',
    'VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict',
    'VmCloneV2CategoryArgs',
    'VmCloneV2CategoryArgsDict',
    'VmCloneV2CdRomArgs',
    'VmCloneV2CdRomArgsDict',
    'VmCloneV2CdRomBackingInfoArgs',
    'VmCloneV2CdRomBackingInfoArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceArgs',
    'VmCloneV2CdRomBackingInfoDataSourceArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceArgs',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VmCloneV2CdRomBackingInfoStorageConfigArgs',
    'VmCloneV2CdRomBackingInfoStorageConfigArgsDict',
    'VmCloneV2CdRomBackingInfoStorageContainerArgs',
    'VmCloneV2CdRomBackingInfoStorageContainerArgsDict',
    'VmCloneV2CdRomDiskAddressArgs',
    'VmCloneV2CdRomDiskAddressArgsDict',
    'VmCloneV2ClusterArgs',
    'VmCloneV2ClusterArgsDict',
    'VmCloneV2DiskArgs',
    'VmCloneV2DiskArgsDict',
    'VmCloneV2DiskBackingInfoArgs',
    'VmCloneV2DiskBackingInfoArgsDict',
    'VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgs',
    'VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskArgs',
    'VmCloneV2DiskBackingInfoVmDiskArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs',
    'VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskStorageConfigArgs',
    'VmCloneV2DiskBackingInfoVmDiskStorageConfigArgsDict',
    'VmCloneV2DiskBackingInfoVmDiskStorageContainerArgs',
    'VmCloneV2DiskBackingInfoVmDiskStorageContainerArgsDict',
    'VmCloneV2DiskDiskAddressArgs',
    'VmCloneV2DiskDiskAddressArgsDict',
    'VmCloneV2GpusArgs',
    'VmCloneV2GpusArgsDict',
    'VmCloneV2GpusPciAddressArgs',
    'VmCloneV2GpusPciAddressArgsDict',
    'VmCloneV2GuestCustomizationArgs',
    'VmCloneV2GuestCustomizationArgsDict',
    'VmCloneV2GuestCustomizationConfigArgs',
    'VmCloneV2GuestCustomizationConfigArgsDict',
    'VmCloneV2GuestCustomizationConfigCloudInitArgs',
    'VmCloneV2GuestCustomizationConfigCloudInitArgsDict',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgs',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgs',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgsDict',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs',
    'VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict',
    'VmCloneV2GuestCustomizationConfigSysprepArgs',
    'VmCloneV2GuestCustomizationConfigSysprepArgsDict',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgs',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgsDict',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs',
    'VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'VmCloneV2GuestToolArgs',
    'VmCloneV2GuestToolArgsDict',
    'VmCloneV2HostArgs',
    'VmCloneV2HostArgsDict',
    'VmCloneV2LinkArgs',
    'VmCloneV2LinkArgsDict',
    'VmCloneV2NicArgs',
    'VmCloneV2NicArgsDict',
    'VmCloneV2NicBackingInfoArgs',
    'VmCloneV2NicBackingInfoArgsDict',
    'VmCloneV2NicNetworkInfoArgs',
    'VmCloneV2NicNetworkInfoArgsDict',
    'VmCloneV2NicNetworkInfoIpv4ConfigArgs',
    'VmCloneV2NicNetworkInfoIpv4ConfigArgsDict',
    'VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgs',
    'VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgsDict',
    'VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs',
    'VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict',
    'VmCloneV2NicNetworkInfoNetworkFunctionChainArgs',
    'VmCloneV2NicNetworkInfoNetworkFunctionChainArgsDict',
    'VmCloneV2NicNetworkInfoSubnetArgs',
    'VmCloneV2NicNetworkInfoSubnetArgsDict',
    'VmCloneV2OwnershipInfoArgs',
    'VmCloneV2OwnershipInfoArgsDict',
    'VmCloneV2OwnershipInfoOwnerArgs',
    'VmCloneV2OwnershipInfoOwnerArgsDict',
    'VmCloneV2ProtectionPolicyStateArgs',
    'VmCloneV2ProtectionPolicyStateArgsDict',
    'VmCloneV2ProtectionPolicyStatePolicyArgs',
    'VmCloneV2ProtectionPolicyStatePolicyArgsDict',
    'VmCloneV2SerialPortArgs',
    'VmCloneV2SerialPortArgsDict',
    'VmCloneV2SourceArgs',
    'VmCloneV2SourceArgsDict',
    'VmCloneV2StorageConfigArgs',
    'VmCloneV2StorageConfigArgsDict',
    'VmCloneV2StorageConfigQosConfigArgs',
    'VmCloneV2StorageConfigQosConfigArgsDict',
    'VmCloneV2VtpmConfigArgs',
    'VmCloneV2VtpmConfigArgsDict',
    'VmGcUpdateV2ConfigArgs',
    'VmGcUpdateV2ConfigArgsDict',
    'VmGcUpdateV2ConfigCloudInitArgs',
    'VmGcUpdateV2ConfigCloudInitArgsDict',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptArgs',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptArgsDict',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgs',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgsDict',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgs',
    'VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgsDict',
    'VmGcUpdateV2ConfigSysprepArgs',
    'VmGcUpdateV2ConfigSysprepArgsDict',
    'VmGcUpdateV2ConfigSysprepSysprepScriptArgs',
    'VmGcUpdateV2ConfigSysprepSysprepScriptArgsDict',
    'VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgs',
    'VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgsDict',
    'VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs',
    'VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict',
    'VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgs',
    'VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgsDict',
    'VmNetworkDeviceAssignIpV2IpAddressArgs',
    'VmNetworkDeviceAssignIpV2IpAddressArgsDict',
    'VmNetworkDeviceMigrateV2IpAddressArgs',
    'VmNetworkDeviceMigrateV2IpAddressArgsDict',
    'VmNetworkDeviceMigrateV2SubnetArgs',
    'VmNetworkDeviceMigrateV2SubnetArgsDict',
    'VmShutdownActionV2GuestPowerStateTransitionConfigArgs',
    'VmShutdownActionV2GuestPowerStateTransitionConfigArgsDict',
    'VolumeGroupDiskV2DiskDataSourceReferenceArgs',
    'VolumeGroupDiskV2DiskDataSourceReferenceArgsDict',
    'VolumeGroupDiskV2DiskStorageFeatureArgs',
    'VolumeGroupDiskV2DiskStorageFeatureArgsDict',
    'VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs',
    'VolumeGroupDiskV2DiskStorageFeatureFlashModeArgsDict',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdArgs',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdArgsDict',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args',
    'VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict',
    'VolumeGroupV2DiskArgs',
    'VolumeGroupV2DiskArgsDict',
    'VolumeGroupV2DiskDiskDataSourceReferenceArgs',
    'VolumeGroupV2DiskDiskDataSourceReferenceArgsDict',
    'VolumeGroupV2DiskDiskStorageFeatureArgs',
    'VolumeGroupV2DiskDiskStorageFeatureArgsDict',
    'VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs',
    'VolumeGroupV2DiskDiskStorageFeatureFlashModeArgsDict',
    'VolumeGroupV2IscsiFeatureArgs',
    'VolumeGroupV2IscsiFeatureArgsDict',
    'VolumeGroupV2StorageFeatureArgs',
    'VolumeGroupV2StorageFeatureArgsDict',
    'VolumeGroupV2StorageFeatureFlashModeArgs',
    'VolumeGroupV2StorageFeatureFlashModeArgsDict',
    'VpcCommonDomainNameServerIpListArgs',
    'VpcCommonDomainNameServerIpListArgsDict',
    'VpcExternalSubnetListStatusArgs',
    'VpcExternalSubnetListStatusArgsDict',
    'VpcExternalSubnetListStatusActiveGatewayNodeArgs',
    'VpcExternalSubnetListStatusActiveGatewayNodeArgsDict',
    'VpcExternallyRoutablePrefixListArgs',
    'VpcExternallyRoutablePrefixListArgsDict',
    'VpcV2CommonDhcpOptionArgs',
    'VpcV2CommonDhcpOptionArgsDict',
    'VpcV2CommonDhcpOptionDomainNameServerArgs',
    'VpcV2CommonDhcpOptionDomainNameServerArgsDict',
    'VpcV2CommonDhcpOptionDomainNameServerIpv4Args',
    'VpcV2CommonDhcpOptionDomainNameServerIpv4ArgsDict',
    'VpcV2CommonDhcpOptionDomainNameServerIpv6Args',
    'VpcV2CommonDhcpOptionDomainNameServerIpv6ArgsDict',
    'VpcV2ExternalSubnetArgs',
    'VpcV2ExternalSubnetArgsDict',
    'VpcV2ExternalSubnetActiveGatewayNodeArgs',
    'VpcV2ExternalSubnetActiveGatewayNodeArgsDict',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgs',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args',
    'VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict',
    'VpcV2ExternalSubnetExternalIpArgs',
    'VpcV2ExternalSubnetExternalIpArgsDict',
    'VpcV2ExternalSubnetExternalIpIpv4Args',
    'VpcV2ExternalSubnetExternalIpIpv4ArgsDict',
    'VpcV2ExternalSubnetExternalIpIpv6Args',
    'VpcV2ExternalSubnetExternalIpIpv6ArgsDict',
    'VpcV2ExternallyRoutablePrefixArgs',
    'VpcV2ExternallyRoutablePrefixArgsDict',
    'VpcV2ExternallyRoutablePrefixIpv4Args',
    'VpcV2ExternallyRoutablePrefixIpv4ArgsDict',
    'VpcV2ExternallyRoutablePrefixIpv4IpArgs',
    'VpcV2ExternallyRoutablePrefixIpv4IpArgsDict',
    'VpcV2ExternallyRoutablePrefixIpv6Args',
    'VpcV2ExternallyRoutablePrefixIpv6ArgsDict',
    'VpcV2ExternallyRoutablePrefixIpv6IpArgs',
    'VpcV2ExternallyRoutablePrefixIpv6IpArgsDict',
    'VpcV2LinkArgs',
    'VpcV2LinkArgsDict',
    'VpcV2MetadataArgs',
    'VpcV2MetadataArgsDict',
    'VpcV2SnatIpArgs',
    'VpcV2SnatIpArgsDict',
    'VpcV2SnatIpIpv4Args',
    'VpcV2SnatIpIpv4ArgsDict',
    'VpcV2SnatIpIpv6Args',
    'VpcV2SnatIpIpv6ArgsDict',
    'GetAccessControlPoliciesMetadataArgs',
    'GetAccessControlPoliciesMetadataArgsDict',
    'GetAccessControlPolicyCategoryArgs',
    'GetAccessControlPolicyCategoryArgsDict',
    'GetAddressGroupV2Ipv4AddressArgs',
    'GetAddressGroupV2Ipv4AddressArgsDict',
    'GetAddressGroupsMetadataArgs',
    'GetAddressGroupsMetadataArgsDict',
    'GetAssertHelperCheckArgs',
    'GetAssertHelperCheckArgsDict',
    'GetClusterCategoryArgs',
    'GetClusterCategoryArgsDict',
    'GetFloatingIpsMetadataArgs',
    'GetFloatingIpsMetadataArgsDict',
    'GetFoundationCentralClusterDetailsClusterStatusArgs',
    'GetFoundationCentralClusterDetailsClusterStatusArgsDict',
    'GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs',
    'GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgsDict',
    'GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs',
    'GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgsDict',
    'GetFoundationCentralClusterDetailsCommonNetworkSettingsArgs',
    'GetFoundationCentralClusterDetailsCommonNetworkSettingsArgsDict',
    'GetFoundationCentralImagedClustersListFiltersArgs',
    'GetFoundationCentralImagedClustersListFiltersArgsDict',
    'GetFoundationCentralImagedNodesListFiltersArgs',
    'GetFoundationCentralImagedNodesListFiltersArgsDict',
    'GetFoundationCentralListApiKeysMetadataArgs',
    'GetFoundationCentralListApiKeysMetadataArgsDict',
    'GetHostCategoryArgs',
    'GetHostCategoryArgsDict',
    'GetImageCategoryArgs',
    'GetImageCategoryArgsDict',
    'GetNdbCloneFilterArgs',
    'GetNdbCloneFilterArgsDict',
    'GetNdbCloneTagArgs',
    'GetNdbCloneTagArgsDict',
    'GetNdbClonesFilterArgs',
    'GetNdbClonesFilterArgsDict',
    'GetNdbDatabaseTagArgs',
    'GetNdbDatabaseTagArgsDict',
    'GetNdbDbserverTagArgs',
    'GetNdbDbserverTagArgsDict',
    'GetNdbMaintenanceWindowTagArgs',
    'GetNdbMaintenanceWindowTagArgsDict',
    'GetNdbSnapshotFilterArgs',
    'GetNdbSnapshotFilterArgsDict',
    'GetNdbSnapshotTagArgs',
    'GetNdbSnapshotTagArgsDict',
    'GetNdbSnapshotsFilterArgs',
    'GetNdbSnapshotsFilterArgsDict',
    'GetNdbTimeMachineTagArgs',
    'GetNdbTimeMachineTagArgsDict',
    'GetNetworkSecurityRuleCategoryArgs',
    'GetNetworkSecurityRuleCategoryArgsDict',
    'GetPbrsMetadataArgs',
    'GetPbrsMetadataArgsDict',
    'GetPermissionCategoryArgs',
    'GetPermissionCategoryArgsDict',
    'GetPermissionsMetadataArgs',
    'GetPermissionsMetadataArgsDict',
    'GetProjectCategoryArgs',
    'GetProjectCategoryArgsDict',
    'GetProjectExternalUserGroupReferenceListArgs',
    'GetProjectExternalUserGroupReferenceListArgsDict',
    'GetProjectSubnetReferenceListArgs',
    'GetProjectSubnetReferenceListArgsDict',
    'GetProjectUserReferenceListArgs',
    'GetProjectUserReferenceListArgsDict',
    'GetProtectionRuleCategoryArgs',
    'GetProtectionRuleCategoryArgsDict',
    'GetRecoveryPlanCategoryArgs',
    'GetRecoveryPlanCategoryArgsDict',
    'GetRoleCategoryArgs',
    'GetRoleCategoryArgsDict',
    'GetRolesMetadataArgs',
    'GetRolesMetadataArgsDict',
    'GetServiceGroupsMetadataArgs',
    'GetServiceGroupsMetadataArgsDict',
    'GetSubnetAdditionalFilterArgs',
    'GetSubnetAdditionalFilterArgsDict',
    'GetSubnetCategoryArgs',
    'GetSubnetCategoryArgsDict',
    'GetSubnetV2ReservedIpAddressArgs',
    'GetSubnetV2ReservedIpAddressArgsDict',
    'GetSubnetsMetadataArgs',
    'GetSubnetsMetadataArgsDict',
    'GetUserCategoryArgs',
    'GetUserCategoryArgsDict',
    'GetUserGroupCategoryArgs',
    'GetUserGroupCategoryArgsDict',
    'GetUserGroupsMetadataArgs',
    'GetUserGroupsMetadataArgsDict',
    'GetUsersMetadataArgs',
    'GetUsersMetadataArgsDict',
    'GetVirtualMachineCategoryArgs',
    'GetVirtualMachineCategoryArgsDict',
    'GetVmRecoveryPointInfoV2DiskRecoveryPointArgs',
    'GetVmRecoveryPointInfoV2DiskRecoveryPointArgsDict',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdArgs',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdArgsDict',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args',
    'GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict',
    'GetVpcsMetadataArgs',
    'GetVpcsMetadataArgsDict',
]

MYPY = False

if not MYPY:
    class AccessControlPolicyCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - value of the key.
        """
elif False:
    AccessControlPolicyCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        :param pulumi.Input[str] value: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AccessControlPolicyContextFilterListArgsDict(TypedDict):
        entity_filter_expression_lists: pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListArgsDict']]]
        """
        A list of Entity filter expressions.
        """
        scope_filter_expression_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListArgsDict']]]]
        """
        - (Optional) Filter the scope of an Access Control Policy.
        """
elif False:
    AccessControlPolicyContextFilterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListArgs:
    def __init__(__self__, *,
                 entity_filter_expression_lists: pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListArgs']]],
                 scope_filter_expression_lists: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListArgs']]] entity_filter_expression_lists: A list of Entity filter expressions.
        :param pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListArgs']]] scope_filter_expression_lists: - (Optional) Filter the scope of an Access Control Policy.
        """
        pulumi.set(__self__, "entity_filter_expression_lists", entity_filter_expression_lists)
        if scope_filter_expression_lists is not None:
            pulumi.set(__self__, "scope_filter_expression_lists", scope_filter_expression_lists)

    @property
    @pulumi.getter(name="entityFilterExpressionLists")
    def entity_filter_expression_lists(self) -> pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListArgs']]]:
        """
        A list of Entity filter expressions.
        """
        return pulumi.get(self, "entity_filter_expression_lists")

    @entity_filter_expression_lists.setter
    def entity_filter_expression_lists(self, value: pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListArgs']]]):
        pulumi.set(self, "entity_filter_expression_lists", value)

    @property
    @pulumi.getter(name="scopeFilterExpressionLists")
    def scope_filter_expression_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListArgs']]]]:
        """
        - (Optional) Filter the scope of an Access Control Policy.
        """
        return pulumi.get(self, "scope_filter_expression_lists")

    @scope_filter_expression_lists.setter
    def scope_filter_expression_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListArgs']]]]):
        pulumi.set(self, "scope_filter_expression_lists", value)


if not MYPY:
    class AccessControlPolicyContextFilterListEntityFilterExpressionListArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        - (Required) The operator in the filter expression.
        """
        right_hand_side: pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgsDict']
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        left_hand_side_entity_type: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  The LHS of the filter expression - the entity type.
        """
elif False:
    AccessControlPolicyContextFilterListEntityFilterExpressionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListEntityFilterExpressionListArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 right_hand_side: pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs'],
                 left_hand_side_entity_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: - (Required) The operator in the filter expression.
        :param pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs'] right_hand_side: - (Required) The right hand side (RHS) of an scope expression.
        :param pulumi.Input[str] left_hand_side_entity_type: - (Optional)  The LHS of the filter expression - the entity type.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "right_hand_side", right_hand_side)
        if left_hand_side_entity_type is not None:
            pulumi.set(__self__, "left_hand_side_entity_type", left_hand_side_entity_type)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        - (Required) The operator in the filter expression.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="rightHandSide")
    def right_hand_side(self) -> pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs']:
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        return pulumi.get(self, "right_hand_side")

    @right_hand_side.setter
    def right_hand_side(self, value: pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs']):
        pulumi.set(self, "right_hand_side", value)

    @property
    @pulumi.getter(name="leftHandSideEntityType")
    def left_hand_side_entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  The LHS of the filter expression - the entity type.
        """
        return pulumi.get(self, "left_hand_side_entity_type")

    @left_hand_side_entity_type.setter
    def left_hand_side_entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "left_hand_side_entity_type", value)


if not MYPY:
    class AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict']]
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        collection: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        uuid_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
elif False:
    AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']] = None,
                 collection: Optional[pulumi.Input[str]] = None,
                 uuid_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs'] categories: - (Optional) The category values represented as a dictionary of key > list of values.
        :param pulumi.Input[str] collection: - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uuid_lists: - (Optional) The explicit list of UUIDs for the given kind.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if uuid_lists is not None:
            pulumi.set(__self__, "uuid_lists", uuid_lists)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']]:
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input['AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="uuidLists")
    def uuid_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
        return pulumi.get(self, "uuid_lists")

    @uuid_lists.setter
    def uuid_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uuid_lists", value)


if not MYPY:
    class AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - value of the key.
        """
elif False:
    AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AccessControlPolicyContextFilterListScopeFilterExpressionListArgsDict(TypedDict):
        left_hand_side: pulumi.Input[str]
        """
        - (Optional)  The LHS of the filter expression - the scope type.
        """
        operator: pulumi.Input[str]
        """
        - (Required) The operator of the filter expression.
        """
        right_hand_side: pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgsDict']
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
elif False:
    AccessControlPolicyContextFilterListScopeFilterExpressionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListScopeFilterExpressionListArgs:
    def __init__(__self__, *,
                 left_hand_side: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 right_hand_side: pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs']):
        """
        :param pulumi.Input[str] left_hand_side: - (Optional)  The LHS of the filter expression - the scope type.
        :param pulumi.Input[str] operator: - (Required) The operator of the filter expression.
        :param pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs'] right_hand_side: - (Required) The right hand side (RHS) of an scope expression.
        """
        pulumi.set(__self__, "left_hand_side", left_hand_side)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "right_hand_side", right_hand_side)

    @property
    @pulumi.getter(name="leftHandSide")
    def left_hand_side(self) -> pulumi.Input[str]:
        """
        - (Optional)  The LHS of the filter expression - the scope type.
        """
        return pulumi.get(self, "left_hand_side")

    @left_hand_side.setter
    def left_hand_side(self, value: pulumi.Input[str]):
        pulumi.set(self, "left_hand_side", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        - (Required) The operator of the filter expression.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="rightHandSide")
    def right_hand_side(self) -> pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs']:
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        return pulumi.get(self, "right_hand_side")

    @right_hand_side.setter
    def right_hand_side(self, value: pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs']):
        pulumi.set(self, "right_hand_side", value)


if not MYPY:
    class AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict']]
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        collection: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        uuid_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
elif False:
    AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']] = None,
                 collection: Optional[pulumi.Input[str]] = None,
                 uuid_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs'] categories: - (Optional) The category values represented as a dictionary of key > list of values.
        :param pulumi.Input[str] collection: - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uuid_lists: - (Optional) The explicit list of UUIDs for the given kind.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if uuid_lists is not None:
            pulumi.set(__self__, "uuid_lists", uuid_lists)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']]:
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input['AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="uuidLists")
    def uuid_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
        return pulumi.get(self, "uuid_lists")

    @uuid_lists.setter
    def uuid_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uuid_lists", value)


if not MYPY:
    class AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - value of the key.
        """
elif False:
    AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class AccessControlPolicyOwnerReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    AccessControlPolicyOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyOwnerReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class AccessControlPolicyRoleReferenceArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        - The kind name (Default value: project)(Required).
        """
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
elif False:
    AccessControlPolicyRoleReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyRoleReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 uuid: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "uuid", uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessControlPolicyUserGroupReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
elif False:
    AccessControlPolicyUserGroupReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyUserGroupReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AccessControlPolicyUserReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the Access Control Policy.
        """
elif False:
    AccessControlPolicyUserReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccessControlPolicyUserReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the Access Control Policy.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the Access Control Policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AddressGroupIpAddressBlockListArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        - (Required) IP of the address block
        """
        prefix_length: pulumi.Input[int]
        """
        - (Required) Prefix length of address block in int

        See detailed information in [Nutanix Address Groups](https://www.nutanix.dev/api_references/prism-central-v3/#/5ccef53a546a4-create-a-new-address-group).
        """
elif False:
    AddressGroupIpAddressBlockListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupIpAddressBlockListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 prefix_length: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: - (Required) IP of the address block
        :param pulumi.Input[int] prefix_length: - (Required) Prefix length of address block in int
               
               See detailed information in [Nutanix Address Groups](https://www.nutanix.dev/api_references/prism-central-v3/#/5ccef53a546a4-create-a-new-address-group).
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        - (Required) IP of the address block
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        - (Required) Prefix length of address block in int

        See detailed information in [Nutanix Address Groups](https://www.nutanix.dev/api_references/prism-central-v3/#/5ccef53a546a4-create-a-new-address-group).
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class AddressGroupsV2IpRangeArgsDict(TypedDict):
        end_ip: NotRequired[pulumi.Input[str]]
        start_ip: NotRequired[pulumi.Input[str]]
elif False:
    AddressGroupsV2IpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupsV2IpRangeArgs:
    def __init__(__self__, *,
                 end_ip: Optional[pulumi.Input[str]] = None,
                 start_ip: Optional[pulumi.Input[str]] = None):
        if end_ip is not None:
            pulumi.set(__self__, "end_ip", end_ip)
        if start_ip is not None:
            pulumi.set(__self__, "start_ip", start_ip)

    @property
    @pulumi.getter(name="endIp")
    def end_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "end_ip")

    @end_ip.setter
    def end_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_ip", value)

    @property
    @pulumi.getter(name="startIp")
    def start_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_ip")

    @start_ip.setter
    def start_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_ip", value)


if not MYPY:
    class AddressGroupsV2Ipv4AddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    AddressGroupsV2Ipv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupsV2Ipv4AddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AddressGroupsV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    AddressGroupsV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupsV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class AuthorizationPolicyV2EntityArgsDict(TypedDict):
        reserved: NotRequired[pulumi.Input[str]]
elif False:
    AuthorizationPolicyV2EntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyV2EntityArgs:
    def __init__(__self__, *,
                 reserved: Optional[pulumi.Input[str]] = None):
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reserved", value)


if not MYPY:
    class AuthorizationPolicyV2IdentityArgsDict(TypedDict):
        reserved: NotRequired[pulumi.Input[str]]
elif False:
    AuthorizationPolicyV2IdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyV2IdentityArgs:
    def __init__(__self__, *,
                 reserved: Optional[pulumi.Input[str]] = None):
        if reserved is not None:
            pulumi.set(__self__, "reserved", reserved)

    @property
    @pulumi.getter
    def reserved(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reserved")

    @reserved.setter
    def reserved(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reserved", value)


if not MYPY:
    class CategoryV2AssociationArgsDict(TypedDict):
        category_id: NotRequired[pulumi.Input[str]]
        """
        External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        """
        count: NotRequired[pulumi.Input[str]]
        """
        Count of associations of a particular type of entity or policy
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        An enum denoting the resource group.
        Resources can be organized into either an entity or a policy.
        Valid values are:
        - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
        - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
        Valid values are:
        - `APP`:  A resource of type application.
        - `PROTECTION_RULE`:  A policy or rule of type protection rule.
        - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
        - `MH_VM`: A resource of type Virtual Machine.
        - `BLUEPRINT`:  A resource of type blueprint.
        - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
        - `IMAGE`:  A resource of type image.
        - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
        - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
        - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
        - `NGT_POLICY`:  A policy or rule of type NGT policy.
        - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
        - `MARKETPLACE_ITEM`: A resource of type marketplace item.
        - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
        - `NETWORK_SECURITY_RULE`:  A rule of type network security.
        - `HOST_NIC`:  A resource of type Physical NIC.
        - `ACTION_RULE`:  A policy of type Playbook.
        - `VOLUMEGROUP`:  A resource of type volume group.
        - `REPORT`:  A resource of type report.
        - `STORAGE_POLICY`: A policy or rule of type storage policy.
        - `BUNDLE`:  A resource of type bundle.
        - `QOS_POLICY`: A policy or rule of type QoS policy.
        - `SUBNET`:  A resource of type network subnets.
        - `VM`: A resource of type Virtual Machine.
        - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
        - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
        - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
elif False:
    CategoryV2AssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CategoryV2AssociationArgs:
    def __init__(__self__, *,
                 category_id: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category_id: External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        :param pulumi.Input[str] count: Count of associations of a particular type of entity or policy
        :param pulumi.Input[str] resource_group: An enum denoting the resource group.
               Resources can be organized into either an entity or a policy.
               Valid values are:
               - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
               - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        :param pulumi.Input[str] resource_type: An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
               Valid values are:
               - `APP`:  A resource of type application.
               - `PROTECTION_RULE`:  A policy or rule of type protection rule.
               - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
               - `MH_VM`: A resource of type Virtual Machine.
               - `BLUEPRINT`:  A resource of type blueprint.
               - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
               - `IMAGE`:  A resource of type image.
               - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
               - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
               - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
               - `NGT_POLICY`:  A policy or rule of type NGT policy.
               - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
               - `MARKETPLACE_ITEM`: A resource of type marketplace item.
               - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
               - `NETWORK_SECURITY_RULE`:  A rule of type network security.
               - `HOST_NIC`:  A resource of type Physical NIC.
               - `ACTION_RULE`:  A policy of type Playbook.
               - `VOLUMEGROUP`:  A resource of type volume group.
               - `REPORT`:  A resource of type report.
               - `STORAGE_POLICY`: A policy or rule of type storage policy.
               - `BUNDLE`:  A resource of type bundle.
               - `QOS_POLICY`: A policy or rule of type QoS policy.
               - `SUBNET`:  A resource of type network subnets.
               - `VM`: A resource of type Virtual Machine.
               - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
               - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
               - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
        if category_id is not None:
            pulumi.set(__self__, "category_id", category_id)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="categoryId")
    def category_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        """
        return pulumi.get(self, "category_id")

    @category_id.setter
    def category_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category_id", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        Count of associations of a particular type of entity or policy
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        An enum denoting the resource group.
        Resources can be organized into either an entity or a policy.
        Valid values are:
        - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
        - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
        Valid values are:
        - `APP`:  A resource of type application.
        - `PROTECTION_RULE`:  A policy or rule of type protection rule.
        - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
        - `MH_VM`: A resource of type Virtual Machine.
        - `BLUEPRINT`:  A resource of type blueprint.
        - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
        - `IMAGE`:  A resource of type image.
        - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
        - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
        - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
        - `NGT_POLICY`:  A policy or rule of type NGT policy.
        - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
        - `MARKETPLACE_ITEM`: A resource of type marketplace item.
        - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
        - `NETWORK_SECURITY_RULE`:  A rule of type network security.
        - `HOST_NIC`:  A resource of type Physical NIC.
        - `ACTION_RULE`:  A policy of type Playbook.
        - `VOLUMEGROUP`:  A resource of type volume group.
        - `REPORT`:  A resource of type report.
        - `STORAGE_POLICY`: A policy or rule of type storage policy.
        - `BUNDLE`:  A resource of type bundle.
        - `QOS_POLICY`: A policy or rule of type QoS policy.
        - `SUBNET`:  A resource of type network subnets.
        - `VM`: A resource of type Virtual Machine.
        - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
        - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
        - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class CategoryV2DetailedAssociationArgsDict(TypedDict):
        category_id: NotRequired[pulumi.Input[str]]
        """
        External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        An enum denoting the resource group.
        Resources can be organized into either an entity or a policy.
        Valid values are:
        - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
        - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        """
        resource_id: NotRequired[pulumi.Input[str]]
        """
        The UUID of the entity or policy associated with the particular category.
        """
        resource_type: NotRequired[pulumi.Input[str]]
        """
        An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
        Valid values are:
        - `APP`:  A resource of type application.
        - `PROTECTION_RULE`:  A policy or rule of type protection rule.
        - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
        - `MH_VM`: A resource of type Virtual Machine.
        - `BLUEPRINT`:  A resource of type blueprint.
        - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
        - `IMAGE`:  A resource of type image.
        - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
        - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
        - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
        - `NGT_POLICY`:  A policy or rule of type NGT policy.
        - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
        - `MARKETPLACE_ITEM`: A resource of type marketplace item.
        - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
        - `NETWORK_SECURITY_RULE`:  A rule of type network security.
        - `HOST_NIC`:  A resource of type Physical NIC.
        - `ACTION_RULE`:  A policy of type Playbook.
        - `VOLUMEGROUP`:  A resource of type volume group.
        - `REPORT`:  A resource of type report.
        - `STORAGE_POLICY`: A policy or rule of type storage policy.
        - `BUNDLE`:  A resource of type bundle.
        - `QOS_POLICY`: A policy or rule of type QoS policy.
        - `SUBNET`:  A resource of type network subnets.
        - `VM`: A resource of type Virtual Machine.
        - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
        - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
        - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
elif False:
    CategoryV2DetailedAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CategoryV2DetailedAssociationArgs:
    def __init__(__self__, *,
                 category_id: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category_id: External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        :param pulumi.Input[str] resource_group: An enum denoting the resource group.
               Resources can be organized into either an entity or a policy.
               Valid values are:
               - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
               - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        :param pulumi.Input[str] resource_id: The UUID of the entity or policy associated with the particular category.
        :param pulumi.Input[str] resource_type: An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
               Valid values are:
               - `APP`:  A resource of type application.
               - `PROTECTION_RULE`:  A policy or rule of type protection rule.
               - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
               - `MH_VM`: A resource of type Virtual Machine.
               - `BLUEPRINT`:  A resource of type blueprint.
               - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
               - `IMAGE`:  A resource of type image.
               - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
               - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
               - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
               - `NGT_POLICY`:  A policy or rule of type NGT policy.
               - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
               - `MARKETPLACE_ITEM`: A resource of type marketplace item.
               - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
               - `NETWORK_SECURITY_RULE`:  A rule of type network security.
               - `HOST_NIC`:  A resource of type Physical NIC.
               - `ACTION_RULE`:  A policy of type Playbook.
               - `VOLUMEGROUP`:  A resource of type volume group.
               - `REPORT`:  A resource of type report.
               - `STORAGE_POLICY`: A policy or rule of type storage policy.
               - `BUNDLE`:  A resource of type bundle.
               - `QOS_POLICY`: A policy or rule of type QoS policy.
               - `SUBNET`:  A resource of type network subnets.
               - `VM`: A resource of type Virtual Machine.
               - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
               - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
               - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
        if category_id is not None:
            pulumi.set(__self__, "category_id", category_id)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="categoryId")
    def category_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier for the given category, used across all v4 apis/entities/resources where categories are referenced.
        """
        return pulumi.get(self, "category_id")

    @category_id.setter
    def category_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category_id", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        An enum denoting the resource group.
        Resources can be organized into either an entity or a policy.
        Valid values are:
        - `POLICY`:  A ResourceGroup denoting a nutanix policy like VM host affinity policy, image placement policy, access control policy, and so on.<br> A category is generally associated with many entities.<br> The policy which is associated with this category, is then applied to those entities which are also associated with the same category.
        - `ENTITY`: A ResourceGroup denoting a nutanix entity like VM, cluster, host, image, and so on.<br> A category is generally associated with many entities.<br> A policy is then applied to these entities through the category.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the entity or policy associated with the particular category.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        An enum denoting the associated resource types. Resource types are further grouped into 2 types - entity or a policy.
        Valid values are:
        - `APP`:  A resource of type application.
        - `PROTECTION_RULE`:  A policy or rule of type protection rule.
        - `IMAGE_RATE_LIMIT`: A resource of type rate limit.
        - `MH_VM`: A resource of type Virtual Machine.
        - `BLUEPRINT`:  A resource of type blueprint.
        - `HOST`:  A resource representing the underlying host, the machine hosting the hypervisors and VMs.
        - `IMAGE`:  A resource of type image.
        - `VM_VM_ANTI_AFFINITY_POLICY`:  A policy of type VM-VM anti-affinity; This policy decides that the specified set of VMs are running on different hosts.
        - `ACCESS_CONTROL_POLICY`: A policy or rule of type access control policy or ACP; the rules that decide authorization of users to access an API.
        - `VM_HOST_AFFINITY_POLICY`: A policy of type VM host affinity; The policy decides the affinity between a set of VMs to be run only a specified set of hosts
        - `NGT_POLICY`:  A policy or rule of type NGT policy.
        - `RECOVERY_PLAN`:  A policy or rule of type recovery plan.
        - `MARKETPLACE_ITEM`: A resource of type marketplace item.
        - `CLUSTER`:  A resource of type cluster, usually refers to a PE cluster.
        - `NETWORK_SECURITY_RULE`:  A rule of type network security.
        - `HOST_NIC`:  A resource of type Physical NIC.
        - `ACTION_RULE`:  A policy of type Playbook.
        - `VOLUMEGROUP`:  A resource of type volume group.
        - `REPORT`:  A resource of type report.
        - `STORAGE_POLICY`: A policy or rule of type storage policy.
        - `BUNDLE`:  A resource of type bundle.
        - `QOS_POLICY`: A policy or rule of type QoS policy.
        - `SUBNET`:  A resource of type network subnets.
        - `VM`: A resource of type Virtual Machine.
        - `NETWORK_SECURITY_POLICY`:  A policy of type network security.
        - `POLICY_SCHEMA`:  Policies like user-defined-alerts.
        - `IMAGE_PLACEMENT_POLICY`:  A policy of type image placement.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class ClusterAddNodeV2ConfigParamArgsDict(TypedDict):
        hipervs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervArgsDict']]]]
        """
        -(Optional) HyperV Credentials.
        """
        is_compute_only: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates whether the node is compute only or not.
        """
        is_never_schedulable: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates whether the node is marked to be never schedulable or not.
        """
        is_nos_compatible: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if node is compatible or not.
        """
        should_skip_discovery: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if node discovery need to be skipped or not.
        """
        should_skip_imaging: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if node imaging needs to be skipped or not.
        """
        should_validate_rack_awareness: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if rack awareness needs to be validated or not.
        """
        target_hypervisor: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Target hypervisor.
        """
elif False:
    ClusterAddNodeV2ConfigParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2ConfigParamArgs:
    def __init__(__self__, *,
                 hipervs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervArgs']]]] = None,
                 is_compute_only: Optional[pulumi.Input[bool]] = None,
                 is_never_schedulable: Optional[pulumi.Input[bool]] = None,
                 is_nos_compatible: Optional[pulumi.Input[bool]] = None,
                 should_skip_discovery: Optional[pulumi.Input[bool]] = None,
                 should_skip_imaging: Optional[pulumi.Input[bool]] = None,
                 should_validate_rack_awareness: Optional[pulumi.Input[bool]] = None,
                 target_hypervisor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervArgs']]] hipervs: -(Optional) HyperV Credentials.
        :param pulumi.Input[bool] is_compute_only: -(Optional) Indicates whether the node is compute only or not.
        :param pulumi.Input[bool] is_never_schedulable: -(Optional) Indicates whether the node is marked to be never schedulable or not.
        :param pulumi.Input[bool] is_nos_compatible: -(Optional) Indicates if node is compatible or not.
        :param pulumi.Input[bool] should_skip_discovery: -(Optional) Indicates if node discovery need to be skipped or not.
        :param pulumi.Input[bool] should_skip_imaging: -(Optional) Indicates if node imaging needs to be skipped or not.
        :param pulumi.Input[bool] should_validate_rack_awareness: -(Optional) Indicates if rack awareness needs to be validated or not.
        :param pulumi.Input[str] target_hypervisor: -(Optional) Target hypervisor.
        """
        if hipervs is not None:
            pulumi.set(__self__, "hipervs", hipervs)
        if is_compute_only is not None:
            pulumi.set(__self__, "is_compute_only", is_compute_only)
        if is_never_schedulable is not None:
            pulumi.set(__self__, "is_never_schedulable", is_never_schedulable)
        if is_nos_compatible is not None:
            pulumi.set(__self__, "is_nos_compatible", is_nos_compatible)
        if should_skip_discovery is not None:
            pulumi.set(__self__, "should_skip_discovery", should_skip_discovery)
        if should_skip_imaging is not None:
            pulumi.set(__self__, "should_skip_imaging", should_skip_imaging)
        if should_validate_rack_awareness is not None:
            pulumi.set(__self__, "should_validate_rack_awareness", should_validate_rack_awareness)
        if target_hypervisor is not None:
            pulumi.set(__self__, "target_hypervisor", target_hypervisor)

    @property
    @pulumi.getter
    def hipervs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervArgs']]]]:
        """
        -(Optional) HyperV Credentials.
        """
        return pulumi.get(self, "hipervs")

    @hipervs.setter
    def hipervs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervArgs']]]]):
        pulumi.set(self, "hipervs", value)

    @property
    @pulumi.getter(name="isComputeOnly")
    def is_compute_only(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates whether the node is compute only or not.
        """
        return pulumi.get(self, "is_compute_only")

    @is_compute_only.setter
    def is_compute_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_compute_only", value)

    @property
    @pulumi.getter(name="isNeverSchedulable")
    def is_never_schedulable(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates whether the node is marked to be never schedulable or not.
        """
        return pulumi.get(self, "is_never_schedulable")

    @is_never_schedulable.setter
    def is_never_schedulable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_never_schedulable", value)

    @property
    @pulumi.getter(name="isNosCompatible")
    def is_nos_compatible(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if node is compatible or not.
        """
        return pulumi.get(self, "is_nos_compatible")

    @is_nos_compatible.setter
    def is_nos_compatible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nos_compatible", value)

    @property
    @pulumi.getter(name="shouldSkipDiscovery")
    def should_skip_discovery(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if node discovery need to be skipped or not.
        """
        return pulumi.get(self, "should_skip_discovery")

    @should_skip_discovery.setter
    def should_skip_discovery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_discovery", value)

    @property
    @pulumi.getter(name="shouldSkipImaging")
    def should_skip_imaging(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if node imaging needs to be skipped or not.
        """
        return pulumi.get(self, "should_skip_imaging")

    @should_skip_imaging.setter
    def should_skip_imaging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_imaging", value)

    @property
    @pulumi.getter(name="shouldValidateRackAwareness")
    def should_validate_rack_awareness(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if rack awareness needs to be validated or not.
        """
        return pulumi.get(self, "should_validate_rack_awareness")

    @should_validate_rack_awareness.setter
    def should_validate_rack_awareness(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_validate_rack_awareness", value)

    @property
    @pulumi.getter(name="targetHypervisor")
    def target_hypervisor(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Target hypervisor.
        """
        return pulumi.get(self, "target_hypervisor")

    @target_hypervisor.setter
    def target_hypervisor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_hypervisor", value)


if not MYPY:
    class ClusterAddNodeV2ConfigParamHipervArgsDict(TypedDict):
        domain_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervDomainDetailArgsDict']]]]
        """
        -(Optional) UserName and Password model.
        """
        failover_cluster_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgsDict']]]]
        """
        -(Optional) UserName and Password model.
        """
elif False:
    ClusterAddNodeV2ConfigParamHipervArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2ConfigParamHipervArgs:
    def __init__(__self__, *,
                 domain_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervDomainDetailArgs']]]] = None,
                 failover_cluster_details: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervDomainDetailArgs']]] domain_details: -(Optional) UserName and Password model.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs']]] failover_cluster_details: -(Optional) UserName and Password model.
        """
        if domain_details is not None:
            pulumi.set(__self__, "domain_details", domain_details)
        if failover_cluster_details is not None:
            pulumi.set(__self__, "failover_cluster_details", failover_cluster_details)

    @property
    @pulumi.getter(name="domainDetails")
    def domain_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervDomainDetailArgs']]]]:
        """
        -(Optional) UserName and Password model.
        """
        return pulumi.get(self, "domain_details")

    @domain_details.setter
    def domain_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervDomainDetailArgs']]]]):
        pulumi.set(self, "domain_details", value)

    @property
    @pulumi.getter(name="failoverClusterDetails")
    def failover_cluster_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs']]]]:
        """
        -(Optional) UserName and Password model.
        """
        return pulumi.get(self, "failover_cluster_details")

    @failover_cluster_details.setter
    def failover_cluster_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs']]]]):
        pulumi.set(self, "failover_cluster_details", value)


if not MYPY:
    class ClusterAddNodeV2ConfigParamHipervDomainDetailArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Password.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Username.
        """
elif False:
    ClusterAddNodeV2ConfigParamHipervDomainDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2ConfigParamHipervDomainDetailArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        :param pulumi.Input[str] password: -(Optional) Password.
        :param pulumi.Input[str] username: -(Optional) Username.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Password.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Username.
        """
elif False:
    ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2ConfigParamHipervFailoverClusterDetailArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        :param pulumi.Input[str] password: -(Optional) Password.
        :param pulumi.Input[str] username: -(Optional) Username.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Cluster name. This is part of payload for both cluster create & update operations.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamArgsDict(TypedDict):
        node_lists: pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListArgsDict']]]
        """
        -(Required) List of nodes in a cluster.
        """
        block_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBlockListArgsDict']]]]
        """
        -(Optional) Block list of a cluster.
        """
        bundle_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBundleInfoArgsDict']]]]
        """
        -(Optional) Hypervisor bundle information.
        """
        compute_node_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListArgsDict']]]]
        hyperv_sku: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Hyperv SKU.
        """
        hypervisor_isos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamHypervisorIsoArgsDict']]]]
        """
        -(Optional) Hypervisor type to md5sum map.
        """
        should_skip_host_networking: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if the host networking needs to be skipped or not.
        """
elif False:
    ClusterAddNodeV2NodeParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamArgs:
    def __init__(__self__, *,
                 node_lists: pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListArgs']]],
                 block_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBlockListArgs']]]] = None,
                 bundle_infos: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBundleInfoArgs']]]] = None,
                 compute_node_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListArgs']]]] = None,
                 hyperv_sku: Optional[pulumi.Input[str]] = None,
                 hypervisor_isos: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamHypervisorIsoArgs']]]] = None,
                 should_skip_host_networking: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListArgs']]] node_lists: -(Required) List of nodes in a cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBlockListArgs']]] block_lists: -(Optional) Block list of a cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBundleInfoArgs']]] bundle_infos: -(Optional) Hypervisor bundle information.
        :param pulumi.Input[str] hyperv_sku: -(Optional) Hyperv SKU.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamHypervisorIsoArgs']]] hypervisor_isos: -(Optional) Hypervisor type to md5sum map.
        :param pulumi.Input[bool] should_skip_host_networking: -(Optional) Indicates if the host networking needs to be skipped or not.
        """
        pulumi.set(__self__, "node_lists", node_lists)
        if block_lists is not None:
            pulumi.set(__self__, "block_lists", block_lists)
        if bundle_infos is not None:
            pulumi.set(__self__, "bundle_infos", bundle_infos)
        if compute_node_lists is not None:
            pulumi.set(__self__, "compute_node_lists", compute_node_lists)
        if hyperv_sku is not None:
            pulumi.set(__self__, "hyperv_sku", hyperv_sku)
        if hypervisor_isos is not None:
            pulumi.set(__self__, "hypervisor_isos", hypervisor_isos)
        if should_skip_host_networking is not None:
            pulumi.set(__self__, "should_skip_host_networking", should_skip_host_networking)

    @property
    @pulumi.getter(name="nodeLists")
    def node_lists(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListArgs']]]:
        """
        -(Required) List of nodes in a cluster.
        """
        return pulumi.get(self, "node_lists")

    @node_lists.setter
    def node_lists(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListArgs']]]):
        pulumi.set(self, "node_lists", value)

    @property
    @pulumi.getter(name="blockLists")
    def block_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBlockListArgs']]]]:
        """
        -(Optional) Block list of a cluster.
        """
        return pulumi.get(self, "block_lists")

    @block_lists.setter
    def block_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBlockListArgs']]]]):
        pulumi.set(self, "block_lists", value)

    @property
    @pulumi.getter(name="bundleInfos")
    def bundle_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBundleInfoArgs']]]]:
        """
        -(Optional) Hypervisor bundle information.
        """
        return pulumi.get(self, "bundle_infos")

    @bundle_infos.setter
    def bundle_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamBundleInfoArgs']]]]):
        pulumi.set(self, "bundle_infos", value)

    @property
    @pulumi.getter(name="computeNodeLists")
    def compute_node_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListArgs']]]]:
        return pulumi.get(self, "compute_node_lists")

    @compute_node_lists.setter
    def compute_node_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListArgs']]]]):
        pulumi.set(self, "compute_node_lists", value)

    @property
    @pulumi.getter(name="hypervSku")
    def hyperv_sku(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Hyperv SKU.
        """
        return pulumi.get(self, "hyperv_sku")

    @hyperv_sku.setter
    def hyperv_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hyperv_sku", value)

    @property
    @pulumi.getter(name="hypervisorIsos")
    def hypervisor_isos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamHypervisorIsoArgs']]]]:
        """
        -(Optional) Hypervisor type to md5sum map.
        """
        return pulumi.get(self, "hypervisor_isos")

    @hypervisor_isos.setter
    def hypervisor_isos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamHypervisorIsoArgs']]]]):
        pulumi.set(self, "hypervisor_isos", value)

    @property
    @pulumi.getter(name="shouldSkipHostNetworking")
    def should_skip_host_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if the host networking needs to be skipped or not.
        """
        return pulumi.get(self, "should_skip_host_networking")

    @should_skip_host_networking.setter
    def should_skip_host_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_host_networking", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamBlockListArgsDict(TypedDict):
        block_id: NotRequired[pulumi.Input[str]]
        """
        -(Required) List of nodes in a block.
        """
        rack_name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Indicates if the host networking needs to be skipped or not.
        """
elif False:
    ClusterAddNodeV2NodeParamBlockListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamBlockListArgs:
    def __init__(__self__, *,
                 block_id: Optional[pulumi.Input[str]] = None,
                 rack_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_id: -(Required) List of nodes in a block.
        :param pulumi.Input[str] rack_name: -(Optional) Indicates if the host networking needs to be skipped or not.
        """
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)
        if rack_name is not None:
            pulumi.set(__self__, "rack_name", rack_name)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        """
        -(Required) List of nodes in a block.
        """
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)

    @property
    @pulumi.getter(name="rackName")
    def rack_name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Indicates if the host networking needs to be skipped or not.
        """
        return pulumi.get(self, "rack_name")

    @rack_name.setter
    def rack_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rack_name", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamBundleInfoArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Name of the hypervisor bundle.
        """
elif False:
    ClusterAddNodeV2NodeParamBundleInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamBundleInfoArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: -(Optional) Name of the hypervisor bundle.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Name of the hypervisor bundle.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListArgsDict(TypedDict):
        block_id: NotRequired[pulumi.Input[str]]
        digital_certificate_map_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgsDict']]]]
        hypervisor_hostname: NotRequired[pulumi.Input[str]]
        hypervisor_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgsDict']]]]
        ipmi_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgsDict']]]]
        model: NotRequired[pulumi.Input[str]]
        node_position: NotRequired[pulumi.Input[str]]
        node_uuid: NotRequired[pulumi.Input[str]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListArgs:
    def __init__(__self__, *,
                 block_id: Optional[pulumi.Input[str]] = None,
                 digital_certificate_map_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgs']]]] = None,
                 hypervisor_hostname: Optional[pulumi.Input[str]] = None,
                 hypervisor_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgs']]]] = None,
                 ipmi_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgs']]]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 node_position: Optional[pulumi.Input[str]] = None,
                 node_uuid: Optional[pulumi.Input[str]] = None):
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)
        if digital_certificate_map_lists is not None:
            pulumi.set(__self__, "digital_certificate_map_lists", digital_certificate_map_lists)
        if hypervisor_hostname is not None:
            pulumi.set(__self__, "hypervisor_hostname", hypervisor_hostname)
        if hypervisor_ips is not None:
            pulumi.set(__self__, "hypervisor_ips", hypervisor_ips)
        if ipmi_ips is not None:
            pulumi.set(__self__, "ipmi_ips", ipmi_ips)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if node_position is not None:
            pulumi.set(__self__, "node_position", node_position)
        if node_uuid is not None:
            pulumi.set(__self__, "node_uuid", node_uuid)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)

    @property
    @pulumi.getter(name="digitalCertificateMapLists")
    def digital_certificate_map_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgs']]]]:
        return pulumi.get(self, "digital_certificate_map_lists")

    @digital_certificate_map_lists.setter
    def digital_certificate_map_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgs']]]]):
        pulumi.set(self, "digital_certificate_map_lists", value)

    @property
    @pulumi.getter(name="hypervisorHostname")
    def hypervisor_hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hypervisor_hostname")

    @hypervisor_hostname.setter
    def hypervisor_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_hostname", value)

    @property
    @pulumi.getter(name="hypervisorIps")
    def hypervisor_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgs']]]]:
        return pulumi.get(self, "hypervisor_ips")

    @hypervisor_ips.setter
    def hypervisor_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgs']]]]):
        pulumi.set(self, "hypervisor_ips", value)

    @property
    @pulumi.getter(name="ipmiIps")
    def ipmi_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgs']]]]:
        return pulumi.get(self, "ipmi_ips")

    @ipmi_ips.setter
    def ipmi_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgs']]]]):
        pulumi.set(self, "ipmi_ips", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="nodeUuid")
    def node_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_uuid")

    @node_uuid.setter
    def node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_uuid", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListDigitalCertificateMapListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListHypervisorIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamComputeNodeListIpmiIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamHypervisorIsoArgsDict(TypedDict):
        md5_sum: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Hypervisor type.
        Valid values are:
        - `XEN`: Xen hypervisor.
        - `HYPERV`: Hyper-V hypervisor.
        - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
        - `ESX`: ESX hypervisor.
        - `AHV`: AHV hypervisor.
        """
elif False:
    ClusterAddNodeV2NodeParamHypervisorIsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamHypervisorIsoArgs:
    def __init__(__self__, *,
                 md5_sum: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: -(Optional) Hypervisor type.
               Valid values are:
               - `XEN`: Xen hypervisor.
               - `HYPERV`: Hyper-V hypervisor.
               - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
               - `ESX`: ESX hypervisor.
               - `AHV`: AHV hypervisor.
        """
        if md5_sum is not None:
            pulumi.set(__self__, "md5_sum", md5_sum)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="md5Sum")
    def md5_sum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "md5_sum")

    @md5_sum.setter
    def md5_sum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "md5_sum", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Hypervisor type.
        Valid values are:
        - `XEN`: Xen hypervisor.
        - `HYPERV`: Hyper-V hypervisor.
        - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
        - `ESX`: ESX hypervisor.
        - `AHV`: AHV hypervisor.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListArgsDict(TypedDict):
        block_id: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Block ID.
        """
        current_network_interface: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Current network interface of a node.
        """
        cvm_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        digital_certificate_map_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgsDict']]]]
        """
        -(Optional) List of objects containing digital_certificate_base64 and key_management_server_uuid fields for key management server.
        """
        hypervisor_hostname: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Name of the host.
        """
        hypervisor_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Hypervisor type.
        Valid values are:
        - `XEN`: Xen hypervisor.
        - `HYPERV`: Hyper-V hypervisor.
        - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
        - `ESX`: ESX hypervisor.
        - `AHV`: AHV hypervisor.
        """
        hypervisor_version: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Host version of the node.
        """
        ipmi_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        is_light_compute: NotRequired[pulumi.Input[bool]]
        is_robo_mixed_hypervisor: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Is ROBO mixed hypervisor.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Rackable unit model name.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkArgsDict']]]]
        """
        -(Optional) Active and standby uplink information of the target nodes.
        """
        node_position: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Node position.
        """
        node_uuid: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Node UUID.
        """
        nos_version: NotRequired[pulumi.Input[str]]
        """
        -(Optional) NOS software version of a node.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListArgs:
    def __init__(__self__, *,
                 block_id: Optional[pulumi.Input[str]] = None,
                 current_network_interface: Optional[pulumi.Input[str]] = None,
                 cvm_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpArgs']]]] = None,
                 digital_certificate_map_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs']]]] = None,
                 hypervisor_hostname: Optional[pulumi.Input[str]] = None,
                 hypervisor_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs']]]] = None,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 hypervisor_version: Optional[pulumi.Input[str]] = None,
                 ipmi_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpArgs']]]] = None,
                 is_light_compute: Optional[pulumi.Input[bool]] = None,
                 is_robo_mixed_hypervisor: Optional[pulumi.Input[bool]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkArgs']]]] = None,
                 node_position: Optional[pulumi.Input[str]] = None,
                 node_uuid: Optional[pulumi.Input[str]] = None,
                 nos_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_id: -(Optional) Block ID.
        :param pulumi.Input[str] current_network_interface: -(Optional) Current network interface of a node.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpArgs']]] cvm_ips: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs']]] digital_certificate_map_lists: -(Optional) List of objects containing digital_certificate_base64 and key_management_server_uuid fields for key management server.
        :param pulumi.Input[str] hypervisor_hostname: -(Optional) Name of the host.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs']]] hypervisor_ips: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[str] hypervisor_type: -(Optional) Hypervisor type.
               Valid values are:
               - `XEN`: Xen hypervisor.
               - `HYPERV`: Hyper-V hypervisor.
               - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
               - `ESX`: ESX hypervisor.
               - `AHV`: AHV hypervisor.
        :param pulumi.Input[str] hypervisor_version: -(Optional) Host version of the node.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpArgs']]] ipmi_ips: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[bool] is_robo_mixed_hypervisor: -(Optional) Is ROBO mixed hypervisor.
        :param pulumi.Input[str] model: -(Optional) Rackable unit model name.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkArgs']]] networks: -(Optional) Active and standby uplink information of the target nodes.
        :param pulumi.Input[str] node_position: -(Optional) Node position.
        :param pulumi.Input[str] node_uuid: -(Optional) Node UUID.
        :param pulumi.Input[str] nos_version: -(Optional) NOS software version of a node.
        """
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)
        if current_network_interface is not None:
            pulumi.set(__self__, "current_network_interface", current_network_interface)
        if cvm_ips is not None:
            pulumi.set(__self__, "cvm_ips", cvm_ips)
        if digital_certificate_map_lists is not None:
            pulumi.set(__self__, "digital_certificate_map_lists", digital_certificate_map_lists)
        if hypervisor_hostname is not None:
            pulumi.set(__self__, "hypervisor_hostname", hypervisor_hostname)
        if hypervisor_ips is not None:
            pulumi.set(__self__, "hypervisor_ips", hypervisor_ips)
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if hypervisor_version is not None:
            pulumi.set(__self__, "hypervisor_version", hypervisor_version)
        if ipmi_ips is not None:
            pulumi.set(__self__, "ipmi_ips", ipmi_ips)
        if is_light_compute is not None:
            pulumi.set(__self__, "is_light_compute", is_light_compute)
        if is_robo_mixed_hypervisor is not None:
            pulumi.set(__self__, "is_robo_mixed_hypervisor", is_robo_mixed_hypervisor)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if node_position is not None:
            pulumi.set(__self__, "node_position", node_position)
        if node_uuid is not None:
            pulumi.set(__self__, "node_uuid", node_uuid)
        if nos_version is not None:
            pulumi.set(__self__, "nos_version", nos_version)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Block ID.
        """
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)

    @property
    @pulumi.getter(name="currentNetworkInterface")
    def current_network_interface(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Current network interface of a node.
        """
        return pulumi.get(self, "current_network_interface")

    @current_network_interface.setter
    def current_network_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_network_interface", value)

    @property
    @pulumi.getter(name="cvmIps")
    def cvm_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpArgs']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "cvm_ips")

    @cvm_ips.setter
    def cvm_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpArgs']]]]):
        pulumi.set(self, "cvm_ips", value)

    @property
    @pulumi.getter(name="digitalCertificateMapLists")
    def digital_certificate_map_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs']]]]:
        """
        -(Optional) List of objects containing digital_certificate_base64 and key_management_server_uuid fields for key management server.
        """
        return pulumi.get(self, "digital_certificate_map_lists")

    @digital_certificate_map_lists.setter
    def digital_certificate_map_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs']]]]):
        pulumi.set(self, "digital_certificate_map_lists", value)

    @property
    @pulumi.getter(name="hypervisorHostname")
    def hypervisor_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Name of the host.
        """
        return pulumi.get(self, "hypervisor_hostname")

    @hypervisor_hostname.setter
    def hypervisor_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_hostname", value)

    @property
    @pulumi.getter(name="hypervisorIps")
    def hypervisor_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "hypervisor_ips")

    @hypervisor_ips.setter
    def hypervisor_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs']]]]):
        pulumi.set(self, "hypervisor_ips", value)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Hypervisor type.
        Valid values are:
        - `XEN`: Xen hypervisor.
        - `HYPERV`: Hyper-V hypervisor.
        - `NATIVEHOST`: NativeHost type where AOS runs natively, without hypervisor.
        - `ESX`: ESX hypervisor.
        - `AHV`: AHV hypervisor.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter(name="hypervisorVersion")
    def hypervisor_version(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Host version of the node.
        """
        return pulumi.get(self, "hypervisor_version")

    @hypervisor_version.setter
    def hypervisor_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_version", value)

    @property
    @pulumi.getter(name="ipmiIps")
    def ipmi_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpArgs']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "ipmi_ips")

    @ipmi_ips.setter
    def ipmi_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpArgs']]]]):
        pulumi.set(self, "ipmi_ips", value)

    @property
    @pulumi.getter(name="isLightCompute")
    def is_light_compute(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_light_compute")

    @is_light_compute.setter
    def is_light_compute(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_light_compute", value)

    @property
    @pulumi.getter(name="isRoboMixedHypervisor")
    def is_robo_mixed_hypervisor(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Is ROBO mixed hypervisor.
        """
        return pulumi.get(self, "is_robo_mixed_hypervisor")

    @is_robo_mixed_hypervisor.setter
    def is_robo_mixed_hypervisor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_robo_mixed_hypervisor", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Rackable unit model name.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkArgs']]]]:
        """
        -(Optional) Active and standby uplink information of the target nodes.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkArgs']]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Node position.
        """
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="nodeUuid")
    def node_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Node UUID.
        """
        return pulumi.get(self, "node_uuid")

    @node_uuid.setter
    def node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_uuid", value)

    @property
    @pulumi.getter(name="nosVersion")
    def nos_version(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) NOS software version of a node.
        """
        return pulumi.get(self, "nos_version")

    @nos_version.setter
    def nos_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nos_version", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListCvmIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListCvmIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListCvmIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListCvmIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListCvmIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListCvmIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListCvmIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListCvmIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListCvmIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListDigitalCertificateMapListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListHypervisorIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListHypervisorIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListHypervisorIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListHypervisorIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListIpmiIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListIpmiIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListIpmiIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListIpmiIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListIpmiIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListNetworkArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Name of the uplink.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        -(Optional) List of network types.
        """
        uplinks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgsDict']]]]
        """
        -(Optional) Active and standby uplink information of the target nodes.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListNetworkArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 uplinks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs']]]] = None):
        """
        :param pulumi.Input[str] name: -(Optional) Name of the uplink.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: -(Optional) List of network types.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs']]] uplinks: -(Optional) Active and standby uplink information of the target nodes.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if uplinks is not None:
            pulumi.set(__self__, "uplinks", uplinks)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Name of the uplink.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        -(Optional) List of network types.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def uplinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs']]]]:
        """
        -(Optional) Active and standby uplink information of the target nodes.
        """
        return pulumi.get(self, "uplinks")

    @uplinks.setter
    def uplinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs']]]]):
        pulumi.set(self, "uplinks", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgsDict(TypedDict):
        actives: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgsDict']]]]
        """
        -(Optional) Active uplink information.
        """
        standbies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgsDict']]]]
        """
        -(Optional) Standby uplink information.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListNetworkUplinkArgs:
    def __init__(__self__, *,
                 actives: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs']]]] = None,
                 standbies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs']]] actives: -(Optional) Active uplink information.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs']]] standbies: -(Optional) Standby uplink information.
        """
        if actives is not None:
            pulumi.set(__self__, "actives", actives)
        if standbies is not None:
            pulumi.set(__self__, "standbies", standbies)

    @property
    @pulumi.getter
    def actives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs']]]]:
        """
        -(Optional) Active uplink information.
        """
        return pulumi.get(self, "actives")

    @actives.setter
    def actives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs']]]]):
        pulumi.set(self, "actives", value)

    @property
    @pulumi.getter
    def standbies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs']]]]:
        """
        -(Optional) Standby uplink information.
        """
        return pulumi.get(self, "standbies")

    @standbies.setter
    def standbies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs']]]]):
        pulumi.set(self, "standbies", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Mac address.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Interface name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Interface value.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListNetworkUplinkActiveArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mac: -(Optional) Mac address.
        :param pulumi.Input[str] name: -(Optional) Interface name.
        :param pulumi.Input[str] value: -(Optional) Interface value.
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Mac address.
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Interface name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Interface value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Mac address.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Interface name.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Interface value.
        """
elif False:
    ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2NodeParamNodeListNetworkUplinkStandbyArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mac: -(Optional) Mac address.
        :param pulumi.Input[str] name: -(Optional) Interface name.
        :param pulumi.Input[str] value: -(Optional) Interface value.
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Mac address.
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Interface name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Interface value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterAddNodeV2RemoveNodeParamArgsDict(TypedDict):
        extra_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2RemoveNodeParamExtraParamArgsDict']]]]
        """
        -(Optional) Extra parameters for node addition.
        """
        should_skip_prechecks: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if prechecks can be skipped for node removal.
        """
        should_skip_remove: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if node removal can be skipped.
        """
elif False:
    ClusterAddNodeV2RemoveNodeParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2RemoveNodeParamArgs:
    def __init__(__self__, *,
                 extra_params: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2RemoveNodeParamExtraParamArgs']]]] = None,
                 should_skip_prechecks: Optional[pulumi.Input[bool]] = None,
                 should_skip_remove: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2RemoveNodeParamExtraParamArgs']]] extra_params: -(Optional) Extra parameters for node addition.
        :param pulumi.Input[bool] should_skip_prechecks: -(Optional) Indicates if prechecks can be skipped for node removal.
        :param pulumi.Input[bool] should_skip_remove: -(Optional) Indicates if node removal can be skipped.
        """
        if extra_params is not None:
            pulumi.set(__self__, "extra_params", extra_params)
        if should_skip_prechecks is not None:
            pulumi.set(__self__, "should_skip_prechecks", should_skip_prechecks)
        if should_skip_remove is not None:
            pulumi.set(__self__, "should_skip_remove", should_skip_remove)

    @property
    @pulumi.getter(name="extraParams")
    def extra_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2RemoveNodeParamExtraParamArgs']]]]:
        """
        -(Optional) Extra parameters for node addition.
        """
        return pulumi.get(self, "extra_params")

    @extra_params.setter
    def extra_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAddNodeV2RemoveNodeParamExtraParamArgs']]]]):
        pulumi.set(self, "extra_params", value)

    @property
    @pulumi.getter(name="shouldSkipPrechecks")
    def should_skip_prechecks(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if prechecks can be skipped for node removal.
        """
        return pulumi.get(self, "should_skip_prechecks")

    @should_skip_prechecks.setter
    def should_skip_prechecks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_prechecks", value)

    @property
    @pulumi.getter(name="shouldSkipRemove")
    def should_skip_remove(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if node removal can be skipped.
        """
        return pulumi.get(self, "should_skip_remove")

    @should_skip_remove.setter
    def should_skip_remove(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_remove", value)


if not MYPY:
    class ClusterAddNodeV2RemoveNodeParamExtraParamArgsDict(TypedDict):
        should_skip_add_check: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if add check needs to be skipped or not.




        See detailed information in [Nutanix Cluster - Add Node on a Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/expandCluster).
        """
        should_skip_upgrade_check: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if upgrade check needs to be skipped or not.
        """
        skip_space_check: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates if space check needs to be skipped or not.
        """
elif False:
    ClusterAddNodeV2RemoveNodeParamExtraParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAddNodeV2RemoveNodeParamExtraParamArgs:
    def __init__(__self__, *,
                 should_skip_add_check: Optional[pulumi.Input[bool]] = None,
                 should_skip_upgrade_check: Optional[pulumi.Input[bool]] = None,
                 skip_space_check: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_skip_add_check: -(Optional) Indicates if add check needs to be skipped or not.
               
               
               
               
               See detailed information in [Nutanix Cluster - Add Node on a Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/expandCluster).
        :param pulumi.Input[bool] should_skip_upgrade_check: -(Optional) Indicates if upgrade check needs to be skipped or not.
        :param pulumi.Input[bool] skip_space_check: -(Optional) Indicates if space check needs to be skipped or not.
        """
        if should_skip_add_check is not None:
            pulumi.set(__self__, "should_skip_add_check", should_skip_add_check)
        if should_skip_upgrade_check is not None:
            pulumi.set(__self__, "should_skip_upgrade_check", should_skip_upgrade_check)
        if skip_space_check is not None:
            pulumi.set(__self__, "skip_space_check", skip_space_check)

    @property
    @pulumi.getter(name="shouldSkipAddCheck")
    def should_skip_add_check(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if add check needs to be skipped or not.




        See detailed information in [Nutanix Cluster - Add Node on a Cluster V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0#tag/Clusters/operation/expandCluster).
        """
        return pulumi.get(self, "should_skip_add_check")

    @should_skip_add_check.setter
    def should_skip_add_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_add_check", value)

    @property
    @pulumi.getter(name="shouldSkipUpgradeCheck")
    def should_skip_upgrade_check(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if upgrade check needs to be skipped or not.
        """
        return pulumi.get(self, "should_skip_upgrade_check")

    @should_skip_upgrade_check.setter
    def should_skip_upgrade_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_skip_upgrade_check", value)

    @property
    @pulumi.getter(name="skipSpaceCheck")
    def skip_space_check(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates if space check needs to be skipped or not.
        """
        return pulumi.get(self, "skip_space_check")

    @skip_space_check.setter
    def skip_space_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_space_check", value)


if not MYPY:
    class ClusterV2ConfigArgsDict(TypedDict):
        authorized_public_key_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigAuthorizedPublicKeyListArgsDict']]]]
        """
        - (Optional) Public ssh key details. This is part of payload for cluster update operation only.
        """
        build_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigBuildInfoArgsDict']]]]
        """
        - (Optional) Build information details.
        """
        cluster_arch: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Cluster arch.
        Valid values are:
        - "PPC64LE" PPC64LE cluster architecture type.
        - "X86_64" X86_64 cluster architecture type.
        """
        cluster_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) Cluster function. This is part of payload for cluster 
        create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
        Valid values are:
        - "AOS"
        - "PRISM_CENTRAL"
        - "CLOUD_DATA_GATEWAY"
        - "AFS"
        - "ONE_NODE"
        - "TWO_NODE"
        - "ANALYTICS_PLATFORM"
        """
        cluster_software_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigClusterSoftwareMapArgsDict']]]]
        encryption_in_transit_status: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Encryption in transit Status.
        Valid values are:
        - "DISABLED"	Disabled encryption status.
        - "ENABLED"	Enabled encryption status.
        """
        encryption_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        encryption_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        fault_tolerance_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateArgsDict']]]]
        """
        - (Optional) Fault tolerant state of cluster.
        """
        hypervisor_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        incarnation_id: NotRequired[pulumi.Input[int]]
        is_available: NotRequired[pulumi.Input[bool]]
        is_lts: NotRequired[pulumi.Input[bool]]
        is_password_remote_login_enabled: NotRequired[pulumi.Input[bool]]
        is_remote_support_enabled: NotRequired[pulumi.Input[bool]]
        operation_mode: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Cluster operation mode. This is part of payload for cluster
        update operation only.
        Valid values are:
        - "OVERRIDE"	Override operation mode.
        - "STAND_ALONE"	Stand-alone operation mode.
        - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
        - "NORMAL"	Normal operation mode.
        - "READ_ONLY"	Read-only operation mode.
        """
        pulse_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigPulseStatusArgsDict']]]]
        """
        - (Optional) Pulse status for a cluster.
        """
        redundancy_factor: NotRequired[pulumi.Input[int]]
        """
        - (Optional) Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigArgs:
    def __init__(__self__, *,
                 authorized_public_key_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigAuthorizedPublicKeyListArgs']]]] = None,
                 build_infos: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigBuildInfoArgs']]]] = None,
                 cluster_arch: Optional[pulumi.Input[str]] = None,
                 cluster_functions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cluster_software_maps: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigClusterSoftwareMapArgs']]]] = None,
                 encryption_in_transit_status: Optional[pulumi.Input[str]] = None,
                 encryption_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 encryption_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fault_tolerance_states: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateArgs']]]] = None,
                 hypervisor_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 incarnation_id: Optional[pulumi.Input[int]] = None,
                 is_available: Optional[pulumi.Input[bool]] = None,
                 is_lts: Optional[pulumi.Input[bool]] = None,
                 is_password_remote_login_enabled: Optional[pulumi.Input[bool]] = None,
                 is_remote_support_enabled: Optional[pulumi.Input[bool]] = None,
                 operation_mode: Optional[pulumi.Input[str]] = None,
                 pulse_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigPulseStatusArgs']]]] = None,
                 redundancy_factor: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigAuthorizedPublicKeyListArgs']]] authorized_public_key_lists: - (Optional) Public ssh key details. This is part of payload for cluster update operation only.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigBuildInfoArgs']]] build_infos: - (Optional) Build information details.
        :param pulumi.Input[str] cluster_arch: - (Optional) Cluster arch.
               Valid values are:
               - "PPC64LE" PPC64LE cluster architecture type.
               - "X86_64" X86_64 cluster architecture type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cluster_functions: - (Optional) Cluster function. This is part of payload for cluster 
               create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
               Valid values are:
               - "AOS"
               - "PRISM_CENTRAL"
               - "CLOUD_DATA_GATEWAY"
               - "AFS"
               - "ONE_NODE"
               - "TWO_NODE"
               - "ANALYTICS_PLATFORM"
        :param pulumi.Input[str] encryption_in_transit_status: - (Optional) Encryption in transit Status.
               Valid values are:
               - "DISABLED"	Disabled encryption status.
               - "ENABLED"	Enabled encryption status.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateArgs']]] fault_tolerance_states: - (Optional) Fault tolerant state of cluster.
        :param pulumi.Input[str] operation_mode: - (Optional) Cluster operation mode. This is part of payload for cluster
               update operation only.
               Valid values are:
               - "OVERRIDE"	Override operation mode.
               - "STAND_ALONE"	Stand-alone operation mode.
               - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
               - "NORMAL"	Normal operation mode.
               - "READ_ONLY"	Read-only operation mode.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigPulseStatusArgs']]] pulse_statuses: - (Optional) Pulse status for a cluster.
        :param pulumi.Input[int] redundancy_factor: - (Optional) Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
        """
        if authorized_public_key_lists is not None:
            pulumi.set(__self__, "authorized_public_key_lists", authorized_public_key_lists)
        if build_infos is not None:
            pulumi.set(__self__, "build_infos", build_infos)
        if cluster_arch is not None:
            pulumi.set(__self__, "cluster_arch", cluster_arch)
        if cluster_functions is not None:
            pulumi.set(__self__, "cluster_functions", cluster_functions)
        if cluster_software_maps is not None:
            pulumi.set(__self__, "cluster_software_maps", cluster_software_maps)
        if encryption_in_transit_status is not None:
            pulumi.set(__self__, "encryption_in_transit_status", encryption_in_transit_status)
        if encryption_options is not None:
            pulumi.set(__self__, "encryption_options", encryption_options)
        if encryption_scopes is not None:
            pulumi.set(__self__, "encryption_scopes", encryption_scopes)
        if fault_tolerance_states is not None:
            pulumi.set(__self__, "fault_tolerance_states", fault_tolerance_states)
        if hypervisor_types is not None:
            pulumi.set(__self__, "hypervisor_types", hypervisor_types)
        if incarnation_id is not None:
            pulumi.set(__self__, "incarnation_id", incarnation_id)
        if is_available is not None:
            pulumi.set(__self__, "is_available", is_available)
        if is_lts is not None:
            pulumi.set(__self__, "is_lts", is_lts)
        if is_password_remote_login_enabled is not None:
            pulumi.set(__self__, "is_password_remote_login_enabled", is_password_remote_login_enabled)
        if is_remote_support_enabled is not None:
            pulumi.set(__self__, "is_remote_support_enabled", is_remote_support_enabled)
        if operation_mode is not None:
            pulumi.set(__self__, "operation_mode", operation_mode)
        if pulse_statuses is not None:
            pulumi.set(__self__, "pulse_statuses", pulse_statuses)
        if redundancy_factor is not None:
            pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="authorizedPublicKeyLists")
    def authorized_public_key_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigAuthorizedPublicKeyListArgs']]]]:
        """
        - (Optional) Public ssh key details. This is part of payload for cluster update operation only.
        """
        return pulumi.get(self, "authorized_public_key_lists")

    @authorized_public_key_lists.setter
    def authorized_public_key_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigAuthorizedPublicKeyListArgs']]]]):
        pulumi.set(self, "authorized_public_key_lists", value)

    @property
    @pulumi.getter(name="buildInfos")
    def build_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigBuildInfoArgs']]]]:
        """
        - (Optional) Build information details.
        """
        return pulumi.get(self, "build_infos")

    @build_infos.setter
    def build_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigBuildInfoArgs']]]]):
        pulumi.set(self, "build_infos", value)

    @property
    @pulumi.getter(name="clusterArch")
    def cluster_arch(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Cluster arch.
        Valid values are:
        - "PPC64LE" PPC64LE cluster architecture type.
        - "X86_64" X86_64 cluster architecture type.
        """
        return pulumi.get(self, "cluster_arch")

    @cluster_arch.setter
    def cluster_arch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_arch", value)

    @property
    @pulumi.getter(name="clusterFunctions")
    def cluster_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) Cluster function. This is part of payload for cluster 
        create operation only (allowed enum values for creation are AOS, ONE_NODE & TWO_NODE only).
        Valid values are:
        - "AOS"
        - "PRISM_CENTRAL"
        - "CLOUD_DATA_GATEWAY"
        - "AFS"
        - "ONE_NODE"
        - "TWO_NODE"
        - "ANALYTICS_PLATFORM"
        """
        return pulumi.get(self, "cluster_functions")

    @cluster_functions.setter
    def cluster_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_functions", value)

    @property
    @pulumi.getter(name="clusterSoftwareMaps")
    def cluster_software_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigClusterSoftwareMapArgs']]]]:
        return pulumi.get(self, "cluster_software_maps")

    @cluster_software_maps.setter
    def cluster_software_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigClusterSoftwareMapArgs']]]]):
        pulumi.set(self, "cluster_software_maps", value)

    @property
    @pulumi.getter(name="encryptionInTransitStatus")
    def encryption_in_transit_status(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Encryption in transit Status.
        Valid values are:
        - "DISABLED"	Disabled encryption status.
        - "ENABLED"	Enabled encryption status.
        """
        return pulumi.get(self, "encryption_in_transit_status")

    @encryption_in_transit_status.setter
    def encryption_in_transit_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_in_transit_status", value)

    @property
    @pulumi.getter(name="encryptionOptions")
    def encryption_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "encryption_options")

    @encryption_options.setter
    def encryption_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "encryption_options", value)

    @property
    @pulumi.getter(name="encryptionScopes")
    def encryption_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "encryption_scopes")

    @encryption_scopes.setter
    def encryption_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "encryption_scopes", value)

    @property
    @pulumi.getter(name="faultToleranceStates")
    def fault_tolerance_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateArgs']]]]:
        """
        - (Optional) Fault tolerant state of cluster.
        """
        return pulumi.get(self, "fault_tolerance_states")

    @fault_tolerance_states.setter
    def fault_tolerance_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateArgs']]]]):
        pulumi.set(self, "fault_tolerance_states", value)

    @property
    @pulumi.getter(name="hypervisorTypes")
    def hypervisor_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hypervisor_types")

    @hypervisor_types.setter
    def hypervisor_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisor_types", value)

    @property
    @pulumi.getter(name="incarnationId")
    def incarnation_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "incarnation_id")

    @incarnation_id.setter
    def incarnation_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "incarnation_id", value)

    @property
    @pulumi.getter(name="isAvailable")
    def is_available(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_available")

    @is_available.setter
    def is_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_available", value)

    @property
    @pulumi.getter(name="isLts")
    def is_lts(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_lts")

    @is_lts.setter
    def is_lts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_lts", value)

    @property
    @pulumi.getter(name="isPasswordRemoteLoginEnabled")
    def is_password_remote_login_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_password_remote_login_enabled")

    @is_password_remote_login_enabled.setter
    def is_password_remote_login_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_password_remote_login_enabled", value)

    @property
    @pulumi.getter(name="isRemoteSupportEnabled")
    def is_remote_support_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_remote_support_enabled")

    @is_remote_support_enabled.setter
    def is_remote_support_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_remote_support_enabled", value)

    @property
    @pulumi.getter(name="operationMode")
    def operation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Cluster operation mode. This is part of payload for cluster
        update operation only.
        Valid values are:
        - "OVERRIDE"	Override operation mode.
        - "STAND_ALONE"	Stand-alone operation mode.
        - "SWITCH_TO_TWO_NODE"	Switch to two-node operation mode.
        - "NORMAL"	Normal operation mode.
        - "READ_ONLY"	Read-only operation mode.
        """
        return pulumi.get(self, "operation_mode")

    @operation_mode.setter
    def operation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operation_mode", value)

    @property
    @pulumi.getter(name="pulseStatuses")
    def pulse_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigPulseStatusArgs']]]]:
        """
        - (Optional) Pulse status for a cluster.
        """
        return pulumi.get(self, "pulse_statuses")

    @pulse_statuses.setter
    def pulse_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigPulseStatusArgs']]]]):
        pulumi.set(self, "pulse_statuses", value)

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) Redundancy factor of a cluster. This is part of payload for both cluster create & update operations.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redundancy_factor", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class ClusterV2ConfigAuthorizedPublicKeyListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Ssh key value.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Ssh key name.
        """
elif False:
    ClusterV2ConfigAuthorizedPublicKeyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigAuthorizedPublicKeyListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Ssh key value.
        :param pulumi.Input[str] name: Ssh key name.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Ssh key value.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Ssh key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ClusterV2ConfigBuildInfoArgsDict(TypedDict):
        build_type: NotRequired[pulumi.Input[str]]
        """
        Software build type.
        """
        commit_id: NotRequired[pulumi.Input[str]]
        """
        Commit Id used for version.
        """
        full_version: NotRequired[pulumi.Input[str]]
        """
        Full name of software version.
        """
        short_commit_id: NotRequired[pulumi.Input[str]]
        """
        Short commit Id used for version.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Software version.
        """
elif False:
    ClusterV2ConfigBuildInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigBuildInfoArgs:
    def __init__(__self__, *,
                 build_type: Optional[pulumi.Input[str]] = None,
                 commit_id: Optional[pulumi.Input[str]] = None,
                 full_version: Optional[pulumi.Input[str]] = None,
                 short_commit_id: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] build_type: Software build type.
        :param pulumi.Input[str] commit_id: Commit Id used for version.
        :param pulumi.Input[str] full_version: Full name of software version.
        :param pulumi.Input[str] short_commit_id: Short commit Id used for version.
        :param pulumi.Input[str] version: Software version.
        """
        if build_type is not None:
            pulumi.set(__self__, "build_type", build_type)
        if commit_id is not None:
            pulumi.set(__self__, "commit_id", commit_id)
        if full_version is not None:
            pulumi.set(__self__, "full_version", full_version)
        if short_commit_id is not None:
            pulumi.set(__self__, "short_commit_id", short_commit_id)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> Optional[pulumi.Input[str]]:
        """
        Software build type.
        """
        return pulumi.get(self, "build_type")

    @build_type.setter
    def build_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_type", value)

    @property
    @pulumi.getter(name="commitId")
    def commit_id(self) -> Optional[pulumi.Input[str]]:
        """
        Commit Id used for version.
        """
        return pulumi.get(self, "commit_id")

    @commit_id.setter
    def commit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_id", value)

    @property
    @pulumi.getter(name="fullVersion")
    def full_version(self) -> Optional[pulumi.Input[str]]:
        """
        Full name of software version.
        """
        return pulumi.get(self, "full_version")

    @full_version.setter
    def full_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "full_version", value)

    @property
    @pulumi.getter(name="shortCommitId")
    def short_commit_id(self) -> Optional[pulumi.Input[str]]:
        """
        Short commit Id used for version.
        """
        return pulumi.get(self, "short_commit_id")

    @short_commit_id.setter
    def short_commit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "short_commit_id", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Software version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterV2ConfigClusterSoftwareMapArgsDict(TypedDict):
        software_type: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[str]]
        """
        Software version.
        """
elif False:
    ClusterV2ConfigClusterSoftwareMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigClusterSoftwareMapArgs:
    def __init__(__self__, *,
                 software_type: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] version: Software version.
        """
        if software_type is not None:
            pulumi.set(__self__, "software_type", software_type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="softwareType")
    def software_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_type")

    @software_type.setter
    def software_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Software version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterV2ConfigFaultToleranceStateArgsDict(TypedDict):
        current_cluster_fault_tolerance: NotRequired[pulumi.Input[str]]
        current_max_fault_tolerance: NotRequired[pulumi.Input[int]]
        desired_cluster_fault_tolerance: NotRequired[pulumi.Input[str]]
        desired_max_fault_tolerance: NotRequired[pulumi.Input[int]]
        domain_awareness_level: NotRequired[pulumi.Input[str]]
        """
        Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
        Valid values are:
        - "RACK"	Rack level awareness.
        - "NODE"	Node level awareness.
        - "BLOCK"	Block level awareness.
        - "DISK"	Disk level awareness.
        """
        redundancy_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateRedundancyStatusArgsDict']]]]
elif False:
    ClusterV2ConfigFaultToleranceStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigFaultToleranceStateArgs:
    def __init__(__self__, *,
                 current_cluster_fault_tolerance: Optional[pulumi.Input[str]] = None,
                 current_max_fault_tolerance: Optional[pulumi.Input[int]] = None,
                 desired_cluster_fault_tolerance: Optional[pulumi.Input[str]] = None,
                 desired_max_fault_tolerance: Optional[pulumi.Input[int]] = None,
                 domain_awareness_level: Optional[pulumi.Input[str]] = None,
                 redundancy_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateRedundancyStatusArgs']]]] = None):
        """
        :param pulumi.Input[str] domain_awareness_level: Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
               Valid values are:
               - "RACK"	Rack level awareness.
               - "NODE"	Node level awareness.
               - "BLOCK"	Block level awareness.
               - "DISK"	Disk level awareness.
        """
        if current_cluster_fault_tolerance is not None:
            pulumi.set(__self__, "current_cluster_fault_tolerance", current_cluster_fault_tolerance)
        if current_max_fault_tolerance is not None:
            pulumi.set(__self__, "current_max_fault_tolerance", current_max_fault_tolerance)
        if desired_cluster_fault_tolerance is not None:
            pulumi.set(__self__, "desired_cluster_fault_tolerance", desired_cluster_fault_tolerance)
        if desired_max_fault_tolerance is not None:
            pulumi.set(__self__, "desired_max_fault_tolerance", desired_max_fault_tolerance)
        if domain_awareness_level is not None:
            pulumi.set(__self__, "domain_awareness_level", domain_awareness_level)
        if redundancy_statuses is not None:
            pulumi.set(__self__, "redundancy_statuses", redundancy_statuses)

    @property
    @pulumi.getter(name="currentClusterFaultTolerance")
    def current_cluster_fault_tolerance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_cluster_fault_tolerance")

    @current_cluster_fault_tolerance.setter
    def current_cluster_fault_tolerance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_cluster_fault_tolerance", value)

    @property
    @pulumi.getter(name="currentMaxFaultTolerance")
    def current_max_fault_tolerance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "current_max_fault_tolerance")

    @current_max_fault_tolerance.setter
    def current_max_fault_tolerance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_max_fault_tolerance", value)

    @property
    @pulumi.getter(name="desiredClusterFaultTolerance")
    def desired_cluster_fault_tolerance(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "desired_cluster_fault_tolerance")

    @desired_cluster_fault_tolerance.setter
    def desired_cluster_fault_tolerance(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_cluster_fault_tolerance", value)

    @property
    @pulumi.getter(name="desiredMaxFaultTolerance")
    def desired_max_fault_tolerance(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "desired_max_fault_tolerance")

    @desired_max_fault_tolerance.setter
    def desired_max_fault_tolerance(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "desired_max_fault_tolerance", value)

    @property
    @pulumi.getter(name="domainAwarenessLevel")
    def domain_awareness_level(self) -> Optional[pulumi.Input[str]]:
        """
        Domain awareness level corresponds to unit of cluster group. This is part of payload for both cluster create & update operations.
        Valid values are:
        - "RACK"	Rack level awareness.
        - "NODE"	Node level awareness.
        - "BLOCK"	Block level awareness.
        - "DISK"	Disk level awareness.
        """
        return pulumi.get(self, "domain_awareness_level")

    @domain_awareness_level.setter
    def domain_awareness_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_awareness_level", value)

    @property
    @pulumi.getter(name="redundancyStatuses")
    def redundancy_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateRedundancyStatusArgs']]]]:
        return pulumi.get(self, "redundancy_statuses")

    @redundancy_statuses.setter
    def redundancy_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ConfigFaultToleranceStateRedundancyStatusArgs']]]]):
        pulumi.set(self, "redundancy_statuses", value)


if not MYPY:
    class ClusterV2ConfigFaultToleranceStateRedundancyStatusArgsDict(TypedDict):
        is_cassandra_preparation_done: NotRequired[pulumi.Input[bool]]
        is_zookeeper_preparation_done: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterV2ConfigFaultToleranceStateRedundancyStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigFaultToleranceStateRedundancyStatusArgs:
    def __init__(__self__, *,
                 is_cassandra_preparation_done: Optional[pulumi.Input[bool]] = None,
                 is_zookeeper_preparation_done: Optional[pulumi.Input[bool]] = None):
        if is_cassandra_preparation_done is not None:
            pulumi.set(__self__, "is_cassandra_preparation_done", is_cassandra_preparation_done)
        if is_zookeeper_preparation_done is not None:
            pulumi.set(__self__, "is_zookeeper_preparation_done", is_zookeeper_preparation_done)

    @property
    @pulumi.getter(name="isCassandraPreparationDone")
    def is_cassandra_preparation_done(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_cassandra_preparation_done")

    @is_cassandra_preparation_done.setter
    def is_cassandra_preparation_done(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cassandra_preparation_done", value)

    @property
    @pulumi.getter(name="isZookeeperPreparationDone")
    def is_zookeeper_preparation_done(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_zookeeper_preparation_done")

    @is_zookeeper_preparation_done.setter
    def is_zookeeper_preparation_done(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_zookeeper_preparation_done", value)


if not MYPY:
    class ClusterV2ConfigPulseStatusArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Flag to indicate if pulse is enabled or not.
        """
        pii_scrubbing_level: NotRequired[pulumi.Input[str]]
        """
        - (Optional) PII scrubbing level.
        Valid values are:
        - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
        - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
        """
elif False:
    ClusterV2ConfigPulseStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ConfigPulseStatusArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 pii_scrubbing_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: - (Optional) Flag to indicate if pulse is enabled or not.
        :param pulumi.Input[str] pii_scrubbing_level: - (Optional) PII scrubbing level.
               Valid values are:
               - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
               - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if pii_scrubbing_level is not None:
            pulumi.set(__self__, "pii_scrubbing_level", pii_scrubbing_level)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Flag to indicate if pulse is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="piiScrubbingLevel")
    def pii_scrubbing_level(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) PII scrubbing level.
        Valid values are:
        - "ALL" :	Scrub All PII Information from Pulse including data like entity names and IP addresses.
        - "DEFAULT":	Default PII Scrubbing level. Data like entity names and IP addresses will not be scrubbed from Pulse.
        """
        return pulumi.get(self, "pii_scrubbing_level")

    @pii_scrubbing_level.setter
    def pii_scrubbing_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pii_scrubbing_level", value)


if not MYPY:
    class ClusterV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class ClusterV2NetworkArgsDict(TypedDict):
        backplanes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneArgsDict']]]]
        """
        Params associated to the backplane network segmentation. This is part of payload for cluster(create operation only.)
        """
        external_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        external_data_services_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        external_subnet: NotRequired[pulumi.Input[str]]
        fqdn: NotRequired[pulumi.Input[str]]
        """
        Cluster fully qualified domain name. This is part of payload for cluster update operation only.
        """
        http_proxy_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListArgsDict']]]]
        """
        List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        http_proxy_white_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyWhiteListArgsDict']]]]
        internal_subnet: NotRequired[pulumi.Input[str]]
        key_management_server_type: NotRequired[pulumi.Input[str]]
        """
        Management server type.
        Valid values are:
        - "PRISM_CENTRAL"	Prism Central management server.
        - "EXTERNAL"	External management server.
        - "LOCAL"	Local management server.
        """
        management_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerArgsDict']]]]
        """
        Management server information.
        """
        masquerading_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        masquerading_port: NotRequired[pulumi.Input[str]]
        name_server_ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListArgsDict']]]]
        """
        List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        """
        nfs_subnet_white_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        NFS subnet whitelist addresses. This is part of payload for cluster update operation only.
        """
        ntp_server_ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListArgsDict']]]]
        """
        List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        """
        smtp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerArgsDict']]]]
        """
        SMTP servers on a cluster. This is part of payload for cluster update operation only.
        """
elif False:
    ClusterV2NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkArgs:
    def __init__(__self__, *,
                 backplanes: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneArgs']]]] = None,
                 external_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressArgs']]]] = None,
                 external_data_services_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpArgs']]]] = None,
                 external_subnet: Optional[pulumi.Input[str]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 http_proxy_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListArgs']]]] = None,
                 http_proxy_white_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyWhiteListArgs']]]] = None,
                 internal_subnet: Optional[pulumi.Input[str]] = None,
                 key_management_server_type: Optional[pulumi.Input[str]] = None,
                 management_servers: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerArgs']]]] = None,
                 masquerading_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpArgs']]]] = None,
                 masquerading_port: Optional[pulumi.Input[str]] = None,
                 name_server_ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListArgs']]]] = None,
                 nfs_subnet_white_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ntp_server_ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListArgs']]]] = None,
                 smtp_servers: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneArgs']]] backplanes: Params associated to the backplane network segmentation. This is part of payload for cluster(create operation only.)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressArgs']]] external_addresses: An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpArgs']]] external_data_services_ips: An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[str] fqdn: Cluster fully qualified domain name. This is part of payload for cluster update operation only.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListArgs']]] http_proxy_lists: List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        :param pulumi.Input[str] key_management_server_type: Management server type.
               Valid values are:
               - "PRISM_CENTRAL"	Prism Central management server.
               - "EXTERNAL"	External management server.
               - "LOCAL"	Local management server.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerArgs']]] management_servers: Management server information.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpArgs']]] masquerading_ips: An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListArgs']]] name_server_ip_lists: List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nfs_subnet_white_lists: NFS subnet whitelist addresses. This is part of payload for cluster update operation only.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListArgs']]] ntp_server_ip_lists: List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerArgs']]] smtp_servers: SMTP servers on a cluster. This is part of payload for cluster update operation only.
        """
        if backplanes is not None:
            pulumi.set(__self__, "backplanes", backplanes)
        if external_addresses is not None:
            pulumi.set(__self__, "external_addresses", external_addresses)
        if external_data_services_ips is not None:
            pulumi.set(__self__, "external_data_services_ips", external_data_services_ips)
        if external_subnet is not None:
            pulumi.set(__self__, "external_subnet", external_subnet)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if http_proxy_lists is not None:
            pulumi.set(__self__, "http_proxy_lists", http_proxy_lists)
        if http_proxy_white_lists is not None:
            pulumi.set(__self__, "http_proxy_white_lists", http_proxy_white_lists)
        if internal_subnet is not None:
            pulumi.set(__self__, "internal_subnet", internal_subnet)
        if key_management_server_type is not None:
            pulumi.set(__self__, "key_management_server_type", key_management_server_type)
        if management_servers is not None:
            pulumi.set(__self__, "management_servers", management_servers)
        if masquerading_ips is not None:
            pulumi.set(__self__, "masquerading_ips", masquerading_ips)
        if masquerading_port is not None:
            pulumi.set(__self__, "masquerading_port", masquerading_port)
        if name_server_ip_lists is not None:
            pulumi.set(__self__, "name_server_ip_lists", name_server_ip_lists)
        if nfs_subnet_white_lists is not None:
            pulumi.set(__self__, "nfs_subnet_white_lists", nfs_subnet_white_lists)
        if ntp_server_ip_lists is not None:
            pulumi.set(__self__, "ntp_server_ip_lists", ntp_server_ip_lists)
        if smtp_servers is not None:
            pulumi.set(__self__, "smtp_servers", smtp_servers)

    @property
    @pulumi.getter
    def backplanes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneArgs']]]]:
        """
        Params associated to the backplane network segmentation. This is part of payload for cluster(create operation only.)
        """
        return pulumi.get(self, "backplanes")

    @backplanes.setter
    def backplanes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneArgs']]]]):
        pulumi.set(self, "backplanes", value)

    @property
    @pulumi.getter(name="externalAddresses")
    def external_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressArgs']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "external_addresses")

    @external_addresses.setter
    def external_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressArgs']]]]):
        pulumi.set(self, "external_addresses", value)

    @property
    @pulumi.getter(name="externalDataServicesIps")
    def external_data_services_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpArgs']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "external_data_services_ips")

    @external_data_services_ips.setter
    def external_data_services_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpArgs']]]]):
        pulumi.set(self, "external_data_services_ips", value)

    @property
    @pulumi.getter(name="externalSubnet")
    def external_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_subnet")

    @external_subnet.setter
    def external_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_subnet", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster fully qualified domain name. This is part of payload for cluster update operation only.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="httpProxyLists")
    def http_proxy_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListArgs']]]]:
        """
        List of HTTP Proxy server configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        return pulumi.get(self, "http_proxy_lists")

    @http_proxy_lists.setter
    def http_proxy_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListArgs']]]]):
        pulumi.set(self, "http_proxy_lists", value)

    @property
    @pulumi.getter(name="httpProxyWhiteLists")
    def http_proxy_white_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyWhiteListArgs']]]]:
        return pulumi.get(self, "http_proxy_white_lists")

    @http_proxy_white_lists.setter
    def http_proxy_white_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyWhiteListArgs']]]]):
        pulumi.set(self, "http_proxy_white_lists", value)

    @property
    @pulumi.getter(name="internalSubnet")
    def internal_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_subnet")

    @internal_subnet.setter
    def internal_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_subnet", value)

    @property
    @pulumi.getter(name="keyManagementServerType")
    def key_management_server_type(self) -> Optional[pulumi.Input[str]]:
        """
        Management server type.
        Valid values are:
        - "PRISM_CENTRAL"	Prism Central management server.
        - "EXTERNAL"	External management server.
        - "LOCAL"	Local management server.
        """
        return pulumi.get(self, "key_management_server_type")

    @key_management_server_type.setter
    def key_management_server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_management_server_type", value)

    @property
    @pulumi.getter(name="managementServers")
    def management_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerArgs']]]]:
        """
        Management server information.
        """
        return pulumi.get(self, "management_servers")

    @management_servers.setter
    def management_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerArgs']]]]):
        pulumi.set(self, "management_servers", value)

    @property
    @pulumi.getter(name="masqueradingIps")
    def masquerading_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpArgs']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "masquerading_ips")

    @masquerading_ips.setter
    def masquerading_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpArgs']]]]):
        pulumi.set(self, "masquerading_ips", value)

    @property
    @pulumi.getter(name="masqueradingPort")
    def masquerading_port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "masquerading_port")

    @masquerading_port.setter
    def masquerading_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "masquerading_port", value)

    @property
    @pulumi.getter(name="nameServerIpLists")
    def name_server_ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListArgs']]]]:
        """
        List of name servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        """
        return pulumi.get(self, "name_server_ip_lists")

    @name_server_ip_lists.setter
    def name_server_ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListArgs']]]]):
        pulumi.set(self, "name_server_ip_lists", value)

    @property
    @pulumi.getter(name="nfsSubnetWhiteLists")
    def nfs_subnet_white_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        NFS subnet whitelist addresses. This is part of payload for cluster update operation only.
        """
        return pulumi.get(self, "nfs_subnet_white_lists")

    @nfs_subnet_white_lists.setter
    def nfs_subnet_white_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nfs_subnet_white_lists", value)

    @property
    @pulumi.getter(name="ntpServerIpLists")
    def ntp_server_ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListArgs']]]]:
        """
        List of NTP servers on a cluster. This is part of payload for both cluster create & update operations. For create operation, only ipv4 address / fqdn values are supported currently.
        """
        return pulumi.get(self, "ntp_server_ip_lists")

    @ntp_server_ip_lists.setter
    def ntp_server_ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListArgs']]]]):
        pulumi.set(self, "ntp_server_ip_lists", value)

    @property
    @pulumi.getter(name="smtpServers")
    def smtp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerArgs']]]]:
        """
        SMTP servers on a cluster. This is part of payload for cluster update operation only.
        """
        return pulumi.get(self, "smtp_servers")

    @smtp_servers.setter
    def smtp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerArgs']]]]):
        pulumi.set(self, "smtp_servers", value)


if not MYPY:
    class ClusterV2NetworkBackplaneArgsDict(TypedDict):
        is_segmentation_enabled: NotRequired[pulumi.Input[bool]]
        """
        Flag to indicate if the backplane segmentation needs to be enabled or not.
        """
        netmasks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneNetmaskArgsDict']]]]
        """
        Netmask configs.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneSubnetArgsDict']]]]
        """
        Subnet configs.
        """
        vlan_tag: NotRequired[pulumi.Input[int]]
        """
        VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
        """
elif False:
    ClusterV2NetworkBackplaneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkBackplaneArgs:
    def __init__(__self__, *,
                 is_segmentation_enabled: Optional[pulumi.Input[bool]] = None,
                 netmasks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneNetmaskArgs']]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneSubnetArgs']]]] = None,
                 vlan_tag: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_segmentation_enabled: Flag to indicate if the backplane segmentation needs to be enabled or not.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneNetmaskArgs']]] netmasks: Netmask configs.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneSubnetArgs']]] subnets: Subnet configs.
        :param pulumi.Input[int] vlan_tag: VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
        """
        if is_segmentation_enabled is not None:
            pulumi.set(__self__, "is_segmentation_enabled", is_segmentation_enabled)
        if netmasks is not None:
            pulumi.set(__self__, "netmasks", netmasks)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if vlan_tag is not None:
            pulumi.set(__self__, "vlan_tag", vlan_tag)

    @property
    @pulumi.getter(name="isSegmentationEnabled")
    def is_segmentation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to indicate if the backplane segmentation needs to be enabled or not.
        """
        return pulumi.get(self, "is_segmentation_enabled")

    @is_segmentation_enabled.setter
    def is_segmentation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_segmentation_enabled", value)

    @property
    @pulumi.getter
    def netmasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneNetmaskArgs']]]]:
        """
        Netmask configs.
        """
        return pulumi.get(self, "netmasks")

    @netmasks.setter
    def netmasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneNetmaskArgs']]]]):
        pulumi.set(self, "netmasks", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneSubnetArgs']]]]:
        """
        Subnet configs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkBackplaneSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="vlanTag")
    def vlan_tag(self) -> Optional[pulumi.Input[int]]:
        """
        VLAN Id tagged to the backplane network on the cluster. This is part of cluster create payload.
        """
        return pulumi.get(self, "vlan_tag")

    @vlan_tag.setter
    def vlan_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan_tag", value)


if not MYPY:
    class ClusterV2NetworkBackplaneNetmaskArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkBackplaneNetmaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkBackplaneNetmaskArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkBackplaneSubnetArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkBackplaneSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkBackplaneSubnetArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkExternalAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkExternalAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkExternalAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkExternalAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkExternalAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkExternalAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkExternalDataServicesIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkExternalDataServicesIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalDataServicesIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkExternalDataServicesIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkExternalDataServicesIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkExternalDataServicesIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalDataServicesIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkExternalDataServicesIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkExternalDataServicesIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkExternalDataServicesIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkHttpProxyListArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressArgsDict']]]]
        """
        - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        - (Optional) HTTP Proxy server password needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        - (Optional) HTTP Proxy server port configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        proxy_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        username: NotRequired[pulumi.Input[str]]
        """
        - (Optional) HTTP Proxy server username needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
elif False:
    ClusterV2NetworkHttpProxyListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkHttpProxyListArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressArgs']]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 proxy_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressArgs']]] ip_addresses: - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[str] password: - (Optional) HTTP Proxy server password needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        :param pulumi.Input[int] port: - (Optional) HTTP Proxy server port configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        :param pulumi.Input[str] username: - (Optional) HTTP Proxy server username needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        pulumi.set(__self__, "name", name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proxy_types is not None:
            pulumi.set(__self__, "proxy_types", proxy_types)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) HTTP Proxy server name configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressArgs']]]]:
        """
        - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) HTTP Proxy server password needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) HTTP Proxy server port configuration needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="proxyTypes")
    def proxy_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "proxy_types")

    @proxy_types.setter
    def proxy_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "proxy_types", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) HTTP Proxy server username needed to access a cluster which is hosted behind a HTTP Proxy to not reveal its identity.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ClusterV2NetworkHttpProxyListIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkHttpProxyListIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkHttpProxyListIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkHttpProxyListIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkHttpProxyListIpAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkHttpProxyListIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkHttpProxyListIpAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkHttpProxyListIpAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkHttpProxyListIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkHttpProxyListIpAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkHttpProxyWhiteListArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        - (Required) Target's identifier which is exempted from going through the configured HTTP Proxy.
        """
        target_type: pulumi.Input[str]
        """
        - (Optional) Target type.
        Valid values are:
        - "IPV6_ADDRESS"	IPV6 address.
        - "HOST_NAME"	Name of the host.
        - "IPV4_ADDRESS"	IPV4 address.
        - "DOMAIN_NAME_SUFFIX"	Domain Name Suffix required for http proxy whitelist.
        - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
        """
elif False:
    ClusterV2NetworkHttpProxyWhiteListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkHttpProxyWhiteListArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 target_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] target: - (Required) Target's identifier which is exempted from going through the configured HTTP Proxy.
        :param pulumi.Input[str] target_type: - (Optional) Target type.
               Valid values are:
               - "IPV6_ADDRESS"	IPV6 address.
               - "HOST_NAME"	Name of the host.
               - "IPV4_ADDRESS"	IPV4 address.
               - "DOMAIN_NAME_SUFFIX"	Domain Name Suffix required for http proxy whitelist.
               - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        - (Required) Target's identifier which is exempted from going through the configured HTTP Proxy.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        - (Optional) Target type.
        Valid values are:
        - "IPV6_ADDRESS"	IPV6 address.
        - "HOST_NAME"	Name of the host.
        - "IPV4_ADDRESS"	IPV4 address.
        - "DOMAIN_NAME_SUFFIX"	Domain Name Suffix required for http proxy whitelist.
        - "IPV4_NETWORK_MASK" Network Mask of the IpV4 family.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)


if not MYPY:
    class ClusterV2NetworkManagementServerArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        is_drs_enabled: NotRequired[pulumi.Input[bool]]
        is_in_use: NotRequired[pulumi.Input[bool]]
        is_registered: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether it is registered or not.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Management server type.
        Valid values are:
        - "VCENTER"	Vcenter management server.
        """
elif False:
    ClusterV2NetworkManagementServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkManagementServerArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpArgs']]]] = None,
                 is_drs_enabled: Optional[pulumi.Input[bool]] = None,
                 is_in_use: Optional[pulumi.Input[bool]] = None,
                 is_registered: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpArgs']]] ips: An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[bool] is_registered: Indicates whether it is registered or not.
        :param pulumi.Input[str] type: Management server type.
               Valid values are:
               - "VCENTER"	Vcenter management server.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if is_drs_enabled is not None:
            pulumi.set(__self__, "is_drs_enabled", is_drs_enabled)
        if is_in_use is not None:
            pulumi.set(__self__, "is_in_use", is_in_use)
        if is_registered is not None:
            pulumi.set(__self__, "is_registered", is_registered)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpArgs']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="isDrsEnabled")
    def is_drs_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_drs_enabled")

    @is_drs_enabled.setter
    def is_drs_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_drs_enabled", value)

    @property
    @pulumi.getter(name="isInUse")
    def is_in_use(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_in_use")

    @is_in_use.setter
    def is_in_use(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_in_use", value)

    @property
    @pulumi.getter(name="isRegistered")
    def is_registered(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether it is registered or not.
        """
        return pulumi.get(self, "is_registered")

    @is_registered.setter
    def is_registered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_registered", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Management server type.
        Valid values are:
        - "VCENTER"	Vcenter management server.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterV2NetworkManagementServerIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkManagementServerIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkManagementServerIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkManagementServerIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkManagementServerIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkManagementServerIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkManagementServerIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkManagementServerIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkManagementServerIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkManagementServerIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkMasqueradingIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkMasqueradingIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkMasqueradingIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkMasqueradingIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkMasqueradingIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkMasqueradingIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkMasqueradingIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkMasqueradingIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkMasqueradingIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkMasqueradingIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkNameServerIpListArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListFqdnArgsDict']]]]
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkNameServerIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNameServerIpListArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListFqdnArgs']]] fqdns: - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListFqdnArgs']]]]:
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNameServerIpListIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkNameServerIpListFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2NetworkNameServerIpListFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNameServerIpListFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2NetworkNameServerIpListIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkNameServerIpListIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNameServerIpListIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkNameServerIpListIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkNameServerIpListIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNameServerIpListIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkNtpServerIpListArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListFqdnArgsDict']]]]
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkNtpServerIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNtpServerIpListArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListFqdnArgs']]] fqdns: - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListFqdnArgs']]]]:
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkNtpServerIpListIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkNtpServerIpListFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2NetworkNtpServerIpListFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNtpServerIpListFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2NetworkNtpServerIpListIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkNtpServerIpListIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNtpServerIpListIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkNtpServerIpListIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkNtpServerIpListIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkNtpServerIpListIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerArgsDict(TypedDict):
        email_address: NotRequired[pulumi.Input[str]]
        """
        SMTP email address.
        """
        servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerArgsDict']]]]
        """
        SMTP network details.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of SMTP server.
        Valid values are:
        - "PLAIN"	Plain type SMTP server.
        - "STARTTLS"	Start TLS type SMTP server.
        - "SSL"	SSL type SMTP server.
        """
elif False:
    ClusterV2NetworkSmtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerArgs:
    def __init__(__self__, *,
                 email_address: Optional[pulumi.Input[str]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email_address: SMTP email address.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerArgs']]] servers: SMTP network details.
        :param pulumi.Input[str] type: Type of SMTP server.
               Valid values are:
               - "PLAIN"	Plain type SMTP server.
               - "STARTTLS"	Start TLS type SMTP server.
               - "SSL"	SSL type SMTP server.
        """
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        SMTP email address.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerArgs']]]]:
        """
        SMTP network details.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerArgs']]]]):
        pulumi.set(self, "servers", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of SMTP server.
        Valid values are:
        - "PLAIN"	Plain type SMTP server.
        - "STARTTLS"	Start TLS type SMTP server.
        - "SSL"	SSL type SMTP server.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerServerArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        SMTP server password.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        SMTP port.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        SMTP server user name.
        """
elif False:
    ClusterV2NetworkSmtpServerServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerServerArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressArgs']]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressArgs']]] ip_addresses: An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[str] password: SMTP server password.
        :param pulumi.Input[int] port: SMTP port.
        :param pulumi.Input[str] username: SMTP server user name.
        """
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressArgs']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        SMTP server password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        SMTP port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        SMTP server user name.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerServerIpAddressArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressFqdnArgsDict']]]]
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NetworkSmtpServerServerIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerServerIpAddressArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs']]] fqdns: - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs']]]]:
        """
        - (Optional) A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NetworkSmtpServerServerIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerServerIpAddressFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2NetworkSmtpServerServerIpAddressFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerServerIpAddressFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerServerIpAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkSmtpServerServerIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerServerIpAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NetworkSmtpServerServerIpAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NetworkSmtpServerServerIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NetworkSmtpServerServerIpAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NodeArgsDict(TypedDict):
        node_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListArgsDict']]]]
        """
        - (Optional) List of nodes in a cluster.
        """
        number_of_nodes: NotRequired[pulumi.Input[int]]
elif False:
    ClusterV2NodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeArgs:
    def __init__(__self__, *,
                 node_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListArgs']]]] = None,
                 number_of_nodes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListArgs']]] node_lists: - (Optional) List of nodes in a cluster.
        """
        if node_lists is not None:
            pulumi.set(__self__, "node_lists", node_lists)
        if number_of_nodes is not None:
            pulumi.set(__self__, "number_of_nodes", number_of_nodes)

    @property
    @pulumi.getter(name="nodeLists")
    def node_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListArgs']]]]:
        """
        - (Optional) List of nodes in a cluster.
        """
        return pulumi.get(self, "node_lists")

    @node_lists.setter
    def node_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListArgs']]]]):
        pulumi.set(self, "node_lists", value)

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_nodes")

    @number_of_nodes.setter
    def number_of_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_nodes", value)


if not MYPY:
    class ClusterV2NodeNodeListArgsDict(TypedDict):
        controller_vm_ips: pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpArgsDict']]]
        """
        - (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        host_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpArgsDict']]]]
        """
        - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        node_uuid: NotRequired[pulumi.Input[str]]
elif False:
    ClusterV2NodeNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListArgs:
    def __init__(__self__, *,
                 controller_vm_ips: pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpArgs']]],
                 host_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpArgs']]]] = None,
                 node_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpArgs']]] controller_vm_ips: - (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpArgs']]] host_ips: - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        pulumi.set(__self__, "controller_vm_ips", controller_vm_ips)
        if host_ips is not None:
            pulumi.set(__self__, "host_ips", host_ips)
        if node_uuid is not None:
            pulumi.set(__self__, "node_uuid", node_uuid)

    @property
    @pulumi.getter(name="controllerVmIps")
    def controller_vm_ips(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpArgs']]]:
        """
        - (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "controller_vm_ips")

    @controller_vm_ips.setter
    def controller_vm_ips(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpArgs']]]):
        pulumi.set(self, "controller_vm_ips", value)

    @property
    @pulumi.getter(name="hostIps")
    def host_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpArgs']]]]:
        """
        - (Optional) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "host_ips")

    @host_ips.setter
    def host_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpArgs']]]]):
        pulumi.set(self, "host_ips", value)

    @property
    @pulumi.getter(name="nodeUuid")
    def node_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_uuid")

    @node_uuid.setter
    def node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_uuid", value)


if not MYPY:
    class ClusterV2NodeNodeListControllerVmIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NodeNodeListControllerVmIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListControllerVmIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListControllerVmIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NodeNodeListControllerVmIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NodeNodeListControllerVmIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListControllerVmIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NodeNodeListControllerVmIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NodeNodeListControllerVmIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListControllerVmIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NodeNodeListHostIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv4ArgsDict']]]]
        """
        - (Optional) ip adresss params.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv6ArgsDict']]]]
        """
        - (Optional) Ip address params.
        """
elif False:
    ClusterV2NodeNodeListHostIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListHostIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv4Args']]] ipv4s: - (Optional) ip adresss params.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv6Args']]] ipv6s: - (Optional) Ip address params.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv4Args']]]]:
        """
        - (Optional) ip adresss params.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv6Args']]]]:
        """
        - (Optional) Ip address params.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2NodeNodeListHostIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClusterV2NodeNodeListHostIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NodeNodeListHostIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListHostIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClusterV2NodeNodeListHostIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
elif False:
    ClusterV2NodeNodeListHostIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2NodeNodeListHostIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - (Required) Ip address.
               
               See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        :param pulumi.Input[int] prefix_length: - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) Ip address.

        See detailed information in [Nutanix Cluster Entity V4](https://developers.nutanix.com/api-reference?namespace=clustermgmt&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2IpFilterListArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2IpFilterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2IpFilterListArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2IpFilterListIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeArgsDict(TypedDict):
        arch: NotRequired[pulumi.Input[str]]
        """
        Cluster arch type.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgsDict']]]]
        """
        Attributes of a node.
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Cluster ID.
        """
        cpu_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        CPU type.
        """
        current_cvm_vlan_tag: NotRequired[pulumi.Input[str]]
        """
        Current CVM VLAN tag.
        """
        current_network_interface: NotRequired[pulumi.Input[str]]
        """
        Current network interface of a node.
        """
        cvm_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgsDict']]]]
        """
        CVM IP.
        """
        foundation_version: NotRequired[pulumi.Input[str]]
        """
        Foundation version.
        """
        host_type: NotRequired[pulumi.Input[str]]
        """
        Host type.
        """
        hypervisor_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgsDict']]]]
        """
        Hypervisor IP Address.
        """
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        Hypervisor type.
        """
        hypervisor_version: NotRequired[pulumi.Input[str]]
        """
        Host version of the node.
        """
        interface_ipv6: NotRequired[pulumi.Input[str]]
        """
        Interface IPV6 address.
        """
        ipmi_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgsDict']]]]
        """
        IPMI IP Address.
        """
        is_secure_booted: NotRequired[pulumi.Input[bool]]
        """
        Secure boot status.
        """
        node_position: NotRequired[pulumi.Input[str]]
        """
        Position of a node in a rackable unit.
        """
        node_uuid: NotRequired[pulumi.Input[str]]
        """
        UUID of the host.
        """
        nos_version: NotRequired[pulumi.Input[str]]
        """
        NOS software version of a node.
        """
        rackable_unit_max_nodes: NotRequired[pulumi.Input[int]]
        """
        Maximum number of nodes in rackable-unit.
        """
        rackable_unit_model: NotRequired[pulumi.Input[str]]
        """
        Rackable unit model type.
        """
        rackable_unit_serial: NotRequired[pulumi.Input[str]]
        """
        Rackable unit serial name.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeArgs:
    def __init__(__self__, *,
                 arch: Optional[pulumi.Input[str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs']]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cpu_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 current_cvm_vlan_tag: Optional[pulumi.Input[str]] = None,
                 current_network_interface: Optional[pulumi.Input[str]] = None,
                 cvm_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs']]]] = None,
                 foundation_version: Optional[pulumi.Input[str]] = None,
                 host_type: Optional[pulumi.Input[str]] = None,
                 hypervisor_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs']]]] = None,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 hypervisor_version: Optional[pulumi.Input[str]] = None,
                 interface_ipv6: Optional[pulumi.Input[str]] = None,
                 ipmi_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs']]]] = None,
                 is_secure_booted: Optional[pulumi.Input[bool]] = None,
                 node_position: Optional[pulumi.Input[str]] = None,
                 node_uuid: Optional[pulumi.Input[str]] = None,
                 nos_version: Optional[pulumi.Input[str]] = None,
                 rackable_unit_max_nodes: Optional[pulumi.Input[int]] = None,
                 rackable_unit_model: Optional[pulumi.Input[str]] = None,
                 rackable_unit_serial: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] arch: Cluster arch type.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs']]] attributes: Attributes of a node.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cpu_types: CPU type.
        :param pulumi.Input[str] current_cvm_vlan_tag: Current CVM VLAN tag.
        :param pulumi.Input[str] current_network_interface: Current network interface of a node.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs']]] cvm_ips: CVM IP.
        :param pulumi.Input[str] foundation_version: Foundation version.
        :param pulumi.Input[str] host_type: Host type.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs']]] hypervisor_ips: Hypervisor IP Address.
        :param pulumi.Input[str] hypervisor_type: Hypervisor type.
        :param pulumi.Input[str] hypervisor_version: Host version of the node.
        :param pulumi.Input[str] interface_ipv6: Interface IPV6 address.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs']]] ipmi_ips: IPMI IP Address.
        :param pulumi.Input[bool] is_secure_booted: Secure boot status.
        :param pulumi.Input[str] node_position: Position of a node in a rackable unit.
        :param pulumi.Input[str] node_uuid: UUID of the host.
        :param pulumi.Input[str] nos_version: NOS software version of a node.
        :param pulumi.Input[int] rackable_unit_max_nodes: Maximum number of nodes in rackable-unit.
        :param pulumi.Input[str] rackable_unit_model: Rackable unit model type.
        :param pulumi.Input[str] rackable_unit_serial: Rackable unit serial name.
        """
        if arch is not None:
            pulumi.set(__self__, "arch", arch)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cpu_types is not None:
            pulumi.set(__self__, "cpu_types", cpu_types)
        if current_cvm_vlan_tag is not None:
            pulumi.set(__self__, "current_cvm_vlan_tag", current_cvm_vlan_tag)
        if current_network_interface is not None:
            pulumi.set(__self__, "current_network_interface", current_network_interface)
        if cvm_ips is not None:
            pulumi.set(__self__, "cvm_ips", cvm_ips)
        if foundation_version is not None:
            pulumi.set(__self__, "foundation_version", foundation_version)
        if host_type is not None:
            pulumi.set(__self__, "host_type", host_type)
        if hypervisor_ips is not None:
            pulumi.set(__self__, "hypervisor_ips", hypervisor_ips)
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if hypervisor_version is not None:
            pulumi.set(__self__, "hypervisor_version", hypervisor_version)
        if interface_ipv6 is not None:
            pulumi.set(__self__, "interface_ipv6", interface_ipv6)
        if ipmi_ips is not None:
            pulumi.set(__self__, "ipmi_ips", ipmi_ips)
        if is_secure_booted is not None:
            pulumi.set(__self__, "is_secure_booted", is_secure_booted)
        if node_position is not None:
            pulumi.set(__self__, "node_position", node_position)
        if node_uuid is not None:
            pulumi.set(__self__, "node_uuid", node_uuid)
        if nos_version is not None:
            pulumi.set(__self__, "nos_version", nos_version)
        if rackable_unit_max_nodes is not None:
            pulumi.set(__self__, "rackable_unit_max_nodes", rackable_unit_max_nodes)
        if rackable_unit_model is not None:
            pulumi.set(__self__, "rackable_unit_model", rackable_unit_model)
        if rackable_unit_serial is not None:
            pulumi.set(__self__, "rackable_unit_serial", rackable_unit_serial)

    @property
    @pulumi.getter
    def arch(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster arch type.
        """
        return pulumi.get(self, "arch")

    @arch.setter
    def arch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arch", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs']]]]:
        """
        Attributes of a node.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="cpuTypes")
    def cpu_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        CPU type.
        """
        return pulumi.get(self, "cpu_types")

    @cpu_types.setter
    def cpu_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cpu_types", value)

    @property
    @pulumi.getter(name="currentCvmVlanTag")
    def current_cvm_vlan_tag(self) -> Optional[pulumi.Input[str]]:
        """
        Current CVM VLAN tag.
        """
        return pulumi.get(self, "current_cvm_vlan_tag")

    @current_cvm_vlan_tag.setter
    def current_cvm_vlan_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_cvm_vlan_tag", value)

    @property
    @pulumi.getter(name="currentNetworkInterface")
    def current_network_interface(self) -> Optional[pulumi.Input[str]]:
        """
        Current network interface of a node.
        """
        return pulumi.get(self, "current_network_interface")

    @current_network_interface.setter
    def current_network_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_network_interface", value)

    @property
    @pulumi.getter(name="cvmIps")
    def cvm_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs']]]]:
        """
        CVM IP.
        """
        return pulumi.get(self, "cvm_ips")

    @cvm_ips.setter
    def cvm_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs']]]]):
        pulumi.set(self, "cvm_ips", value)

    @property
    @pulumi.getter(name="foundationVersion")
    def foundation_version(self) -> Optional[pulumi.Input[str]]:
        """
        Foundation version.
        """
        return pulumi.get(self, "foundation_version")

    @foundation_version.setter
    def foundation_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "foundation_version", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> Optional[pulumi.Input[str]]:
        """
        Host type.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="hypervisorIps")
    def hypervisor_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs']]]]:
        """
        Hypervisor IP Address.
        """
        return pulumi.get(self, "hypervisor_ips")

    @hypervisor_ips.setter
    def hypervisor_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs']]]]):
        pulumi.set(self, "hypervisor_ips", value)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        Hypervisor type.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter(name="hypervisorVersion")
    def hypervisor_version(self) -> Optional[pulumi.Input[str]]:
        """
        Host version of the node.
        """
        return pulumi.get(self, "hypervisor_version")

    @hypervisor_version.setter
    def hypervisor_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_version", value)

    @property
    @pulumi.getter(name="interfaceIpv6")
    def interface_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        Interface IPV6 address.
        """
        return pulumi.get(self, "interface_ipv6")

    @interface_ipv6.setter
    def interface_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_ipv6", value)

    @property
    @pulumi.getter(name="ipmiIps")
    def ipmi_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs']]]]:
        """
        IPMI IP Address.
        """
        return pulumi.get(self, "ipmi_ips")

    @ipmi_ips.setter
    def ipmi_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs']]]]):
        pulumi.set(self, "ipmi_ips", value)

    @property
    @pulumi.getter(name="isSecureBooted")
    def is_secure_booted(self) -> Optional[pulumi.Input[bool]]:
        """
        Secure boot status.
        """
        return pulumi.get(self, "is_secure_booted")

    @is_secure_booted.setter
    def is_secure_booted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_booted", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> Optional[pulumi.Input[str]]:
        """
        Position of a node in a rackable unit.
        """
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="nodeUuid")
    def node_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the host.
        """
        return pulumi.get(self, "node_uuid")

    @node_uuid.setter
    def node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_uuid", value)

    @property
    @pulumi.getter(name="nosVersion")
    def nos_version(self) -> Optional[pulumi.Input[str]]:
        """
        NOS software version of a node.
        """
        return pulumi.get(self, "nos_version")

    @nos_version.setter
    def nos_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nos_version", value)

    @property
    @pulumi.getter(name="rackableUnitMaxNodes")
    def rackable_unit_max_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of nodes in rackable-unit.
        """
        return pulumi.get(self, "rackable_unit_max_nodes")

    @rackable_unit_max_nodes.setter
    def rackable_unit_max_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rackable_unit_max_nodes", value)

    @property
    @pulumi.getter(name="rackableUnitModel")
    def rackable_unit_model(self) -> Optional[pulumi.Input[str]]:
        """
        Rackable unit model type.
        """
        return pulumi.get(self, "rackable_unit_model")

    @rackable_unit_model.setter
    def rackable_unit_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rackable_unit_model", value)

    @property
    @pulumi.getter(name="rackableUnitSerial")
    def rackable_unit_serial(self) -> Optional[pulumi.Input[str]]:
        """
        Rackable unit serial name.
        """
        return pulumi.get(self, "rackable_unit_serial")

    @rackable_unit_serial.setter
    def rackable_unit_serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rackable_unit_serial", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgsDict(TypedDict):
        default_workload: NotRequired[pulumi.Input[str]]
        """
        Default workload.
        """
        is_model_supported: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the model is supported or not.
        """
        is_robo_mixed_hypervisor: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the hypervisor is robo mixed or not.
        """
        lcm_family: NotRequired[pulumi.Input[str]]
        """
        LCM family name.
        """
        should_work_with1g_nic: NotRequired[pulumi.Input[bool]]
        """
        Indicates if cvm interface can work with 1 GIG NIC or not.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeAttributeArgs:
    def __init__(__self__, *,
                 default_workload: Optional[pulumi.Input[str]] = None,
                 is_model_supported: Optional[pulumi.Input[bool]] = None,
                 is_robo_mixed_hypervisor: Optional[pulumi.Input[bool]] = None,
                 lcm_family: Optional[pulumi.Input[str]] = None,
                 should_work_with1g_nic: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] default_workload: Default workload.
        :param pulumi.Input[bool] is_model_supported: Indicates whether the model is supported or not.
        :param pulumi.Input[bool] is_robo_mixed_hypervisor: Indicates whether the hypervisor is robo mixed or not.
        :param pulumi.Input[str] lcm_family: LCM family name.
        :param pulumi.Input[bool] should_work_with1g_nic: Indicates if cvm interface can work with 1 GIG NIC or not.
        """
        if default_workload is not None:
            pulumi.set(__self__, "default_workload", default_workload)
        if is_model_supported is not None:
            pulumi.set(__self__, "is_model_supported", is_model_supported)
        if is_robo_mixed_hypervisor is not None:
            pulumi.set(__self__, "is_robo_mixed_hypervisor", is_robo_mixed_hypervisor)
        if lcm_family is not None:
            pulumi.set(__self__, "lcm_family", lcm_family)
        if should_work_with1g_nic is not None:
            pulumi.set(__self__, "should_work_with1g_nic", should_work_with1g_nic)

    @property
    @pulumi.getter(name="defaultWorkload")
    def default_workload(self) -> Optional[pulumi.Input[str]]:
        """
        Default workload.
        """
        return pulumi.get(self, "default_workload")

    @default_workload.setter
    def default_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_workload", value)

    @property
    @pulumi.getter(name="isModelSupported")
    def is_model_supported(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the model is supported or not.
        """
        return pulumi.get(self, "is_model_supported")

    @is_model_supported.setter
    def is_model_supported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_model_supported", value)

    @property
    @pulumi.getter(name="isRoboMixedHypervisor")
    def is_robo_mixed_hypervisor(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the hypervisor is robo mixed or not.
        """
        return pulumi.get(self, "is_robo_mixed_hypervisor")

    @is_robo_mixed_hypervisor.setter
    def is_robo_mixed_hypervisor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_robo_mixed_hypervisor", value)

    @property
    @pulumi.getter(name="lcmFamily")
    def lcm_family(self) -> Optional[pulumi.Input[str]]:
        """
        LCM family name.
        """
        return pulumi.get(self, "lcm_family")

    @lcm_family.setter
    def lcm_family(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lcm_family", value)

    @property
    @pulumi.getter(name="shouldWorkWith1gNic")
    def should_work_with1g_nic(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if cvm interface can work with 1 GIG NIC or not.
        """
        return pulumi.get(self, "should_work_with1g_nic")

    @should_work_with1g_nic.setter
    def should_work_with1g_nic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_work_with1g_nic", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args']]] ipv4s: An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args']]] ipv6s: An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeCvmIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args']]] ipv4s: An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args']]] ipv6s: An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeHypervisorIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args']]] ipv4s: An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args']]] ipv6s: An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersDiscoverUnconfiguredNodesV2UnconfiguredNodeIpmiIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListArgsDict(TypedDict):
        block_id: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Block ID.
        """
        current_network_interface: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Current network interface.
        """
        cvm_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgsDict']]]]
        """
        -(Optional) CVM IP.
        """
        digital_certificate_map_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgsDict']]]]
        """
        -(Optional) Digital certificate map list.
        """
        hypervisor_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgsDict']]]]
        """
        -(Optional) Hypervisor IP.
        """
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Hypervisor type.
        """
        hypervisor_version: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Hypervisor version.
        """
        ipmi_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgsDict']]]]
        """
        -(Optional) IPMI IP.
        """
        is_compute_only: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Is compute only.
        """
        is_light_compute: NotRequired[pulumi.Input[bool]]
        is_robo_mixed_hypervisor: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Is ROBO mixed hypervisor.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Model name.
        """
        node_position: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Node position.
        """
        node_uuid: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Node UUID.
        """
        nos_version: NotRequired[pulumi.Input[str]]
        """
        -(Optional) NOS version.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListArgs:
    def __init__(__self__, *,
                 block_id: Optional[pulumi.Input[str]] = None,
                 current_network_interface: Optional[pulumi.Input[str]] = None,
                 cvm_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs']]]] = None,
                 digital_certificate_map_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs']]]] = None,
                 hypervisor_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs']]]] = None,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 hypervisor_version: Optional[pulumi.Input[str]] = None,
                 ipmi_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs']]]] = None,
                 is_compute_only: Optional[pulumi.Input[bool]] = None,
                 is_light_compute: Optional[pulumi.Input[bool]] = None,
                 is_robo_mixed_hypervisor: Optional[pulumi.Input[bool]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 node_position: Optional[pulumi.Input[str]] = None,
                 node_uuid: Optional[pulumi.Input[str]] = None,
                 nos_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_id: -(Optional) Block ID.
        :param pulumi.Input[str] current_network_interface: -(Optional) Current network interface.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs']]] cvm_ips: -(Optional) CVM IP.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs']]] digital_certificate_map_lists: -(Optional) Digital certificate map list.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs']]] hypervisor_ips: -(Optional) Hypervisor IP.
        :param pulumi.Input[str] hypervisor_type: -(Optional) Hypervisor type.
        :param pulumi.Input[str] hypervisor_version: -(Optional) Hypervisor version.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs']]] ipmi_ips: -(Optional) IPMI IP.
        :param pulumi.Input[bool] is_compute_only: -(Optional) Is compute only.
        :param pulumi.Input[bool] is_robo_mixed_hypervisor: -(Optional) Is ROBO mixed hypervisor.
        :param pulumi.Input[str] model: -(Optional) Model name.
        :param pulumi.Input[str] node_position: -(Optional) Node position.
        :param pulumi.Input[str] node_uuid: -(Optional) Node UUID.
        :param pulumi.Input[str] nos_version: -(Optional) NOS version.
        """
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)
        if current_network_interface is not None:
            pulumi.set(__self__, "current_network_interface", current_network_interface)
        if cvm_ips is not None:
            pulumi.set(__self__, "cvm_ips", cvm_ips)
        if digital_certificate_map_lists is not None:
            pulumi.set(__self__, "digital_certificate_map_lists", digital_certificate_map_lists)
        if hypervisor_ips is not None:
            pulumi.set(__self__, "hypervisor_ips", hypervisor_ips)
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if hypervisor_version is not None:
            pulumi.set(__self__, "hypervisor_version", hypervisor_version)
        if ipmi_ips is not None:
            pulumi.set(__self__, "ipmi_ips", ipmi_ips)
        if is_compute_only is not None:
            pulumi.set(__self__, "is_compute_only", is_compute_only)
        if is_light_compute is not None:
            pulumi.set(__self__, "is_light_compute", is_light_compute)
        if is_robo_mixed_hypervisor is not None:
            pulumi.set(__self__, "is_robo_mixed_hypervisor", is_robo_mixed_hypervisor)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if node_position is not None:
            pulumi.set(__self__, "node_position", node_position)
        if node_uuid is not None:
            pulumi.set(__self__, "node_uuid", node_uuid)
        if nos_version is not None:
            pulumi.set(__self__, "nos_version", nos_version)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Block ID.
        """
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)

    @property
    @pulumi.getter(name="currentNetworkInterface")
    def current_network_interface(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Current network interface.
        """
        return pulumi.get(self, "current_network_interface")

    @current_network_interface.setter
    def current_network_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_network_interface", value)

    @property
    @pulumi.getter(name="cvmIps")
    def cvm_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs']]]]:
        """
        -(Optional) CVM IP.
        """
        return pulumi.get(self, "cvm_ips")

    @cvm_ips.setter
    def cvm_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs']]]]):
        pulumi.set(self, "cvm_ips", value)

    @property
    @pulumi.getter(name="digitalCertificateMapLists")
    def digital_certificate_map_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs']]]]:
        """
        -(Optional) Digital certificate map list.
        """
        return pulumi.get(self, "digital_certificate_map_lists")

    @digital_certificate_map_lists.setter
    def digital_certificate_map_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs']]]]):
        pulumi.set(self, "digital_certificate_map_lists", value)

    @property
    @pulumi.getter(name="hypervisorIps")
    def hypervisor_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs']]]]:
        """
        -(Optional) Hypervisor IP.
        """
        return pulumi.get(self, "hypervisor_ips")

    @hypervisor_ips.setter
    def hypervisor_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs']]]]):
        pulumi.set(self, "hypervisor_ips", value)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Hypervisor type.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter(name="hypervisorVersion")
    def hypervisor_version(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Hypervisor version.
        """
        return pulumi.get(self, "hypervisor_version")

    @hypervisor_version.setter
    def hypervisor_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_version", value)

    @property
    @pulumi.getter(name="ipmiIps")
    def ipmi_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs']]]]:
        """
        -(Optional) IPMI IP.
        """
        return pulumi.get(self, "ipmi_ips")

    @ipmi_ips.setter
    def ipmi_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs']]]]):
        pulumi.set(self, "ipmi_ips", value)

    @property
    @pulumi.getter(name="isComputeOnly")
    def is_compute_only(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Is compute only.
        """
        return pulumi.get(self, "is_compute_only")

    @is_compute_only.setter
    def is_compute_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_compute_only", value)

    @property
    @pulumi.getter(name="isLightCompute")
    def is_light_compute(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_light_compute")

    @is_light_compute.setter
    def is_light_compute(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_light_compute", value)

    @property
    @pulumi.getter(name="isRoboMixedHypervisor")
    def is_robo_mixed_hypervisor(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Is ROBO mixed hypervisor.
        """
        return pulumi.get(self, "is_robo_mixed_hypervisor")

    @is_robo_mixed_hypervisor.setter
    def is_robo_mixed_hypervisor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_robo_mixed_hypervisor", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Model name.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Node position.
        """
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="nodeUuid")
    def node_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Node UUID.
        """
        return pulumi.get(self, "node_uuid")

    @node_uuid.setter
    def node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_uuid", value)

    @property
    @pulumi.getter(name="nosVersion")
    def nos_version(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) NOS version.
        """
        return pulumi.get(self, "nos_version")

    @nos_version.setter
    def nos_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nos_version", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListCvmIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListDigitalCertificateMapListArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) Field containing digital_certificate_base64 and key_management_server_uuid for key management server.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListHypervisorIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodeListIpmiIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailArgsDict(TypedDict):
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgsDict']]]]
        """
        - Network information for the given nodes.
        """
        uplinks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgsDict']]]]
        """
        - List of uplinks information for each CVM IP.
        """
        warnings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - List of warning messages.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailArgs:
    def __init__(__self__, *,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs']]]] = None,
                 uplinks: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs']]]] = None,
                 warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs']]] network_infos: - Network information for the given nodes.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs']]] uplinks: - List of uplinks information for each CVM IP.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] warnings: - List of warning messages.
        """
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)
        if uplinks is not None:
            pulumi.set(__self__, "uplinks", uplinks)
        if warnings is not None:
            pulumi.set(__self__, "warnings", warnings)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs']]]]:
        """
        - Network information for the given nodes.
        """
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)

    @property
    @pulumi.getter
    def uplinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs']]]]:
        """
        - List of uplinks information for each CVM IP.
        """
        return pulumi.get(self, "uplinks")

    @uplinks.setter
    def uplinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs']]]]):
        pulumi.set(self, "uplinks", value)

    @property
    @pulumi.getter
    def warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List of warning messages.
        """
        return pulumi.get(self, "warnings")

    @warnings.setter
    def warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "warnings", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgsDict(TypedDict):
        hcis: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgsDict']]]]
        """
        - Network information of HCI nodes.
        """
        sos: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgsDict']]]]
        """
        - Network information of SO nodes.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoArgs:
    def __init__(__self__, *,
                 hcis: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs']]]] = None,
                 sos: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs']]] hcis: - Network information of HCI nodes.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs']]] sos: - Network information of SO nodes.
        """
        if hcis is not None:
            pulumi.set(__self__, "hcis", hcis)
        if sos is not None:
            pulumi.set(__self__, "sos", sos)

    @property
    @pulumi.getter
    def hcis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs']]]]:
        """
        - Network information of HCI nodes.
        """
        return pulumi.get(self, "hcis")

    @hcis.setter
    def hcis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs']]]]):
        pulumi.set(self, "hcis", value)

    @property
    @pulumi.getter
    def sos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs']]]]:
        """
        - Network information of SO nodes.
        """
        return pulumi.get(self, "sos")

    @sos.setter
    def sos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs']]]]):
        pulumi.set(self, "sos", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgsDict(TypedDict):
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        - Hypervisor type.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - Interface name.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - List of networks for interface.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoHciArgs:
    def __init__(__self__, *,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] hypervisor_type: - Hypervisor type.
        :param pulumi.Input[str] name: - Interface name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: - List of networks for interface.
        """
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        - Hypervisor type.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - Interface name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List of networks for interface.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgsDict(TypedDict):
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        - Hypervisor type.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - Interface name.
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - List of networks for interface.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailNetworkInfoSoArgs:
    def __init__(__self__, *,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] hypervisor_type: - Hypervisor type.
        :param pulumi.Input[str] name: - Interface name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: - List of networks for interface.
        """
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        - Hypervisor type.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - Interface name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - List of networks for interface.
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgsDict(TypedDict):
        cvm_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        uplink_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgsDict']]]]
        """
        - Uplink details for a controller VM.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkArgs:
    def __init__(__self__, *,
                 cvm_ips: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs']]]] = None,
                 uplink_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs']]] cvm_ips: - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs']]] uplink_lists: - Uplink details for a controller VM.
        """
        if cvm_ips is not None:
            pulumi.set(__self__, "cvm_ips", cvm_ips)
        if uplink_lists is not None:
            pulumi.set(__self__, "uplink_lists", uplink_lists)

    @property
    @pulumi.getter(name="cvmIps")
    def cvm_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "cvm_ips")

    @cvm_ips.setter
    def cvm_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs']]]]):
        pulumi.set(self, "cvm_ips", value)

    @property
    @pulumi.getter(name="uplinkLists")
    def uplink_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs']]]]:
        """
        - Uplink details for a controller VM.
        """
        return pulumi.get(self, "uplink_lists")

    @uplink_lists.setter
    def uplink_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs']]]]):
        pulumi.set(self, "uplink_lists", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6ArgsDict']]]]
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args']]] ipv4s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args']]] ipv6s: -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args']]]]:
        """
        -(Optional) An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkCvmIpIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: -(Required) The IPv4/IPv6 address of the host.
        :param pulumi.Input[int] prefix_length: -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        -(Required) The IPv4/IPv6 address of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        -(Optional) The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgsDict(TypedDict):
        mac: NotRequired[pulumi.Input[str]]
        """
        - MAC address.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - Interface name.
        """
elif False:
    ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClustersUnconfiguredNodeNetworksV2NodesNetworkingDetailUplinkUplinkListArgs:
    def __init__(__self__, *,
                 mac: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mac: - MAC address.
        :param pulumi.Input[str] name: - Interface name.
        """
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def mac(self) -> Optional[pulumi.Input[str]]:
        """
        - MAC address.
        """
        return pulumi.get(self, "mac")

    @mac.setter
    def mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - Interface name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapArgsDict(TypedDict):
        guest_customizations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgsDict']]]]
        memory_size_bytes: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicArgsDict']]]]
        num_cores_per_socket: NotRequired[pulumi.Input[int]]
        num_sockets: NotRequired[pulumi.Input[int]]
        num_threads_per_core: NotRequired[pulumi.Input[int]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapArgs:
    def __init__(__self__, *,
                 guest_customizations: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgs']]]] = None,
                 memory_size_bytes: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nics: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicArgs']]]] = None,
                 num_cores_per_socket: Optional[pulumi.Input[int]] = None,
                 num_sockets: Optional[pulumi.Input[int]] = None,
                 num_threads_per_core: Optional[pulumi.Input[int]] = None):
        if guest_customizations is not None:
            pulumi.set(__self__, "guest_customizations", guest_customizations)
        if memory_size_bytes is not None:
            pulumi.set(__self__, "memory_size_bytes", memory_size_bytes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if num_cores_per_socket is not None:
            pulumi.set(__self__, "num_cores_per_socket", num_cores_per_socket)
        if num_sockets is not None:
            pulumi.set(__self__, "num_sockets", num_sockets)
        if num_threads_per_core is not None:
            pulumi.set(__self__, "num_threads_per_core", num_threads_per_core)

    @property
    @pulumi.getter(name="guestCustomizations")
    def guest_customizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgs']]]]:
        return pulumi.get(self, "guest_customizations")

    @guest_customizations.setter
    def guest_customizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgs']]]]):
        pulumi.set(self, "guest_customizations", value)

    @property
    @pulumi.getter(name="memorySizeBytes")
    def memory_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_size_bytes")

    @memory_size_bytes.setter
    def memory_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_size_bytes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicArgs']]]]:
        return pulumi.get(self, "nics")

    @nics.setter
    def nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicArgs']]]]):
        pulumi.set(self, "nics", value)

    @property
    @pulumi.getter(name="numCoresPerSocket")
    def num_cores_per_socket(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cores_per_socket")

    @num_cores_per_socket.setter
    def num_cores_per_socket(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cores_per_socket", value)

    @property
    @pulumi.getter(name="numSockets")
    def num_sockets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_sockets")

    @num_sockets.setter
    def num_sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_sockets", value)

    @property
    @pulumi.getter(name="numThreadsPerCore")
    def num_threads_per_core(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_threads_per_core")

    @num_threads_per_core.setter
    def num_threads_per_core(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_threads_per_core", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgs']]]] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgs']]]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgs']]]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgs']]]]:
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgsDict(TypedDict):
        is_connected: NotRequired[pulumi.Input[bool]]
        mac_address: NotRequired[pulumi.Input[str]]
        model: NotRequired[pulumi.Input[str]]
        num_queues: NotRequired[pulumi.Input[int]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicBackingInfoArgs:
    def __init__(__self__, *,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None):
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgsDict(TypedDict):
        ipv4_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgsDict']]]]
        ipv4_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgsDict']]]]
        network_function_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgsDict']]]]
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        nic_type: NotRequired[pulumi.Input[str]]
        should_allow_unknown_macs: NotRequired[pulumi.Input[bool]]
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgsDict']]]]
        trunked_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        vlan_mode: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoArgs:
    def __init__(__self__, *,
                 ipv4_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgs']]]] = None,
                 ipv4_infos: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgs']]]] = None,
                 network_function_chains: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgs']]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 should_allow_unknown_macs: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgs']]]] = None,
                 trunked_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 vlan_mode: Optional[pulumi.Input[str]] = None):
        if ipv4_configs is not None:
            pulumi.set(__self__, "ipv4_configs", ipv4_configs)
        if ipv4_infos is not None:
            pulumi.set(__self__, "ipv4_infos", ipv4_infos)
        if network_function_chains is not None:
            pulumi.set(__self__, "network_function_chains", network_function_chains)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if should_allow_unknown_macs is not None:
            pulumi.set(__self__, "should_allow_unknown_macs", should_allow_unknown_macs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if trunked_vlans is not None:
            pulumi.set(__self__, "trunked_vlans", trunked_vlans)
        if vlan_mode is not None:
            pulumi.set(__self__, "vlan_mode", vlan_mode)

    @property
    @pulumi.getter(name="ipv4Configs")
    def ipv4_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgs']]]]:
        return pulumi.get(self, "ipv4_configs")

    @ipv4_configs.setter
    def ipv4_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgs']]]]):
        pulumi.set(self, "ipv4_configs", value)

    @property
    @pulumi.getter(name="ipv4Infos")
    def ipv4_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgs']]]]:
        return pulumi.get(self, "ipv4_infos")

    @ipv4_infos.setter
    def ipv4_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgs']]]]):
        pulumi.set(self, "ipv4_infos", value)

    @property
    @pulumi.getter(name="networkFunctionChains")
    def network_function_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgs']]]]:
        return pulumi.get(self, "network_function_chains")

    @network_function_chains.setter
    def network_function_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgs']]]]):
        pulumi.set(self, "network_function_chains", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="shouldAllowUnknownMacs")
    def should_allow_unknown_macs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allow_unknown_macs")

    @should_allow_unknown_macs.setter
    def should_allow_unknown_macs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_unknown_macs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgs']]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="trunkedVlans")
    def trunked_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "trunked_vlans")

    @trunked_vlans.setter
    def trunked_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "trunked_vlans", value)

    @property
    @pulumi.getter(name="vlanMode")
    def vlan_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_mode")

    @vlan_mode.setter
    def vlan_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_mode", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgsDict']]]]
        secondary_ip_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict']]]]
        should_assign_ip: NotRequired[pulumi.Input[bool]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgs']]]] = None,
                 secondary_ip_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]] = None,
                 should_assign_ip: Optional[pulumi.Input[bool]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if secondary_ip_address_lists is not None:
            pulumi.set(__self__, "secondary_ip_address_lists", secondary_ip_address_lists)
        if should_assign_ip is not None:
            pulumi.set(__self__, "should_assign_ip", should_assign_ip)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="secondaryIpAddressLists")
    def secondary_ip_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]:
        return pulumi.get(self, "secondary_ip_address_lists")

    @secondary_ip_address_lists.setter
    def secondary_ip_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]):
        pulumi.set(self, "secondary_ip_address_lists", value)

    @property
    @pulumi.getter(name="shouldAssignIp")
    def should_assign_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_assign_ip")

    @should_assign_ip.setter
    def should_assign_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_assign_ip", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgsDict(TypedDict):
        learned_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict']]]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoArgs:
    def __init__(__self__, *,
                 learned_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]] = None):
        if learned_ip_addresses is not None:
            pulumi.set(__self__, "learned_ip_addresses", learned_ip_addresses)

    @property
    @pulumi.getter(name="learnedIpAddresses")
    def learned_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]:
        return pulumi.get(self, "learned_ip_addresses")

    @learned_ip_addresses.setter
    def learned_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]):
        pulumi.set(self, "learned_ip_addresses", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoIpv4InfoLearnedIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoNetworkFunctionChainArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeployTemplatesV2OverrideVmConfigMapNicNetworkInfoSubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class DirectoryServicesV2OpenLdapConfigurationArgsDict(TypedDict):
        user_configurations: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgsDict']]]
        """
        -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        user_group_configurations: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgsDict']]]
        """
        -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
elif False:
    DirectoryServicesV2OpenLdapConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryServicesV2OpenLdapConfigurationArgs:
    def __init__(__self__, *,
                 user_configurations: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs']]],
                 user_group_configurations: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs']]] user_configurations: -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        :param pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs']]] user_group_configurations: -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        pulumi.set(__self__, "user_configurations", user_configurations)
        pulumi.set(__self__, "user_group_configurations", user_group_configurations)

    @property
    @pulumi.getter(name="userConfigurations")
    def user_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs']]]:
        """
        -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        return pulumi.get(self, "user_configurations")

    @user_configurations.setter
    def user_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs']]]):
        pulumi.set(self, "user_configurations", value)

    @property
    @pulumi.getter(name="userGroupConfigurations")
    def user_group_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs']]]:
        """
        -(Required) this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        return pulumi.get(self, "user_group_configurations")

    @user_group_configurations.setter
    def user_group_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs']]]):
        pulumi.set(self, "user_group_configurations", value)


if not MYPY:
    class DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgsDict(TypedDict):
        user_object_class: pulumi.Input[str]
        """
        -(Required) Object class in the OpenLDAP system that corresponds to Users.
        """
        user_search_base: pulumi.Input[str]
        """
        -(Required) Base DN for User search.
        """
        username_attribute: pulumi.Input[str]
        """
        -(Required) Unique Identifier for each User which can be used in Authentication.
        """
elif False:
    DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryServicesV2OpenLdapConfigurationUserConfigurationArgs:
    def __init__(__self__, *,
                 user_object_class: pulumi.Input[str],
                 user_search_base: pulumi.Input[str],
                 username_attribute: pulumi.Input[str]):
        """
        :param pulumi.Input[str] user_object_class: -(Required) Object class in the OpenLDAP system that corresponds to Users.
        :param pulumi.Input[str] user_search_base: -(Required) Base DN for User search.
        :param pulumi.Input[str] username_attribute: -(Required) Unique Identifier for each User which can be used in Authentication.
        """
        pulumi.set(__self__, "user_object_class", user_object_class)
        pulumi.set(__self__, "user_search_base", user_search_base)
        pulumi.set(__self__, "username_attribute", username_attribute)

    @property
    @pulumi.getter(name="userObjectClass")
    def user_object_class(self) -> pulumi.Input[str]:
        """
        -(Required) Object class in the OpenLDAP system that corresponds to Users.
        """
        return pulumi.get(self, "user_object_class")

    @user_object_class.setter
    def user_object_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_object_class", value)

    @property
    @pulumi.getter(name="userSearchBase")
    def user_search_base(self) -> pulumi.Input[str]:
        """
        -(Required) Base DN for User search.
        """
        return pulumi.get(self, "user_search_base")

    @user_search_base.setter
    def user_search_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_search_base", value)

    @property
    @pulumi.getter(name="usernameAttribute")
    def username_attribute(self) -> pulumi.Input[str]:
        """
        -(Required) Unique Identifier for each User which can be used in Authentication.
        """
        return pulumi.get(self, "username_attribute")

    @username_attribute.setter
    def username_attribute(self, value: pulumi.Input[str]):
        pulumi.set(self, "username_attribute", value)


if not MYPY:
    class DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgsDict(TypedDict):
        group_member_attribute: pulumi.Input[str]
        """
        -(Required) Attribute in a group that associates Users to the group.
        """
        group_member_attribute_value: pulumi.Input[str]
        """
        -(Required) User attribute value that will be used in group entity to associate User to the group.
        """
        group_object_class: pulumi.Input[str]
        """
        -(Required) Object class in the OpenLDAP system that corresponds to groups.
        """
        group_search_base: pulumi.Input[str]
        """
        -(Required) Base DN for group search.
        """
elif False:
    DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryServicesV2OpenLdapConfigurationUserGroupConfigurationArgs:
    def __init__(__self__, *,
                 group_member_attribute: pulumi.Input[str],
                 group_member_attribute_value: pulumi.Input[str],
                 group_object_class: pulumi.Input[str],
                 group_search_base: pulumi.Input[str]):
        """
        :param pulumi.Input[str] group_member_attribute: -(Required) Attribute in a group that associates Users to the group.
        :param pulumi.Input[str] group_member_attribute_value: -(Required) User attribute value that will be used in group entity to associate User to the group.
        :param pulumi.Input[str] group_object_class: -(Required) Object class in the OpenLDAP system that corresponds to groups.
        :param pulumi.Input[str] group_search_base: -(Required) Base DN for group search.
        """
        pulumi.set(__self__, "group_member_attribute", group_member_attribute)
        pulumi.set(__self__, "group_member_attribute_value", group_member_attribute_value)
        pulumi.set(__self__, "group_object_class", group_object_class)
        pulumi.set(__self__, "group_search_base", group_search_base)

    @property
    @pulumi.getter(name="groupMemberAttribute")
    def group_member_attribute(self) -> pulumi.Input[str]:
        """
        -(Required) Attribute in a group that associates Users to the group.
        """
        return pulumi.get(self, "group_member_attribute")

    @group_member_attribute.setter
    def group_member_attribute(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_member_attribute", value)

    @property
    @pulumi.getter(name="groupMemberAttributeValue")
    def group_member_attribute_value(self) -> pulumi.Input[str]:
        """
        -(Required) User attribute value that will be used in group entity to associate User to the group.
        """
        return pulumi.get(self, "group_member_attribute_value")

    @group_member_attribute_value.setter
    def group_member_attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_member_attribute_value", value)

    @property
    @pulumi.getter(name="groupObjectClass")
    def group_object_class(self) -> pulumi.Input[str]:
        """
        -(Required) Object class in the OpenLDAP system that corresponds to groups.
        """
        return pulumi.get(self, "group_object_class")

    @group_object_class.setter
    def group_object_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_object_class", value)

    @property
    @pulumi.getter(name="groupSearchBase")
    def group_search_base(self) -> pulumi.Input[str]:
        """
        -(Required) Base DN for group search.
        """
        return pulumi.get(self, "group_search_base")

    @group_search_base.setter
    def group_search_base(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_search_base", value)


if not MYPY:
    class DirectoryServicesV2ServiceAccountArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        -(Required) Password to connect to the Directory Service.
        """
        username: pulumi.Input[str]
        """
        -(Required) Username to connect to the Directory Service.
        """
elif False:
    DirectoryServicesV2ServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DirectoryServicesV2ServiceAccountArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: -(Required) Password to connect to the Directory Service.
        :param pulumi.Input[str] username: -(Required) Username to connect to the Directory Service.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        -(Required) Password to connect to the Directory Service.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        -(Required) Username to connect to the Directory Service.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class FloatingIpV2AssociationArgsDict(TypedDict):
        private_ip_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationArgsDict']]]]
        """
        Association of Floating IP with private IP
        - `private_ip_association.vpc_reference`: (Required) VPC in which the private IP exists.
        - `private_ip_association.private_ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        vm_nic_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationVmNicAssociationArgsDict']]]]
        """
        Association of Floating IP with nic
        - `vm_nic_association.vm_nic_reference`: (Required) VM NIC reference.
        - `vm_nic_association.vpc_reference`: (Optional) VPC reference to which the VM NIC subnet belongs.
        """
elif False:
    FloatingIpV2AssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationArgs:
    def __init__(__self__, *,
                 private_ip_associations: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationArgs']]]] = None,
                 vm_nic_associations: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationVmNicAssociationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationArgs']]] private_ip_associations: Association of Floating IP with private IP
               - `private_ip_association.vpc_reference`: (Required) VPC in which the private IP exists.
               - `private_ip_association.private_ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationVmNicAssociationArgs']]] vm_nic_associations: Association of Floating IP with nic
               - `vm_nic_association.vm_nic_reference`: (Required) VM NIC reference.
               - `vm_nic_association.vpc_reference`: (Optional) VPC reference to which the VM NIC subnet belongs.
        """
        if private_ip_associations is not None:
            pulumi.set(__self__, "private_ip_associations", private_ip_associations)
        if vm_nic_associations is not None:
            pulumi.set(__self__, "vm_nic_associations", vm_nic_associations)

    @property
    @pulumi.getter(name="privateIpAssociations")
    def private_ip_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationArgs']]]]:
        """
        Association of Floating IP with private IP
        - `private_ip_association.vpc_reference`: (Required) VPC in which the private IP exists.
        - `private_ip_association.private_ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 or IPv6 format.
        """
        return pulumi.get(self, "private_ip_associations")

    @private_ip_associations.setter
    def private_ip_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationArgs']]]]):
        pulumi.set(self, "private_ip_associations", value)

    @property
    @pulumi.getter(name="vmNicAssociations")
    def vm_nic_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationVmNicAssociationArgs']]]]:
        """
        Association of Floating IP with nic
        - `vm_nic_association.vm_nic_reference`: (Required) VM NIC reference.
        - `vm_nic_association.vpc_reference`: (Optional) VPC reference to which the VM NIC subnet belongs.
        """
        return pulumi.get(self, "vm_nic_associations")

    @vm_nic_associations.setter
    def vm_nic_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationVmNicAssociationArgs']]]]):
        pulumi.set(self, "vm_nic_associations", value)


if not MYPY:
    class FloatingIpV2AssociationPrivateIpAssociationArgsDict(TypedDict):
        private_ips: pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgsDict']]]
        vpc_reference: pulumi.Input[str]
        """
        VPC reference UUID
        """
elif False:
    FloatingIpV2AssociationPrivateIpAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationPrivateIpAssociationArgs:
    def __init__(__self__, *,
                 private_ips: pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgs']]],
                 vpc_reference: pulumi.Input[str]):
        """
        :param pulumi.Input[str] vpc_reference: VPC reference UUID
        """
        pulumi.set(__self__, "private_ips", private_ips)
        pulumi.set(__self__, "vpc_reference", vpc_reference)

    @property
    @pulumi.getter(name="privateIps")
    def private_ips(self) -> pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgs']]]:
        return pulumi.get(self, "private_ips")

    @private_ips.setter
    def private_ips(self, value: pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgs']]]):
        pulumi.set(self, "private_ips", value)

    @property
    @pulumi.getter(name="vpcReference")
    def vpc_reference(self) -> pulumi.Input[str]:
        """
        VPC reference UUID
        """
        return pulumi.get(self, "vpc_reference")

    @vpc_reference.setter
    def vpc_reference(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_reference", value)


if not MYPY:
    class FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationPrivateIpAssociationPrivateIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationPrivateIpAssociationPrivateIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2AssociationVmNicAssociationArgsDict(TypedDict):
        vm_nic_reference: pulumi.Input[str]
        """
        VM NIC reference.
        """
        vpc_reference: NotRequired[pulumi.Input[str]]
        """
        VPC reference UUID
        """
elif False:
    FloatingIpV2AssociationVmNicAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2AssociationVmNicAssociationArgs:
    def __init__(__self__, *,
                 vm_nic_reference: pulumi.Input[str],
                 vpc_reference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vm_nic_reference: VM NIC reference.
        :param pulumi.Input[str] vpc_reference: VPC reference UUID
        """
        pulumi.set(__self__, "vm_nic_reference", vm_nic_reference)
        if vpc_reference is not None:
            pulumi.set(__self__, "vpc_reference", vpc_reference)

    @property
    @pulumi.getter(name="vmNicReference")
    def vm_nic_reference(self) -> pulumi.Input[str]:
        """
        VM NIC reference.
        """
        return pulumi.get(self, "vm_nic_reference")

    @vm_nic_reference.setter
    def vm_nic_reference(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_nic_reference", value)

    @property
    @pulumi.getter(name="vpcReference")
    def vpc_reference(self) -> Optional[pulumi.Input[str]]:
        """
        VPC reference UUID
        """
        return pulumi.get(self, "vpc_reference")

    @vpc_reference.setter
    def vpc_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_reference", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
        bridge_name: NotRequired[pulumi.Input[str]]
        cluster_name: NotRequired[pulumi.Input[str]]
        cluster_reference: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        Description for the Floating IP.
        """
        dhcp_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionArgsDict']]]]
        dynamic_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressArgsDict']]]]
        hypervisor_type: NotRequired[pulumi.Input[str]]
        ip_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigArgsDict']]]]
        ip_prefix: NotRequired[pulumi.Input[str]]
        ip_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageArgsDict']]]]
        is_advanced_networking: NotRequired[pulumi.Input[bool]]
        is_external: NotRequired[pulumi.Input[bool]]
        is_nat_enabled: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        migration_state: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the floating IP.
        """
        network_function_chain_reference: NotRequired[pulumi.Input[str]]
        network_id: NotRequired[pulumi.Input[int]]
        reserved_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetReservedIpAddressArgsDict']]]]
        subnet_type: NotRequired[pulumi.Input[str]]
        virtual_switch_reference: NotRequired[pulumi.Input[str]]
        virtual_switches: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchArgsDict']]]]
        vpc_reference: NotRequired[pulumi.Input[str]]
        """
        VPC reference UUID
        """
        vpcs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcArgsDict']]]]
        """
        Networking common base object
        """
elif False:
    FloatingIpV2ExternalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str],
                 bridge_name: Optional[pulumi.Input[str]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 cluster_reference: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 dhcp_options: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionArgs']]]] = None,
                 dynamic_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressArgs']]]] = None,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 ip_configs: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigArgs']]]] = None,
                 ip_prefix: Optional[pulumi.Input[str]] = None,
                 ip_usages: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageArgs']]]] = None,
                 is_advanced_networking: Optional[pulumi.Input[bool]] = None,
                 is_external: Optional[pulumi.Input[bool]] = None,
                 is_nat_enabled: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetLinkArgs']]]] = None,
                 migration_state: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[int]] = None,
                 reserved_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetReservedIpAddressArgs']]]] = None,
                 subnet_type: Optional[pulumi.Input[str]] = None,
                 virtual_switch_reference: Optional[pulumi.Input[str]] = None,
                 virtual_switches: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchArgs']]]] = None,
                 vpc_reference: Optional[pulumi.Input[str]] = None,
                 vpcs: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcArgs']]]] = None):
        """
        :param pulumi.Input[str] description: Description for the Floating IP.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[str] name: Name of the floating IP.
        :param pulumi.Input[str] vpc_reference: VPC reference UUID
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcArgs']]] vpcs: Networking common base object
        """
        pulumi.set(__self__, "ext_id", ext_id)
        if bridge_name is not None:
            pulumi.set(__self__, "bridge_name", bridge_name)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_reference is not None:
            pulumi.set(__self__, "cluster_reference", cluster_reference)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dhcp_options is not None:
            pulumi.set(__self__, "dhcp_options", dhcp_options)
        if dynamic_ip_addresses is not None:
            pulumi.set(__self__, "dynamic_ip_addresses", dynamic_ip_addresses)
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if ip_configs is not None:
            pulumi.set(__self__, "ip_configs", ip_configs)
        if ip_prefix is not None:
            pulumi.set(__self__, "ip_prefix", ip_prefix)
        if ip_usages is not None:
            pulumi.set(__self__, "ip_usages", ip_usages)
        if is_advanced_networking is not None:
            pulumi.set(__self__, "is_advanced_networking", is_advanced_networking)
        if is_external is not None:
            pulumi.set(__self__, "is_external", is_external)
        if is_nat_enabled is not None:
            pulumi.set(__self__, "is_nat_enabled", is_nat_enabled)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if migration_state is not None:
            pulumi.set(__self__, "migration_state", migration_state)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if reserved_ip_addresses is not None:
            pulumi.set(__self__, "reserved_ip_addresses", reserved_ip_addresses)
        if subnet_type is not None:
            pulumi.set(__self__, "subnet_type", subnet_type)
        if virtual_switch_reference is not None:
            pulumi.set(__self__, "virtual_switch_reference", virtual_switch_reference)
        if virtual_switches is not None:
            pulumi.set(__self__, "virtual_switches", virtual_switches)
        if vpc_reference is not None:
            pulumi.set(__self__, "vpc_reference", vpc_reference)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="bridgeName")
    def bridge_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bridge_name")

    @bridge_name.setter
    def bridge_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge_name", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterReference")
    def cluster_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_reference")

    @cluster_reference.setter
    def cluster_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_reference", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the Floating IP.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dhcpOptions")
    def dhcp_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionArgs']]]]:
        return pulumi.get(self, "dhcp_options")

    @dhcp_options.setter
    def dhcp_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionArgs']]]]):
        pulumi.set(self, "dhcp_options", value)

    @property
    @pulumi.getter(name="dynamicIpAddresses")
    def dynamic_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressArgs']]]]:
        return pulumi.get(self, "dynamic_ip_addresses")

    @dynamic_ip_addresses.setter
    def dynamic_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressArgs']]]]):
        pulumi.set(self, "dynamic_ip_addresses", value)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter(name="ipConfigs")
    def ip_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigArgs']]]]:
        return pulumi.get(self, "ip_configs")

    @ip_configs.setter
    def ip_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigArgs']]]]):
        pulumi.set(self, "ip_configs", value)

    @property
    @pulumi.getter(name="ipPrefix")
    def ip_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_prefix")

    @ip_prefix.setter
    def ip_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_prefix", value)

    @property
    @pulumi.getter(name="ipUsages")
    def ip_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageArgs']]]]:
        return pulumi.get(self, "ip_usages")

    @ip_usages.setter
    def ip_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageArgs']]]]):
        pulumi.set(self, "ip_usages", value)

    @property
    @pulumi.getter(name="isAdvancedNetworking")
    def is_advanced_networking(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_advanced_networking")

    @is_advanced_networking.setter
    def is_advanced_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_advanced_networking", value)

    @property
    @pulumi.getter(name="isExternal")
    def is_external(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_external")

    @is_external.setter
    def is_external(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_external", value)

    @property
    @pulumi.getter(name="isNatEnabled")
    def is_nat_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_nat_enabled")

    @is_nat_enabled.setter
    def is_nat_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nat_enabled", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="migrationState")
    def migration_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "migration_state")

    @migration_state.setter
    def migration_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "migration_state", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the floating IP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="reservedIpAddresses")
    def reserved_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetReservedIpAddressArgs']]]]:
        return pulumi.get(self, "reserved_ip_addresses")

    @reserved_ip_addresses.setter
    def reserved_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetReservedIpAddressArgs']]]]):
        pulumi.set(self, "reserved_ip_addresses", value)

    @property
    @pulumi.getter(name="subnetType")
    def subnet_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_type")

    @subnet_type.setter
    def subnet_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_type", value)

    @property
    @pulumi.getter(name="virtualSwitchReference")
    def virtual_switch_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "virtual_switch_reference")

    @virtual_switch_reference.setter
    def virtual_switch_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_switch_reference", value)

    @property
    @pulumi.getter(name="virtualSwitches")
    def virtual_switches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchArgs']]]]:
        return pulumi.get(self, "virtual_switches")

    @virtual_switches.setter
    def virtual_switches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchArgs']]]]):
        pulumi.set(self, "virtual_switches", value)

    @property
    @pulumi.getter(name="vpcReference")
    def vpc_reference(self) -> Optional[pulumi.Input[str]]:
        """
        VPC reference UUID
        """
        return pulumi.get(self, "vpc_reference")

    @vpc_reference.setter
    def vpc_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_reference", value)

    @property
    @pulumi.getter
    def vpcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcArgs']]]]:
        """
        Networking common base object
        """
        return pulumi.get(self, "vpcs")

    @vpcs.setter
    def vpcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcArgs']]]]):
        pulumi.set(self, "vpcs", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionArgsDict(TypedDict):
        boot_file_name: NotRequired[pulumi.Input[str]]
        domain_name: NotRequired[pulumi.Input[str]]
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgsDict']]]]
        ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgsDict']]]]
        search_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        tftp_server_name: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionArgs:
    def __init__(__self__, *,
                 boot_file_name: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgs']]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgs']]]] = None,
                 search_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tftp_server_name: Optional[pulumi.Input[str]] = None):
        if boot_file_name is not None:
            pulumi.set(__self__, "boot_file_name", boot_file_name)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)
        if search_domains is not None:
            pulumi.set(__self__, "search_domains", search_domains)
        if tftp_server_name is not None:
            pulumi.set(__self__, "tftp_server_name", tftp_server_name)

    @property
    @pulumi.getter(name="bootFileName")
    def boot_file_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "boot_file_name")

    @boot_file_name.setter
    def boot_file_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_file_name", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgs']]]]:
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgs']]]]:
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgs']]]]):
        pulumi.set(self, "ntp_servers", value)

    @property
    @pulumi.getter(name="searchDomains")
    def search_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "search_domains")

    @search_domains.setter
    def search_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domains", value)

    @property
    @pulumi.getter(name="tftpServerName")
    def tftp_server_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tftp_server_name")

    @tftp_server_name.setter
    def tftp_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tftp_server_name", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionNtpServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDhcpOptionNtpServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDynamicIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetDynamicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDynamicIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDynamicIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDynamicIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDynamicIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetDynamicIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetDynamicIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetDynamicIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4ArgsDict(TypedDict):
        default_gateway_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgsDict']]]]
        dhcp_server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgsDict']]]]
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgsDict']]]]
        pool_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4Args:
    def __init__(__self__, *,
                 default_gateway_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgs']]]] = None,
                 dhcp_server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgs']]]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgs']]]] = None,
                 pool_lists: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgs']]]] = None):
        if default_gateway_ips is not None:
            pulumi.set(__self__, "default_gateway_ips", default_gateway_ips)
        if dhcp_server_addresses is not None:
            pulumi.set(__self__, "dhcp_server_addresses", dhcp_server_addresses)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if pool_lists is not None:
            pulumi.set(__self__, "pool_lists", pool_lists)

    @property
    @pulumi.getter(name="defaultGatewayIps")
    def default_gateway_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgs']]]]:
        return pulumi.get(self, "default_gateway_ips")

    @default_gateway_ips.setter
    def default_gateway_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgs']]]]):
        pulumi.set(self, "default_gateway_ips", value)

    @property
    @pulumi.getter(name="dhcpServerAddresses")
    def dhcp_server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgs']]]]:
        return pulumi.get(self, "dhcp_server_addresses")

    @dhcp_server_addresses.setter
    def dhcp_server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgs']]]]):
        pulumi.set(self, "dhcp_server_addresses", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgs']]]]:
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgs']]]]):
        pulumi.set(self, "ip_subnets", value)

    @property
    @pulumi.getter(name="poolLists")
    def pool_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgs']]]]:
        return pulumi.get(self, "pool_lists")

    @pool_lists.setter
    def pool_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgs']]]]):
        pulumi.set(self, "pool_lists", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4DefaultGatewayIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4DhcpServerAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4IpSubnetIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv4PoolListStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6ArgsDict(TypedDict):
        default_gateway_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgsDict']]]]
        dhcp_server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgsDict']]]]
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgsDict']]]]
        pool_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6Args:
    def __init__(__self__, *,
                 default_gateway_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgs']]]] = None,
                 dhcp_server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgs']]]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgs']]]] = None,
                 pool_lists: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgs']]]] = None):
        if default_gateway_ips is not None:
            pulumi.set(__self__, "default_gateway_ips", default_gateway_ips)
        if dhcp_server_addresses is not None:
            pulumi.set(__self__, "dhcp_server_addresses", dhcp_server_addresses)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if pool_lists is not None:
            pulumi.set(__self__, "pool_lists", pool_lists)

    @property
    @pulumi.getter(name="defaultGatewayIps")
    def default_gateway_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgs']]]]:
        return pulumi.get(self, "default_gateway_ips")

    @default_gateway_ips.setter
    def default_gateway_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgs']]]]):
        pulumi.set(self, "default_gateway_ips", value)

    @property
    @pulumi.getter(name="dhcpServerAddresses")
    def dhcp_server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgs']]]]:
        return pulumi.get(self, "dhcp_server_addresses")

    @dhcp_server_addresses.setter
    def dhcp_server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgs']]]]):
        pulumi.set(self, "dhcp_server_addresses", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgs']]]]:
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgs']]]]):
        pulumi.set(self, "ip_subnets", value)

    @property
    @pulumi.getter(name="poolLists")
    def pool_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgs']]]]:
        return pulumi.get(self, "pool_lists")

    @pool_lists.setter
    def pool_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgs']]]]):
        pulumi.set(self, "pool_lists", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6DefaultGatewayIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6DhcpServerAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6IpSubnetIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpConfigIpv6PoolListStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpUsageArgsDict(TypedDict):
        ip_pool_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgsDict']]]]
        num_assigned_ips: NotRequired[pulumi.Input[int]]
        num_free_ips: NotRequired[pulumi.Input[int]]
        num_macs: NotRequired[pulumi.Input[int]]
elif False:
    FloatingIpV2ExternalSubnetIpUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpUsageArgs:
    def __init__(__self__, *,
                 ip_pool_usages: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgs']]]] = None,
                 num_assigned_ips: Optional[pulumi.Input[int]] = None,
                 num_free_ips: Optional[pulumi.Input[int]] = None,
                 num_macs: Optional[pulumi.Input[int]] = None):
        if ip_pool_usages is not None:
            pulumi.set(__self__, "ip_pool_usages", ip_pool_usages)
        if num_assigned_ips is not None:
            pulumi.set(__self__, "num_assigned_ips", num_assigned_ips)
        if num_free_ips is not None:
            pulumi.set(__self__, "num_free_ips", num_free_ips)
        if num_macs is not None:
            pulumi.set(__self__, "num_macs", num_macs)

    @property
    @pulumi.getter(name="ipPoolUsages")
    def ip_pool_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgs']]]]:
        return pulumi.get(self, "ip_pool_usages")

    @ip_pool_usages.setter
    def ip_pool_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgs']]]]):
        pulumi.set(self, "ip_pool_usages", value)

    @property
    @pulumi.getter(name="numAssignedIps")
    def num_assigned_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_assigned_ips")

    @num_assigned_ips.setter
    def num_assigned_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_assigned_ips", value)

    @property
    @pulumi.getter(name="numFreeIps")
    def num_free_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_free_ips")

    @num_free_ips.setter
    def num_free_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_free_ips", value)

    @property
    @pulumi.getter(name="numMacs")
    def num_macs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_macs")

    @num_macs.setter
    def num_macs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_macs", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgsDict(TypedDict):
        num_free_ips: NotRequired[pulumi.Input[int]]
        num_total_ips: NotRequired[pulumi.Input[int]]
        ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageArgs:
    def __init__(__self__, *,
                 num_free_ips: Optional[pulumi.Input[int]] = None,
                 num_total_ips: Optional[pulumi.Input[int]] = None,
                 ranges: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgs']]]] = None):
        if num_free_ips is not None:
            pulumi.set(__self__, "num_free_ips", num_free_ips)
        if num_total_ips is not None:
            pulumi.set(__self__, "num_total_ips", num_total_ips)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter(name="numFreeIps")
    def num_free_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_free_ips")

    @num_free_ips.setter
    def num_free_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_free_ips", value)

    @property
    @pulumi.getter(name="numTotalIps")
    def num_total_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_total_ips")

    @num_total_ips.setter
    def num_total_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_total_ips", value)

    @property
    @pulumi.getter
    def ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgs']]]]:
        return pulumi.get(self, "ranges")

    @ranges.setter
    def ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgs']]]]):
        pulumi.set(self, "ranges", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetIpUsageIpPoolUsageRangeStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetReservedIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetReservedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetReservedIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchArgsDict(TypedDict):
        bond_mode: NotRequired[pulumi.Input[bool]]
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterArgsDict']]]]
        description: NotRequired[pulumi.Input[str]]
        """
        Description for the Floating IP.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        has_deployment_error: NotRequired[pulumi.Input[bool]]
        is_default: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgsDict']]]]
        """
        Metadata associated with this resource.
        """
        mtu: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the floating IP.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchArgs:
    def __init__(__self__, *,
                 bond_mode: Optional[pulumi.Input[bool]] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 has_deployment_error: Optional[pulumi.Input[bool]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs']]]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description for the Floating IP.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs']]] metadatas: Metadata associated with this resource.
        :param pulumi.Input[str] name: Name of the floating IP.
        :param pulumi.Input[str] tenant_id: A globally unique identifier that represents the tenant that owns this entity.
        """
        if bond_mode is not None:
            pulumi.set(__self__, "bond_mode", bond_mode)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if has_deployment_error is not None:
            pulumi.set(__self__, "has_deployment_error", has_deployment_error)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="bondMode")
    def bond_mode(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "bond_mode")

    @bond_mode.setter
    def bond_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bond_mode", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the Floating IP.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="hasDeploymentError")
    def has_deployment_error(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "has_deployment_error")

    @has_deployment_error.setter
    def has_deployment_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_deployment_error", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs']]]]:
        """
        Metadata associated with this resource.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the floating IP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchClusterArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        gateway_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgsDict']]]]
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchClusterArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 gateway_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgs']]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgs']]]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if gateway_ip_addresses is not None:
            pulumi.set(__self__, "gateway_ip_addresses", gateway_ip_addresses)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="gatewayIpAddresses")
    def gateway_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgs']]]]:
        return pulumi.get(self, "gateway_ip_addresses")

    @gateway_ip_addresses.setter
    def gateway_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgs']]]]):
        pulumi.set(self, "gateway_ip_addresses", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgs']]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgs']]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchClusterGatewayIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        host_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        internal_bridge_name: NotRequired[pulumi.Input[str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgsDict']]]]
        route_table: NotRequired[pulumi.Input[int]]
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 host_nics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 internal_bridge_name: Optional[pulumi.Input[str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgs']]]] = None,
                 route_table: Optional[pulumi.Input[int]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if host_nics is not None:
            pulumi.set(__self__, "host_nics", host_nics)
        if internal_bridge_name is not None:
            pulumi.set(__self__, "internal_bridge_name", internal_bridge_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="hostNics")
    def host_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "host_nics")

    @host_nics.setter
    def host_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "host_nics", value)

    @property
    @pulumi.getter(name="internalBridgeName")
    def internal_bridge_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_bridge_name")

    @internal_bridge_name.setter
    def internal_bridge_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_bridge_name", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "route_table", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchClusterHostIpAddressIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVirtualSwitchMetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcArgsDict(TypedDict):
        common_dhcp_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgsDict']]]]
        description: NotRequired[pulumi.Input[str]]
        """
        Description for the Floating IP.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        external_routing_domain_reference: NotRequired[pulumi.Input[str]]
        external_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetArgsDict']]]]
        externally_routable_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgsDict']]]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcMetadataArgsDict']]]]
        """
        Metadata associated with this resource.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the floating IP.
        """
        snat_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
        vpc_type: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcArgs:
    def __init__(__self__, *,
                 common_dhcp_options: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 external_routing_domain_reference: Optional[pulumi.Input[str]] = None,
                 external_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetArgs']]]] = None,
                 externally_routable_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgs']]]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcLinkArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcMetadataArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 snat_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vpc_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description for the Floating IP.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcMetadataArgs']]] metadatas: Metadata associated with this resource.
        :param pulumi.Input[str] name: Name of the floating IP.
        :param pulumi.Input[str] tenant_id: A globally unique identifier that represents the tenant that owns this entity.
        """
        if common_dhcp_options is not None:
            pulumi.set(__self__, "common_dhcp_options", common_dhcp_options)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if external_routing_domain_reference is not None:
            pulumi.set(__self__, "external_routing_domain_reference", external_routing_domain_reference)
        if external_subnets is not None:
            pulumi.set(__self__, "external_subnets", external_subnets)
        if externally_routable_prefixes is not None:
            pulumi.set(__self__, "externally_routable_prefixes", externally_routable_prefixes)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if snat_ips is not None:
            pulumi.set(__self__, "snat_ips", snat_ips)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vpc_type is not None:
            pulumi.set(__self__, "vpc_type", vpc_type)

    @property
    @pulumi.getter(name="commonDhcpOptions")
    def common_dhcp_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgs']]]]:
        return pulumi.get(self, "common_dhcp_options")

    @common_dhcp_options.setter
    def common_dhcp_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgs']]]]):
        pulumi.set(self, "common_dhcp_options", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the Floating IP.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="externalRoutingDomainReference")
    def external_routing_domain_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_routing_domain_reference")

    @external_routing_domain_reference.setter
    def external_routing_domain_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_routing_domain_reference", value)

    @property
    @pulumi.getter(name="externalSubnets")
    def external_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetArgs']]]]:
        return pulumi.get(self, "external_subnets")

    @external_subnets.setter
    def external_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetArgs']]]]):
        pulumi.set(self, "external_subnets", value)

    @property
    @pulumi.getter(name="externallyRoutablePrefixes")
    def externally_routable_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgs']]]]:
        return pulumi.get(self, "externally_routable_prefixes")

    @externally_routable_prefixes.setter
    def externally_routable_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgs']]]]):
        pulumi.set(self, "externally_routable_prefixes", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcMetadataArgs']]]]:
        """
        Metadata associated with this resource.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the floating IP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="snatIps")
    def snat_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpArgs']]]]:
        return pulumi.get(self, "snat_ips")

    @snat_ips.setter
    def snat_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpArgs']]]]):
        pulumi.set(self, "snat_ips", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="vpcType")
    def vpc_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_type")

    @vpc_type.setter
    def vpc_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_type", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgsDict(TypedDict):
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionArgs:
    def __init__(__self__, *,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgs']]]] = None):
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgs']]]]:
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcCommonDhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetArgsDict(TypedDict):
        active_gateway_count: NotRequired[pulumi.Input[int]]
        active_gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgsDict']]]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgsDict']]]]
        gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        subnet_reference: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetArgs:
    def __init__(__self__, *,
                 active_gateway_count: Optional[pulumi.Input[int]] = None,
                 active_gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgs']]]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgs']]]] = None,
                 gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_reference: Optional[pulumi.Input[str]] = None):
        if active_gateway_count is not None:
            pulumi.set(__self__, "active_gateway_count", active_gateway_count)
        if active_gateway_nodes is not None:
            pulumi.set(__self__, "active_gateway_nodes", active_gateway_nodes)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if gateway_nodes is not None:
            pulumi.set(__self__, "gateway_nodes", gateway_nodes)
        if subnet_reference is not None:
            pulumi.set(__self__, "subnet_reference", subnet_reference)

    @property
    @pulumi.getter(name="activeGatewayCount")
    def active_gateway_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_gateway_count")

    @active_gateway_count.setter
    def active_gateway_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_gateway_count", value)

    @property
    @pulumi.getter(name="activeGatewayNodes")
    def active_gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgs']]]]:
        return pulumi.get(self, "active_gateway_nodes")

    @active_gateway_nodes.setter
    def active_gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgs']]]]):
        pulumi.set(self, "active_gateway_nodes", value)

    @property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgs']]]]:
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgs']]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="gatewayNodes")
    def gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "gateway_nodes")

    @gateway_nodes.setter
    def gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_nodes", value)

    @property
    @pulumi.getter(name="subnetReference")
    def subnet_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_reference")

    @subnet_reference.setter
    def subnet_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_reference", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgsDict(TypedDict):
        node_id: NotRequired[pulumi.Input[str]]
        node_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict']]]]
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 node_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]] = None):
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if node_ip_addresses is not None:
            pulumi.set(__self__, "node_ip_addresses", node_ip_addresses)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="nodeIpAddresses")
    def node_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]:
        return pulumi.get(self, "node_ip_addresses")

    @node_ip_addresses.setter
    def node_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]):
        pulumi.set(self, "node_ip_addresses", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternalSubnetExternalIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcExternallyRoutablePrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVpcLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcMetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2ExternalSubnetVpcMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcMetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcSnatIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2ExternalSubnetVpcSnatIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcSnatIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcSnatIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcSnatIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcSnatIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2ExternalSubnetVpcSnatIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2ExternalSubnetVpcSnatIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2ExternalSubnetVpcSnatIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2FloatingIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2FloatingIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2FloatingIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2FloatingIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2FloatingIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2FloatingIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2FloatingIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2FloatingIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2FloatingIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2FloatingIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class FloatingIpV2MetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2MetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class FloatingIpV2VmNicArgsDict(TypedDict):
        private_ip: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2VmNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VmNicArgs:
    def __init__(__self__, *,
                 private_ip: Optional[pulumi.Input[str]] = None):
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)


if not MYPY:
    class FloatingIpV2VpcArgsDict(TypedDict):
        common_dhcp_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionArgsDict']]]]
        description: NotRequired[pulumi.Input[str]]
        """
        Description for the Floating IP.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        external_routing_domain_reference: NotRequired[pulumi.Input[str]]
        external_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetArgsDict']]]]
        externally_routable_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixArgsDict']]]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcMetadataArgsDict']]]]
        """
        Metadata associated with this resource.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the floating IP.
        """
        snat_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
        vpc_type: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2VpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcArgs:
    def __init__(__self__, *,
                 common_dhcp_options: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 external_routing_domain_reference: Optional[pulumi.Input[str]] = None,
                 external_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetArgs']]]] = None,
                 externally_routable_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixArgs']]]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcLinkArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcMetadataArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 snat_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vpc_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description for the Floating IP.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcMetadataArgs']]] metadatas: Metadata associated with this resource.
        :param pulumi.Input[str] name: Name of the floating IP.
        :param pulumi.Input[str] tenant_id: A globally unique identifier that represents the tenant that owns this entity.
        """
        if common_dhcp_options is not None:
            pulumi.set(__self__, "common_dhcp_options", common_dhcp_options)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if external_routing_domain_reference is not None:
            pulumi.set(__self__, "external_routing_domain_reference", external_routing_domain_reference)
        if external_subnets is not None:
            pulumi.set(__self__, "external_subnets", external_subnets)
        if externally_routable_prefixes is not None:
            pulumi.set(__self__, "externally_routable_prefixes", externally_routable_prefixes)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if snat_ips is not None:
            pulumi.set(__self__, "snat_ips", snat_ips)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vpc_type is not None:
            pulumi.set(__self__, "vpc_type", vpc_type)

    @property
    @pulumi.getter(name="commonDhcpOptions")
    def common_dhcp_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionArgs']]]]:
        return pulumi.get(self, "common_dhcp_options")

    @common_dhcp_options.setter
    def common_dhcp_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionArgs']]]]):
        pulumi.set(self, "common_dhcp_options", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for the Floating IP.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="externalRoutingDomainReference")
    def external_routing_domain_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_routing_domain_reference")

    @external_routing_domain_reference.setter
    def external_routing_domain_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_routing_domain_reference", value)

    @property
    @pulumi.getter(name="externalSubnets")
    def external_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetArgs']]]]:
        return pulumi.get(self, "external_subnets")

    @external_subnets.setter
    def external_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetArgs']]]]):
        pulumi.set(self, "external_subnets", value)

    @property
    @pulumi.getter(name="externallyRoutablePrefixes")
    def externally_routable_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixArgs']]]]:
        return pulumi.get(self, "externally_routable_prefixes")

    @externally_routable_prefixes.setter
    def externally_routable_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixArgs']]]]):
        pulumi.set(self, "externally_routable_prefixes", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcMetadataArgs']]]]:
        """
        Metadata associated with this resource.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the floating IP.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="snatIps")
    def snat_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpArgs']]]]:
        return pulumi.get(self, "snat_ips")

    @snat_ips.setter
    def snat_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpArgs']]]]):
        pulumi.set(self, "snat_ips", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the tenant that owns this entity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="vpcType")
    def vpc_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_type")

    @vpc_type.setter
    def vpc_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_type", value)


if not MYPY:
    class FloatingIpV2VpcCommonDhcpOptionArgsDict(TypedDict):
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgsDict']]]]
elif False:
    FloatingIpV2VpcCommonDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcCommonDhcpOptionArgs:
    def __init__(__self__, *,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgs']]]] = None):
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgs']]]]:
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)


if not MYPY:
    class FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcCommonDhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcCommonDhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetArgsDict(TypedDict):
        active_gateway_count: NotRequired[pulumi.Input[int]]
        active_gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgsDict']]]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpArgsDict']]]]
        gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        subnet_reference: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2VpcExternalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetArgs:
    def __init__(__self__, *,
                 active_gateway_count: Optional[pulumi.Input[int]] = None,
                 active_gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgs']]]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpArgs']]]] = None,
                 gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_reference: Optional[pulumi.Input[str]] = None):
        if active_gateway_count is not None:
            pulumi.set(__self__, "active_gateway_count", active_gateway_count)
        if active_gateway_nodes is not None:
            pulumi.set(__self__, "active_gateway_nodes", active_gateway_nodes)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if gateway_nodes is not None:
            pulumi.set(__self__, "gateway_nodes", gateway_nodes)
        if subnet_reference is not None:
            pulumi.set(__self__, "subnet_reference", subnet_reference)

    @property
    @pulumi.getter(name="activeGatewayCount")
    def active_gateway_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_gateway_count")

    @active_gateway_count.setter
    def active_gateway_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_gateway_count", value)

    @property
    @pulumi.getter(name="activeGatewayNodes")
    def active_gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgs']]]]:
        return pulumi.get(self, "active_gateway_nodes")

    @active_gateway_nodes.setter
    def active_gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgs']]]]):
        pulumi.set(self, "active_gateway_nodes", value)

    @property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpArgs']]]]:
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpArgs']]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="gatewayNodes")
    def gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "gateway_nodes")

    @gateway_nodes.setter
    def gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_nodes", value)

    @property
    @pulumi.getter(name="subnetReference")
    def subnet_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_reference")

    @subnet_reference.setter
    def subnet_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_reference", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgsDict(TypedDict):
        node_id: NotRequired[pulumi.Input[str]]
        node_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict']]]]
elif False:
    FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetActiveGatewayNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 node_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]] = None):
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if node_ip_addresses is not None:
            pulumi.set(__self__, "node_ip_addresses", node_ip_addresses)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="nodeIpAddresses")
    def node_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]:
        return pulumi.get(self, "node_ip_addresses")

    @node_ip_addresses.setter
    def node_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]):
        pulumi.set(self, "node_ip_addresses", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetExternalIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2VpcExternalSubnetExternalIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetExternalIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternalSubnetExternalIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetExternalIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternalSubnetExternalIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetExternalIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternalSubnetExternalIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternalSubnetExternalIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternalSubnetExternalIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternallyRoutablePrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2VpcExternallyRoutablePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternallyRoutablePrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2VpcExternallyRoutablePrefixIpv4ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2VpcExternallyRoutablePrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternallyRoutablePrefixIpv4Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternallyRoutablePrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcExternallyRoutablePrefixIpv6ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
elif False:
    FloatingIpV2VpcExternallyRoutablePrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternallyRoutablePrefixIpv6Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcExternallyRoutablePrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2VpcLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class FloatingIpV2VpcMetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    FloatingIpV2VpcMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcMetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class FloatingIpV2VpcSnatIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv4ArgsDict']]]]
        """
        Reference to IP Configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv6ArgsDict']]]]
        """
        Reference to IP Configuration
        """
elif False:
    FloatingIpV2VpcSnatIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcSnatIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv4Args']]] ipv4s: Reference to IP Configuration
        :param pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv6Args']]] ipv6s: Reference to IP Configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv4Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv6Args']]]]:
        """
        Reference to IP Configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FloatingIpV2VpcSnatIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class FloatingIpV2VpcSnatIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcSnatIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcSnatIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FloatingIpV2VpcSnatIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of address
        """
elif False:
    FloatingIpV2VpcSnatIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FloatingIpV2VpcSnatIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        :param pulumi.Input[str] value: value of address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        Prefix length of the network to which this host IPv4 address belongs. Default value is 32.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FoundationCentralImageClusterClusterStatusArgsDict(TypedDict):
        aggregate_percent_complete: NotRequired[pulumi.Input[float]]
        cluster_creation_started: NotRequired[pulumi.Input[bool]]
        cluster_progress_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusClusterProgressDetailArgsDict']]]]
        current_foundation_ip: NotRequired[pulumi.Input[str]]
        foundation_session_id: NotRequired[pulumi.Input[str]]
        imaging_stopped: NotRequired[pulumi.Input[bool]]
        intent_picked_up: NotRequired[pulumi.Input[bool]]
        node_progress_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusNodeProgressDetailArgsDict']]]]
elif False:
    FoundationCentralImageClusterClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterClusterStatusArgs:
    def __init__(__self__, *,
                 aggregate_percent_complete: Optional[pulumi.Input[float]] = None,
                 cluster_creation_started: Optional[pulumi.Input[bool]] = None,
                 cluster_progress_details: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusClusterProgressDetailArgs']]]] = None,
                 current_foundation_ip: Optional[pulumi.Input[str]] = None,
                 foundation_session_id: Optional[pulumi.Input[str]] = None,
                 imaging_stopped: Optional[pulumi.Input[bool]] = None,
                 intent_picked_up: Optional[pulumi.Input[bool]] = None,
                 node_progress_details: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusNodeProgressDetailArgs']]]] = None):
        if aggregate_percent_complete is not None:
            pulumi.set(__self__, "aggregate_percent_complete", aggregate_percent_complete)
        if cluster_creation_started is not None:
            pulumi.set(__self__, "cluster_creation_started", cluster_creation_started)
        if cluster_progress_details is not None:
            pulumi.set(__self__, "cluster_progress_details", cluster_progress_details)
        if current_foundation_ip is not None:
            pulumi.set(__self__, "current_foundation_ip", current_foundation_ip)
        if foundation_session_id is not None:
            pulumi.set(__self__, "foundation_session_id", foundation_session_id)
        if imaging_stopped is not None:
            pulumi.set(__self__, "imaging_stopped", imaging_stopped)
        if intent_picked_up is not None:
            pulumi.set(__self__, "intent_picked_up", intent_picked_up)
        if node_progress_details is not None:
            pulumi.set(__self__, "node_progress_details", node_progress_details)

    @property
    @pulumi.getter(name="aggregatePercentComplete")
    def aggregate_percent_complete(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "aggregate_percent_complete")

    @aggregate_percent_complete.setter
    def aggregate_percent_complete(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "aggregate_percent_complete", value)

    @property
    @pulumi.getter(name="clusterCreationStarted")
    def cluster_creation_started(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cluster_creation_started")

    @cluster_creation_started.setter
    def cluster_creation_started(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_creation_started", value)

    @property
    @pulumi.getter(name="clusterProgressDetails")
    def cluster_progress_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusClusterProgressDetailArgs']]]]:
        return pulumi.get(self, "cluster_progress_details")

    @cluster_progress_details.setter
    def cluster_progress_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusClusterProgressDetailArgs']]]]):
        pulumi.set(self, "cluster_progress_details", value)

    @property
    @pulumi.getter(name="currentFoundationIp")
    def current_foundation_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_foundation_ip")

    @current_foundation_ip.setter
    def current_foundation_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_foundation_ip", value)

    @property
    @pulumi.getter(name="foundationSessionId")
    def foundation_session_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "foundation_session_id")

    @foundation_session_id.setter
    def foundation_session_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "foundation_session_id", value)

    @property
    @pulumi.getter(name="imagingStopped")
    def imaging_stopped(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "imaging_stopped")

    @imaging_stopped.setter
    def imaging_stopped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imaging_stopped", value)

    @property
    @pulumi.getter(name="intentPickedUp")
    def intent_picked_up(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "intent_picked_up")

    @intent_picked_up.setter
    def intent_picked_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "intent_picked_up", value)

    @property
    @pulumi.getter(name="nodeProgressDetails")
    def node_progress_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusNodeProgressDetailArgs']]]]:
        return pulumi.get(self, "node_progress_details")

    @node_progress_details.setter
    def node_progress_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterClusterStatusNodeProgressDetailArgs']]]]):
        pulumi.set(self, "node_progress_details", value)


if not MYPY:
    class FoundationCentralImageClusterClusterStatusClusterProgressDetailArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        Name of the cluster.
        """
        message_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        percent_complete: NotRequired[pulumi.Input[float]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    FoundationCentralImageClusterClusterStatusClusterProgressDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterClusterStatusClusterProgressDetailArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 message_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 percent_complete: Optional[pulumi.Input[float]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: Name of the cluster.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if message_lists is not None:
            pulumi.set(__self__, "message_lists", message_lists)
        if percent_complete is not None:
            pulumi.set(__self__, "percent_complete", percent_complete)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="messageLists")
    def message_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "message_lists")

    @message_lists.setter
    def message_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "message_lists", value)

    @property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "percent_complete")

    @percent_complete.setter
    def percent_complete(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_complete", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FoundationCentralImageClusterClusterStatusNodeProgressDetailArgsDict(TypedDict):
        imaged_node_uuid: NotRequired[pulumi.Input[str]]
        """
        UUID of the node.
        """
        imaging_stopped: NotRequired[pulumi.Input[bool]]
        intent_picked_up: NotRequired[pulumi.Input[bool]]
        message_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        percent_complete: NotRequired[pulumi.Input[float]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    FoundationCentralImageClusterClusterStatusNodeProgressDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterClusterStatusNodeProgressDetailArgs:
    def __init__(__self__, *,
                 imaged_node_uuid: Optional[pulumi.Input[str]] = None,
                 imaging_stopped: Optional[pulumi.Input[bool]] = None,
                 intent_picked_up: Optional[pulumi.Input[bool]] = None,
                 message_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 percent_complete: Optional[pulumi.Input[float]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] imaged_node_uuid: UUID of the node.
        """
        if imaged_node_uuid is not None:
            pulumi.set(__self__, "imaged_node_uuid", imaged_node_uuid)
        if imaging_stopped is not None:
            pulumi.set(__self__, "imaging_stopped", imaging_stopped)
        if intent_picked_up is not None:
            pulumi.set(__self__, "intent_picked_up", intent_picked_up)
        if message_lists is not None:
            pulumi.set(__self__, "message_lists", message_lists)
        if percent_complete is not None:
            pulumi.set(__self__, "percent_complete", percent_complete)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="imagedNodeUuid")
    def imaged_node_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the node.
        """
        return pulumi.get(self, "imaged_node_uuid")

    @imaged_node_uuid.setter
    def imaged_node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "imaged_node_uuid", value)

    @property
    @pulumi.getter(name="imagingStopped")
    def imaging_stopped(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "imaging_stopped")

    @imaging_stopped.setter
    def imaging_stopped(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imaging_stopped", value)

    @property
    @pulumi.getter(name="intentPickedUp")
    def intent_picked_up(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "intent_picked_up")

    @intent_picked_up.setter
    def intent_picked_up(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "intent_picked_up", value)

    @property
    @pulumi.getter(name="messageLists")
    def message_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "message_lists")

    @message_lists.setter
    def message_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "message_lists", value)

    @property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "percent_complete")

    @percent_complete.setter
    def percent_complete(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "percent_complete", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class FoundationCentralImageClusterCommonNetworkSettingsArgsDict(TypedDict):
        cvm_dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of dns servers for the cvms in the cluster.
        """
        cvm_ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ntp servers for the cvms in the cluster.
        """
        hypervisor_dns_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of dns servers for the hypervisors in the cluster.
        """
        hypervisor_ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of ntp servers for the hypervisors in the cluster.
        """
elif False:
    FoundationCentralImageClusterCommonNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterCommonNetworkSettingsArgs:
    def __init__(__self__, *,
                 cvm_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cvm_ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hypervisor_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hypervisor_ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cvm_dns_servers: List of dns servers for the cvms in the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cvm_ntp_servers: List of ntp servers for the cvms in the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hypervisor_dns_servers: List of dns servers for the hypervisors in the cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hypervisor_ntp_servers: List of ntp servers for the hypervisors in the cluster.
        """
        if cvm_dns_servers is not None:
            pulumi.set(__self__, "cvm_dns_servers", cvm_dns_servers)
        if cvm_ntp_servers is not None:
            pulumi.set(__self__, "cvm_ntp_servers", cvm_ntp_servers)
        if hypervisor_dns_servers is not None:
            pulumi.set(__self__, "hypervisor_dns_servers", hypervisor_dns_servers)
        if hypervisor_ntp_servers is not None:
            pulumi.set(__self__, "hypervisor_ntp_servers", hypervisor_ntp_servers)

    @property
    @pulumi.getter(name="cvmDnsServers")
    def cvm_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of dns servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_dns_servers")

    @cvm_dns_servers.setter
    def cvm_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cvm_dns_servers", value)

    @property
    @pulumi.getter(name="cvmNtpServers")
    def cvm_ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ntp servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_ntp_servers")

    @cvm_ntp_servers.setter
    def cvm_ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cvm_ntp_servers", value)

    @property
    @pulumi.getter(name="hypervisorDnsServers")
    def hypervisor_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of dns servers for the hypervisors in the cluster.
        """
        return pulumi.get(self, "hypervisor_dns_servers")

    @hypervisor_dns_servers.setter
    def hypervisor_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisor_dns_servers", value)

    @property
    @pulumi.getter(name="hypervisorNtpServers")
    def hypervisor_ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of ntp servers for the hypervisors in the cluster.
        """
        return pulumi.get(self, "hypervisor_ntp_servers")

    @hypervisor_ntp_servers.setter
    def hypervisor_ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisor_ntp_servers", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigArgsDict(TypedDict):
        blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockArgsDict']]]]
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigClusterArgsDict']]]]
        cvm_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the cvm.
        """
        cvm_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the cvm.
        """
        dns_servers: NotRequired[pulumi.Input[str]]
        hyperv_product_key: NotRequired[pulumi.Input[str]]
        """
        Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        """
        hyperv_sku: NotRequired[pulumi.Input[str]]
        """
        SKU of hyperv to be installed if hypervisor_type is hyperv.
        """
        hypervisor_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the hypervisor.
        """
        hypervisor_iso_url: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        hypervisor_isos: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgsDict']]]]
        hypervisor_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the hypervisor.
        """
        ipmi_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the ipmi.
        """
        ipmi_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the ipmi.
        """
        nos_package_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgsDict']]]]
elif False:
    FoundationCentralImageClusterFoundationInitConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigArgs:
    def __init__(__self__, *,
                 blocks: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockArgs']]]] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigClusterArgs']]]] = None,
                 cvm_gateway: Optional[pulumi.Input[str]] = None,
                 cvm_netmask: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[str]] = None,
                 hyperv_product_key: Optional[pulumi.Input[str]] = None,
                 hyperv_sku: Optional[pulumi.Input[str]] = None,
                 hypervisor_gateway: Optional[pulumi.Input[str]] = None,
                 hypervisor_iso_url: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hypervisor_isos: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgs']]]] = None,
                 hypervisor_netmask: Optional[pulumi.Input[str]] = None,
                 ipmi_gateway: Optional[pulumi.Input[str]] = None,
                 ipmi_netmask: Optional[pulumi.Input[str]] = None,
                 nos_package_urls: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgs']]]] = None):
        """
        :param pulumi.Input[str] cvm_gateway: Gateway of the cvm.
        :param pulumi.Input[str] cvm_netmask: Netmask of the cvm.
        :param pulumi.Input[str] hyperv_product_key: Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        :param pulumi.Input[str] hyperv_sku: SKU of hyperv to be installed if hypervisor_type is hyperv.
        :param pulumi.Input[str] hypervisor_gateway: Gateway of the hypervisor.
        :param pulumi.Input[str] hypervisor_netmask: Netmask of the hypervisor.
        :param pulumi.Input[str] ipmi_gateway: Gateway of the ipmi.
        :param pulumi.Input[str] ipmi_netmask: Netmask of the ipmi.
        """
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if cvm_gateway is not None:
            pulumi.set(__self__, "cvm_gateway", cvm_gateway)
        if cvm_netmask is not None:
            pulumi.set(__self__, "cvm_netmask", cvm_netmask)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if hyperv_product_key is not None:
            pulumi.set(__self__, "hyperv_product_key", hyperv_product_key)
        if hyperv_sku is not None:
            pulumi.set(__self__, "hyperv_sku", hyperv_sku)
        if hypervisor_gateway is not None:
            pulumi.set(__self__, "hypervisor_gateway", hypervisor_gateway)
        if hypervisor_iso_url is not None:
            pulumi.set(__self__, "hypervisor_iso_url", hypervisor_iso_url)
        if hypervisor_isos is not None:
            pulumi.set(__self__, "hypervisor_isos", hypervisor_isos)
        if hypervisor_netmask is not None:
            pulumi.set(__self__, "hypervisor_netmask", hypervisor_netmask)
        if ipmi_gateway is not None:
            pulumi.set(__self__, "ipmi_gateway", ipmi_gateway)
        if ipmi_netmask is not None:
            pulumi.set(__self__, "ipmi_netmask", ipmi_netmask)
        if nos_package_urls is not None:
            pulumi.set(__self__, "nos_package_urls", nos_package_urls)

    @property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockArgs']]]]:
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockArgs']]]]):
        pulumi.set(self, "blocks", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigClusterArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigClusterArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter(name="cvmGateway")
    def cvm_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the cvm.
        """
        return pulumi.get(self, "cvm_gateway")

    @cvm_gateway.setter
    def cvm_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_gateway", value)

    @property
    @pulumi.getter(name="cvmNetmask")
    def cvm_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the cvm.
        """
        return pulumi.get(self, "cvm_netmask")

    @cvm_netmask.setter
    def cvm_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_netmask", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="hypervProductKey")
    def hyperv_product_key(self) -> Optional[pulumi.Input[str]]:
        """
        Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        """
        return pulumi.get(self, "hyperv_product_key")

    @hyperv_product_key.setter
    def hyperv_product_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hyperv_product_key", value)

    @property
    @pulumi.getter(name="hypervSku")
    def hyperv_sku(self) -> Optional[pulumi.Input[str]]:
        """
        SKU of hyperv to be installed if hypervisor_type is hyperv.
        """
        return pulumi.get(self, "hyperv_sku")

    @hyperv_sku.setter
    def hyperv_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hyperv_sku", value)

    @property
    @pulumi.getter(name="hypervisorGateway")
    def hypervisor_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the hypervisor.
        """
        return pulumi.get(self, "hypervisor_gateway")

    @hypervisor_gateway.setter
    def hypervisor_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_gateway", value)

    @property
    @pulumi.getter(name="hypervisorIsoUrl")
    def hypervisor_iso_url(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "hypervisor_iso_url")

    @hypervisor_iso_url.setter
    def hypervisor_iso_url(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "hypervisor_iso_url", value)

    @property
    @pulumi.getter(name="hypervisorIsos")
    def hypervisor_isos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgs']]]]:
        return pulumi.get(self, "hypervisor_isos")

    @hypervisor_isos.setter
    def hypervisor_isos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgs']]]]):
        pulumi.set(self, "hypervisor_isos", value)

    @property
    @pulumi.getter(name="hypervisorNetmask")
    def hypervisor_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the hypervisor.
        """
        return pulumi.get(self, "hypervisor_netmask")

    @hypervisor_netmask.setter
    def hypervisor_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_netmask", value)

    @property
    @pulumi.getter(name="ipmiGateway")
    def ipmi_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the ipmi.
        """
        return pulumi.get(self, "ipmi_gateway")

    @ipmi_gateway.setter
    def ipmi_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_gateway", value)

    @property
    @pulumi.getter(name="ipmiNetmask")
    def ipmi_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the ipmi.
        """
        return pulumi.get(self, "ipmi_netmask")

    @ipmi_netmask.setter
    def ipmi_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_netmask", value)

    @property
    @pulumi.getter(name="nosPackageUrls")
    def nos_package_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgs']]]]:
        return pulumi.get(self, "nos_package_urls")

    @nos_package_urls.setter
    def nos_package_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgs']]]]):
        pulumi.set(self, "nos_package_urls", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigBlockArgsDict(TypedDict):
        block_id: NotRequired[pulumi.Input[str]]
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockNodeArgsDict']]]]
elif False:
    FoundationCentralImageClusterFoundationInitConfigBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigBlockArgs:
    def __init__(__self__, *,
                 block_id: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockNodeArgs']]]] = None):
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockNodeArgs']]]]:
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationCentralImageClusterFoundationInitConfigBlockNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigBlockNodeArgsDict(TypedDict):
        cvm_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the cvm on the node.
        """
        cvm_vlan_id: NotRequired[pulumi.Input[int]]
        """
        Vlan tag of the cvm, if the cvm is on a vlan.
        """
        fc_imaged_node_uuid: NotRequired[pulumi.Input[str]]
        hardware_attributes_override: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Hardware attributes override json for the node.
        """
        hypervisor: NotRequired[pulumi.Input[str]]
        hypervisor_hostname: NotRequired[pulumi.Input[str]]
        """
        Name to be set for the hypervisor host.
        """
        hypervisor_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the hypervisor on the node.
        """
        image_now: NotRequired[pulumi.Input[bool]]
        """
        True, if the node should be imaged, False, otherwise.
        """
        ipmi_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the ipmi of the node.
        """
        ipv6_address: NotRequired[pulumi.Input[str]]
        node_position: NotRequired[pulumi.Input[str]]
        node_serial: NotRequired[pulumi.Input[str]]
elif False:
    FoundationCentralImageClusterFoundationInitConfigBlockNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigBlockNodeArgs:
    def __init__(__self__, *,
                 cvm_ip: Optional[pulumi.Input[str]] = None,
                 cvm_vlan_id: Optional[pulumi.Input[int]] = None,
                 fc_imaged_node_uuid: Optional[pulumi.Input[str]] = None,
                 hardware_attributes_override: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hypervisor: Optional[pulumi.Input[str]] = None,
                 hypervisor_hostname: Optional[pulumi.Input[str]] = None,
                 hypervisor_ip: Optional[pulumi.Input[str]] = None,
                 image_now: Optional[pulumi.Input[bool]] = None,
                 ipmi_ip: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 node_position: Optional[pulumi.Input[str]] = None,
                 node_serial: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cvm_ip: IP address to be set for the cvm on the node.
        :param pulumi.Input[int] cvm_vlan_id: Vlan tag of the cvm, if the cvm is on a vlan.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] hardware_attributes_override: Hardware attributes override json for the node.
        :param pulumi.Input[str] hypervisor_hostname: Name to be set for the hypervisor host.
        :param pulumi.Input[str] hypervisor_ip: IP address to be set for the hypervisor on the node.
        :param pulumi.Input[bool] image_now: True, if the node should be imaged, False, otherwise.
        :param pulumi.Input[str] ipmi_ip: IP address to be set for the ipmi of the node.
        """
        if cvm_ip is not None:
            pulumi.set(__self__, "cvm_ip", cvm_ip)
        if cvm_vlan_id is not None:
            pulumi.set(__self__, "cvm_vlan_id", cvm_vlan_id)
        if fc_imaged_node_uuid is not None:
            pulumi.set(__self__, "fc_imaged_node_uuid", fc_imaged_node_uuid)
        if hardware_attributes_override is not None:
            pulumi.set(__self__, "hardware_attributes_override", hardware_attributes_override)
        if hypervisor is not None:
            pulumi.set(__self__, "hypervisor", hypervisor)
        if hypervisor_hostname is not None:
            pulumi.set(__self__, "hypervisor_hostname", hypervisor_hostname)
        if hypervisor_ip is not None:
            pulumi.set(__self__, "hypervisor_ip", hypervisor_ip)
        if image_now is not None:
            pulumi.set(__self__, "image_now", image_now)
        if ipmi_ip is not None:
            pulumi.set(__self__, "ipmi_ip", ipmi_ip)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if node_position is not None:
            pulumi.set(__self__, "node_position", node_position)
        if node_serial is not None:
            pulumi.set(__self__, "node_serial", node_serial)

    @property
    @pulumi.getter(name="cvmIp")
    def cvm_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the cvm on the node.
        """
        return pulumi.get(self, "cvm_ip")

    @cvm_ip.setter
    def cvm_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_ip", value)

    @property
    @pulumi.getter(name="cvmVlanId")
    def cvm_vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        Vlan tag of the cvm, if the cvm is on a vlan.
        """
        return pulumi.get(self, "cvm_vlan_id")

    @cvm_vlan_id.setter
    def cvm_vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cvm_vlan_id", value)

    @property
    @pulumi.getter(name="fcImagedNodeUuid")
    def fc_imaged_node_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fc_imaged_node_uuid")

    @fc_imaged_node_uuid.setter
    def fc_imaged_node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fc_imaged_node_uuid", value)

    @property
    @pulumi.getter(name="hardwareAttributesOverride")
    def hardware_attributes_override(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Hardware attributes override json for the node.
        """
        return pulumi.get(self, "hardware_attributes_override")

    @hardware_attributes_override.setter
    def hardware_attributes_override(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "hardware_attributes_override", value)

    @property
    @pulumi.getter
    def hypervisor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hypervisor")

    @hypervisor.setter
    def hypervisor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor", value)

    @property
    @pulumi.getter(name="hypervisorHostname")
    def hypervisor_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Name to be set for the hypervisor host.
        """
        return pulumi.get(self, "hypervisor_hostname")

    @hypervisor_hostname.setter
    def hypervisor_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_hostname", value)

    @property
    @pulumi.getter(name="hypervisorIp")
    def hypervisor_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the hypervisor on the node.
        """
        return pulumi.get(self, "hypervisor_ip")

    @hypervisor_ip.setter
    def hypervisor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_ip", value)

    @property
    @pulumi.getter(name="imageNow")
    def image_now(self) -> Optional[pulumi.Input[bool]]:
        """
        True, if the node should be imaged, False, otherwise.
        """
        return pulumi.get(self, "image_now")

    @image_now.setter
    def image_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_now", value)

    @property
    @pulumi.getter(name="ipmiIp")
    def ipmi_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the ipmi of the node.
        """
        return pulumi.get(self, "ipmi_ip")

    @ipmi_ip.setter
    def ipmi_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_ip", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="nodeSerial")
    def node_serial(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_serial")

    @node_serial.setter
    def node_serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_serial", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigClusterArgsDict(TypedDict):
        cluster_external_ip: NotRequired[pulumi.Input[str]]
        """
        External management ip of the cluster.
        """
        cluster_init_now: NotRequired[pulumi.Input[bool]]
        cluster_init_successful: NotRequired[pulumi.Input[bool]]
        cluster_members: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        Name of the cluster.
        """
        cvm_dns_servers: NotRequired[pulumi.Input[str]]
        """
        List of dns servers for the cvms in the cluster.
        """
        cvm_ntp_servers: NotRequired[pulumi.Input[str]]
        """
        List of ntp servers for the cvms in the cluster.
        """
        redundancy_factor: NotRequired[pulumi.Input[int]]
        """
        Redundancy factor of the cluster.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Timezone to be set on the cluster.
        """
elif False:
    FoundationCentralImageClusterFoundationInitConfigClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigClusterArgs:
    def __init__(__self__, *,
                 cluster_external_ip: Optional[pulumi.Input[str]] = None,
                 cluster_init_now: Optional[pulumi.Input[bool]] = None,
                 cluster_init_successful: Optional[pulumi.Input[bool]] = None,
                 cluster_members: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 cvm_dns_servers: Optional[pulumi.Input[str]] = None,
                 cvm_ntp_servers: Optional[pulumi.Input[str]] = None,
                 redundancy_factor: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_external_ip: External management ip of the cluster.
        :param pulumi.Input[str] cluster_name: Name of the cluster.
        :param pulumi.Input[str] cvm_dns_servers: List of dns servers for the cvms in the cluster.
        :param pulumi.Input[str] cvm_ntp_servers: List of ntp servers for the cvms in the cluster.
        :param pulumi.Input[int] redundancy_factor: Redundancy factor of the cluster.
        :param pulumi.Input[str] timezone: Timezone to be set on the cluster.
        """
        if cluster_external_ip is not None:
            pulumi.set(__self__, "cluster_external_ip", cluster_external_ip)
        if cluster_init_now is not None:
            pulumi.set(__self__, "cluster_init_now", cluster_init_now)
        if cluster_init_successful is not None:
            pulumi.set(__self__, "cluster_init_successful", cluster_init_successful)
        if cluster_members is not None:
            pulumi.set(__self__, "cluster_members", cluster_members)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cvm_dns_servers is not None:
            pulumi.set(__self__, "cvm_dns_servers", cvm_dns_servers)
        if cvm_ntp_servers is not None:
            pulumi.set(__self__, "cvm_ntp_servers", cvm_ntp_servers)
        if redundancy_factor is not None:
            pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="clusterExternalIp")
    def cluster_external_ip(self) -> Optional[pulumi.Input[str]]:
        """
        External management ip of the cluster.
        """
        return pulumi.get(self, "cluster_external_ip")

    @cluster_external_ip.setter
    def cluster_external_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_external_ip", value)

    @property
    @pulumi.getter(name="clusterInitNow")
    def cluster_init_now(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cluster_init_now")

    @cluster_init_now.setter
    def cluster_init_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_init_now", value)

    @property
    @pulumi.getter(name="clusterInitSuccessful")
    def cluster_init_successful(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cluster_init_successful")

    @cluster_init_successful.setter
    def cluster_init_successful(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_init_successful", value)

    @property
    @pulumi.getter(name="clusterMembers")
    def cluster_members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "cluster_members")

    @cluster_members.setter
    def cluster_members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_members", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="cvmDnsServers")
    def cvm_dns_servers(self) -> Optional[pulumi.Input[str]]:
        """
        List of dns servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_dns_servers")

    @cvm_dns_servers.setter
    def cvm_dns_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_dns_servers", value)

    @property
    @pulumi.getter(name="cvmNtpServers")
    def cvm_ntp_servers(self) -> Optional[pulumi.Input[str]]:
        """
        List of ntp servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_ntp_servers")

    @cvm_ntp_servers.setter
    def cvm_ntp_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_ntp_servers", value)

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> Optional[pulumi.Input[int]]:
        """
        Redundancy factor of the cluster.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redundancy_factor", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone to be set on the cluster.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgsDict(TypedDict):
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        """
        sha256sum: NotRequired[pulumi.Input[str]]
        """
        sha256sum of the hypervisor iso.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
elif False:
    FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigHypervisorIsoArgs:
    def __init__(__self__, *,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 sha256sum: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hypervisor_type: Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        :param pulumi.Input[str] sha256sum: sha256sum of the hypervisor iso.
        :param pulumi.Input[str] url: URL to download hypervisor iso. Required only if imaging is needed.
        """
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[pulumi.Input[str]]:
        """
        sha256sum of the hypervisor iso.
        """
        return pulumi.get(self, "sha256sum")

    @sha256sum.setter
    def sha256sum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256sum", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgsDict(TypedDict):
        sha256sum: NotRequired[pulumi.Input[str]]
        """
        sha256sum of the hypervisor iso.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
elif False:
    FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterFoundationInitConfigNosPackageUrlArgs:
    def __init__(__self__, *,
                 sha256sum: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] sha256sum: sha256sum of the hypervisor iso.
        :param pulumi.Input[str] url: URL to download hypervisor iso. Required only if imaging is needed.
        """
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[pulumi.Input[str]]:
        """
        sha256sum of the hypervisor iso.
        """
        return pulumi.get(self, "sha256sum")

    @sha256sum.setter
    def sha256sum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256sum", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FoundationCentralImageClusterHypervisorIsoDetailsArgsDict(TypedDict):
        hyperv_product_key: NotRequired[pulumi.Input[str]]
        """
        Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        """
        hyperv_sku: NotRequired[pulumi.Input[str]]
        """
        SKU of hyperv to be installed if hypervisor_type is hyperv.
        """
        sha256sum: NotRequired[pulumi.Input[str]]
        """
        sha256sum of the hypervisor iso.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
elif False:
    FoundationCentralImageClusterHypervisorIsoDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterHypervisorIsoDetailsArgs:
    def __init__(__self__, *,
                 hyperv_product_key: Optional[pulumi.Input[str]] = None,
                 hyperv_sku: Optional[pulumi.Input[str]] = None,
                 sha256sum: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hyperv_product_key: Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        :param pulumi.Input[str] hyperv_sku: SKU of hyperv to be installed if hypervisor_type is hyperv.
        :param pulumi.Input[str] sha256sum: sha256sum of the hypervisor iso.
        :param pulumi.Input[str] url: URL to download hypervisor iso. Required only if imaging is needed.
        """
        if hyperv_product_key is not None:
            pulumi.set(__self__, "hyperv_product_key", hyperv_product_key)
        if hyperv_sku is not None:
            pulumi.set(__self__, "hyperv_sku", hyperv_sku)
        if sha256sum is not None:
            pulumi.set(__self__, "sha256sum", sha256sum)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="hypervProductKey")
    def hyperv_product_key(self) -> Optional[pulumi.Input[str]]:
        """
        Product key for hyperv isos. Required only if the hypervisor type is hyperv and product key is mandatory (ex: for volume license).
        """
        return pulumi.get(self, "hyperv_product_key")

    @hyperv_product_key.setter
    def hyperv_product_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hyperv_product_key", value)

    @property
    @pulumi.getter(name="hypervSku")
    def hyperv_sku(self) -> Optional[pulumi.Input[str]]:
        """
        SKU of hyperv to be installed if hypervisor_type is hyperv.
        """
        return pulumi.get(self, "hyperv_sku")

    @hyperv_sku.setter
    def hyperv_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hyperv_sku", value)

    @property
    @pulumi.getter
    def sha256sum(self) -> Optional[pulumi.Input[str]]:
        """
        sha256sum of the hypervisor iso.
        """
        return pulumi.get(self, "sha256sum")

    @sha256sum.setter
    def sha256sum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sha256sum", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        URL to download hypervisor iso. Required only if imaging is needed.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FoundationCentralImageClusterNodeListArgsDict(TypedDict):
        cvm_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the cvm.
        """
        cvm_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the cvm on the node.
        """
        cvm_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the cvm.
        """
        cvm_ram_gb: NotRequired[pulumi.Input[int]]
        """
        Amount of memory to be assigned for the cvm.
        """
        cvm_vlan_id: NotRequired[pulumi.Input[int]]
        """
        Vlan tag of the cvm, if the cvm is on a vlan.
        """
        hardware_attributes_override: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Hardware attributes override json for the node.
        """
        hypervisor_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the hypervisor.
        """
        hypervisor_hostname: NotRequired[pulumi.Input[str]]
        """
        Name to be set for the hypervisor host.
        """
        hypervisor_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the hypervisor on the node.
        """
        hypervisor_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the hypervisor.
        """
        hypervisor_type: NotRequired[pulumi.Input[str]]
        """
        Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        """
        image_now: NotRequired[pulumi.Input[bool]]
        """
        True, if the node should be imaged, False, otherwise.
        """
        imaged_node_uuid: NotRequired[pulumi.Input[str]]
        """
        UUID of the node.
        """
        ipmi_gateway: NotRequired[pulumi.Input[str]]
        """
        Gateway of the ipmi.
        """
        ipmi_ip: NotRequired[pulumi.Input[str]]
        """
        IP address to be set for the ipmi of the node.
        """
        ipmi_netmask: NotRequired[pulumi.Input[str]]
        """
        Netmask of the ipmi.
        """
        rdma_passthrough: NotRequired[pulumi.Input[bool]]
        """
        Passthrough RDMA nic to CVM if possible, default to false.
        """
        use_existing_network_settings: NotRequired[pulumi.Input[bool]]
        """
        Decides whether to use the existing network settings for the node. If True, the existing network settings of the node will be used during cluster creation. If False, then client must provide new network settings. If all nodes are booted in phoenix, this field is, by default, considered to be False.
        """
elif False:
    FoundationCentralImageClusterNodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationCentralImageClusterNodeListArgs:
    def __init__(__self__, *,
                 cvm_gateway: Optional[pulumi.Input[str]] = None,
                 cvm_ip: Optional[pulumi.Input[str]] = None,
                 cvm_netmask: Optional[pulumi.Input[str]] = None,
                 cvm_ram_gb: Optional[pulumi.Input[int]] = None,
                 cvm_vlan_id: Optional[pulumi.Input[int]] = None,
                 hardware_attributes_override: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 hypervisor_gateway: Optional[pulumi.Input[str]] = None,
                 hypervisor_hostname: Optional[pulumi.Input[str]] = None,
                 hypervisor_ip: Optional[pulumi.Input[str]] = None,
                 hypervisor_netmask: Optional[pulumi.Input[str]] = None,
                 hypervisor_type: Optional[pulumi.Input[str]] = None,
                 image_now: Optional[pulumi.Input[bool]] = None,
                 imaged_node_uuid: Optional[pulumi.Input[str]] = None,
                 ipmi_gateway: Optional[pulumi.Input[str]] = None,
                 ipmi_ip: Optional[pulumi.Input[str]] = None,
                 ipmi_netmask: Optional[pulumi.Input[str]] = None,
                 rdma_passthrough: Optional[pulumi.Input[bool]] = None,
                 use_existing_network_settings: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cvm_gateway: Gateway of the cvm.
        :param pulumi.Input[str] cvm_ip: IP address to be set for the cvm on the node.
        :param pulumi.Input[str] cvm_netmask: Netmask of the cvm.
        :param pulumi.Input[int] cvm_ram_gb: Amount of memory to be assigned for the cvm.
        :param pulumi.Input[int] cvm_vlan_id: Vlan tag of the cvm, if the cvm is on a vlan.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] hardware_attributes_override: Hardware attributes override json for the node.
        :param pulumi.Input[str] hypervisor_gateway: Gateway of the hypervisor.
        :param pulumi.Input[str] hypervisor_hostname: Name to be set for the hypervisor host.
        :param pulumi.Input[str] hypervisor_ip: IP address to be set for the hypervisor on the node.
        :param pulumi.Input[str] hypervisor_netmask: Netmask of the hypervisor.
        :param pulumi.Input[str] hypervisor_type: Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        :param pulumi.Input[bool] image_now: True, if the node should be imaged, False, otherwise.
        :param pulumi.Input[str] imaged_node_uuid: UUID of the node.
        :param pulumi.Input[str] ipmi_gateway: Gateway of the ipmi.
        :param pulumi.Input[str] ipmi_ip: IP address to be set for the ipmi of the node.
        :param pulumi.Input[str] ipmi_netmask: Netmask of the ipmi.
        :param pulumi.Input[bool] rdma_passthrough: Passthrough RDMA nic to CVM if possible, default to false.
        :param pulumi.Input[bool] use_existing_network_settings: Decides whether to use the existing network settings for the node. If True, the existing network settings of the node will be used during cluster creation. If False, then client must provide new network settings. If all nodes are booted in phoenix, this field is, by default, considered to be False.
        """
        if cvm_gateway is not None:
            pulumi.set(__self__, "cvm_gateway", cvm_gateway)
        if cvm_ip is not None:
            pulumi.set(__self__, "cvm_ip", cvm_ip)
        if cvm_netmask is not None:
            pulumi.set(__self__, "cvm_netmask", cvm_netmask)
        if cvm_ram_gb is not None:
            pulumi.set(__self__, "cvm_ram_gb", cvm_ram_gb)
        if cvm_vlan_id is not None:
            pulumi.set(__self__, "cvm_vlan_id", cvm_vlan_id)
        if hardware_attributes_override is not None:
            pulumi.set(__self__, "hardware_attributes_override", hardware_attributes_override)
        if hypervisor_gateway is not None:
            pulumi.set(__self__, "hypervisor_gateway", hypervisor_gateway)
        if hypervisor_hostname is not None:
            pulumi.set(__self__, "hypervisor_hostname", hypervisor_hostname)
        if hypervisor_ip is not None:
            pulumi.set(__self__, "hypervisor_ip", hypervisor_ip)
        if hypervisor_netmask is not None:
            pulumi.set(__self__, "hypervisor_netmask", hypervisor_netmask)
        if hypervisor_type is not None:
            pulumi.set(__self__, "hypervisor_type", hypervisor_type)
        if image_now is not None:
            pulumi.set(__self__, "image_now", image_now)
        if imaged_node_uuid is not None:
            pulumi.set(__self__, "imaged_node_uuid", imaged_node_uuid)
        if ipmi_gateway is not None:
            pulumi.set(__self__, "ipmi_gateway", ipmi_gateway)
        if ipmi_ip is not None:
            pulumi.set(__self__, "ipmi_ip", ipmi_ip)
        if ipmi_netmask is not None:
            pulumi.set(__self__, "ipmi_netmask", ipmi_netmask)
        if rdma_passthrough is not None:
            pulumi.set(__self__, "rdma_passthrough", rdma_passthrough)
        if use_existing_network_settings is not None:
            pulumi.set(__self__, "use_existing_network_settings", use_existing_network_settings)

    @property
    @pulumi.getter(name="cvmGateway")
    def cvm_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the cvm.
        """
        return pulumi.get(self, "cvm_gateway")

    @cvm_gateway.setter
    def cvm_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_gateway", value)

    @property
    @pulumi.getter(name="cvmIp")
    def cvm_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the cvm on the node.
        """
        return pulumi.get(self, "cvm_ip")

    @cvm_ip.setter
    def cvm_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_ip", value)

    @property
    @pulumi.getter(name="cvmNetmask")
    def cvm_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the cvm.
        """
        return pulumi.get(self, "cvm_netmask")

    @cvm_netmask.setter
    def cvm_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_netmask", value)

    @property
    @pulumi.getter(name="cvmRamGb")
    def cvm_ram_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Amount of memory to be assigned for the cvm.
        """
        return pulumi.get(self, "cvm_ram_gb")

    @cvm_ram_gb.setter
    def cvm_ram_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cvm_ram_gb", value)

    @property
    @pulumi.getter(name="cvmVlanId")
    def cvm_vlan_id(self) -> Optional[pulumi.Input[int]]:
        """
        Vlan tag of the cvm, if the cvm is on a vlan.
        """
        return pulumi.get(self, "cvm_vlan_id")

    @cvm_vlan_id.setter
    def cvm_vlan_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cvm_vlan_id", value)

    @property
    @pulumi.getter(name="hardwareAttributesOverride")
    def hardware_attributes_override(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Hardware attributes override json for the node.
        """
        return pulumi.get(self, "hardware_attributes_override")

    @hardware_attributes_override.setter
    def hardware_attributes_override(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "hardware_attributes_override", value)

    @property
    @pulumi.getter(name="hypervisorGateway")
    def hypervisor_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the hypervisor.
        """
        return pulumi.get(self, "hypervisor_gateway")

    @hypervisor_gateway.setter
    def hypervisor_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_gateway", value)

    @property
    @pulumi.getter(name="hypervisorHostname")
    def hypervisor_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Name to be set for the hypervisor host.
        """
        return pulumi.get(self, "hypervisor_hostname")

    @hypervisor_hostname.setter
    def hypervisor_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_hostname", value)

    @property
    @pulumi.getter(name="hypervisorIp")
    def hypervisor_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the hypervisor on the node.
        """
        return pulumi.get(self, "hypervisor_ip")

    @hypervisor_ip.setter
    def hypervisor_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_ip", value)

    @property
    @pulumi.getter(name="hypervisorNetmask")
    def hypervisor_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the hypervisor.
        """
        return pulumi.get(self, "hypervisor_netmask")

    @hypervisor_netmask.setter
    def hypervisor_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_netmask", value)

    @property
    @pulumi.getter(name="hypervisorType")
    def hypervisor_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of hypervisor to be installed. Must be one of {kvm, esx, hyperv}.
        """
        return pulumi.get(self, "hypervisor_type")

    @hypervisor_type.setter
    def hypervisor_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_type", value)

    @property
    @pulumi.getter(name="imageNow")
    def image_now(self) -> Optional[pulumi.Input[bool]]:
        """
        True, if the node should be imaged, False, otherwise.
        """
        return pulumi.get(self, "image_now")

    @image_now.setter
    def image_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_now", value)

    @property
    @pulumi.getter(name="imagedNodeUuid")
    def imaged_node_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        UUID of the node.
        """
        return pulumi.get(self, "imaged_node_uuid")

    @imaged_node_uuid.setter
    def imaged_node_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "imaged_node_uuid", value)

    @property
    @pulumi.getter(name="ipmiGateway")
    def ipmi_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        Gateway of the ipmi.
        """
        return pulumi.get(self, "ipmi_gateway")

    @ipmi_gateway.setter
    def ipmi_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_gateway", value)

    @property
    @pulumi.getter(name="ipmiIp")
    def ipmi_ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP address to be set for the ipmi of the node.
        """
        return pulumi.get(self, "ipmi_ip")

    @ipmi_ip.setter
    def ipmi_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_ip", value)

    @property
    @pulumi.getter(name="ipmiNetmask")
    def ipmi_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        Netmask of the ipmi.
        """
        return pulumi.get(self, "ipmi_netmask")

    @ipmi_netmask.setter
    def ipmi_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_netmask", value)

    @property
    @pulumi.getter(name="rdmaPassthrough")
    def rdma_passthrough(self) -> Optional[pulumi.Input[bool]]:
        """
        Passthrough RDMA nic to CVM if possible, default to false.
        """
        return pulumi.get(self, "rdma_passthrough")

    @rdma_passthrough.setter
    def rdma_passthrough(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rdma_passthrough", value)

    @property
    @pulumi.getter(name="useExistingNetworkSettings")
    def use_existing_network_settings(self) -> Optional[pulumi.Input[bool]]:
        """
        Decides whether to use the existing network settings for the node. If True, the existing network settings of the node will be used during cluster creation. If False, then client must provide new network settings. If all nodes are booted in phoenix, this field is, by default, considered to be False.
        """
        return pulumi.get(self, "use_existing_network_settings")

    @use_existing_network_settings.setter
    def use_existing_network_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_existing_network_settings", value)


if not MYPY:
    class FoundationImageNodesBlockArgsDict(TypedDict):
        nodes: pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeArgsDict']]]
        block_id: NotRequired[pulumi.Input[str]]
        """
        - Block ID.
        """
elif False:
    FoundationImageNodesBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesBlockArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeArgs']]],
                 block_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_id: - Block ID.
        """
        pulumi.set(__self__, "nodes", nodes)
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeArgs']]]:
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        """
        - Block ID.
        """
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)


if not MYPY:
    class FoundationImageNodesBlockNodeArgsDict(TypedDict):
        hypervisor_hostname: pulumi.Input[str]
        """
        - (Required) Hypervisor Hostname.
        """
        hypervisor_ip: pulumi.Input[str]
        """
        - (Required) Hypervisor IP address.
        """
        node_position: pulumi.Input[str]
        """
        - (Required) Position of the node in the block.
        """
        bond_lacp_rate: NotRequired[pulumi.Input[str]]
        """
        - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
        """
        bond_mode: NotRequired[pulumi.Input[str]]
        """
        - (Required if node is capable) dynamic if using LACP, static for LAG
        """
        bond_uplinks: NotRequired[pulumi.Input[str]]
        """
        - MAC Addresses of NICs in a team/bond
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        - ID of cluster.
        """
        current_cvm_vlan_tag: NotRequired[pulumi.Input[int]]
        """
        - Current CVM vlan tag. 0 Value with remove vlan tag.
        """
        current_network_interface: NotRequired[pulumi.Input[str]]
        """
        - CVM current network interface.
        """
        cvm_gb_ram: NotRequired[pulumi.Input[int]]
        """
        - RAM capacity of CVM in GB.
        """
        cvm_ip: NotRequired[pulumi.Input[str]]
        cvm_num_vcpus: NotRequired[pulumi.Input[int]]
        """
        - Number of CVM vcpus.
        """
        device_hint: NotRequired[pulumi.Input[str]]
        """
        - use "vm_installer" to enable CVM imaging from standalone.
        """
        exlude_boot_serial: NotRequired[pulumi.Input[str]]
        """
        - serial of boot device to be excluded (used by NX G6 platforms)
        """
        hypervisor: NotRequired[pulumi.Input[str]]
        image_delay: NotRequired[pulumi.Input[int]]
        """
        - Imaging delay.
        """
        image_now: NotRequired[pulumi.Input[bool]]
        """
        - (Optional, Default = true) If the node should be imaged now.
        """
        image_successful: NotRequired[pulumi.Input[bool]]
        ipmi_configure_now: NotRequired[pulumi.Input[bool]]
        """
        - Whether IPMI should be configured.
        """
        ipmi_gateway: NotRequired[pulumi.Input[str]]
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
        """
        ipmi_ip: NotRequired[pulumi.Input[str]]
        """
        - (Required) IPMI IP address.
        """
        ipmi_mac: NotRequired[pulumi.Input[str]]
        """
        - IPMI MAC address.
        """
        ipmi_netmask: NotRequired[pulumi.Input[str]]
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
        """
        ipmi_password: NotRequired[pulumi.Input[str]]
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
        """
        ipmi_user: NotRequired[pulumi.Input[str]]
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
        """
        ipv6_address: NotRequired[pulumi.Input[str]]
        """
        - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) IPV6 address.
        """
        ipv6_interface: NotRequired[pulumi.Input[str]]
        """
        - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) ipv6 interface.
        """
        mitigate_low_boot_space: NotRequired[pulumi.Input[bool]]
        """
        - relocate bootbank files to make space for phoenix files.
        """
        node_serial: NotRequired[pulumi.Input[str]]
        """
        - serial number of the node.
        """
        rdma_mac_addr: NotRequired[pulumi.Input[str]]
        """
        - mac address of nic to be used for rdma
        """
        rdma_passthrough: NotRequired[pulumi.Input[bool]]
        """
        - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
        """
        ucsm_managed_mode: NotRequired[pulumi.Input[str]]
        """
        - UCSM Managed mode.
        """
        ucsm_node_serial: NotRequired[pulumi.Input[str]]
        """
        - UCSM node serial.
        """
        ucsm_params: NotRequired[pulumi.Input['FoundationImageNodesBlockNodeUcsmParamsArgsDict']]
        """
        - Object of UCSM parameters.
        * `ucsm_params.native_vlan` :- If the vlan is native.
        * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
        * `ucsm_params.mac_pool` :- Mac address pool.
        * `ucsm_params.vlan_name` :- Name of vlan.
        """
        vswitches: NotRequired[pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeVswitchArgsDict']]]]
elif False:
    FoundationImageNodesBlockNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesBlockNodeArgs:
    def __init__(__self__, *,
                 hypervisor_hostname: pulumi.Input[str],
                 hypervisor_ip: pulumi.Input[str],
                 node_position: pulumi.Input[str],
                 bond_lacp_rate: Optional[pulumi.Input[str]] = None,
                 bond_mode: Optional[pulumi.Input[str]] = None,
                 bond_uplinks: Optional[pulumi.Input[str]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 current_cvm_vlan_tag: Optional[pulumi.Input[int]] = None,
                 current_network_interface: Optional[pulumi.Input[str]] = None,
                 cvm_gb_ram: Optional[pulumi.Input[int]] = None,
                 cvm_ip: Optional[pulumi.Input[str]] = None,
                 cvm_num_vcpus: Optional[pulumi.Input[int]] = None,
                 device_hint: Optional[pulumi.Input[str]] = None,
                 exlude_boot_serial: Optional[pulumi.Input[str]] = None,
                 hypervisor: Optional[pulumi.Input[str]] = None,
                 image_delay: Optional[pulumi.Input[int]] = None,
                 image_now: Optional[pulumi.Input[bool]] = None,
                 image_successful: Optional[pulumi.Input[bool]] = None,
                 ipmi_configure_now: Optional[pulumi.Input[bool]] = None,
                 ipmi_gateway: Optional[pulumi.Input[str]] = None,
                 ipmi_ip: Optional[pulumi.Input[str]] = None,
                 ipmi_mac: Optional[pulumi.Input[str]] = None,
                 ipmi_netmask: Optional[pulumi.Input[str]] = None,
                 ipmi_password: Optional[pulumi.Input[str]] = None,
                 ipmi_user: Optional[pulumi.Input[str]] = None,
                 ipv6_address: Optional[pulumi.Input[str]] = None,
                 ipv6_interface: Optional[pulumi.Input[str]] = None,
                 mitigate_low_boot_space: Optional[pulumi.Input[bool]] = None,
                 node_serial: Optional[pulumi.Input[str]] = None,
                 rdma_mac_addr: Optional[pulumi.Input[str]] = None,
                 rdma_passthrough: Optional[pulumi.Input[bool]] = None,
                 ucsm_managed_mode: Optional[pulumi.Input[str]] = None,
                 ucsm_node_serial: Optional[pulumi.Input[str]] = None,
                 ucsm_params: Optional[pulumi.Input['FoundationImageNodesBlockNodeUcsmParamsArgs']] = None,
                 vswitches: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeVswitchArgs']]]] = None):
        """
        :param pulumi.Input[str] hypervisor_hostname: - (Required) Hypervisor Hostname.
        :param pulumi.Input[str] hypervisor_ip: - (Required) Hypervisor IP address.
        :param pulumi.Input[str] node_position: - (Required) Position of the node in the block.
        :param pulumi.Input[str] bond_lacp_rate: - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
        :param pulumi.Input[str] bond_mode: - (Required if node is capable) dynamic if using LACP, static for LAG
        :param pulumi.Input[str] bond_uplinks: - MAC Addresses of NICs in a team/bond
        :param pulumi.Input[str] cluster_id: - ID of cluster.
        :param pulumi.Input[int] current_cvm_vlan_tag: - Current CVM vlan tag. 0 Value with remove vlan tag.
        :param pulumi.Input[str] current_network_interface: - CVM current network interface.
        :param pulumi.Input[int] cvm_gb_ram: - RAM capacity of CVM in GB.
        :param pulumi.Input[int] cvm_num_vcpus: - Number of CVM vcpus.
        :param pulumi.Input[str] device_hint: - use "vm_installer" to enable CVM imaging from standalone.
        :param pulumi.Input[str] exlude_boot_serial: - serial of boot device to be excluded (used by NX G6 platforms)
        :param pulumi.Input[int] image_delay: - Imaging delay.
        :param pulumi.Input[bool] image_now: - (Optional, Default = true) If the node should be imaged now.
        :param pulumi.Input[bool] ipmi_configure_now: - Whether IPMI should be configured.
        :param pulumi.Input[str] ipmi_gateway: - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
        :param pulumi.Input[str] ipmi_ip: - (Required) IPMI IP address.
        :param pulumi.Input[str] ipmi_mac: - IPMI MAC address.
        :param pulumi.Input[str] ipmi_netmask: - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
        :param pulumi.Input[str] ipmi_password: - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
        :param pulumi.Input[str] ipmi_user: - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
        :param pulumi.Input[str] ipv6_address: - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) IPV6 address.
        :param pulumi.Input[str] ipv6_interface: - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) ipv6 interface.
        :param pulumi.Input[bool] mitigate_low_boot_space: - relocate bootbank files to make space for phoenix files.
        :param pulumi.Input[str] node_serial: - serial number of the node.
        :param pulumi.Input[str] rdma_mac_addr: - mac address of nic to be used for rdma
        :param pulumi.Input[bool] rdma_passthrough: - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
        :param pulumi.Input[str] ucsm_managed_mode: - UCSM Managed mode.
        :param pulumi.Input[str] ucsm_node_serial: - UCSM node serial.
        :param pulumi.Input['FoundationImageNodesBlockNodeUcsmParamsArgs'] ucsm_params: - Object of UCSM parameters.
               * `ucsm_params.native_vlan` :- If the vlan is native.
               * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
               * `ucsm_params.mac_pool` :- Mac address pool.
               * `ucsm_params.vlan_name` :- Name of vlan.
        """
        pulumi.set(__self__, "hypervisor_hostname", hypervisor_hostname)
        pulumi.set(__self__, "hypervisor_ip", hypervisor_ip)
        pulumi.set(__self__, "node_position", node_position)
        if bond_lacp_rate is not None:
            pulumi.set(__self__, "bond_lacp_rate", bond_lacp_rate)
        if bond_mode is not None:
            pulumi.set(__self__, "bond_mode", bond_mode)
        if bond_uplinks is not None:
            pulumi.set(__self__, "bond_uplinks", bond_uplinks)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if current_cvm_vlan_tag is not None:
            pulumi.set(__self__, "current_cvm_vlan_tag", current_cvm_vlan_tag)
        if current_network_interface is not None:
            pulumi.set(__self__, "current_network_interface", current_network_interface)
        if cvm_gb_ram is not None:
            pulumi.set(__self__, "cvm_gb_ram", cvm_gb_ram)
        if cvm_ip is not None:
            pulumi.set(__self__, "cvm_ip", cvm_ip)
        if cvm_num_vcpus is not None:
            pulumi.set(__self__, "cvm_num_vcpus", cvm_num_vcpus)
        if device_hint is not None:
            pulumi.set(__self__, "device_hint", device_hint)
        if exlude_boot_serial is not None:
            pulumi.set(__self__, "exlude_boot_serial", exlude_boot_serial)
        if hypervisor is not None:
            pulumi.set(__self__, "hypervisor", hypervisor)
        if image_delay is not None:
            pulumi.set(__self__, "image_delay", image_delay)
        if image_now is not None:
            pulumi.set(__self__, "image_now", image_now)
        if image_successful is not None:
            pulumi.set(__self__, "image_successful", image_successful)
        if ipmi_configure_now is not None:
            pulumi.set(__self__, "ipmi_configure_now", ipmi_configure_now)
        if ipmi_gateway is not None:
            pulumi.set(__self__, "ipmi_gateway", ipmi_gateway)
        if ipmi_ip is not None:
            pulumi.set(__self__, "ipmi_ip", ipmi_ip)
        if ipmi_mac is not None:
            pulumi.set(__self__, "ipmi_mac", ipmi_mac)
        if ipmi_netmask is not None:
            pulumi.set(__self__, "ipmi_netmask", ipmi_netmask)
        if ipmi_password is not None:
            pulumi.set(__self__, "ipmi_password", ipmi_password)
        if ipmi_user is not None:
            pulumi.set(__self__, "ipmi_user", ipmi_user)
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)
        if ipv6_interface is not None:
            pulumi.set(__self__, "ipv6_interface", ipv6_interface)
        if mitigate_low_boot_space is not None:
            pulumi.set(__self__, "mitigate_low_boot_space", mitigate_low_boot_space)
        if node_serial is not None:
            pulumi.set(__self__, "node_serial", node_serial)
        if rdma_mac_addr is not None:
            pulumi.set(__self__, "rdma_mac_addr", rdma_mac_addr)
        if rdma_passthrough is not None:
            pulumi.set(__self__, "rdma_passthrough", rdma_passthrough)
        if ucsm_managed_mode is not None:
            pulumi.set(__self__, "ucsm_managed_mode", ucsm_managed_mode)
        if ucsm_node_serial is not None:
            pulumi.set(__self__, "ucsm_node_serial", ucsm_node_serial)
        if ucsm_params is not None:
            pulumi.set(__self__, "ucsm_params", ucsm_params)
        if vswitches is not None:
            pulumi.set(__self__, "vswitches", vswitches)

    @property
    @pulumi.getter(name="hypervisorHostname")
    def hypervisor_hostname(self) -> pulumi.Input[str]:
        """
        - (Required) Hypervisor Hostname.
        """
        return pulumi.get(self, "hypervisor_hostname")

    @hypervisor_hostname.setter
    def hypervisor_hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hypervisor_hostname", value)

    @property
    @pulumi.getter(name="hypervisorIp")
    def hypervisor_ip(self) -> pulumi.Input[str]:
        """
        - (Required) Hypervisor IP address.
        """
        return pulumi.get(self, "hypervisor_ip")

    @hypervisor_ip.setter
    def hypervisor_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "hypervisor_ip", value)

    @property
    @pulumi.getter(name="nodePosition")
    def node_position(self) -> pulumi.Input[str]:
        """
        - (Required) Position of the node in the block.
        """
        return pulumi.get(self, "node_position")

    @node_position.setter
    def node_position(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_position", value)

    @property
    @pulumi.getter(name="bondLacpRate")
    def bond_lacp_rate(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required if node is lacp configured) slow or fast if lacp if being used at the switch
        """
        return pulumi.get(self, "bond_lacp_rate")

    @bond_lacp_rate.setter
    def bond_lacp_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bond_lacp_rate", value)

    @property
    @pulumi.getter(name="bondMode")
    def bond_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required if node is capable) dynamic if using LACP, static for LAG
        """
        return pulumi.get(self, "bond_mode")

    @bond_mode.setter
    def bond_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bond_mode", value)

    @property
    @pulumi.getter(name="bondUplinks")
    def bond_uplinks(self) -> Optional[pulumi.Input[str]]:
        """
        - MAC Addresses of NICs in a team/bond
        """
        return pulumi.get(self, "bond_uplinks")

    @bond_uplinks.setter
    def bond_uplinks(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bond_uplinks", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        - ID of cluster.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="currentCvmVlanTag")
    def current_cvm_vlan_tag(self) -> Optional[pulumi.Input[int]]:
        """
        - Current CVM vlan tag. 0 Value with remove vlan tag.
        """
        return pulumi.get(self, "current_cvm_vlan_tag")

    @current_cvm_vlan_tag.setter
    def current_cvm_vlan_tag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_cvm_vlan_tag", value)

    @property
    @pulumi.getter(name="currentNetworkInterface")
    def current_network_interface(self) -> Optional[pulumi.Input[str]]:
        """
        - CVM current network interface.
        """
        return pulumi.get(self, "current_network_interface")

    @current_network_interface.setter
    def current_network_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_network_interface", value)

    @property
    @pulumi.getter(name="cvmGbRam")
    def cvm_gb_ram(self) -> Optional[pulumi.Input[int]]:
        """
        - RAM capacity of CVM in GB.
        """
        return pulumi.get(self, "cvm_gb_ram")

    @cvm_gb_ram.setter
    def cvm_gb_ram(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cvm_gb_ram", value)

    @property
    @pulumi.getter(name="cvmIp")
    def cvm_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cvm_ip")

    @cvm_ip.setter
    def cvm_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_ip", value)

    @property
    @pulumi.getter(name="cvmNumVcpus")
    def cvm_num_vcpus(self) -> Optional[pulumi.Input[int]]:
        """
        - Number of CVM vcpus.
        """
        return pulumi.get(self, "cvm_num_vcpus")

    @cvm_num_vcpus.setter
    def cvm_num_vcpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cvm_num_vcpus", value)

    @property
    @pulumi.getter(name="deviceHint")
    def device_hint(self) -> Optional[pulumi.Input[str]]:
        """
        - use "vm_installer" to enable CVM imaging from standalone.
        """
        return pulumi.get(self, "device_hint")

    @device_hint.setter
    def device_hint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_hint", value)

    @property
    @pulumi.getter(name="exludeBootSerial")
    def exlude_boot_serial(self) -> Optional[pulumi.Input[str]]:
        """
        - serial of boot device to be excluded (used by NX G6 platforms)
        """
        return pulumi.get(self, "exlude_boot_serial")

    @exlude_boot_serial.setter
    def exlude_boot_serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exlude_boot_serial", value)

    @property
    @pulumi.getter
    def hypervisor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hypervisor")

    @hypervisor.setter
    def hypervisor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor", value)

    @property
    @pulumi.getter(name="imageDelay")
    def image_delay(self) -> Optional[pulumi.Input[int]]:
        """
        - Imaging delay.
        """
        return pulumi.get(self, "image_delay")

    @image_delay.setter
    def image_delay(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_delay", value)

    @property
    @pulumi.getter(name="imageNow")
    def image_now(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional, Default = true) If the node should be imaged now.
        """
        return pulumi.get(self, "image_now")

    @image_now.setter
    def image_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_now", value)

    @property
    @pulumi.getter(name="imageSuccessful")
    def image_successful(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "image_successful")

    @image_successful.setter
    def image_successful(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "image_successful", value)

    @property
    @pulumi.getter(name="ipmiConfigureNow")
    def ipmi_configure_now(self) -> Optional[pulumi.Input[bool]]:
        """
        - Whether IPMI should be configured.
        """
        return pulumi.get(self, "ipmi_configure_now")

    @ipmi_configure_now.setter
    def ipmi_configure_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipmi_configure_now", value)

    @property
    @pulumi.getter(name="ipmiGateway")
    def ipmi_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI gateway for this node
        """
        return pulumi.get(self, "ipmi_gateway")

    @ipmi_gateway.setter
    def ipmi_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_gateway", value)

    @property
    @pulumi.getter(name="ipmiIp")
    def ipmi_ip(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) IPMI IP address.
        """
        return pulumi.get(self, "ipmi_ip")

    @ipmi_ip.setter
    def ipmi_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_ip", value)

    @property
    @pulumi.getter(name="ipmiMac")
    def ipmi_mac(self) -> Optional[pulumi.Input[str]]:
        """
        - IPMI MAC address.
        """
        return pulumi.get(self, "ipmi_mac")

    @ipmi_mac.setter
    def ipmi_mac(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_mac", value)

    @property
    @pulumi.getter(name="ipmiNetmask")
    def ipmi_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI netmask for this node
        """
        return pulumi.get(self, "ipmi_netmask")

    @ipmi_netmask.setter
    def ipmi_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_netmask", value)

    @property
    @pulumi.getter(name="ipmiPassword")
    def ipmi_password(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI username
        """
        return pulumi.get(self, "ipmi_password")

    @ipmi_password.setter
    def ipmi_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_password", value)

    @property
    @pulumi.getter(name="ipmiUser")
    def ipmi_user(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required incase using IPMI based imaging either here or outside blocks) IPMI password
        """
        return pulumi.get(self, "ipmi_user")

    @ipmi_user.setter
    def ipmi_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_user", value)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) IPV6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_address", value)

    @property
    @pulumi.getter(name="ipv6Interface")
    def ipv6_interface(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required when device_hint = "vm_installer" for imaging using node's existing cvm for imaging) ipv6 interface.
        """
        return pulumi.get(self, "ipv6_interface")

    @ipv6_interface.setter
    def ipv6_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6_interface", value)

    @property
    @pulumi.getter(name="mitigateLowBootSpace")
    def mitigate_low_boot_space(self) -> Optional[pulumi.Input[bool]]:
        """
        - relocate bootbank files to make space for phoenix files.
        """
        return pulumi.get(self, "mitigate_low_boot_space")

    @mitigate_low_boot_space.setter
    def mitigate_low_boot_space(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mitigate_low_boot_space", value)

    @property
    @pulumi.getter(name="nodeSerial")
    def node_serial(self) -> Optional[pulumi.Input[str]]:
        """
        - serial number of the node.
        """
        return pulumi.get(self, "node_serial")

    @node_serial.setter
    def node_serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_serial", value)

    @property
    @pulumi.getter(name="rdmaMacAddr")
    def rdma_mac_addr(self) -> Optional[pulumi.Input[str]]:
        """
        - mac address of nic to be used for rdma
        """
        return pulumi.get(self, "rdma_mac_addr")

    @rdma_mac_addr.setter
    def rdma_mac_addr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rdma_mac_addr", value)

    @property
    @pulumi.getter(name="rdmaPassthrough")
    def rdma_passthrough(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Required if node is capable) passthru RDMA nic to CVM if possible, default to false
        """
        return pulumi.get(self, "rdma_passthrough")

    @rdma_passthrough.setter
    def rdma_passthrough(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rdma_passthrough", value)

    @property
    @pulumi.getter(name="ucsmManagedMode")
    def ucsm_managed_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - UCSM Managed mode.
        """
        return pulumi.get(self, "ucsm_managed_mode")

    @ucsm_managed_mode.setter
    def ucsm_managed_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ucsm_managed_mode", value)

    @property
    @pulumi.getter(name="ucsmNodeSerial")
    def ucsm_node_serial(self) -> Optional[pulumi.Input[str]]:
        """
        - UCSM node serial.
        """
        return pulumi.get(self, "ucsm_node_serial")

    @ucsm_node_serial.setter
    def ucsm_node_serial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ucsm_node_serial", value)

    @property
    @pulumi.getter(name="ucsmParams")
    def ucsm_params(self) -> Optional[pulumi.Input['FoundationImageNodesBlockNodeUcsmParamsArgs']]:
        """
        - Object of UCSM parameters.
        * `ucsm_params.native_vlan` :- If the vlan is native.
        * `ucsm_params.keep_ucsm_settings` :- Whether UCSM settings should be kept.
        * `ucsm_params.mac_pool` :- Mac address pool.
        * `ucsm_params.vlan_name` :- Name of vlan.
        """
        return pulumi.get(self, "ucsm_params")

    @ucsm_params.setter
    def ucsm_params(self, value: Optional[pulumi.Input['FoundationImageNodesBlockNodeUcsmParamsArgs']]):
        pulumi.set(self, "ucsm_params", value)

    @property
    @pulumi.getter
    def vswitches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeVswitchArgs']]]]:
        return pulumi.get(self, "vswitches")

    @vswitches.setter
    def vswitches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FoundationImageNodesBlockNodeVswitchArgs']]]]):
        pulumi.set(self, "vswitches", value)


if not MYPY:
    class FoundationImageNodesBlockNodeUcsmParamsArgsDict(TypedDict):
        keep_ucsm_settings: NotRequired[pulumi.Input[bool]]
        mac_pool: NotRequired[pulumi.Input[str]]
        native_vlan: NotRequired[pulumi.Input[bool]]
        vlan_name: NotRequired[pulumi.Input[str]]
elif False:
    FoundationImageNodesBlockNodeUcsmParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesBlockNodeUcsmParamsArgs:
    def __init__(__self__, *,
                 keep_ucsm_settings: Optional[pulumi.Input[bool]] = None,
                 mac_pool: Optional[pulumi.Input[str]] = None,
                 native_vlan: Optional[pulumi.Input[bool]] = None,
                 vlan_name: Optional[pulumi.Input[str]] = None):
        if keep_ucsm_settings is not None:
            pulumi.set(__self__, "keep_ucsm_settings", keep_ucsm_settings)
        if mac_pool is not None:
            pulumi.set(__self__, "mac_pool", mac_pool)
        if native_vlan is not None:
            pulumi.set(__self__, "native_vlan", native_vlan)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="keepUcsmSettings")
    def keep_ucsm_settings(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keep_ucsm_settings")

    @keep_ucsm_settings.setter
    def keep_ucsm_settings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_ucsm_settings", value)

    @property
    @pulumi.getter(name="macPool")
    def mac_pool(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_pool")

    @mac_pool.setter
    def mac_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_pool", value)

    @property
    @pulumi.getter(name="nativeVlan")
    def native_vlan(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "native_vlan")

    @native_vlan.setter
    def native_vlan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "native_vlan", value)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_name")

    @vlan_name.setter
    def vlan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_name", value)


if not MYPY:
    class FoundationImageNodesBlockNodeVswitchArgsDict(TypedDict):
        bond_mode: NotRequired[pulumi.Input[str]]
        """
        - (Required if node is capable) dynamic if using LACP, static for LAG
        """
        lacp: NotRequired[pulumi.Input[str]]
        mtu: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        other_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        uplinks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    FoundationImageNodesBlockNodeVswitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesBlockNodeVswitchArgs:
    def __init__(__self__, *,
                 bond_mode: Optional[pulumi.Input[str]] = None,
                 lacp: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 other_configs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 uplinks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] bond_mode: - (Required if node is capable) dynamic if using LACP, static for LAG
        """
        if bond_mode is not None:
            pulumi.set(__self__, "bond_mode", bond_mode)
        if lacp is not None:
            pulumi.set(__self__, "lacp", lacp)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if other_configs is not None:
            pulumi.set(__self__, "other_configs", other_configs)
        if uplinks is not None:
            pulumi.set(__self__, "uplinks", uplinks)

    @property
    @pulumi.getter(name="bondMode")
    def bond_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required if node is capable) dynamic if using LACP, static for LAG
        """
        return pulumi.get(self, "bond_mode")

    @bond_mode.setter
    def bond_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bond_mode", value)

    @property
    @pulumi.getter
    def lacp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lacp")

    @lacp.setter
    def lacp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lacp", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="otherConfigs")
    def other_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "other_configs")

    @other_configs.setter
    def other_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "other_configs", value)

    @property
    @pulumi.getter
    def uplinks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "uplinks")

    @uplinks.setter
    def uplinks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uplinks", value)


if not MYPY:
    class FoundationImageNodesClusterArgsDict(TypedDict):
        cluster_members: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        - (Required) Members in the cluster.
        """
        cluster_name: pulumi.Input[str]
        """
        - (Required) Name of the cluster.
        """
        redundancy_factor: pulumi.Input[int]
        """
        - (Required) Cluster Redundancy Factor.
        """
        backplane_netmask: NotRequired[pulumi.Input[str]]
        """
        - Backplane netmask.
        """
        backplane_subnet: NotRequired[pulumi.Input[str]]
        """
        - Backplane subnet address.
        """
        backplane_vlan: NotRequired[pulumi.Input[str]]
        """
        - Backplane vlan.
        """
        cluster_external_ip: NotRequired[pulumi.Input[str]]
        """
        - External IP of the cluster.
        """
        cluster_init_now: NotRequired[pulumi.Input[bool]]
        """
        - (Optional, Default = true) If cluster should be created.
        """
        cluster_init_successful: NotRequired[pulumi.Input[bool]]
        """
        - If cluster initialization was successful.
        """
        cvm_dns_servers: NotRequired[pulumi.Input[str]]
        """
        - DNS servers of CVM.
        """
        cvm_ntp_servers: NotRequired[pulumi.Input[str]]
        """
        - NTP servers of CVM.
        """
        enable_ns: NotRequired[pulumi.Input[bool]]
        """
        - If network segmentation should be enabled.
        """
        hypervisor_ntp_servers: NotRequired[pulumi.Input[str]]
        """
        - NTP servers of hypervisor.
        """
        single_node_cluster: NotRequired[pulumi.Input[bool]]
        """
        - If it is a single node cluster.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        - Set timezone for every CVM
        """
elif False:
    FoundationImageNodesClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesClusterArgs:
    def __init__(__self__, *,
                 cluster_members: pulumi.Input[Sequence[pulumi.Input[str]]],
                 cluster_name: pulumi.Input[str],
                 redundancy_factor: pulumi.Input[int],
                 backplane_netmask: Optional[pulumi.Input[str]] = None,
                 backplane_subnet: Optional[pulumi.Input[str]] = None,
                 backplane_vlan: Optional[pulumi.Input[str]] = None,
                 cluster_external_ip: Optional[pulumi.Input[str]] = None,
                 cluster_init_now: Optional[pulumi.Input[bool]] = None,
                 cluster_init_successful: Optional[pulumi.Input[bool]] = None,
                 cvm_dns_servers: Optional[pulumi.Input[str]] = None,
                 cvm_ntp_servers: Optional[pulumi.Input[str]] = None,
                 enable_ns: Optional[pulumi.Input[bool]] = None,
                 hypervisor_ntp_servers: Optional[pulumi.Input[str]] = None,
                 single_node_cluster: Optional[pulumi.Input[bool]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cluster_members: - (Required) Members in the cluster.
        :param pulumi.Input[str] cluster_name: - (Required) Name of the cluster.
        :param pulumi.Input[int] redundancy_factor: - (Required) Cluster Redundancy Factor.
        :param pulumi.Input[str] backplane_netmask: - Backplane netmask.
        :param pulumi.Input[str] backplane_subnet: - Backplane subnet address.
        :param pulumi.Input[str] backplane_vlan: - Backplane vlan.
        :param pulumi.Input[str] cluster_external_ip: - External IP of the cluster.
        :param pulumi.Input[bool] cluster_init_now: - (Optional, Default = true) If cluster should be created.
        :param pulumi.Input[bool] cluster_init_successful: - If cluster initialization was successful.
        :param pulumi.Input[str] cvm_dns_servers: - DNS servers of CVM.
        :param pulumi.Input[str] cvm_ntp_servers: - NTP servers of CVM.
        :param pulumi.Input[bool] enable_ns: - If network segmentation should be enabled.
        :param pulumi.Input[str] hypervisor_ntp_servers: - NTP servers of hypervisor.
        :param pulumi.Input[bool] single_node_cluster: - If it is a single node cluster.
        :param pulumi.Input[str] timezone: - Set timezone for every CVM
        """
        pulumi.set(__self__, "cluster_members", cluster_members)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "redundancy_factor", redundancy_factor)
        if backplane_netmask is not None:
            pulumi.set(__self__, "backplane_netmask", backplane_netmask)
        if backplane_subnet is not None:
            pulumi.set(__self__, "backplane_subnet", backplane_subnet)
        if backplane_vlan is not None:
            pulumi.set(__self__, "backplane_vlan", backplane_vlan)
        if cluster_external_ip is not None:
            pulumi.set(__self__, "cluster_external_ip", cluster_external_ip)
        if cluster_init_now is not None:
            pulumi.set(__self__, "cluster_init_now", cluster_init_now)
        if cluster_init_successful is not None:
            pulumi.set(__self__, "cluster_init_successful", cluster_init_successful)
        if cvm_dns_servers is not None:
            pulumi.set(__self__, "cvm_dns_servers", cvm_dns_servers)
        if cvm_ntp_servers is not None:
            pulumi.set(__self__, "cvm_ntp_servers", cvm_ntp_servers)
        if enable_ns is not None:
            pulumi.set(__self__, "enable_ns", enable_ns)
        if hypervisor_ntp_servers is not None:
            pulumi.set(__self__, "hypervisor_ntp_servers", hypervisor_ntp_servers)
        if single_node_cluster is not None:
            pulumi.set(__self__, "single_node_cluster", single_node_cluster)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="clusterMembers")
    def cluster_members(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        - (Required) Members in the cluster.
        """
        return pulumi.get(self, "cluster_members")

    @cluster_members.setter
    def cluster_members(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "cluster_members", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        - (Required) Name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="redundancyFactor")
    def redundancy_factor(self) -> pulumi.Input[int]:
        """
        - (Required) Cluster Redundancy Factor.
        """
        return pulumi.get(self, "redundancy_factor")

    @redundancy_factor.setter
    def redundancy_factor(self, value: pulumi.Input[int]):
        pulumi.set(self, "redundancy_factor", value)

    @property
    @pulumi.getter(name="backplaneNetmask")
    def backplane_netmask(self) -> Optional[pulumi.Input[str]]:
        """
        - Backplane netmask.
        """
        return pulumi.get(self, "backplane_netmask")

    @backplane_netmask.setter
    def backplane_netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backplane_netmask", value)

    @property
    @pulumi.getter(name="backplaneSubnet")
    def backplane_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        - Backplane subnet address.
        """
        return pulumi.get(self, "backplane_subnet")

    @backplane_subnet.setter
    def backplane_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backplane_subnet", value)

    @property
    @pulumi.getter(name="backplaneVlan")
    def backplane_vlan(self) -> Optional[pulumi.Input[str]]:
        """
        - Backplane vlan.
        """
        return pulumi.get(self, "backplane_vlan")

    @backplane_vlan.setter
    def backplane_vlan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backplane_vlan", value)

    @property
    @pulumi.getter(name="clusterExternalIp")
    def cluster_external_ip(self) -> Optional[pulumi.Input[str]]:
        """
        - External IP of the cluster.
        """
        return pulumi.get(self, "cluster_external_ip")

    @cluster_external_ip.setter
    def cluster_external_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_external_ip", value)

    @property
    @pulumi.getter(name="clusterInitNow")
    def cluster_init_now(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional, Default = true) If cluster should be created.
        """
        return pulumi.get(self, "cluster_init_now")

    @cluster_init_now.setter
    def cluster_init_now(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_init_now", value)

    @property
    @pulumi.getter(name="clusterInitSuccessful")
    def cluster_init_successful(self) -> Optional[pulumi.Input[bool]]:
        """
        - If cluster initialization was successful.
        """
        return pulumi.get(self, "cluster_init_successful")

    @cluster_init_successful.setter
    def cluster_init_successful(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_init_successful", value)

    @property
    @pulumi.getter(name="cvmDnsServers")
    def cvm_dns_servers(self) -> Optional[pulumi.Input[str]]:
        """
        - DNS servers of CVM.
        """
        return pulumi.get(self, "cvm_dns_servers")

    @cvm_dns_servers.setter
    def cvm_dns_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_dns_servers", value)

    @property
    @pulumi.getter(name="cvmNtpServers")
    def cvm_ntp_servers(self) -> Optional[pulumi.Input[str]]:
        """
        - NTP servers of CVM.
        """
        return pulumi.get(self, "cvm_ntp_servers")

    @cvm_ntp_servers.setter
    def cvm_ntp_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cvm_ntp_servers", value)

    @property
    @pulumi.getter(name="enableNs")
    def enable_ns(self) -> Optional[pulumi.Input[bool]]:
        """
        - If network segmentation should be enabled.
        """
        return pulumi.get(self, "enable_ns")

    @enable_ns.setter
    def enable_ns(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ns", value)

    @property
    @pulumi.getter(name="hypervisorNtpServers")
    def hypervisor_ntp_servers(self) -> Optional[pulumi.Input[str]]:
        """
        - NTP servers of hypervisor.
        """
        return pulumi.get(self, "hypervisor_ntp_servers")

    @hypervisor_ntp_servers.setter
    def hypervisor_ntp_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hypervisor_ntp_servers", value)

    @property
    @pulumi.getter(name="singleNodeCluster")
    def single_node_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        - If it is a single node cluster.
        """
        return pulumi.get(self, "single_node_cluster")

    @single_node_cluster.setter
    def single_node_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "single_node_cluster", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        - Set timezone for every CVM
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class FoundationImageNodesClusterUrlArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the cluster.
        """
        cluster_url: NotRequired[pulumi.Input[str]]
elif False:
    FoundationImageNodesClusterUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesClusterUrlArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 cluster_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: - (Required) Name of the cluster.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_url is not None:
            pulumi.set(__self__, "cluster_url", cluster_url)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterUrl")
    def cluster_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_url")

    @cluster_url.setter
    def cluster_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_url", value)


if not MYPY:
    class FoundationImageNodesEosMetadataArgsDict(TypedDict):
        account_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - arrya of account names
        """
        config_id: NotRequired[pulumi.Input[str]]
        """
        - Id of the Eos config uploaded in foundation GUI.
        """
        email: NotRequired[pulumi.Input[str]]
        """
        - Email address of the user who downloaded Eos config.
        """
elif False:
    FoundationImageNodesEosMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesEosMetadataArgs:
    def __init__(__self__, *,
                 account_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 config_id: Optional[pulumi.Input[str]] = None,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] account_names: - arrya of account names
        :param pulumi.Input[str] config_id: - Id of the Eos config uploaded in foundation GUI.
        :param pulumi.Input[str] email: - Email address of the user who downloaded Eos config.
        """
        if account_names is not None:
            pulumi.set(__self__, "account_names", account_names)
        if config_id is not None:
            pulumi.set(__self__, "config_id", config_id)
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter(name="accountNames")
    def account_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - arrya of account names
        """
        return pulumi.get(self, "account_names")

    @account_names.setter
    def account_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "account_names", value)

    @property
    @pulumi.getter(name="configId")
    def config_id(self) -> Optional[pulumi.Input[str]]:
        """
        - Id of the Eos config uploaded in foundation GUI.
        """
        return pulumi.get(self, "config_id")

    @config_id.setter
    def config_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_id", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        - Email address of the user who downloaded Eos config.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


if not MYPY:
    class FoundationImageNodesFcSettingsArgsDict(TypedDict):
        fc_metadata: pulumi.Input['FoundationImageNodesFcSettingsFcMetadataArgsDict']
        """
        - Foundation Central metadata which will be transferred to the newly imaged node.
        * `fc_metadata.fc_ip` :- IP address of foundation central.
        * `fc_metadata.api_key` :- api_key which the node uses to register itself with foundation central.
        """
        foundation_central: pulumi.Input[bool]
        """
        - If this attribute is set to True, FC workflow will be invoked.
        """
elif False:
    FoundationImageNodesFcSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesFcSettingsArgs:
    def __init__(__self__, *,
                 fc_metadata: pulumi.Input['FoundationImageNodesFcSettingsFcMetadataArgs'],
                 foundation_central: pulumi.Input[bool]):
        """
        :param pulumi.Input['FoundationImageNodesFcSettingsFcMetadataArgs'] fc_metadata: - Foundation Central metadata which will be transferred to the newly imaged node.
               * `fc_metadata.fc_ip` :- IP address of foundation central.
               * `fc_metadata.api_key` :- api_key which the node uses to register itself with foundation central.
        :param pulumi.Input[bool] foundation_central: - If this attribute is set to True, FC workflow will be invoked.
        """
        pulumi.set(__self__, "fc_metadata", fc_metadata)
        pulumi.set(__self__, "foundation_central", foundation_central)

    @property
    @pulumi.getter(name="fcMetadata")
    def fc_metadata(self) -> pulumi.Input['FoundationImageNodesFcSettingsFcMetadataArgs']:
        """
        - Foundation Central metadata which will be transferred to the newly imaged node.
        * `fc_metadata.fc_ip` :- IP address of foundation central.
        * `fc_metadata.api_key` :- api_key which the node uses to register itself with foundation central.
        """
        return pulumi.get(self, "fc_metadata")

    @fc_metadata.setter
    def fc_metadata(self, value: pulumi.Input['FoundationImageNodesFcSettingsFcMetadataArgs']):
        pulumi.set(self, "fc_metadata", value)

    @property
    @pulumi.getter(name="foundationCentral")
    def foundation_central(self) -> pulumi.Input[bool]:
        """
        - If this attribute is set to True, FC workflow will be invoked.
        """
        return pulumi.get(self, "foundation_central")

    @foundation_central.setter
    def foundation_central(self, value: pulumi.Input[bool]):
        pulumi.set(self, "foundation_central", value)


if not MYPY:
    class FoundationImageNodesFcSettingsFcMetadataArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        fc_ip: pulumi.Input[str]
elif False:
    FoundationImageNodesFcSettingsFcMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesFcSettingsFcMetadataArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 fc_ip: pulumi.Input[str]):
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "fc_ip", fc_ip)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="fcIp")
    def fc_ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "fc_ip")

    @fc_ip.setter
    def fc_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "fc_ip", value)


if not MYPY:
    class FoundationImageNodesHypervisorIsoArgsDict(TypedDict):
        esx: NotRequired[pulumi.Input['FoundationImageNodesHypervisorIsoEsxArgsDict']]
        """
        - Details of hypervisor ISO of type esx.
        """
        hyperv: NotRequired[pulumi.Input['FoundationImageNodesHypervisorIsoHypervArgsDict']]
        """
        - Details of hypervisor ISO of type hyperv.
        """
        kvm: NotRequired[pulumi.Input['FoundationImageNodesHypervisorIsoKvmArgsDict']]
        """
        - Details of hypervisor ISO of type kvm.
        """
        xen: NotRequired[pulumi.Input['FoundationImageNodesHypervisorIsoXenArgsDict']]
        """
        - Details of hypervisor ISO of type xen.
        """
elif False:
    FoundationImageNodesHypervisorIsoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesHypervisorIsoArgs:
    def __init__(__self__, *,
                 esx: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoEsxArgs']] = None,
                 hyperv: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoHypervArgs']] = None,
                 kvm: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoKvmArgs']] = None,
                 xen: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoXenArgs']] = None):
        """
        :param pulumi.Input['FoundationImageNodesHypervisorIsoEsxArgs'] esx: - Details of hypervisor ISO of type esx.
        :param pulumi.Input['FoundationImageNodesHypervisorIsoHypervArgs'] hyperv: - Details of hypervisor ISO of type hyperv.
        :param pulumi.Input['FoundationImageNodesHypervisorIsoKvmArgs'] kvm: - Details of hypervisor ISO of type kvm.
        :param pulumi.Input['FoundationImageNodesHypervisorIsoXenArgs'] xen: - Details of hypervisor ISO of type xen.
        """
        if esx is not None:
            pulumi.set(__self__, "esx", esx)
        if hyperv is not None:
            pulumi.set(__self__, "hyperv", hyperv)
        if kvm is not None:
            pulumi.set(__self__, "kvm", kvm)
        if xen is not None:
            pulumi.set(__self__, "xen", xen)

    @property
    @pulumi.getter
    def esx(self) -> Optional[pulumi.Input['FoundationImageNodesHypervisorIsoEsxArgs']]:
        """
        - Details of hypervisor ISO of type esx.
        """
        return pulumi.get(self, "esx")

    @esx.setter
    def esx(self, value: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoEsxArgs']]):
        pulumi.set(self, "esx", value)

    @property
    @pulumi.getter
    def hyperv(self) -> Optional[pulumi.Input['FoundationImageNodesHypervisorIsoHypervArgs']]:
        """
        - Details of hypervisor ISO of type hyperv.
        """
        return pulumi.get(self, "hyperv")

    @hyperv.setter
    def hyperv(self, value: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoHypervArgs']]):
        pulumi.set(self, "hyperv", value)

    @property
    @pulumi.getter
    def kvm(self) -> Optional[pulumi.Input['FoundationImageNodesHypervisorIsoKvmArgs']]:
        """
        - Details of hypervisor ISO of type kvm.
        """
        return pulumi.get(self, "kvm")

    @kvm.setter
    def kvm(self, value: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoKvmArgs']]):
        pulumi.set(self, "kvm", value)

    @property
    @pulumi.getter
    def xen(self) -> Optional[pulumi.Input['FoundationImageNodesHypervisorIsoXenArgs']]:
        """
        - Details of hypervisor ISO of type xen.
        """
        return pulumi.get(self, "xen")

    @xen.setter
    def xen(self, value: Optional[pulumi.Input['FoundationImageNodesHypervisorIsoXenArgs']]):
        pulumi.set(self, "xen", value)


if not MYPY:
    class FoundationImageNodesHypervisorIsoEsxArgsDict(TypedDict):
        checksum: pulumi.Input[str]
        """
        - (Required) Filename of hypervisor ISO.
        """
        filename: pulumi.Input[str]
        """
        - (Required) Checksum for ISO file.
        """
elif False:
    FoundationImageNodesHypervisorIsoEsxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesHypervisorIsoEsxArgs:
    def __init__(__self__, *,
                 checksum: pulumi.Input[str],
                 filename: pulumi.Input[str]):
        """
        :param pulumi.Input[str] checksum: - (Required) Filename of hypervisor ISO.
        :param pulumi.Input[str] filename: - (Required) Checksum for ISO file.
        """
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        - (Required) Filename of hypervisor ISO.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        - (Required) Checksum for ISO file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)


if not MYPY:
    class FoundationImageNodesHypervisorIsoHypervArgsDict(TypedDict):
        checksum: pulumi.Input[str]
        """
        - (Required) Filename of hypervisor ISO.
        """
        filename: pulumi.Input[str]
        """
        - (Required) Checksum for ISO file.
        """
elif False:
    FoundationImageNodesHypervisorIsoHypervArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesHypervisorIsoHypervArgs:
    def __init__(__self__, *,
                 checksum: pulumi.Input[str],
                 filename: pulumi.Input[str]):
        """
        :param pulumi.Input[str] checksum: - (Required) Filename of hypervisor ISO.
        :param pulumi.Input[str] filename: - (Required) Checksum for ISO file.
        """
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        - (Required) Filename of hypervisor ISO.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        - (Required) Checksum for ISO file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)


if not MYPY:
    class FoundationImageNodesHypervisorIsoKvmArgsDict(TypedDict):
        checksum: pulumi.Input[str]
        """
        - (Required) Filename of hypervisor ISO.
        """
        filename: pulumi.Input[str]
        """
        - (Required) Checksum for ISO file.
        """
elif False:
    FoundationImageNodesHypervisorIsoKvmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesHypervisorIsoKvmArgs:
    def __init__(__self__, *,
                 checksum: pulumi.Input[str],
                 filename: pulumi.Input[str]):
        """
        :param pulumi.Input[str] checksum: - (Required) Filename of hypervisor ISO.
        :param pulumi.Input[str] filename: - (Required) Checksum for ISO file.
        """
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        - (Required) Filename of hypervisor ISO.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        - (Required) Checksum for ISO file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)


if not MYPY:
    class FoundationImageNodesHypervisorIsoXenArgsDict(TypedDict):
        checksum: pulumi.Input[str]
        """
        - (Required) Filename of hypervisor ISO.
        """
        filename: pulumi.Input[str]
        """
        - (Required) Checksum for ISO file.
        """
elif False:
    FoundationImageNodesHypervisorIsoXenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesHypervisorIsoXenArgs:
    def __init__(__self__, *,
                 checksum: pulumi.Input[str],
                 filename: pulumi.Input[str]):
        """
        :param pulumi.Input[str] checksum: - (Required) Filename of hypervisor ISO.
        :param pulumi.Input[str] filename: - (Required) Checksum for ISO file.
        """
        pulumi.set(__self__, "checksum", checksum)
        pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def checksum(self) -> pulumi.Input[str]:
        """
        - (Required) Filename of hypervisor ISO.
        """
        return pulumi.get(self, "checksum")

    @checksum.setter
    def checksum(self, value: pulumi.Input[str]):
        pulumi.set(self, "checksum", value)

    @property
    @pulumi.getter
    def filename(self) -> pulumi.Input[str]:
        """
        - (Required) Checksum for ISO file.
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: pulumi.Input[str]):
        pulumi.set(self, "filename", value)


if not MYPY:
    class FoundationImageNodesTestsArgsDict(TypedDict):
        run_ncc: NotRequired[pulumi.Input[bool]]
        """
        - Whether NCC checks should run.
        """
        run_syscheck: NotRequired[pulumi.Input[bool]]
        """
        - Whether system checks should run.
        """
elif False:
    FoundationImageNodesTestsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationImageNodesTestsArgs:
    def __init__(__self__, *,
                 run_ncc: Optional[pulumi.Input[bool]] = None,
                 run_syscheck: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] run_ncc: - Whether NCC checks should run.
        :param pulumi.Input[bool] run_syscheck: - Whether system checks should run.
        """
        if run_ncc is not None:
            pulumi.set(__self__, "run_ncc", run_ncc)
        if run_syscheck is not None:
            pulumi.set(__self__, "run_syscheck", run_syscheck)

    @property
    @pulumi.getter(name="runNcc")
    def run_ncc(self) -> Optional[pulumi.Input[bool]]:
        """
        - Whether NCC checks should run.
        """
        return pulumi.get(self, "run_ncc")

    @run_ncc.setter
    def run_ncc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_ncc", value)

    @property
    @pulumi.getter(name="runSyscheck")
    def run_syscheck(self) -> Optional[pulumi.Input[bool]]:
        """
        - Whether system checks should run.
        """
        return pulumi.get(self, "run_syscheck")

    @run_syscheck.setter
    def run_syscheck(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "run_syscheck", value)


if not MYPY:
    class FoundationIpmiConfigBlockArgsDict(TypedDict):
        nodes: pulumi.Input[Sequence[pulumi.Input['FoundationIpmiConfigBlockNodeArgsDict']]]
        """
        - (Required) array of nodes for ipmi config.
        """
        block_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Block Id
        """
elif False:
    FoundationIpmiConfigBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationIpmiConfigBlockArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[Sequence[pulumi.Input['FoundationIpmiConfigBlockNodeArgs']]],
                 block_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FoundationIpmiConfigBlockNodeArgs']]] nodes: - (Required) array of nodes for ipmi config.
        :param pulumi.Input[str] block_id: - (Optional) Block Id
        """
        pulumi.set(__self__, "nodes", nodes)
        if block_id is not None:
            pulumi.set(__self__, "block_id", block_id)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['FoundationIpmiConfigBlockNodeArgs']]]:
        """
        - (Required) array of nodes for ipmi config.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['FoundationIpmiConfigBlockNodeArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="blockId")
    def block_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Block Id
        """
        return pulumi.get(self, "block_id")

    @block_id.setter
    def block_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_id", value)


if not MYPY:
    class FoundationIpmiConfigBlockNodeArgsDict(TypedDict):
        ipmi_configure_now: pulumi.Input[bool]
        """
        - (Required) Whether IPMI should be configured. Should be kept true to configure
        """
        ipmi_ip: pulumi.Input[str]
        """
        - IPMI IP address.
        """
        ipmi_mac: pulumi.Input[str]
        """
        - (Required) IPMI mac address.
        """
        ipmi_configure_successful: NotRequired[pulumi.Input[bool]]
        """
        - Whether IPMI was successfully configured.
        """
        ipmi_message: NotRequired[pulumi.Input[str]]
        """
        - IPMI configuration status message if any.
        """
elif False:
    FoundationIpmiConfigBlockNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FoundationIpmiConfigBlockNodeArgs:
    def __init__(__self__, *,
                 ipmi_configure_now: pulumi.Input[bool],
                 ipmi_ip: pulumi.Input[str],
                 ipmi_mac: pulumi.Input[str],
                 ipmi_configure_successful: Optional[pulumi.Input[bool]] = None,
                 ipmi_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] ipmi_configure_now: - (Required) Whether IPMI should be configured. Should be kept true to configure
        :param pulumi.Input[str] ipmi_ip: - IPMI IP address.
        :param pulumi.Input[str] ipmi_mac: - (Required) IPMI mac address.
        :param pulumi.Input[bool] ipmi_configure_successful: - Whether IPMI was successfully configured.
        :param pulumi.Input[str] ipmi_message: - IPMI configuration status message if any.
        """
        pulumi.set(__self__, "ipmi_configure_now", ipmi_configure_now)
        pulumi.set(__self__, "ipmi_ip", ipmi_ip)
        pulumi.set(__self__, "ipmi_mac", ipmi_mac)
        if ipmi_configure_successful is not None:
            pulumi.set(__self__, "ipmi_configure_successful", ipmi_configure_successful)
        if ipmi_message is not None:
            pulumi.set(__self__, "ipmi_message", ipmi_message)

    @property
    @pulumi.getter(name="ipmiConfigureNow")
    def ipmi_configure_now(self) -> pulumi.Input[bool]:
        """
        - (Required) Whether IPMI should be configured. Should be kept true to configure
        """
        return pulumi.get(self, "ipmi_configure_now")

    @ipmi_configure_now.setter
    def ipmi_configure_now(self, value: pulumi.Input[bool]):
        pulumi.set(self, "ipmi_configure_now", value)

    @property
    @pulumi.getter(name="ipmiIp")
    def ipmi_ip(self) -> pulumi.Input[str]:
        """
        - IPMI IP address.
        """
        return pulumi.get(self, "ipmi_ip")

    @ipmi_ip.setter
    def ipmi_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipmi_ip", value)

    @property
    @pulumi.getter(name="ipmiMac")
    def ipmi_mac(self) -> pulumi.Input[str]:
        """
        - (Required) IPMI mac address.
        """
        return pulumi.get(self, "ipmi_mac")

    @ipmi_mac.setter
    def ipmi_mac(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipmi_mac", value)

    @property
    @pulumi.getter(name="ipmiConfigureSuccessful")
    def ipmi_configure_successful(self) -> Optional[pulumi.Input[bool]]:
        """
        - Whether IPMI was successfully configured.
        """
        return pulumi.get(self, "ipmi_configure_successful")

    @ipmi_configure_successful.setter
    def ipmi_configure_successful(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipmi_configure_successful", value)

    @property
    @pulumi.getter(name="ipmiMessage")
    def ipmi_message(self) -> Optional[pulumi.Input[str]]:
        """
        - IPMI configuration status message if any.
        """
        return pulumi.get(self, "ipmi_message")

    @ipmi_message.setter
    def ipmi_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipmi_message", value)


if not MYPY:
    class ImageCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the image.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ImageCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) The name for the image.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ImageClusterReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the image.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    ImageClusterReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageClusterReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the image.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ImageCurrentClusterReferenceListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the image.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    ImageCurrentClusterReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageCurrentClusterReferenceListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the image.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the image.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ImagePlacementPolicyV2ClusterEntityFilterArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        """
        category_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of strings


        See detailed information in [Nutanix Image Placement Policies V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0)
        """
elif False:
    ImagePlacementPolicyV2ClusterEntityFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePlacementPolicyV2ClusterEntityFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] category_ext_ids: Array of strings
               
               
               See detailed information in [Nutanix Image Placement Policies V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0)
        """
        pulumi.set(__self__, "type", type)
        if category_ext_ids is not None:
            pulumi.set(__self__, "category_ext_ids", category_ext_ids)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="categoryExtIds")
    def category_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of strings


        See detailed information in [Nutanix Image Placement Policies V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0)
        """
        return pulumi.get(self, "category_ext_ids")

    @category_ext_ids.setter
    def category_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "category_ext_ids", value)


if not MYPY:
    class ImagePlacementPolicyV2ImageEntityFilterArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        """
        category_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Array of strings
        """
elif False:
    ImagePlacementPolicyV2ImageEntityFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagePlacementPolicyV2ImageEntityFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 category_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] category_ext_ids: Array of strings
        """
        pulumi.set(__self__, "type", type)
        if category_ext_ids is not None:
            pulumi.set(__self__, "category_ext_ids", category_ext_ids)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Filter matching type. Valid values "CATEGORIES_MATCH_ALL", "CATEGORIES_MATCH_ANY"
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="categoryExtIds")
    def category_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of strings
        """
        return pulumi.get(self, "category_ext_ids")

    @category_ext_ids.setter
    def category_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "category_ext_ids", value)


if not MYPY:
    class ImagesV2ChecksumArgsDict(TypedDict):
        hex_digest: pulumi.Input[str]
        object_type: pulumi.Input[str]
elif False:
    ImagesV2ChecksumArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2ChecksumArgs:
    def __init__(__self__, *,
                 hex_digest: pulumi.Input[str],
                 object_type: pulumi.Input[str]):
        pulumi.set(__self__, "hex_digest", hex_digest)
        pulumi.set(__self__, "object_type", object_type)

    @property
    @pulumi.getter(name="hexDigest")
    def hex_digest(self) -> pulumi.Input[str]:
        return pulumi.get(self, "hex_digest")

    @hex_digest.setter
    def hex_digest(self, value: pulumi.Input[str]):
        pulumi.set(self, "hex_digest", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)


if not MYPY:
    class ImagesV2PlacementPolicyStatusArgsDict(TypedDict):
        compliance_status: NotRequired[pulumi.Input[str]]
        conflicting_policy_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        enforced_cluster_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        enforcement_mode: NotRequired[pulumi.Input[str]]
        placement_policy_ext_id: NotRequired[pulumi.Input[str]]
        policy_cluster_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ImagesV2PlacementPolicyStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2PlacementPolicyStatusArgs:
    def __init__(__self__, *,
                 compliance_status: Optional[pulumi.Input[str]] = None,
                 conflicting_policy_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enforced_cluster_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enforcement_mode: Optional[pulumi.Input[str]] = None,
                 placement_policy_ext_id: Optional[pulumi.Input[str]] = None,
                 policy_cluster_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if compliance_status is not None:
            pulumi.set(__self__, "compliance_status", compliance_status)
        if conflicting_policy_ext_ids is not None:
            pulumi.set(__self__, "conflicting_policy_ext_ids", conflicting_policy_ext_ids)
        if enforced_cluster_ext_ids is not None:
            pulumi.set(__self__, "enforced_cluster_ext_ids", enforced_cluster_ext_ids)
        if enforcement_mode is not None:
            pulumi.set(__self__, "enforcement_mode", enforcement_mode)
        if placement_policy_ext_id is not None:
            pulumi.set(__self__, "placement_policy_ext_id", placement_policy_ext_id)
        if policy_cluster_ext_ids is not None:
            pulumi.set(__self__, "policy_cluster_ext_ids", policy_cluster_ext_ids)

    @property
    @pulumi.getter(name="complianceStatus")
    def compliance_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "compliance_status")

    @compliance_status.setter
    def compliance_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compliance_status", value)

    @property
    @pulumi.getter(name="conflictingPolicyExtIds")
    def conflicting_policy_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "conflicting_policy_ext_ids")

    @conflicting_policy_ext_ids.setter
    def conflicting_policy_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "conflicting_policy_ext_ids", value)

    @property
    @pulumi.getter(name="enforcedClusterExtIds")
    def enforced_cluster_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "enforced_cluster_ext_ids")

    @enforced_cluster_ext_ids.setter
    def enforced_cluster_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enforced_cluster_ext_ids", value)

    @property
    @pulumi.getter(name="enforcementMode")
    def enforcement_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "enforcement_mode")

    @enforcement_mode.setter
    def enforcement_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enforcement_mode", value)

    @property
    @pulumi.getter(name="placementPolicyExtId")
    def placement_policy_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "placement_policy_ext_id")

    @placement_policy_ext_id.setter
    def placement_policy_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "placement_policy_ext_id", value)

    @property
    @pulumi.getter(name="policyClusterExtIds")
    def policy_cluster_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "policy_cluster_ext_ids")

    @policy_cluster_ext_ids.setter
    def policy_cluster_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policy_cluster_ext_ids", value)


if not MYPY:
    class ImagesV2SourceArgsDict(TypedDict):
        object_lite_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceObjectLiteSourceArgsDict']]]]
        url_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceArgsDict']]]]
        vm_disk_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceVmDiskSourceArgsDict']]]]
elif False:
    ImagesV2SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2SourceArgs:
    def __init__(__self__, *,
                 object_lite_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceObjectLiteSourceArgs']]]] = None,
                 url_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceArgs']]]] = None,
                 vm_disk_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceVmDiskSourceArgs']]]] = None):
        if object_lite_sources is not None:
            pulumi.set(__self__, "object_lite_sources", object_lite_sources)
        if url_sources is not None:
            pulumi.set(__self__, "url_sources", url_sources)
        if vm_disk_sources is not None:
            pulumi.set(__self__, "vm_disk_sources", vm_disk_sources)

    @property
    @pulumi.getter(name="objectLiteSources")
    def object_lite_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceObjectLiteSourceArgs']]]]:
        return pulumi.get(self, "object_lite_sources")

    @object_lite_sources.setter
    def object_lite_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceObjectLiteSourceArgs']]]]):
        pulumi.set(self, "object_lite_sources", value)

    @property
    @pulumi.getter(name="urlSources")
    def url_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceArgs']]]]:
        return pulumi.get(self, "url_sources")

    @url_sources.setter
    def url_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceArgs']]]]):
        pulumi.set(self, "url_sources", value)

    @property
    @pulumi.getter(name="vmDiskSources")
    def vm_disk_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceVmDiskSourceArgs']]]]:
        return pulumi.get(self, "vm_disk_sources")

    @vm_disk_sources.setter
    def vm_disk_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceVmDiskSourceArgs']]]]):
        pulumi.set(self, "vm_disk_sources", value)


if not MYPY:
    class ImagesV2SourceObjectLiteSourceArgsDict(TypedDict):
        key: pulumi.Input[str]
elif False:
    ImagesV2SourceObjectLiteSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2SourceObjectLiteSourceArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class ImagesV2SourceUrlSourceArgsDict(TypedDict):
        url: pulumi.Input[str]
        basic_auths: NotRequired[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceBasicAuthArgsDict']]]]
        should_allow_insecure_url: NotRequired[pulumi.Input[bool]]
elif False:
    ImagesV2SourceUrlSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2SourceUrlSourceArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 basic_auths: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceBasicAuthArgs']]]] = None,
                 should_allow_insecure_url: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "url", url)
        if basic_auths is not None:
            pulumi.set(__self__, "basic_auths", basic_auths)
        if should_allow_insecure_url is not None:
            pulumi.set(__self__, "should_allow_insecure_url", should_allow_insecure_url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="basicAuths")
    def basic_auths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceBasicAuthArgs']]]]:
        return pulumi.get(self, "basic_auths")

    @basic_auths.setter
    def basic_auths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ImagesV2SourceUrlSourceBasicAuthArgs']]]]):
        pulumi.set(self, "basic_auths", value)

    @property
    @pulumi.getter(name="shouldAllowInsecureUrl")
    def should_allow_insecure_url(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allow_insecure_url")

    @should_allow_insecure_url.setter
    def should_allow_insecure_url(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_insecure_url", value)


if not MYPY:
    class ImagesV2SourceUrlSourceBasicAuthArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    ImagesV2SourceUrlSourceBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2SourceUrlSourceBasicAuthArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ImagesV2SourceVmDiskSourceArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
elif False:
    ImagesV2SourceVmDiskSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImagesV2SourceVmDiskSourceArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str]):
        pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class KarbonClusterActivePassiveConfigArgsDict(TypedDict):
        external_ipv4_address: pulumi.Input[str]
elif False:
    KarbonClusterActivePassiveConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterActivePassiveConfigArgs:
    def __init__(__self__, *,
                 external_ipv4_address: pulumi.Input[str]):
        pulumi.set(__self__, "external_ipv4_address", external_ipv4_address)

    @property
    @pulumi.getter(name="externalIpv4Address")
    def external_ipv4_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "external_ipv4_address")

    @external_ipv4_address.setter
    def external_ipv4_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_ipv4_address", value)


if not MYPY:
    class KarbonClusterCniConfigArgsDict(TypedDict):
        calico_config: NotRequired[pulumi.Input['KarbonClusterCniConfigCalicoConfigArgsDict']]
        """
        - (Optional) Configuration of the calico CNI provider.
        * `calico_config.ip_pool_config`: - (Optional) List of IP pools to be configured/managed by calico.
        * `calico_config.ip_pool_config.cidr`: - (Optional) IP range to use for this pool, it should fall within pod cidr.
        """
        flannel_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigFlannelConfigArgsDict']]]]
        """
        - (Optional) Configuration of the flannel container network interface (CNI) provider.
        """
        node_cidr_mask_size: NotRequired[pulumi.Input[int]]
        """
        - (Optional) The size of the subnet from the pod_ipv4_cidr assigned to each host. A value of 24 would allow up to 255 pods per node.
        """
        pod_ipv4_cidr: NotRequired[pulumi.Input[str]]
        """
        - (Optional) CIDR for pods in the cluster.
        """
        service_ipv4_cidr: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Classless inter-domain routing (CIDR) for k8s services in the cluster.
        """
elif False:
    KarbonClusterCniConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterCniConfigArgs:
    def __init__(__self__, *,
                 calico_config: Optional[pulumi.Input['KarbonClusterCniConfigCalicoConfigArgs']] = None,
                 flannel_configs: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigFlannelConfigArgs']]]] = None,
                 node_cidr_mask_size: Optional[pulumi.Input[int]] = None,
                 pod_ipv4_cidr: Optional[pulumi.Input[str]] = None,
                 service_ipv4_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['KarbonClusterCniConfigCalicoConfigArgs'] calico_config: - (Optional) Configuration of the calico CNI provider.
               * `calico_config.ip_pool_config`: - (Optional) List of IP pools to be configured/managed by calico.
               * `calico_config.ip_pool_config.cidr`: - (Optional) IP range to use for this pool, it should fall within pod cidr.
        :param pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigFlannelConfigArgs']]] flannel_configs: - (Optional) Configuration of the flannel container network interface (CNI) provider.
        :param pulumi.Input[int] node_cidr_mask_size: - (Optional) The size of the subnet from the pod_ipv4_cidr assigned to each host. A value of 24 would allow up to 255 pods per node.
        :param pulumi.Input[str] pod_ipv4_cidr: - (Optional) CIDR for pods in the cluster.
        :param pulumi.Input[str] service_ipv4_cidr: - (Optional) Classless inter-domain routing (CIDR) for k8s services in the cluster.
        """
        if calico_config is not None:
            pulumi.set(__self__, "calico_config", calico_config)
        if flannel_configs is not None:
            pulumi.set(__self__, "flannel_configs", flannel_configs)
        if node_cidr_mask_size is not None:
            pulumi.set(__self__, "node_cidr_mask_size", node_cidr_mask_size)
        if pod_ipv4_cidr is not None:
            pulumi.set(__self__, "pod_ipv4_cidr", pod_ipv4_cidr)
        if service_ipv4_cidr is not None:
            pulumi.set(__self__, "service_ipv4_cidr", service_ipv4_cidr)

    @property
    @pulumi.getter(name="calicoConfig")
    def calico_config(self) -> Optional[pulumi.Input['KarbonClusterCniConfigCalicoConfigArgs']]:
        """
        - (Optional) Configuration of the calico CNI provider.
        * `calico_config.ip_pool_config`: - (Optional) List of IP pools to be configured/managed by calico.
        * `calico_config.ip_pool_config.cidr`: - (Optional) IP range to use for this pool, it should fall within pod cidr.
        """
        return pulumi.get(self, "calico_config")

    @calico_config.setter
    def calico_config(self, value: Optional[pulumi.Input['KarbonClusterCniConfigCalicoConfigArgs']]):
        pulumi.set(self, "calico_config", value)

    @property
    @pulumi.getter(name="flannelConfigs")
    def flannel_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigFlannelConfigArgs']]]]:
        """
        - (Optional) Configuration of the flannel container network interface (CNI) provider.
        """
        return pulumi.get(self, "flannel_configs")

    @flannel_configs.setter
    def flannel_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigFlannelConfigArgs']]]]):
        pulumi.set(self, "flannel_configs", value)

    @property
    @pulumi.getter(name="nodeCidrMaskSize")
    def node_cidr_mask_size(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) The size of the subnet from the pod_ipv4_cidr assigned to each host. A value of 24 would allow up to 255 pods per node.
        """
        return pulumi.get(self, "node_cidr_mask_size")

    @node_cidr_mask_size.setter
    def node_cidr_mask_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_cidr_mask_size", value)

    @property
    @pulumi.getter(name="podIpv4Cidr")
    def pod_ipv4_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) CIDR for pods in the cluster.
        """
        return pulumi.get(self, "pod_ipv4_cidr")

    @pod_ipv4_cidr.setter
    def pod_ipv4_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_ipv4_cidr", value)

    @property
    @pulumi.getter(name="serviceIpv4Cidr")
    def service_ipv4_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Classless inter-domain routing (CIDR) for k8s services in the cluster.
        """
        return pulumi.get(self, "service_ipv4_cidr")

    @service_ipv4_cidr.setter
    def service_ipv4_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_ipv4_cidr", value)


if not MYPY:
    class KarbonClusterCniConfigCalicoConfigArgsDict(TypedDict):
        ip_pool_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigCalicoConfigIpPoolConfigArgsDict']]]]
elif False:
    KarbonClusterCniConfigCalicoConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterCniConfigCalicoConfigArgs:
    def __init__(__self__, *,
                 ip_pool_configs: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigCalicoConfigIpPoolConfigArgs']]]] = None):
        if ip_pool_configs is not None:
            pulumi.set(__self__, "ip_pool_configs", ip_pool_configs)

    @property
    @pulumi.getter(name="ipPoolConfigs")
    def ip_pool_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigCalicoConfigIpPoolConfigArgs']]]]:
        return pulumi.get(self, "ip_pool_configs")

    @ip_pool_configs.setter
    def ip_pool_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterCniConfigCalicoConfigIpPoolConfigArgs']]]]):
        pulumi.set(self, "ip_pool_configs", value)


if not MYPY:
    class KarbonClusterCniConfigCalicoConfigIpPoolConfigArgsDict(TypedDict):
        cidr: NotRequired[pulumi.Input[str]]
elif False:
    KarbonClusterCniConfigCalicoConfigIpPoolConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterCniConfigCalicoConfigIpPoolConfigArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[str]] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr", value)


if not MYPY:
    class KarbonClusterCniConfigFlannelConfigArgsDict(TypedDict):
        pass
elif False:
    KarbonClusterCniConfigFlannelConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterCniConfigFlannelConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class KarbonClusterEtcdNodePoolArgsDict(TypedDict):
        node_os_version: pulumi.Input[str]
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        num_instances: pulumi.Input[int]
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        ahv_config: NotRequired[pulumi.Input['KarbonClusterEtcdNodePoolAhvConfigArgsDict']]
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['KarbonClusterEtcdNodePoolNodeArgsDict']]]]
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
elif False:
    KarbonClusterEtcdNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterEtcdNodePoolArgs:
    def __init__(__self__, *,
                 node_os_version: pulumi.Input[str],
                 num_instances: pulumi.Input[int],
                 ahv_config: Optional[pulumi.Input['KarbonClusterEtcdNodePoolAhvConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterEtcdNodePoolNodeArgs']]]] = None):
        """
        :param pulumi.Input[str] node_os_version: - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[int] num_instances: - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        :param pulumi.Input['KarbonClusterEtcdNodePoolAhvConfigArgs'] ahv_config: - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
               * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
               * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
               * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
               * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
               * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        :param pulumi.Input[str] name: - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[Sequence[pulumi.Input['KarbonClusterEtcdNodePoolNodeArgs']]] nodes: - List of the deployed nodes in the node pool.
               * `nodes.hostname`: - Hostname of the deployed node.
               * `nodes.ipv4_address`: - IP of the deployed node.
        """
        pulumi.set(__self__, "node_os_version", node_os_version)
        pulumi.set(__self__, "num_instances", num_instances)
        if ahv_config is not None:
            pulumi.set(__self__, "ahv_config", ahv_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter(name="nodeOsVersion")
    def node_os_version(self) -> pulumi.Input[str]:
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "node_os_version")

    @node_os_version.setter
    def node_os_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_os_version", value)

    @property
    @pulumi.getter(name="numInstances")
    def num_instances(self) -> pulumi.Input[int]:
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        return pulumi.get(self, "num_instances")

    @num_instances.setter
    def num_instances(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_instances", value)

    @property
    @pulumi.getter(name="ahvConfig")
    def ahv_config(self) -> Optional[pulumi.Input['KarbonClusterEtcdNodePoolAhvConfigArgs']]:
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        return pulumi.get(self, "ahv_config")

    @ahv_config.setter
    def ahv_config(self, value: Optional[pulumi.Input['KarbonClusterEtcdNodePoolAhvConfigArgs']]):
        pulumi.set(self, "ahv_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterEtcdNodePoolNodeArgs']]]]:
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterEtcdNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class KarbonClusterEtcdNodePoolAhvConfigArgsDict(TypedDict):
        network_uuid: pulumi.Input[str]
        prism_element_cluster_uuid: pulumi.Input[str]
        cpu: NotRequired[pulumi.Input[int]]
        disk_mib: NotRequired[pulumi.Input[int]]
        memory_mib: NotRequired[pulumi.Input[int]]
elif False:
    KarbonClusterEtcdNodePoolAhvConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterEtcdNodePoolAhvConfigArgs:
    def __init__(__self__, *,
                 network_uuid: pulumi.Input[str],
                 prism_element_cluster_uuid: pulumi.Input[str],
                 cpu: Optional[pulumi.Input[int]] = None,
                 disk_mib: Optional[pulumi.Input[int]] = None,
                 memory_mib: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "network_uuid", network_uuid)
        pulumi.set(__self__, "prism_element_cluster_uuid", prism_element_cluster_uuid)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_mib is not None:
            pulumi.set(__self__, "disk_mib", disk_mib)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)

    @property
    @pulumi.getter(name="networkUuid")
    def network_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_uuid")

    @network_uuid.setter
    def network_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_uuid", value)

    @property
    @pulumi.getter(name="prismElementClusterUuid")
    def prism_element_cluster_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prism_element_cluster_uuid")

    @prism_element_cluster_uuid.setter
    def prism_element_cluster_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "prism_element_cluster_uuid", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="diskMib")
    def disk_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_mib")

    @disk_mib.setter
    def disk_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_mib", value)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_mib")

    @memory_mib.setter
    def memory_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mib", value)


if not MYPY:
    class KarbonClusterEtcdNodePoolNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[str]]
        ipv4_address: NotRequired[pulumi.Input[str]]
elif False:
    KarbonClusterEtcdNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterEtcdNodePoolNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)


if not MYPY:
    class KarbonClusterExternalLbConfigArgsDict(TypedDict):
        external_ipv4_address: pulumi.Input[str]
        master_nodes_configs: pulumi.Input[Sequence[pulumi.Input['KarbonClusterExternalLbConfigMasterNodesConfigArgsDict']]]
elif False:
    KarbonClusterExternalLbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterExternalLbConfigArgs:
    def __init__(__self__, *,
                 external_ipv4_address: pulumi.Input[str],
                 master_nodes_configs: pulumi.Input[Sequence[pulumi.Input['KarbonClusterExternalLbConfigMasterNodesConfigArgs']]]):
        pulumi.set(__self__, "external_ipv4_address", external_ipv4_address)
        pulumi.set(__self__, "master_nodes_configs", master_nodes_configs)

    @property
    @pulumi.getter(name="externalIpv4Address")
    def external_ipv4_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "external_ipv4_address")

    @external_ipv4_address.setter
    def external_ipv4_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_ipv4_address", value)

    @property
    @pulumi.getter(name="masterNodesConfigs")
    def master_nodes_configs(self) -> pulumi.Input[Sequence[pulumi.Input['KarbonClusterExternalLbConfigMasterNodesConfigArgs']]]:
        return pulumi.get(self, "master_nodes_configs")

    @master_nodes_configs.setter
    def master_nodes_configs(self, value: pulumi.Input[Sequence[pulumi.Input['KarbonClusterExternalLbConfigMasterNodesConfigArgs']]]):
        pulumi.set(self, "master_nodes_configs", value)


if not MYPY:
    class KarbonClusterExternalLbConfigMasterNodesConfigArgsDict(TypedDict):
        ipv4_address: pulumi.Input[str]
        node_pool_name: NotRequired[pulumi.Input[str]]
elif False:
    KarbonClusterExternalLbConfigMasterNodesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterExternalLbConfigMasterNodesConfigArgs:
    def __init__(__self__, *,
                 ipv4_address: pulumi.Input[str],
                 node_pool_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "ipv4_address", ipv4_address)
        if node_pool_name is not None:
            pulumi.set(__self__, "node_pool_name", node_pool_name)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ipv4_address", value)

    @property
    @pulumi.getter(name="nodePoolName")
    def node_pool_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_pool_name")

    @node_pool_name.setter
    def node_pool_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pool_name", value)


if not MYPY:
    class KarbonClusterMasterNodePoolArgsDict(TypedDict):
        node_os_version: pulumi.Input[str]
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        num_instances: pulumi.Input[int]
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        ahv_config: NotRequired[pulumi.Input['KarbonClusterMasterNodePoolAhvConfigArgsDict']]
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['KarbonClusterMasterNodePoolNodeArgsDict']]]]
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
elif False:
    KarbonClusterMasterNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterMasterNodePoolArgs:
    def __init__(__self__, *,
                 node_os_version: pulumi.Input[str],
                 num_instances: pulumi.Input[int],
                 ahv_config: Optional[pulumi.Input['KarbonClusterMasterNodePoolAhvConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterMasterNodePoolNodeArgs']]]] = None):
        """
        :param pulumi.Input[str] node_os_version: - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[int] num_instances: - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        :param pulumi.Input['KarbonClusterMasterNodePoolAhvConfigArgs'] ahv_config: - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
               * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
               * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
               * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
               * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
               * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        :param pulumi.Input[str] name: - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[Sequence[pulumi.Input['KarbonClusterMasterNodePoolNodeArgs']]] nodes: - List of the deployed nodes in the node pool.
               * `nodes.hostname`: - Hostname of the deployed node.
               * `nodes.ipv4_address`: - IP of the deployed node.
        """
        pulumi.set(__self__, "node_os_version", node_os_version)
        pulumi.set(__self__, "num_instances", num_instances)
        if ahv_config is not None:
            pulumi.set(__self__, "ahv_config", ahv_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter(name="nodeOsVersion")
    def node_os_version(self) -> pulumi.Input[str]:
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "node_os_version")

    @node_os_version.setter
    def node_os_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_os_version", value)

    @property
    @pulumi.getter(name="numInstances")
    def num_instances(self) -> pulumi.Input[int]:
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        return pulumi.get(self, "num_instances")

    @num_instances.setter
    def num_instances(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_instances", value)

    @property
    @pulumi.getter(name="ahvConfig")
    def ahv_config(self) -> Optional[pulumi.Input['KarbonClusterMasterNodePoolAhvConfigArgs']]:
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        return pulumi.get(self, "ahv_config")

    @ahv_config.setter
    def ahv_config(self, value: Optional[pulumi.Input['KarbonClusterMasterNodePoolAhvConfigArgs']]):
        pulumi.set(self, "ahv_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterMasterNodePoolNodeArgs']]]]:
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterMasterNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class KarbonClusterMasterNodePoolAhvConfigArgsDict(TypedDict):
        network_uuid: pulumi.Input[str]
        prism_element_cluster_uuid: pulumi.Input[str]
        cpu: NotRequired[pulumi.Input[int]]
        disk_mib: NotRequired[pulumi.Input[int]]
        memory_mib: NotRequired[pulumi.Input[int]]
elif False:
    KarbonClusterMasterNodePoolAhvConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterMasterNodePoolAhvConfigArgs:
    def __init__(__self__, *,
                 network_uuid: pulumi.Input[str],
                 prism_element_cluster_uuid: pulumi.Input[str],
                 cpu: Optional[pulumi.Input[int]] = None,
                 disk_mib: Optional[pulumi.Input[int]] = None,
                 memory_mib: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "network_uuid", network_uuid)
        pulumi.set(__self__, "prism_element_cluster_uuid", prism_element_cluster_uuid)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_mib is not None:
            pulumi.set(__self__, "disk_mib", disk_mib)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)

    @property
    @pulumi.getter(name="networkUuid")
    def network_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_uuid")

    @network_uuid.setter
    def network_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_uuid", value)

    @property
    @pulumi.getter(name="prismElementClusterUuid")
    def prism_element_cluster_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prism_element_cluster_uuid")

    @prism_element_cluster_uuid.setter
    def prism_element_cluster_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "prism_element_cluster_uuid", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="diskMib")
    def disk_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_mib")

    @disk_mib.setter
    def disk_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_mib", value)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_mib")

    @memory_mib.setter
    def memory_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mib", value)


if not MYPY:
    class KarbonClusterMasterNodePoolNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[str]]
        ipv4_address: NotRequired[pulumi.Input[str]]
elif False:
    KarbonClusterMasterNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterMasterNodePoolNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)


if not MYPY:
    class KarbonClusterPrivateRegistryArgsDict(TypedDict):
        registry_name: pulumi.Input[str]
elif False:
    KarbonClusterPrivateRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterPrivateRegistryArgs:
    def __init__(__self__, *,
                 registry_name: pulumi.Input[str]):
        pulumi.set(__self__, "registry_name", registry_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "registry_name")

    @registry_name.setter
    def registry_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_name", value)


if not MYPY:
    class KarbonClusterSingleMasterConfigArgsDict(TypedDict):
        pass
elif False:
    KarbonClusterSingleMasterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterSingleMasterConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class KarbonClusterStorageClassConfigArgsDict(TypedDict):
        volumes_config: pulumi.Input['KarbonClusterStorageClassConfigVolumesConfigArgsDict']
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name of the storage class.
        """
        reclaim_policy: NotRequired[pulumi.Input[str]]
        """
        Reclaim policy for persistent volumes provisioned using the specified storage class.
        * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
        * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
        * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
        * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
        * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
        * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.

        **Note:** Updates to this attribute forces new resource creation.
        """
elif False:
    KarbonClusterStorageClassConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterStorageClassConfigArgs:
    def __init__(__self__, *,
                 volumes_config: pulumi.Input['KarbonClusterStorageClassConfigVolumesConfigArgs'],
                 name: Optional[pulumi.Input[str]] = None,
                 reclaim_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) The name of the storage class.
        :param pulumi.Input[str] reclaim_policy: Reclaim policy for persistent volumes provisioned using the specified storage class.
               * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
               * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
               * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
               * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
               * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
               * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.
               
               **Note:** Updates to this attribute forces new resource creation.
        """
        pulumi.set(__self__, "volumes_config", volumes_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if reclaim_policy is not None:
            pulumi.set(__self__, "reclaim_policy", reclaim_policy)

    @property
    @pulumi.getter(name="volumesConfig")
    def volumes_config(self) -> pulumi.Input['KarbonClusterStorageClassConfigVolumesConfigArgs']:
        return pulumi.get(self, "volumes_config")

    @volumes_config.setter
    def volumes_config(self, value: pulumi.Input['KarbonClusterStorageClassConfigVolumesConfigArgs']):
        pulumi.set(self, "volumes_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name of the storage class.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="reclaimPolicy")
    def reclaim_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Reclaim policy for persistent volumes provisioned using the specified storage class.
        * `volumes_config.#.file_system` - (Optional) Karbon uses either the ext4 or xfs file-system on the volume disk.
        * `volumes_config.#.flash_mode` - (Optional) Pins the persistent volumes to the flash tier in case of a `true` value.
        * `volumes_config.#.password` - (Required) The password of the Prism Element user that the API calls use to provision volumes.
        * `volumes_config.#.prism_element_cluster_uuid` - (Required) The universally unique identifier (UUID) of the Prism Element cluster.
        * `volumes_config.#.storage_container` - (Required) Name of the storage container the storage container uses to provision volumes.
        * `volumes_config.#.username` - (Required) Username of the Prism Element user that the API calls use to provision volumes.

        **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "reclaim_policy")

    @reclaim_policy.setter
    def reclaim_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reclaim_policy", value)


if not MYPY:
    class KarbonClusterStorageClassConfigVolumesConfigArgsDict(TypedDict):
        password: pulumi.Input[str]
        prism_element_cluster_uuid: pulumi.Input[str]
        storage_container: pulumi.Input[str]
        username: pulumi.Input[str]
        file_system: NotRequired[pulumi.Input[str]]
        flash_mode: NotRequired[pulumi.Input[bool]]
elif False:
    KarbonClusterStorageClassConfigVolumesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterStorageClassConfigVolumesConfigArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 prism_element_cluster_uuid: pulumi.Input[str],
                 storage_container: pulumi.Input[str],
                 username: pulumi.Input[str],
                 file_system: Optional[pulumi.Input[str]] = None,
                 flash_mode: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "prism_element_cluster_uuid", prism_element_cluster_uuid)
        pulumi.set(__self__, "storage_container", storage_container)
        pulumi.set(__self__, "username", username)
        if file_system is not None:
            pulumi.set(__self__, "file_system", file_system)
        if flash_mode is not None:
            pulumi.set(__self__, "flash_mode", flash_mode)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="prismElementClusterUuid")
    def prism_element_cluster_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prism_element_cluster_uuid")

    @prism_element_cluster_uuid.setter
    def prism_element_cluster_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "prism_element_cluster_uuid", value)

    @property
    @pulumi.getter(name="storageContainer")
    def storage_container(self) -> pulumi.Input[str]:
        return pulumi.get(self, "storage_container")

    @storage_container.setter
    def storage_container(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_container", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="fileSystem")
    def file_system(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "file_system")

    @file_system.setter
    def file_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system", value)

    @property
    @pulumi.getter(name="flashMode")
    def flash_mode(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "flash_mode")

    @flash_mode.setter
    def flash_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flash_mode", value)


if not MYPY:
    class KarbonClusterWorkerNodePoolArgsDict(TypedDict):
        node_os_version: pulumi.Input[str]
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        num_instances: pulumi.Input[int]
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        ahv_config: NotRequired[pulumi.Input['KarbonClusterWorkerNodePoolAhvConfigArgsDict']]
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['KarbonClusterWorkerNodePoolNodeArgsDict']]]]
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
elif False:
    KarbonClusterWorkerNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterWorkerNodePoolArgs:
    def __init__(__self__, *,
                 node_os_version: pulumi.Input[str],
                 num_instances: pulumi.Input[int],
                 ahv_config: Optional[pulumi.Input['KarbonClusterWorkerNodePoolAhvConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterWorkerNodePoolNodeArgs']]]] = None):
        """
        :param pulumi.Input[str] node_os_version: - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[int] num_instances: - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        :param pulumi.Input['KarbonClusterWorkerNodePoolAhvConfigArgs'] ahv_config: - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
               * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
               * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
               * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
               * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
               * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        :param pulumi.Input[str] name: - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        :param pulumi.Input[Sequence[pulumi.Input['KarbonClusterWorkerNodePoolNodeArgs']]] nodes: - List of the deployed nodes in the node pool.
               * `nodes.hostname`: - Hostname of the deployed node.
               * `nodes.ipv4_address`: - IP of the deployed node.
        """
        pulumi.set(__self__, "node_os_version", node_os_version)
        pulumi.set(__self__, "num_instances", num_instances)
        if ahv_config is not None:
            pulumi.set(__self__, "ahv_config", ahv_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter(name="nodeOsVersion")
    def node_os_version(self) -> pulumi.Input[str]:
        """
        - (Required) The version of the node OS image. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "node_os_version")

    @node_os_version.setter
    def node_os_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_os_version", value)

    @property
    @pulumi.getter(name="numInstances")
    def num_instances(self) -> pulumi.Input[int]:
        """
        - (Required) Number of nodes in the node pool. **Note:** Updates to etcd or master node pool forces new resource creation.
        """
        return pulumi.get(self, "num_instances")

    @num_instances.setter
    def num_instances(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_instances", value)

    @property
    @pulumi.getter(name="ahvConfig")
    def ahv_config(self) -> Optional[pulumi.Input['KarbonClusterWorkerNodePoolAhvConfigArgs']]:
        """
        - (Optional) VM configuration in AHV. **Note:** Updates to this attribute forces new resource creation.
        * `ahv_config.cpu`: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        * `ahv_config.disk_mib`: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        * `ahv_config.memory_mib`: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        * `ahv_config.network_uuid`: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        * `ahv_config.prism_element_cluster_uuid`: - (Required) The unique universal identifier (UUID) of the Prism Element cluster used to deploy VMs for this node pool.
        """
        return pulumi.get(self, "ahv_config")

    @ahv_config.setter
    def ahv_config(self, value: Optional[pulumi.Input['KarbonClusterWorkerNodePoolAhvConfigArgs']]):
        pulumi.set(self, "ahv_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Unique name of the node pool. **Note:** Updates to this attribute forces new resource creation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterWorkerNodePoolNodeArgs']]]]:
        """
        - List of the deployed nodes in the node pool.
        * `nodes.hostname`: - Hostname of the deployed node.
        * `nodes.ipv4_address`: - IP of the deployed node.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KarbonClusterWorkerNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class KarbonClusterWorkerNodePoolAhvConfigArgsDict(TypedDict):
        network_uuid: pulumi.Input[str]
        prism_element_cluster_uuid: pulumi.Input[str]
        cpu: NotRequired[pulumi.Input[int]]
        disk_mib: NotRequired[pulumi.Input[int]]
        memory_mib: NotRequired[pulumi.Input[int]]
elif False:
    KarbonClusterWorkerNodePoolAhvConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterWorkerNodePoolAhvConfigArgs:
    def __init__(__self__, *,
                 network_uuid: pulumi.Input[str],
                 prism_element_cluster_uuid: pulumi.Input[str],
                 cpu: Optional[pulumi.Input[int]] = None,
                 disk_mib: Optional[pulumi.Input[int]] = None,
                 memory_mib: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "network_uuid", network_uuid)
        pulumi.set(__self__, "prism_element_cluster_uuid", prism_element_cluster_uuid)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_mib is not None:
            pulumi.set(__self__, "disk_mib", disk_mib)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)

    @property
    @pulumi.getter(name="networkUuid")
    def network_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_uuid")

    @network_uuid.setter
    def network_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_uuid", value)

    @property
    @pulumi.getter(name="prismElementClusterUuid")
    def prism_element_cluster_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "prism_element_cluster_uuid")

    @prism_element_cluster_uuid.setter
    def prism_element_cluster_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "prism_element_cluster_uuid", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="diskMib")
    def disk_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_mib")

    @disk_mib.setter
    def disk_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_mib", value)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_mib")

    @memory_mib.setter
    def memory_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mib", value)


if not MYPY:
    class KarbonClusterWorkerNodePoolNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[str]]
        ipv4_address: NotRequired[pulumi.Input[str]]
elif False:
    KarbonClusterWorkerNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonClusterWorkerNodePoolNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None):
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)


if not MYPY:
    class KarbonWorkerNodepoolAhvConfigArgsDict(TypedDict):
        network_uuid: pulumi.Input[str]
        """
        - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        """
        cpu: NotRequired[pulumi.Input[int]]
        """
        - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        """
        disk_mib: NotRequired[pulumi.Input[int]]
        """
        - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        """
        iscsi_network_uuid: NotRequired[pulumi.Input[str]]
        """
        VM network UUID for isolating iscsi data traffic.
        """
        memory_mib: NotRequired[pulumi.Input[int]]
        """
        - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        """
        prism_element_cluster_uuid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The unique universal identifier (UUID) of the Prism Element
        """
elif False:
    KarbonWorkerNodepoolAhvConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonWorkerNodepoolAhvConfigArgs:
    def __init__(__self__, *,
                 network_uuid: pulumi.Input[str],
                 cpu: Optional[pulumi.Input[int]] = None,
                 disk_mib: Optional[pulumi.Input[int]] = None,
                 iscsi_network_uuid: Optional[pulumi.Input[str]] = None,
                 memory_mib: Optional[pulumi.Input[int]] = None,
                 prism_element_cluster_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_uuid: - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        :param pulumi.Input[int] cpu: - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        :param pulumi.Input[int] disk_mib: - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        :param pulumi.Input[str] iscsi_network_uuid: VM network UUID for isolating iscsi data traffic.
        :param pulumi.Input[int] memory_mib: - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        :param pulumi.Input[str] prism_element_cluster_uuid: - (Optional) The unique universal identifier (UUID) of the Prism Element
        """
        pulumi.set(__self__, "network_uuid", network_uuid)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if disk_mib is not None:
            pulumi.set(__self__, "disk_mib", disk_mib)
        if iscsi_network_uuid is not None:
            pulumi.set(__self__, "iscsi_network_uuid", iscsi_network_uuid)
        if memory_mib is not None:
            pulumi.set(__self__, "memory_mib", memory_mib)
        if prism_element_cluster_uuid is not None:
            pulumi.set(__self__, "prism_element_cluster_uuid", prism_element_cluster_uuid)

    @property
    @pulumi.getter(name="networkUuid")
    def network_uuid(self) -> pulumi.Input[str]:
        """
        - (Required) The UUID of the network for the VMs deployed with this resource configuration.
        """
        return pulumi.get(self, "network_uuid")

    @network_uuid.setter
    def network_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_uuid", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[int]]:
        """
        - (Required) The number of VCPUs allocated for each VM on the PE cluster.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="diskMib")
    def disk_mib(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) Size of local storage for each VM on the PE cluster in MiB.
        """
        return pulumi.get(self, "disk_mib")

    @disk_mib.setter
    def disk_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_mib", value)

    @property
    @pulumi.getter(name="iscsiNetworkUuid")
    def iscsi_network_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        VM network UUID for isolating iscsi data traffic.
        """
        return pulumi.get(self, "iscsi_network_uuid")

    @iscsi_network_uuid.setter
    def iscsi_network_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iscsi_network_uuid", value)

    @property
    @pulumi.getter(name="memoryMib")
    def memory_mib(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) Memory allocated for each VM on the PE cluster in MiB.
        """
        return pulumi.get(self, "memory_mib")

    @memory_mib.setter
    def memory_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mib", value)

    @property
    @pulumi.getter(name="prismElementClusterUuid")
    def prism_element_cluster_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The unique universal identifier (UUID) of the Prism Element
        """
        return pulumi.get(self, "prism_element_cluster_uuid")

    @prism_element_cluster_uuid.setter
    def prism_element_cluster_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prism_element_cluster_uuid", value)


if not MYPY:
    class KarbonWorkerNodepoolNodeArgsDict(TypedDict):
        hostname: NotRequired[pulumi.Input[str]]
        """
        hostname of node
        """
        ipv4_address: NotRequired[pulumi.Input[str]]
        """
        ipv4 address of node
        """
elif False:
    KarbonWorkerNodepoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KarbonWorkerNodepoolNodeArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ipv4_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: hostname of node
        :param pulumi.Input[str] ipv4_address: ipv4 address of node
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ipv4_address is not None:
            pulumi.set(__self__, "ipv4_address", ipv4_address)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        hostname of node
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> Optional[pulumi.Input[str]]:
        """
        ipv4 address of node
        """
        return pulumi.get(self, "ipv4_address")

    @ipv4_address.setter
    def ipv4_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_address", value)


if not MYPY:
    class NdbCloneActionargumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) name of argument
        """
        value: pulumi.Input[str]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneActionargumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneActionargumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: - (Required) name of argument
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) name of argument
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        """
        Specify if you want to create a database server. This value can be set to true or false as required.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeInfoArgsDict']]]]
        """
        info of clone
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodePropertyArgsDict']]]]
        """
        List of all the properties
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of clone
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
elif False:
    NdbCloneDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] dbserver_id: Specify if you want to create a database server. This value can be set to true or false as required.
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeInfoArgs']]] infos: info of clone
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodePropertyArgs']]] properties: List of all the properties
        :param pulumi.Input[str] status: status of clone
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if you want to create a database server. This value can be set to true or false as required.
        """
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeInfoArgs']]]]:
        """
        info of clone
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodePropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of clone
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbCloneDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of clone
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbCloneDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of clone
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of clone
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbCloneDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        List of all the properties
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of clone
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of clone
        """
elif False:
    NdbCloneDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainPropertyArgs']]] properties: List of all the properties
        :param pulumi.Input[str] status: status of clone
        :param pulumi.Input[str] type: type of clone
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of clone
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of clone
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbCloneDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbCloneInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbCloneInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbCloneInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbCloneInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbCloneInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbCloneInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbCloneInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbCloneInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbCloneInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbCloneInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbCloneInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbCloneInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbCloneInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbCloneInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbCloneInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbCloneLcmConfigArgsDict(TypedDict):
        database_lcm_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigArgsDict']]]]
elif False:
    NdbCloneLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLcmConfigArgs:
    def __init__(__self__, *,
                 database_lcm_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigArgs']]]] = None):
        if database_lcm_configs is not None:
            pulumi.set(__self__, "database_lcm_configs", database_lcm_configs)

    @property
    @pulumi.getter(name="databaseLcmConfigs")
    def database_lcm_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigArgs']]]]:
        return pulumi.get(self, "database_lcm_configs")

    @database_lcm_configs.setter
    def database_lcm_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigArgs']]]]):
        pulumi.set(self, "database_lcm_configs", value)


if not MYPY:
    class NdbCloneLcmConfigDatabaseLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbCloneLcmConfigDatabaseLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLcmConfigDatabaseLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgsDict(TypedDict):
        expiry_date_timezone: pulumi.Input[str]
        delete_database: NotRequired[pulumi.Input[bool]]
        expire_in_days: NotRequired[pulumi.Input[int]]
elif False:
    NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLcmConfigDatabaseLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 expiry_date_timezone: pulumi.Input[str],
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)


if not MYPY:
    class NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgsDict(TypedDict):
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLcmConfigDatabaseLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbCloneLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        """
        database name
        """
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneLinkedDatabaseInfoArgsDict']]]]
        """
        info of clone
        """
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        snapshot id from where clone is created
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of clone
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbCloneLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: database name
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneLinkedDatabaseInfoArgs']]] infos: info of clone
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] snapshot_id: snapshot id from where clone is created
        :param pulumi.Input[str] status: status of clone
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        database name
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLinkedDatabaseInfoArgs']]]]:
        """
        info of clone
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        snapshot id from where clone is created
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of clone
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbCloneLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of clone
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbCloneLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of clone
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of clone
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbCloneNodeArgsDict(TypedDict):
        compute_profile_id: NotRequired[pulumi.Input[str]]
        """
        specify compute profile id
        """
        dbserver_id: NotRequired[pulumi.Input[str]]
        """
        dberver id
        """
        network_profile_id: NotRequired[pulumi.Input[str]]
        """
        specify network profile id
        """
        new_db_server_time_zone: NotRequired[pulumi.Input[str]]
        """
        dbserver time zone
        """
        nx_cluster_id: NotRequired[pulumi.Input[str]]
        """
        cluster id
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneNodePropertyArgsDict']]]]
        """
        properties of vm
        """
        vm_name: NotRequired[pulumi.Input[str]]
        """
        name for the database server VM.
        """
elif False:
    NdbCloneNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneNodeArgs:
    def __init__(__self__, *,
                 compute_profile_id: Optional[pulumi.Input[str]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 network_profile_id: Optional[pulumi.Input[str]] = None,
                 new_db_server_time_zone: Optional[pulumi.Input[str]] = None,
                 nx_cluster_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneNodePropertyArgs']]]] = None,
                 vm_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compute_profile_id: specify compute profile id
        :param pulumi.Input[str] dbserver_id: dberver id
        :param pulumi.Input[str] network_profile_id: specify network profile id
        :param pulumi.Input[str] new_db_server_time_zone: dbserver time zone
        :param pulumi.Input[str] nx_cluster_id: cluster id
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneNodePropertyArgs']]] properties: properties of vm
        :param pulumi.Input[str] vm_name: name for the database server VM.
        """
        if compute_profile_id is not None:
            pulumi.set(__self__, "compute_profile_id", compute_profile_id)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if network_profile_id is not None:
            pulumi.set(__self__, "network_profile_id", network_profile_id)
        if new_db_server_time_zone is not None:
            pulumi.set(__self__, "new_db_server_time_zone", new_db_server_time_zone)
        if nx_cluster_id is not None:
            pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if vm_name is not None:
            pulumi.set(__self__, "vm_name", vm_name)

    @property
    @pulumi.getter(name="computeProfileId")
    def compute_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify compute profile id
        """
        return pulumi.get(self, "compute_profile_id")

    @compute_profile_id.setter
    def compute_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_profile_id", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        """
        dberver id
        """
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter(name="networkProfileId")
    def network_profile_id(self) -> Optional[pulumi.Input[str]]:
        """
        specify network profile id
        """
        return pulumi.get(self, "network_profile_id")

    @network_profile_id.setter
    def network_profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_profile_id", value)

    @property
    @pulumi.getter(name="newDbServerTimeZone")
    def new_db_server_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        dbserver time zone
        """
        return pulumi.get(self, "new_db_server_time_zone")

    @new_db_server_time_zone.setter
    def new_db_server_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "new_db_server_time_zone", value)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        cluster id
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneNodePropertyArgs']]]]:
        """
        properties of vm
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> Optional[pulumi.Input[str]]:
        """
        name for the database server VM.
        """
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_name", value)


if not MYPY:
    class NdbCloneNodePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneNodePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbClonePostgresqlInfoArgsDict(TypedDict):
        db_password: pulumi.Input[str]
        """
        password of the postgres superuser.
        """
        vm_name: pulumi.Input[str]
        """
        name for the database server VM.
        """
        dbserver_description: NotRequired[pulumi.Input[str]]
        """
        description for the dbserver.
        """
        post_clone_cmd: NotRequired[pulumi.Input[str]]
        """
        OS command that you want to run after the instance is created.
        """
        pre_clone_cmd: NotRequired[pulumi.Input[str]]
        """
        OS command that you want to run before the instance is created.
        """
elif False:
    NdbClonePostgresqlInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClonePostgresqlInfoArgs:
    def __init__(__self__, *,
                 db_password: pulumi.Input[str],
                 vm_name: pulumi.Input[str],
                 dbserver_description: Optional[pulumi.Input[str]] = None,
                 post_clone_cmd: Optional[pulumi.Input[str]] = None,
                 pre_clone_cmd: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_password: password of the postgres superuser.
        :param pulumi.Input[str] vm_name: name for the database server VM.
        :param pulumi.Input[str] dbserver_description: description for the dbserver.
        :param pulumi.Input[str] post_clone_cmd: OS command that you want to run after the instance is created.
        :param pulumi.Input[str] pre_clone_cmd: OS command that you want to run before the instance is created.
        """
        pulumi.set(__self__, "db_password", db_password)
        pulumi.set(__self__, "vm_name", vm_name)
        if dbserver_description is not None:
            pulumi.set(__self__, "dbserver_description", dbserver_description)
        if post_clone_cmd is not None:
            pulumi.set(__self__, "post_clone_cmd", post_clone_cmd)
        if pre_clone_cmd is not None:
            pulumi.set(__self__, "pre_clone_cmd", pre_clone_cmd)

    @property
    @pulumi.getter(name="dbPassword")
    def db_password(self) -> pulumi.Input[str]:
        """
        password of the postgres superuser.
        """
        return pulumi.get(self, "db_password")

    @db_password.setter
    def db_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_password", value)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> pulumi.Input[str]:
        """
        name for the database server VM.
        """
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_name", value)

    @property
    @pulumi.getter(name="dbserverDescription")
    def dbserver_description(self) -> Optional[pulumi.Input[str]]:
        """
        description for the dbserver.
        """
        return pulumi.get(self, "dbserver_description")

    @dbserver_description.setter
    def dbserver_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_description", value)

    @property
    @pulumi.getter(name="postCloneCmd")
    def post_clone_cmd(self) -> Optional[pulumi.Input[str]]:
        """
        OS command that you want to run after the instance is created.
        """
        return pulumi.get(self, "post_clone_cmd")

    @post_clone_cmd.setter
    def post_clone_cmd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_clone_cmd", value)

    @property
    @pulumi.getter(name="preCloneCmd")
    def pre_clone_cmd(self) -> Optional[pulumi.Input[str]]:
        """
        OS command that you want to run before the instance is created.
        """
        return pulumi.get(self, "pre_clone_cmd")

    @pre_clone_cmd.setter
    def pre_clone_cmd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_clone_cmd", value)


if not MYPY:
    class NdbClonePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbClonePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClonePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        """
        cloned or not
        """
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        """
        clone will be clustered or not
        """
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachinePropertyArgsDict']]]]
        """
        List of all the properties
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleArgsDict']]]]
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of clone
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of clone
        """
elif False:
    NdbCloneTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clone: cloned or not
        :param pulumi.Input[bool] clustered: clone will be clustered or not
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachinePropertyArgs']]] properties: List of all the properties
        :param pulumi.Input[str] status: status of clone
        :param pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        :param pulumi.Input[str] type: type of clone
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        """
        cloned or not
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        """
        clone will be clustered or not
        """
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachinePropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleArgs']]]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of clone
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of clone
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbCloneTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        """
        timezone
        """
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbCloneTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        :param pulumi.Input[str] time_zone: timezone
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbCloneTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbCloneTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbCloneTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbCloneTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbCloneTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        minutes: NotRequired[pulumi.Input[int]]
        seconds: NotRequired[pulumi.Input[int]]
elif False:
    NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbCloneTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbCloneTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbCloneTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbCloneTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for clone
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        last modified date for clone
        """
        description: NotRequired[pulumi.Input[str]]
        """
        database instance description
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        database instance name
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbCloneTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] date_created: date created for clone
        :param pulumi.Input[str] date_modified: last modified date for clone
        :param pulumi.Input[str] description: database instance description
        :param pulumi.Input[str] name: database instance name
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for clone
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        last modified date for clone
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        database instance description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        database instance name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbCloneTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbCloneTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbCloneTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbClusterAgentNetworkInfoArgsDict(TypedDict):
        dns: NotRequired[pulumi.Input[str]]
        """
        string of DNS servers(comma separted).
        """
        ntp: NotRequired[pulumi.Input[str]]
        """
        string of NTP servers(comma separted).
        """
elif False:
    NdbClusterAgentNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterAgentNetworkInfoArgs:
    def __init__(__self__, *,
                 dns: Optional[pulumi.Input[str]] = None,
                 ntp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dns: string of DNS servers(comma separted).
        :param pulumi.Input[str] ntp: string of NTP servers(comma separted).
        """
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if ntp is not None:
            pulumi.set(__self__, "ntp", ntp)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        string of DNS servers(comma separted).
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter
    def ntp(self) -> Optional[pulumi.Input[str]]:
        """
        string of NTP servers(comma separted).
        """
        return pulumi.get(self, "ntp")

    @ntp.setter
    def ntp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ntp", value)


if not MYPY:
    class NdbClusterEntityCountArgsDict(TypedDict):
        db_servers: NotRequired[pulumi.Input[int]]
        engine_counts: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountArgsDict']]]]
elif False:
    NdbClusterEntityCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountArgs:
    def __init__(__self__, *,
                 db_servers: Optional[pulumi.Input[int]] = None,
                 engine_counts: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountArgs']]]] = None):
        if db_servers is not None:
            pulumi.set(__self__, "db_servers", db_servers)
        if engine_counts is not None:
            pulumi.set(__self__, "engine_counts", engine_counts)

    @property
    @pulumi.getter(name="dbServers")
    def db_servers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "db_servers")

    @db_servers.setter
    def db_servers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "db_servers", value)

    @property
    @pulumi.getter(name="engineCounts")
    def engine_counts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountArgs']]]]:
        return pulumi.get(self, "engine_counts")

    @engine_counts.setter
    def engine_counts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountArgs']]]]):
        pulumi.set(self, "engine_counts", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountArgsDict(TypedDict):
        mariadb_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseArgsDict']]]]
        mongodb_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseArgsDict']]]]
        mysql_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseArgsDict']]]]
        oracle_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseArgsDict']]]]
        postgres_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseArgsDict']]]]
        saphana_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseArgsDict']]]]
        sqlserver_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseArgsDict']]]]
elif False:
    NdbClusterEntityCountEngineCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountArgs:
    def __init__(__self__, *,
                 mariadb_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseArgs']]]] = None,
                 mongodb_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseArgs']]]] = None,
                 mysql_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseArgs']]]] = None,
                 oracle_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseArgs']]]] = None,
                 postgres_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseArgs']]]] = None,
                 saphana_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseArgs']]]] = None,
                 sqlserver_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseArgs']]]] = None):
        if mariadb_databases is not None:
            pulumi.set(__self__, "mariadb_databases", mariadb_databases)
        if mongodb_databases is not None:
            pulumi.set(__self__, "mongodb_databases", mongodb_databases)
        if mysql_databases is not None:
            pulumi.set(__self__, "mysql_databases", mysql_databases)
        if oracle_databases is not None:
            pulumi.set(__self__, "oracle_databases", oracle_databases)
        if postgres_databases is not None:
            pulumi.set(__self__, "postgres_databases", postgres_databases)
        if saphana_databases is not None:
            pulumi.set(__self__, "saphana_databases", saphana_databases)
        if sqlserver_databases is not None:
            pulumi.set(__self__, "sqlserver_databases", sqlserver_databases)

    @property
    @pulumi.getter(name="mariadbDatabases")
    def mariadb_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseArgs']]]]:
        return pulumi.get(self, "mariadb_databases")

    @mariadb_databases.setter
    def mariadb_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseArgs']]]]):
        pulumi.set(self, "mariadb_databases", value)

    @property
    @pulumi.getter(name="mongodbDatabases")
    def mongodb_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseArgs']]]]:
        return pulumi.get(self, "mongodb_databases")

    @mongodb_databases.setter
    def mongodb_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseArgs']]]]):
        pulumi.set(self, "mongodb_databases", value)

    @property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseArgs']]]]:
        return pulumi.get(self, "mysql_databases")

    @mysql_databases.setter
    def mysql_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseArgs']]]]):
        pulumi.set(self, "mysql_databases", value)

    @property
    @pulumi.getter(name="oracleDatabases")
    def oracle_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseArgs']]]]:
        return pulumi.get(self, "oracle_databases")

    @oracle_databases.setter
    def oracle_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseArgs']]]]):
        pulumi.set(self, "oracle_databases", value)

    @property
    @pulumi.getter(name="postgresDatabases")
    def postgres_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseArgs']]]]:
        return pulumi.get(self, "postgres_databases")

    @postgres_databases.setter
    def postgres_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseArgs']]]]):
        pulumi.set(self, "postgres_databases", value)

    @property
    @pulumi.getter(name="saphanaDatabases")
    def saphana_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseArgs']]]]:
        return pulumi.get(self, "saphana_databases")

    @saphana_databases.setter
    def saphana_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseArgs']]]]):
        pulumi.set(self, "saphana_databases", value)

    @property
    @pulumi.getter(name="sqlserverDatabases")
    def sqlserver_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseArgs']]]]:
        return pulumi.get(self, "sqlserver_databases")

    @sqlserver_databases.setter
    def sqlserver_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseArgs']]]]):
        pulumi.set(self, "sqlserver_databases", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMariadbDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMariadbDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMariadbDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMariadbDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMongodbDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMongodbDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMongodbDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMongodbDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMysqlDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMysqlDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMysqlDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountMysqlDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountOracleDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountOracleDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountOracleDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountOracleDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountOracleDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountOracleDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountOracleDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountPostgresDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountPostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountPostgresDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountPostgresDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountSaphanaDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountSaphanaDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountSaphanaDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountSaphanaDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountSqlserverDatabaseArgsDict(TypedDict):
        profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgsDict']]]]
        time_machines: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountSqlserverDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountSqlserverDatabaseArgs:
    def __init__(__self__, *,
                 profiles: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgs']]]] = None,
                 time_machines: Optional[pulumi.Input[int]] = None):
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)
        if time_machines is not None:
            pulumi.set(__self__, "time_machines", time_machines)

    @property
    @pulumi.getter
    def profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgs']]]]:
        return pulumi.get(self, "profiles")

    @profiles.setter
    def profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgs']]]]):
        pulumi.set(self, "profiles", value)

    @property
    @pulumi.getter(name="timeMachines")
    def time_machines(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "time_machines")

    @time_machines.setter
    def time_machines(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_machines", value)


if not MYPY:
    class NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgsDict(TypedDict):
        compute: NotRequired[pulumi.Input[int]]
        database_parameter: NotRequired[pulumi.Input[int]]
        network: NotRequired[pulumi.Input[int]]
        software: NotRequired[pulumi.Input[int]]
        storage: NotRequired[pulumi.Input[int]]
        windows_domain: NotRequired[pulumi.Input[int]]
elif False:
    NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterEntityCountEngineCountSqlserverDatabaseProfileArgs:
    def __init__(__self__, *,
                 compute: Optional[pulumi.Input[int]] = None,
                 database_parameter: Optional[pulumi.Input[int]] = None,
                 network: Optional[pulumi.Input[int]] = None,
                 software: Optional[pulumi.Input[int]] = None,
                 storage: Optional[pulumi.Input[int]] = None,
                 windows_domain: Optional[pulumi.Input[int]] = None):
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if database_parameter is not None:
            pulumi.set(__self__, "database_parameter", database_parameter)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if software is not None:
            pulumi.set(__self__, "software", software)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if windows_domain is not None:
            pulumi.set(__self__, "windows_domain", windows_domain)

    @property
    @pulumi.getter
    def compute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "compute")

    @compute.setter
    def compute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "compute", value)

    @property
    @pulumi.getter(name="databaseParameter")
    def database_parameter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "database_parameter")

    @database_parameter.setter
    def database_parameter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "database_parameter", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def software(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "software")

    @software.setter
    def software(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "software", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="windowsDomain")
    def windows_domain(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "windows_domain")

    @windows_domain.setter
    def windows_domain(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "windows_domain", value)


if not MYPY:
    class NdbClusterNetworksInfoArgsDict(TypedDict):
        access_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        VLAN access types for which you want to configure network segmentation. Supports [PRISM, DSIP, DBSERVER ]. 
        Prism Element: Select this VLAN access type to configure a VLAN that the NDB agent VM can use to communicate with Prism.
        Prism iSCSI Data Service. Select this VLAN access type to configure a VLAN that the agent VM can use to make connection requests to the iSCSI data services IP.
        DBServer Access from NDB server. Select this VLAN access type to configure a VLAN that is used for communications between the NDB agent VM and the database server VM on the newly registered NDB server cluster.
        """
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbClusterNetworksInfoNetworkInfoArgsDict']]]]
        """
        network segmentation to segment the network traffic
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of vlan. Supported [DHCP, Static, IPAM]
        """
elif False:
    NdbClusterNetworksInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterNetworksInfoArgs:
    def __init__(__self__, *,
                 access_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterNetworksInfoNetworkInfoArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] access_types: VLAN access types for which you want to configure network segmentation. Supports [PRISM, DSIP, DBSERVER ]. 
               Prism Element: Select this VLAN access type to configure a VLAN that the NDB agent VM can use to communicate with Prism.
               Prism iSCSI Data Service. Select this VLAN access type to configure a VLAN that the agent VM can use to make connection requests to the iSCSI data services IP.
               DBServer Access from NDB server. Select this VLAN access type to configure a VLAN that is used for communications between the NDB agent VM and the database server VM on the newly registered NDB server cluster.
        :param pulumi.Input[Sequence[pulumi.Input['NdbClusterNetworksInfoNetworkInfoArgs']]] network_infos: network segmentation to segment the network traffic
        :param pulumi.Input[str] type: type of vlan. Supported [DHCP, Static, IPAM]
        """
        if access_types is not None:
            pulumi.set(__self__, "access_types", access_types)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessTypes")
    def access_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        VLAN access types for which you want to configure network segmentation. Supports [PRISM, DSIP, DBSERVER ]. 
        Prism Element: Select this VLAN access type to configure a VLAN that the NDB agent VM can use to communicate with Prism.
        Prism iSCSI Data Service. Select this VLAN access type to configure a VLAN that the agent VM can use to make connection requests to the iSCSI data services IP.
        DBServer Access from NDB server. Select this VLAN access type to configure a VLAN that is used for communications between the NDB agent VM and the database server VM on the newly registered NDB server cluster.
        """
        return pulumi.get(self, "access_types")

    @access_types.setter
    def access_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "access_types", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterNetworksInfoNetworkInfoArgs']]]]:
        """
        network segmentation to segment the network traffic
        """
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbClusterNetworksInfoNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of vlan. Supported [DHCP, Static, IPAM]
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbClusterNetworksInfoNetworkInfoArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        """
        gateway of agent network
        """
        static_ip: NotRequired[pulumi.Input[str]]
        """
        static ip of agent network
        """
        subnet_mask: NotRequired[pulumi.Input[str]]
        """
        subnet mask of agent network
        """
        vlan_name: NotRequired[pulumi.Input[str]]
        """
        vlan name
        """
elif False:
    NdbClusterNetworksInfoNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterNetworksInfoNetworkInfoArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 static_ip: Optional[pulumi.Input[str]] = None,
                 subnet_mask: Optional[pulumi.Input[str]] = None,
                 vlan_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: gateway of agent network
        :param pulumi.Input[str] static_ip: static ip of agent network
        :param pulumi.Input[str] subnet_mask: subnet mask of agent network
        :param pulumi.Input[str] vlan_name: vlan name
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if static_ip is not None:
            pulumi.set(__self__, "static_ip", static_ip)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        gateway of agent network
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="staticIp")
    def static_ip(self) -> Optional[pulumi.Input[str]]:
        """
        static ip of agent network
        """
        return pulumi.get(self, "static_ip")

    @static_ip.setter
    def static_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static_ip", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[str]]:
        """
        subnet mask of agent network
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[pulumi.Input[str]]:
        """
        vlan name
        """
        return pulumi.get(self, "vlan_name")

    @vlan_name.setter
    def vlan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_name", value)


if not MYPY:
    class NdbClusterPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of cluster
        """
        name: NotRequired[pulumi.Input[str]]
        """
        name of the cluster to be registered
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbClusterPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of cluster
        :param pulumi.Input[str] name: name of the cluster to be registered
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of cluster
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the cluster to be registered
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbClusterResourceConfigArgsDict(TypedDict):
        memory_threshold_percentage: NotRequired[pulumi.Input[float]]
        storage_threshold_percentage: NotRequired[pulumi.Input[float]]
elif False:
    NdbClusterResourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbClusterResourceConfigArgs:
    def __init__(__self__, *,
                 memory_threshold_percentage: Optional[pulumi.Input[float]] = None,
                 storage_threshold_percentage: Optional[pulumi.Input[float]] = None):
        if memory_threshold_percentage is not None:
            pulumi.set(__self__, "memory_threshold_percentage", memory_threshold_percentage)
        if storage_threshold_percentage is not None:
            pulumi.set(__self__, "storage_threshold_percentage", storage_threshold_percentage)

    @property
    @pulumi.getter(name="memoryThresholdPercentage")
    def memory_threshold_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "memory_threshold_percentage")

    @memory_threshold_percentage.setter
    def memory_threshold_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_threshold_percentage", value)

    @property
    @pulumi.getter(name="storageThresholdPercentage")
    def storage_threshold_percentage(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "storage_threshold_percentage")

    @storage_threshold_percentage.setter
    def storage_threshold_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "storage_threshold_percentage", value)


if not MYPY:
    class NdbDatabaseActionargumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) name of argument
        """
        value: pulumi.Input[str]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseActionargumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseActionargumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: - (Required) name of argument
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) name of argument
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseClusterInfoArgsDict(TypedDict):
        cluster_ip_infos: pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoArgsDict']]]
elif False:
    NdbDatabaseClusterInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseClusterInfoArgs:
    def __init__(__self__, *,
                 cluster_ip_infos: pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoArgs']]]):
        pulumi.set(__self__, "cluster_ip_infos", cluster_ip_infos)

    @property
    @pulumi.getter(name="clusterIpInfos")
    def cluster_ip_infos(self) -> pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoArgs']]]:
        return pulumi.get(self, "cluster_ip_infos")

    @cluster_ip_infos.setter
    def cluster_ip_infos(self, value: pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoArgs']]]):
        pulumi.set(self, "cluster_ip_infos", value)


if not MYPY:
    class NdbDatabaseClusterInfoClusterIpInfoArgsDict(TypedDict):
        nx_cluster_id: pulumi.Input[str]
        """
        - (Optional) cluster id.
        """
        ip_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoIpInfoArgsDict']]]]
        """
        - (Optional) IP infos for custom network profile.
        """
elif False:
    NdbDatabaseClusterInfoClusterIpInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseClusterInfoClusterIpInfoArgs:
    def __init__(__self__, *,
                 nx_cluster_id: pulumi.Input[str],
                 ip_infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs']]]] = None):
        """
        :param pulumi.Input[str] nx_cluster_id: - (Optional) cluster id.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs']]] ip_infos: - (Optional) IP infos for custom network profile.
        """
        pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if ip_infos is not None:
            pulumi.set(__self__, "ip_infos", ip_infos)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> pulumi.Input[str]:
        """
        - (Optional) cluster id.
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter(name="ipInfos")
    def ip_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs']]]]:
        """
        - (Optional) IP infos for custom network profile.
        """
        return pulumi.get(self, "ip_infos")

    @ip_infos.setter
    def ip_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs']]]]):
        pulumi.set(self, "ip_infos", value)


if not MYPY:
    class NdbDatabaseClusterInfoClusterIpInfoIpInfoArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        ip_type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseClusterInfoClusterIpInfoIpInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseClusterInfoClusterIpInfoIpInfoArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_type: Optional[pulumi.Input[str]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_type is not None:
            pulumi.set(__self__, "ip_type", ip_type)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class NdbDatabaseDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeInfoArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodePropertyArgsDict']]]]
        """
        List of all the properties
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeTagArgsDict']]]]
        """
        - (Optional) tags
        """
elif False:
    NdbDatabaseDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodePropertyArgs']]] properties: List of all the properties
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeTagArgs']]] tags: - (Optional) tags
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeInfoArgs']]]]:
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodePropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeTagArgs']]]]:
        """
        - (Optional) tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbDatabaseDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        List of all the properties
        """
        status: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs']]] properties: List of all the properties
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbDatabaseInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbDatabaseInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbDatabaseLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbDatabaseLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbDatabaseLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] delete_time_machine: - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbDatabaseLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbDatabaseLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLinkedDatabaseInfoArgsDict']]]]
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLinkedDatabaseInfoArgs']]]]:
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbDatabaseLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseMaintenanceTasksArgsDict(TypedDict):
        maintenance_window_id: NotRequired[pulumi.Input[str]]
        tasks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseMaintenanceTasksTaskArgsDict']]]]
elif False:
    NdbDatabaseMaintenanceTasksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseMaintenanceTasksArgs:
    def __init__(__self__, *,
                 maintenance_window_id: Optional[pulumi.Input[str]] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseMaintenanceTasksTaskArgs']]]] = None):
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseMaintenanceTasksTaskArgs']]]]:
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseMaintenanceTasksTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


if not MYPY:
    class NdbDatabaseMaintenanceTasksTaskArgsDict(TypedDict):
        post_command: NotRequired[pulumi.Input[str]]
        pre_command: NotRequired[pulumi.Input[str]]
        task_type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseMaintenanceTasksTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseMaintenanceTasksTaskArgs:
    def __init__(__self__, *,
                 post_command: Optional[pulumi.Input[str]] = None,
                 pre_command: Optional[pulumi.Input[str]] = None,
                 task_type: Optional[pulumi.Input[str]] = None):
        if post_command is not None:
            pulumi.set(__self__, "post_command", post_command)
        if pre_command is not None:
            pulumi.set(__self__, "pre_command", pre_command)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="postCommand")
    def post_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "post_command")

    @post_command.setter
    def post_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_command", value)

    @property
    @pulumi.getter(name="preCommand")
    def pre_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pre_command")

    @pre_command.setter
    def pre_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_command", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_type", value)


if not MYPY:
    class NdbDatabaseNodeArgsDict(TypedDict):
        vmname: pulumi.Input[str]
        """
        - (Required) name of vm
        """
        computeprofileid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) compute profile id
        """
        dbserverid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Database server ID required for existing VM
        """
        ip_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodeIpInfoArgsDict']]]]
        """
        - (Optional) IP infos for custom network profile.
        """
        networkprofileid: NotRequired[pulumi.Input[str]]
        """
        - (Required) network profile ID
        """
        nx_cluster_id: NotRequired[pulumi.Input[str]]
        """
        - (Optional) cluster id.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodePropertyArgsDict']]]]
        """
        - (Optional) list of additional properties
        """
elif False:
    NdbDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseNodeArgs:
    def __init__(__self__, *,
                 vmname: pulumi.Input[str],
                 computeprofileid: Optional[pulumi.Input[str]] = None,
                 dbserverid: Optional[pulumi.Input[str]] = None,
                 ip_infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodeIpInfoArgs']]]] = None,
                 networkprofileid: Optional[pulumi.Input[str]] = None,
                 nx_cluster_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodePropertyArgs']]]] = None):
        """
        :param pulumi.Input[str] vmname: - (Required) name of vm
        :param pulumi.Input[str] computeprofileid: - (Optional) compute profile id
        :param pulumi.Input[str] dbserverid: - (Optional) Database server ID required for existing VM
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodeIpInfoArgs']]] ip_infos: - (Optional) IP infos for custom network profile.
        :param pulumi.Input[str] networkprofileid: - (Required) network profile ID
        :param pulumi.Input[str] nx_cluster_id: - (Optional) cluster id.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodePropertyArgs']]] properties: - (Optional) list of additional properties
        """
        pulumi.set(__self__, "vmname", vmname)
        if computeprofileid is not None:
            pulumi.set(__self__, "computeprofileid", computeprofileid)
        if dbserverid is not None:
            pulumi.set(__self__, "dbserverid", dbserverid)
        if ip_infos is not None:
            pulumi.set(__self__, "ip_infos", ip_infos)
        if networkprofileid is not None:
            pulumi.set(__self__, "networkprofileid", networkprofileid)
        if nx_cluster_id is not None:
            pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @property
    @pulumi.getter
    def vmname(self) -> pulumi.Input[str]:
        """
        - (Required) name of vm
        """
        return pulumi.get(self, "vmname")

    @vmname.setter
    def vmname(self, value: pulumi.Input[str]):
        pulumi.set(self, "vmname", value)

    @property
    @pulumi.getter
    def computeprofileid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) compute profile id
        """
        return pulumi.get(self, "computeprofileid")

    @computeprofileid.setter
    def computeprofileid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "computeprofileid", value)

    @property
    @pulumi.getter
    def dbserverid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Database server ID required for existing VM
        """
        return pulumi.get(self, "dbserverid")

    @dbserverid.setter
    def dbserverid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserverid", value)

    @property
    @pulumi.getter(name="ipInfos")
    def ip_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodeIpInfoArgs']]]]:
        """
        - (Optional) IP infos for custom network profile.
        """
        return pulumi.get(self, "ip_infos")

    @ip_infos.setter
    def ip_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodeIpInfoArgs']]]]):
        pulumi.set(self, "ip_infos", value)

    @property
    @pulumi.getter
    def networkprofileid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) network profile ID
        """
        return pulumi.get(self, "networkprofileid")

    @networkprofileid.setter
    def networkprofileid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networkprofileid", value)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) cluster id.
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodePropertyArgs']]]]:
        """
        - (Optional) list of additional properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class NdbDatabaseNodeIpInfoArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        ip_type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseNodeIpInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseNodeIpInfoArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ip_type: Optional[pulumi.Input[str]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if ip_type is not None:
            pulumi.set(__self__, "ip_type", ip_type)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="ipType")
    def ip_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_type")

    @ip_type.setter
    def ip_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_type", value)


if not MYPY:
    class NdbDatabaseNodePropertyArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) Name of the instance.
        """
        value: pulumi.Input[str]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabasePostgresqlInfoArgsDict(TypedDict):
        database_names: pulumi.Input[str]
        """
        - (Required) name of initial database to be created
        """
        database_size: pulumi.Input[str]
        """
        - (Required) initial database size
        """
        db_password: pulumi.Input[str]
        """
        - (Required) database instance password
        """
        listener_port: pulumi.Input[str]
        """
        - (Required) listener port for database instance
        """
        allocate_pg_hugepage: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) allocate huge page. Default: false
        """
        auth_method: NotRequired[pulumi.Input[str]]
        """
        - (Optional) auth methods. Default: md5
        """
        auto_tune_staging_drive: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) enable auto tuning of staging drive. Default: false
        """
        cluster_database: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) if clustered database. Default: false
        """
        ha_instance: NotRequired[pulumi.Input['NdbDatabasePostgresqlInfoHaInstanceArgsDict']]
        """
        - (Optional) High Availability instance
        """
        post_create_script: NotRequired[pulumi.Input[str]]
        """
        - (Optional) post instance create script
        """
        pre_create_script: NotRequired[pulumi.Input[str]]
        """
        - (Optional) pre instance create script
        """
elif False:
    NdbDatabasePostgresqlInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabasePostgresqlInfoArgs:
    def __init__(__self__, *,
                 database_names: pulumi.Input[str],
                 database_size: pulumi.Input[str],
                 db_password: pulumi.Input[str],
                 listener_port: pulumi.Input[str],
                 allocate_pg_hugepage: Optional[pulumi.Input[bool]] = None,
                 auth_method: Optional[pulumi.Input[str]] = None,
                 auto_tune_staging_drive: Optional[pulumi.Input[bool]] = None,
                 cluster_database: Optional[pulumi.Input[bool]] = None,
                 ha_instance: Optional[pulumi.Input['NdbDatabasePostgresqlInfoHaInstanceArgs']] = None,
                 post_create_script: Optional[pulumi.Input[str]] = None,
                 pre_create_script: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_names: - (Required) name of initial database to be created
        :param pulumi.Input[str] database_size: - (Required) initial database size
        :param pulumi.Input[str] db_password: - (Required) database instance password
        :param pulumi.Input[str] listener_port: - (Required) listener port for database instance
        :param pulumi.Input[bool] allocate_pg_hugepage: - (Optional) allocate huge page. Default: false
        :param pulumi.Input[str] auth_method: - (Optional) auth methods. Default: md5
        :param pulumi.Input[bool] auto_tune_staging_drive: - (Optional) enable auto tuning of staging drive. Default: false
        :param pulumi.Input[bool] cluster_database: - (Optional) if clustered database. Default: false
        :param pulumi.Input['NdbDatabasePostgresqlInfoHaInstanceArgs'] ha_instance: - (Optional) High Availability instance
        :param pulumi.Input[str] post_create_script: - (Optional) post instance create script
        :param pulumi.Input[str] pre_create_script: - (Optional) pre instance create script
        """
        pulumi.set(__self__, "database_names", database_names)
        pulumi.set(__self__, "database_size", database_size)
        pulumi.set(__self__, "db_password", db_password)
        pulumi.set(__self__, "listener_port", listener_port)
        if allocate_pg_hugepage is not None:
            pulumi.set(__self__, "allocate_pg_hugepage", allocate_pg_hugepage)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if auto_tune_staging_drive is not None:
            pulumi.set(__self__, "auto_tune_staging_drive", auto_tune_staging_drive)
        if cluster_database is not None:
            pulumi.set(__self__, "cluster_database", cluster_database)
        if ha_instance is not None:
            pulumi.set(__self__, "ha_instance", ha_instance)
        if post_create_script is not None:
            pulumi.set(__self__, "post_create_script", post_create_script)
        if pre_create_script is not None:
            pulumi.set(__self__, "pre_create_script", pre_create_script)

    @property
    @pulumi.getter(name="databaseNames")
    def database_names(self) -> pulumi.Input[str]:
        """
        - (Required) name of initial database to be created
        """
        return pulumi.get(self, "database_names")

    @database_names.setter
    def database_names(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_names", value)

    @property
    @pulumi.getter(name="databaseSize")
    def database_size(self) -> pulumi.Input[str]:
        """
        - (Required) initial database size
        """
        return pulumi.get(self, "database_size")

    @database_size.setter
    def database_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_size", value)

    @property
    @pulumi.getter(name="dbPassword")
    def db_password(self) -> pulumi.Input[str]:
        """
        - (Required) database instance password
        """
        return pulumi.get(self, "db_password")

    @db_password.setter
    def db_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_password", value)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> pulumi.Input[str]:
        """
        - (Required) listener port for database instance
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "listener_port", value)

    @property
    @pulumi.getter(name="allocatePgHugepage")
    def allocate_pg_hugepage(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) allocate huge page. Default: false
        """
        return pulumi.get(self, "allocate_pg_hugepage")

    @allocate_pg_hugepage.setter
    def allocate_pg_hugepage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allocate_pg_hugepage", value)

    @property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) auth methods. Default: md5
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_method", value)

    @property
    @pulumi.getter(name="autoTuneStagingDrive")
    def auto_tune_staging_drive(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) enable auto tuning of staging drive. Default: false
        """
        return pulumi.get(self, "auto_tune_staging_drive")

    @auto_tune_staging_drive.setter
    def auto_tune_staging_drive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_tune_staging_drive", value)

    @property
    @pulumi.getter(name="clusterDatabase")
    def cluster_database(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) if clustered database. Default: false
        """
        return pulumi.get(self, "cluster_database")

    @cluster_database.setter
    def cluster_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster_database", value)

    @property
    @pulumi.getter(name="haInstance")
    def ha_instance(self) -> Optional[pulumi.Input['NdbDatabasePostgresqlInfoHaInstanceArgs']]:
        """
        - (Optional) High Availability instance
        """
        return pulumi.get(self, "ha_instance")

    @ha_instance.setter
    def ha_instance(self, value: Optional[pulumi.Input['NdbDatabasePostgresqlInfoHaInstanceArgs']]):
        pulumi.set(self, "ha_instance", value)

    @property
    @pulumi.getter(name="postCreateScript")
    def post_create_script(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) post instance create script
        """
        return pulumi.get(self, "post_create_script")

    @post_create_script.setter
    def post_create_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_create_script", value)

    @property
    @pulumi.getter(name="preCreateScript")
    def pre_create_script(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) pre instance create script
        """
        return pulumi.get(self, "pre_create_script")

    @pre_create_script.setter
    def pre_create_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_create_script", value)


if not MYPY:
    class NdbDatabasePostgresqlInfoHaInstanceArgsDict(TypedDict):
        cluster_name: pulumi.Input[str]
        """
        - (Required) cluster name
        """
        patroni_cluster_name: pulumi.Input[str]
        """
        - (Required) patroni cluster name
        """
        proxy_read_port: pulumi.Input[str]
        """
        -  (Required) proxy read port
        """
        proxy_write_port: pulumi.Input[str]
        """
        - (Required) proxy write port
        """
        archive_wal_expire_days: NotRequired[pulumi.Input[int]]
        """
        - (Optional) archive wal expire days. Default is set to -1
        """
        backup_policy: NotRequired[pulumi.Input[str]]
        """
        - (Optional) backup policy for instance. Default is "primary_only"
        """
        cluster_description: NotRequired[pulumi.Input[str]]
        deploy_haproxy: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) HA proxy node. Default is set to false
        """
        enable_peer_auth: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) enable peer auth . Default is set to false.
        """
        enable_synchronous_mode: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) enable synchronous mode. Default is set to true
        """
        failover_mode: NotRequired[pulumi.Input[str]]
        """
        - (Optional) failover mode of nodes.
        """
        node_type: NotRequired[pulumi.Input[str]]
        """
        - (Optional) node type of instance. Default is set to database
        """
        provision_virtual_ip: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) provisional virtual ip. Default is set to true
        """
elif False:
    NdbDatabasePostgresqlInfoHaInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabasePostgresqlInfoHaInstanceArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 patroni_cluster_name: pulumi.Input[str],
                 proxy_read_port: pulumi.Input[str],
                 proxy_write_port: pulumi.Input[str],
                 archive_wal_expire_days: Optional[pulumi.Input[int]] = None,
                 backup_policy: Optional[pulumi.Input[str]] = None,
                 cluster_description: Optional[pulumi.Input[str]] = None,
                 deploy_haproxy: Optional[pulumi.Input[bool]] = None,
                 enable_peer_auth: Optional[pulumi.Input[bool]] = None,
                 enable_synchronous_mode: Optional[pulumi.Input[bool]] = None,
                 failover_mode: Optional[pulumi.Input[str]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 provision_virtual_ip: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_name: - (Required) cluster name
        :param pulumi.Input[str] patroni_cluster_name: - (Required) patroni cluster name
        :param pulumi.Input[str] proxy_read_port: -  (Required) proxy read port
        :param pulumi.Input[str] proxy_write_port: - (Required) proxy write port
        :param pulumi.Input[int] archive_wal_expire_days: - (Optional) archive wal expire days. Default is set to -1
        :param pulumi.Input[str] backup_policy: - (Optional) backup policy for instance. Default is "primary_only"
        :param pulumi.Input[bool] deploy_haproxy: - (Optional) HA proxy node. Default is set to false
        :param pulumi.Input[bool] enable_peer_auth: - (Optional) enable peer auth . Default is set to false.
        :param pulumi.Input[bool] enable_synchronous_mode: - (Optional) enable synchronous mode. Default is set to true
        :param pulumi.Input[str] failover_mode: - (Optional) failover mode of nodes.
        :param pulumi.Input[str] node_type: - (Optional) node type of instance. Default is set to database
        :param pulumi.Input[bool] provision_virtual_ip: - (Optional) provisional virtual ip. Default is set to true
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "patroni_cluster_name", patroni_cluster_name)
        pulumi.set(__self__, "proxy_read_port", proxy_read_port)
        pulumi.set(__self__, "proxy_write_port", proxy_write_port)
        if archive_wal_expire_days is not None:
            pulumi.set(__self__, "archive_wal_expire_days", archive_wal_expire_days)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if cluster_description is not None:
            pulumi.set(__self__, "cluster_description", cluster_description)
        if deploy_haproxy is not None:
            pulumi.set(__self__, "deploy_haproxy", deploy_haproxy)
        if enable_peer_auth is not None:
            pulumi.set(__self__, "enable_peer_auth", enable_peer_auth)
        if enable_synchronous_mode is not None:
            pulumi.set(__self__, "enable_synchronous_mode", enable_synchronous_mode)
        if failover_mode is not None:
            pulumi.set(__self__, "failover_mode", failover_mode)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if provision_virtual_ip is not None:
            pulumi.set(__self__, "provision_virtual_ip", provision_virtual_ip)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        - (Required) cluster name
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="patroniClusterName")
    def patroni_cluster_name(self) -> pulumi.Input[str]:
        """
        - (Required) patroni cluster name
        """
        return pulumi.get(self, "patroni_cluster_name")

    @patroni_cluster_name.setter
    def patroni_cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "patroni_cluster_name", value)

    @property
    @pulumi.getter(name="proxyReadPort")
    def proxy_read_port(self) -> pulumi.Input[str]:
        """
        -  (Required) proxy read port
        """
        return pulumi.get(self, "proxy_read_port")

    @proxy_read_port.setter
    def proxy_read_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "proxy_read_port", value)

    @property
    @pulumi.getter(name="proxyWritePort")
    def proxy_write_port(self) -> pulumi.Input[str]:
        """
        - (Required) proxy write port
        """
        return pulumi.get(self, "proxy_write_port")

    @proxy_write_port.setter
    def proxy_write_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "proxy_write_port", value)

    @property
    @pulumi.getter(name="archiveWalExpireDays")
    def archive_wal_expire_days(self) -> Optional[pulumi.Input[int]]:
        """
        - (Optional) archive wal expire days. Default is set to -1
        """
        return pulumi.get(self, "archive_wal_expire_days")

    @archive_wal_expire_days.setter
    def archive_wal_expire_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "archive_wal_expire_days", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) backup policy for instance. Default is "primary_only"
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter(name="clusterDescription")
    def cluster_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_description")

    @cluster_description.setter
    def cluster_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_description", value)

    @property
    @pulumi.getter(name="deployHaproxy")
    def deploy_haproxy(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) HA proxy node. Default is set to false
        """
        return pulumi.get(self, "deploy_haproxy")

    @deploy_haproxy.setter
    def deploy_haproxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_haproxy", value)

    @property
    @pulumi.getter(name="enablePeerAuth")
    def enable_peer_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) enable peer auth . Default is set to false.
        """
        return pulumi.get(self, "enable_peer_auth")

    @enable_peer_auth.setter
    def enable_peer_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_peer_auth", value)

    @property
    @pulumi.getter(name="enableSynchronousMode")
    def enable_synchronous_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) enable synchronous mode. Default is set to true
        """
        return pulumi.get(self, "enable_synchronous_mode")

    @enable_synchronous_mode.setter
    def enable_synchronous_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_synchronous_mode", value)

    @property
    @pulumi.getter(name="failoverMode")
    def failover_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) failover mode of nodes.
        """
        return pulumi.get(self, "failover_mode")

    @failover_mode.setter
    def failover_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failover_mode", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) node type of instance. Default is set to database
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter(name="provisionVirtualIp")
    def provision_virtual_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) provisional virtual ip. Default is set to true
        """
        return pulumi.get(self, "provision_virtual_ip")

    @provision_virtual_ip.setter
    def provision_virtual_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "provision_virtual_ip", value)


if not MYPY:
    class NdbDatabasePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabasePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabasePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        """
        database id
        """
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeInfoArgsDict']]]]
        """
        info of instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodePropertyArgsDict']]]]
        """
        properties of database created
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
elif False:
    NdbDatabaseRestoreDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] database_id: database id
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeInfoArgs']]] infos: info of instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        database id
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseRestoreDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        properties of database created
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbDatabaseRestoreDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[str] type: type of database
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseRestoreInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseRestoreInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseRestoreInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbDatabaseRestoreLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbDatabaseRestoreLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbDatabaseRestoreLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseRestoreLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbDatabaseRestoreLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseRestoreLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseRestoreLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbDatabaseRestoreLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        """
        name of database
        """
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLinkedDatabaseInfoArgsDict']]]]
        """
        info of instance
        """
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        """
        parent database id
        """
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        """
        snapshot id from you want to use for restoring the instance
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: name of database
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLinkedDatabaseInfoArgs']]] infos: info of instance
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] parent_database_id: parent database id
        :param pulumi.Input[str] snapshot_id: snapshot id from you want to use for restoring the instance
        :param pulumi.Input[str] status: status of instance
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of database
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLinkedDatabaseInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        """
        parent database id
        """
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        snapshot id from you want to use for restoring the instance
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbDatabaseRestoreLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseRestoreLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseRestorePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestorePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestorePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of database instance
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        """
        whether instance is cloned or not
        """
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        """
        database id
        """
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachinePropertyArgsDict']]]]
        """
        properties of database created
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleArgsDict']]]]
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbDatabaseRestoreTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clone: whether instance is cloned or not
        :param pulumi.Input[str] database_id: database id
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachinePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        :param pulumi.Input[str] type: type of database
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        """
        whether instance is cloned or not
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        database id
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachinePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleArgs']]]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        """
        timezone on which instance is created xw
        """
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] time_zone: timezone on which instance is created xw
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone on which instance is created xw
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        minutes: NotRequired[pulumi.Input[int]]
        seconds: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseRestoreTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbDatabaseRestoreTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseRestoreTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseRestoreTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeInfoArgsDict']]]]
        """
        info of instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodePropertyArgsDict']]]]
        """
        properties of database created
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
elif False:
    NdbDatabaseScaleDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeInfoArgs']]] infos: info of instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseScaleDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        properties of database created
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbDatabaseScaleDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[str] type: type of database
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseScaleInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbDatabaseScaleInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbDatabaseScaleInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbDatabaseScaleInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbDatabaseScaleInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbDatabaseScaleLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbDatabaseScaleLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbDatabaseScaleLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseScaleLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbDatabaseScaleLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseScaleLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseScaleLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbDatabaseScaleLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        """
        name of database
        """
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLinkedDatabaseInfoArgsDict']]]]
        """
        info of instance
        """
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        """
        parent database id
        """
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: name of database
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLinkedDatabaseInfoArgs']]] infos: info of instance
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] parent_database_id: parent database id
        :param pulumi.Input[str] status: status of instance
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of database
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLinkedDatabaseInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        """
        parent database id
        """
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbDatabaseScaleLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbDatabaseScaleLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbDatabaseScalePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScalePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScalePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of database instance
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        """
        whether instance is cloned or not
        """
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachinePropertyArgsDict']]]]
        """
        properties of database created
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleArgsDict']]]]
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbDatabaseScaleTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clone: whether instance is cloned or not
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachinePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        :param pulumi.Input[str] type: type of database
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        """
        whether instance is cloned or not
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachinePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleArgs']]]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        """
        timezone on which instance is created xw
        """
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] time_zone: timezone on which instance is created xw
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone on which instance is created xw
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        minutes: NotRequired[pulumi.Input[int]]
        seconds: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseScaleTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbDatabaseScaleTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseScaleTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseScaleTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseSnapshotLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbDatabaseSnapshotLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseSnapshotLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbDatabaseSnapshotLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        """
        Default is set to Asia/Calcutta
        """
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseSnapshotLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] expiry_date_timezone: Default is set to Asia/Calcutta
        """
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Default is set to Asia/Calcutta
        """
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbDatabaseSnapshotLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseSnapshotLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbDatabaseSnapshotPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of snapshot
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Snapshot name. Default value is era_manual_snapshot.
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseSnapshotPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of snapshot
        :param pulumi.Input[str] name: Snapshot name. Default value is era_manual_snapshot.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of snapshot
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Snapshot name. Default value is era_manual_snapshot.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseSnapshotTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseSnapshotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseSnapshotTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) If clustered database. Default: false
        """
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachinePropertyArgsDict']]]]
        """
        List of all the properties
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleArgsDict']]]]
        """
        - (Optional) schedule for snapshots
        """
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineTagArgsDict']]]]
        """
        - (Optional) tags
        """
        type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clustered: - (Optional) If clustered database. Default: false
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachinePropertyArgs']]] properties: List of all the properties
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleArgs']]] schedules: - (Optional) schedule for snapshots
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineTagArgs']]] tags: - (Optional) tags
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) If clustered database. Default: false
        """
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachinePropertyArgs']]]]:
        """
        List of all the properties
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleArgs']]]]:
        """
        - (Optional) schedule for snapshots
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineTagArgs']]]]:
        """
        - (Optional) tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbDatabaseTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbDatabaseTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        """
        - (Required) hours
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        - (Required) minutes
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        - (Required) seconds
        """
elif False:
    NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: - (Required) hours
        :param pulumi.Input[int] minutes: - (Required) minutes
        :param pulumi.Input[int] seconds: - (Required) seconds
        """
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        - (Required) hours
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        - (Required) minutes
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        - (Required) seconds
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbDatabaseTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        """
        - (Required) month for snapshot
        """
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDatabaseTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] month: - (Required) month for snapshot
        """
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) month for snapshot
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbDatabaseTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The description
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) Name of the instance.
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbDatabaseTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] description: - (Optional) The description
        :param pulumi.Input[str] name: - (Required) Name of the instance.
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) Name of the instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbDatabaseTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) name of time machine
        """
        schedule: pulumi.Input['NdbDatabaseTimemachineinfoScheduleArgsDict']
        """
        - (Optional) schedule for snapshots
        """
        autotunelogdrive: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) enable auto tune log drive. Default: true
        """
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) description of time machine
        """
        sla_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailArgsDict']]]]
        """
        -  (optional) SLA details for HA instance
        """
        slaid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) SLA ID for single instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoTagArgsDict']]]]
        """
        - (Optional) tags
        """
elif False:
    NdbDatabaseTimemachineinfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['NdbDatabaseTimemachineinfoScheduleArgs'],
                 autotunelogdrive: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 sla_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailArgs']]]] = None,
                 slaid: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoTagArgs']]]] = None):
        """
        :param pulumi.Input[str] name: - (Required) name of time machine
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleArgs'] schedule: - (Optional) schedule for snapshots
        :param pulumi.Input[bool] autotunelogdrive: - (Optional) enable auto tune log drive. Default: true
        :param pulumi.Input[str] description: - (Optional) description of time machine
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailArgs']]] sla_details: -  (optional) SLA details for HA instance
        :param pulumi.Input[str] slaid: - (Optional) SLA ID for single instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoTagArgs']]] tags: - (Optional) tags
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if autotunelogdrive is not None:
            pulumi.set(__self__, "autotunelogdrive", autotunelogdrive)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if sla_details is not None:
            pulumi.set(__self__, "sla_details", sla_details)
        if slaid is not None:
            pulumi.set(__self__, "slaid", slaid)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) name of time machine
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['NdbDatabaseTimemachineinfoScheduleArgs']:
        """
        - (Optional) schedule for snapshots
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['NdbDatabaseTimemachineinfoScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter
    def autotunelogdrive(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) enable auto tune log drive. Default: true
        """
        return pulumi.get(self, "autotunelogdrive")

    @autotunelogdrive.setter
    def autotunelogdrive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autotunelogdrive", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) description of time machine
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="slaDetails")
    def sla_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailArgs']]]]:
        """
        -  (optional) SLA details for HA instance
        """
        return pulumi.get(self, "sla_details")

    @sla_details.setter
    def sla_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailArgs']]]]):
        pulumi.set(self, "sla_details", value)

    @property
    @pulumi.getter
    def slaid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) SLA ID for single instance
        """
        return pulumi.get(self, "slaid")

    @slaid.setter
    def slaid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slaid", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoTagArgs']]]]:
        """
        - (Optional) tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleArgsDict(TypedDict):
        continuousschedule: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgsDict']]
        """
        - (Optional) snapshot freq and log config
        """
        monthlyschedule: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgsDict']]
        """
        - (Optional) monthly snapshot config
        """
        quartelyschedule: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgsDict']]
        """
        - (Optional) quaterly snapshot config
        """
        snapshottimeofday: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgsDict']]
        """
        - (Optional) daily snapshot config
        """
        weeklyschedule: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgsDict']]
        """
        - (Optional) weekly snapshot config
        """
        yearlyschedule: NotRequired[pulumi.Input['NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgsDict']]
        """
        - (Optional) yearly snapshot config
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleArgs:
    def __init__(__self__, *,
                 continuousschedule: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs']] = None,
                 monthlyschedule: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs']] = None,
                 quartelyschedule: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs']] = None,
                 snapshottimeofday: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs']] = None,
                 weeklyschedule: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs']] = None,
                 yearlyschedule: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs']] = None):
        """
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs'] continuousschedule: - (Optional) snapshot freq and log config
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs'] monthlyschedule: - (Optional) monthly snapshot config
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs'] quartelyschedule: - (Optional) quaterly snapshot config
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs'] snapshottimeofday: - (Optional) daily snapshot config
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs'] weeklyschedule: - (Optional) weekly snapshot config
        :param pulumi.Input['NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs'] yearlyschedule: - (Optional) yearly snapshot config
        """
        if continuousschedule is not None:
            pulumi.set(__self__, "continuousschedule", continuousschedule)
        if monthlyschedule is not None:
            pulumi.set(__self__, "monthlyschedule", monthlyschedule)
        if quartelyschedule is not None:
            pulumi.set(__self__, "quartelyschedule", quartelyschedule)
        if snapshottimeofday is not None:
            pulumi.set(__self__, "snapshottimeofday", snapshottimeofday)
        if weeklyschedule is not None:
            pulumi.set(__self__, "weeklyschedule", weeklyschedule)
        if yearlyschedule is not None:
            pulumi.set(__self__, "yearlyschedule", yearlyschedule)

    @property
    @pulumi.getter
    def continuousschedule(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs']]:
        """
        - (Optional) snapshot freq and log config
        """
        return pulumi.get(self, "continuousschedule")

    @continuousschedule.setter
    def continuousschedule(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs']]):
        pulumi.set(self, "continuousschedule", value)

    @property
    @pulumi.getter
    def monthlyschedule(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs']]:
        """
        - (Optional) monthly snapshot config
        """
        return pulumi.get(self, "monthlyschedule")

    @monthlyschedule.setter
    def monthlyschedule(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs']]):
        pulumi.set(self, "monthlyschedule", value)

    @property
    @pulumi.getter
    def quartelyschedule(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs']]:
        """
        - (Optional) quaterly snapshot config
        """
        return pulumi.get(self, "quartelyschedule")

    @quartelyschedule.setter
    def quartelyschedule(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs']]):
        pulumi.set(self, "quartelyschedule", value)

    @property
    @pulumi.getter
    def snapshottimeofday(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs']]:
        """
        - (Optional) daily snapshot config
        """
        return pulumi.get(self, "snapshottimeofday")

    @snapshottimeofday.setter
    def snapshottimeofday(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs']]):
        pulumi.set(self, "snapshottimeofday", value)

    @property
    @pulumi.getter
    def weeklyschedule(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs']]:
        """
        - (Optional) weekly snapshot config
        """
        return pulumi.get(self, "weeklyschedule")

    @weeklyschedule.setter
    def weeklyschedule(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs']]):
        pulumi.set(self, "weeklyschedule", value)

    @property
    @pulumi.getter
    def yearlyschedule(self) -> Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs']]:
        """
        - (Optional) yearly snapshot config
        """
        return pulumi.get(self, "yearlyschedule")

    @yearlyschedule.setter
    def yearlyschedule(self, value: Optional[pulumi.Input['NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs']]):
        pulumi.set(self, "yearlyschedule", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        - (Required) to enable
        """
        logbackupinterval: pulumi.Input[int]
        """
        - (Required) log catchup interval for database
        """
        snapshotsperday: pulumi.Input[int]
        """
        - (Required) num of snapshots per day
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleContinuousscheduleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 logbackupinterval: pulumi.Input[int],
                 snapshotsperday: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] enabled: - (Required) to enable
        :param pulumi.Input[int] logbackupinterval: - (Required) log catchup interval for database
        :param pulumi.Input[int] snapshotsperday: - (Required) num of snapshots per day
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "logbackupinterval", logbackupinterval)
        pulumi.set(__self__, "snapshotsperday", snapshotsperday)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        - (Required) to enable
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def logbackupinterval(self) -> pulumi.Input[int]:
        """
        - (Required) log catchup interval for database
        """
        return pulumi.get(self, "logbackupinterval")

    @logbackupinterval.setter
    def logbackupinterval(self, value: pulumi.Input[int]):
        pulumi.set(self, "logbackupinterval", value)

    @property
    @pulumi.getter
    def snapshotsperday(self) -> pulumi.Input[int]:
        """
        - (Required) num of snapshots per day
        """
        return pulumi.get(self, "snapshotsperday")

    @snapshotsperday.setter
    def snapshotsperday(self, value: pulumi.Input[int]):
        pulumi.set(self, "snapshotsperday", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        """
        - (Required) day of month to take snapshot
        """
        enabled: pulumi.Input[bool]
        """
        - (Required) to enable
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleMonthlyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[int] dayofmonth: - (Required) day of month to take snapshot
        :param pulumi.Input[bool] enabled: - (Required) to enable
        """
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        """
        - (Required) day of month to take snapshot
        """
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        - (Required) to enable
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        """
        - (Required) month's day for snapshot
        """
        enabled: pulumi.Input[bool]
        """
        - (Required) to enable
        """
        startmonth: pulumi.Input[str]
        """
        - (Required) quarter start month
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleQuartelyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool],
                 startmonth: pulumi.Input[str]):
        """
        :param pulumi.Input[int] dayofmonth: - (Required) month's day for snapshot
        :param pulumi.Input[bool] enabled: - (Required) to enable
        :param pulumi.Input[str] startmonth: - (Required) quarter start month
        """
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "startmonth", startmonth)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        """
        - (Required) month's day for snapshot
        """
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        - (Required) to enable
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def startmonth(self) -> pulumi.Input[str]:
        """
        - (Required) quarter start month
        """
        return pulumi.get(self, "startmonth")

    @startmonth.setter
    def startmonth(self, value: pulumi.Input[str]):
        pulumi.set(self, "startmonth", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgsDict(TypedDict):
        hours: pulumi.Input[int]
        """
        - (Required) hours
        """
        minutes: pulumi.Input[int]
        """
        - (Required) minutes
        """
        seconds: pulumi.Input[int]
        """
        - (Required) seconds
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleSnapshottimeofdayArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[int],
                 minutes: pulumi.Input[int],
                 seconds: pulumi.Input[int]):
        """
        :param pulumi.Input[int] hours: - (Required) hours
        :param pulumi.Input[int] minutes: - (Required) minutes
        :param pulumi.Input[int] seconds: - (Required) seconds
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[int]:
        """
        - (Required) hours
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[int]:
        """
        - (Required) minutes
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> pulumi.Input[int]:
        """
        - (Required) seconds
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgsDict(TypedDict):
        dayofweek: pulumi.Input[str]
        """
        - (Required) day of week to take snaphsot. Eg. "WEDNESDAY"
        """
        enabled: pulumi.Input[bool]
        """
        - (Required) to enable
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleWeeklyscheduleArgs:
    def __init__(__self__, *,
                 dayofweek: pulumi.Input[str],
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[str] dayofweek: - (Required) day of week to take snaphsot. Eg. "WEDNESDAY"
        :param pulumi.Input[bool] enabled: - (Required) to enable
        """
        pulumi.set(__self__, "dayofweek", dayofweek)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def dayofweek(self) -> pulumi.Input[str]:
        """
        - (Required) day of week to take snaphsot. Eg. "WEDNESDAY"
        """
        return pulumi.get(self, "dayofweek")

    @dayofweek.setter
    def dayofweek(self, value: pulumi.Input[str]):
        pulumi.set(self, "dayofweek", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        - (Required) to enable
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        """
        - (Required) day of month to take snapshot
        """
        enabled: pulumi.Input[bool]
        """
        - (Required) to enable
        """
        month: pulumi.Input[str]
        """
        - (Required) month for snapshot
        """
elif False:
    NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoScheduleYearlyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool],
                 month: pulumi.Input[str]):
        """
        :param pulumi.Input[int] dayofmonth: - (Required) day of month to take snapshot
        :param pulumi.Input[bool] enabled: - (Required) to enable
        :param pulumi.Input[str] month: - (Required) month for snapshot
        """
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "month", month)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        """
        - (Required) day of month to take snapshot
        """
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        - (Required) to enable
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> pulumi.Input[str]:
        """
        - (Required) month for snapshot
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[str]):
        pulumi.set(self, "month", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoSlaDetailArgsDict(TypedDict):
        primary_slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgsDict']]]]
        """
        - (Required) primary sla details
        * `primary_sla.sla_id` :- (Required) sla id
        * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
elif False:
    NdbDatabaseTimemachineinfoSlaDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoSlaDetailArgs:
    def __init__(__self__, *,
                 primary_slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs']]] primary_slas: - (Required) primary sla details
               * `primary_sla.sla_id` :- (Required) sla id
               * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
        if primary_slas is not None:
            pulumi.set(__self__, "primary_slas", primary_slas)

    @property
    @pulumi.getter(name="primarySlas")
    def primary_slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs']]]]:
        """
        - (Required) primary sla details
        * `primary_sla.sla_id` :- (Required) sla id
        * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
        return pulumi.get(self, "primary_slas")

    @primary_slas.setter
    def primary_slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs']]]]):
        pulumi.set(self, "primary_slas", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgsDict(TypedDict):
        sla_id: pulumi.Input[str]
        """
        description of SLA ID.
        """
        nx_cluster_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoSlaDetailPrimarySlaArgs:
    def __init__(__self__, *,
                 sla_id: pulumi.Input[str],
                 nx_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] sla_id: description of SLA ID.
        """
        pulumi.set(__self__, "sla_id", sla_id)
        if nx_cluster_ids is not None:
            pulumi.set(__self__, "nx_cluster_ids", nx_cluster_ids)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> pulumi.Input[str]:
        """
        description of SLA ID.
        """
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="nxClusterIds")
    def nx_cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "nx_cluster_ids")

    @nx_cluster_ids.setter
    def nx_cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nx_cluster_ids", value)


if not MYPY:
    class NdbDatabaseTimemachineinfoTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbDatabaseTimemachineinfoTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDatabaseTimemachineinfoTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDbserverVmCredentialArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
        label: NotRequired[pulumi.Input[str]]
elif False:
    NdbDbserverVmCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmCredentialArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 label: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class NdbDbserverVmMaintenanceTasksArgsDict(TypedDict):
        maintenance_window_id: NotRequired[pulumi.Input[str]]
        """
        Associate an existing maintenance window id. NDB starts OS patching or database patching as per the schedule defined in the maintenance window.
        """
        tasks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbDbserverVmMaintenanceTasksTaskArgsDict']]]]
        """
        Tasks for the maintenance.
        * `tasks.task_type`: use this option if you want NDB to perform database patching or OS patching automatically. Supports [ OS_PATCHING, DB_PATCHING ].
        * `tasks.pre_command`: add pre (operating system and database patching) commands.
        * `tasks.post_command`:add post (operating system and database patching) commands.
        """
elif False:
    NdbDbserverVmMaintenanceTasksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmMaintenanceTasksArgs:
    def __init__(__self__, *,
                 maintenance_window_id: Optional[pulumi.Input[str]] = None,
                 tasks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDbserverVmMaintenanceTasksTaskArgs']]]] = None):
        """
        :param pulumi.Input[str] maintenance_window_id: Associate an existing maintenance window id. NDB starts OS patching or database patching as per the schedule defined in the maintenance window.
        :param pulumi.Input[Sequence[pulumi.Input['NdbDbserverVmMaintenanceTasksTaskArgs']]] tasks: Tasks for the maintenance.
               * `tasks.task_type`: use this option if you want NDB to perform database patching or OS patching automatically. Supports [ OS_PATCHING, DB_PATCHING ].
               * `tasks.pre_command`: add pre (operating system and database patching) commands.
               * `tasks.post_command`:add post (operating system and database patching) commands.
        """
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if tasks is not None:
            pulumi.set(__self__, "tasks", tasks)

    @property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[str]]:
        """
        Associate an existing maintenance window id. NDB starts OS patching or database patching as per the schedule defined in the maintenance window.
        """
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @property
    @pulumi.getter
    def tasks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbDbserverVmMaintenanceTasksTaskArgs']]]]:
        """
        Tasks for the maintenance.
        * `tasks.task_type`: use this option if you want NDB to perform database patching or OS patching automatically. Supports [ OS_PATCHING, DB_PATCHING ].
        * `tasks.pre_command`: add pre (operating system and database patching) commands.
        * `tasks.post_command`:add post (operating system and database patching) commands.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbDbserverVmMaintenanceTasksTaskArgs']]]]):
        pulumi.set(self, "tasks", value)


if not MYPY:
    class NdbDbserverVmMaintenanceTasksTaskArgsDict(TypedDict):
        post_command: NotRequired[pulumi.Input[str]]
        pre_command: NotRequired[pulumi.Input[str]]
        task_type: NotRequired[pulumi.Input[str]]
elif False:
    NdbDbserverVmMaintenanceTasksTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmMaintenanceTasksTaskArgs:
    def __init__(__self__, *,
                 post_command: Optional[pulumi.Input[str]] = None,
                 pre_command: Optional[pulumi.Input[str]] = None,
                 task_type: Optional[pulumi.Input[str]] = None):
        if post_command is not None:
            pulumi.set(__self__, "post_command", post_command)
        if pre_command is not None:
            pulumi.set(__self__, "pre_command", pre_command)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="postCommand")
    def post_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "post_command")

    @post_command.setter
    def post_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_command", value)

    @property
    @pulumi.getter(name="preCommand")
    def pre_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pre_command")

    @pre_command.setter
    def pre_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_command", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_type", value)


if not MYPY:
    class NdbDbserverVmPostgresDatabaseArgsDict(TypedDict):
        vm_name: pulumi.Input[str]
        """
        name for the database server VM.
        """
        client_public_key: NotRequired[pulumi.Input[str]]
        """
        use SSH public keys to access the database server VM.
        """
elif False:
    NdbDbserverVmPostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmPostgresDatabaseArgs:
    def __init__(__self__, *,
                 vm_name: pulumi.Input[str],
                 client_public_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vm_name: name for the database server VM.
        :param pulumi.Input[str] client_public_key: use SSH public keys to access the database server VM.
        """
        pulumi.set(__self__, "vm_name", vm_name)
        if client_public_key is not None:
            pulumi.set(__self__, "client_public_key", client_public_key)

    @property
    @pulumi.getter(name="vmName")
    def vm_name(self) -> pulumi.Input[str]:
        """
        name for the database server VM.
        """
        return pulumi.get(self, "vm_name")

    @vm_name.setter
    def vm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_name", value)

    @property
    @pulumi.getter(name="clientPublicKey")
    def client_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        use SSH public keys to access the database server VM.
        """
        return pulumi.get(self, "client_public_key")

    @client_public_key.setter
    def client_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_public_key", value)


if not MYPY:
    class NdbDbserverVmPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        name of the dbserver vm
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDbserverVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: name of the dbserver vm
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of the dbserver vm
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbDbserverVmTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbDbserverVmTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbDbserverVmTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbLinkedDatabasesInfoArgsDict(TypedDict):
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbLinkedDatabasesInfoInfoArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbLinkedDatabasesInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbLinkedDatabasesInfoArgs:
    def __init__(__self__, *,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbLinkedDatabasesInfoInfoArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbLinkedDatabasesInfoInfoArgs']]]]:
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbLinkedDatabasesInfoInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbLinkedDatabasesInfoInfoArgsDict(TypedDict):
        created_by: NotRequired[pulumi.Input[str]]
elif False:
    NdbLinkedDatabasesInfoInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbLinkedDatabasesInfoInfoArgs:
    def __init__(__self__, *,
                 created_by: Optional[pulumi.Input[str]] = None):
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_by", value)


if not MYPY:
    class NdbMaintenanceTaskEntityTaskAssociationArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        access level of tasks
        """
        date_created: NotRequired[pulumi.Input[str]]
        """
        created date of task
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        modified date of task
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of maintenance window
        """
        entity: NotRequired[pulumi.Input[str]]
        entity_id: NotRequired[pulumi.Input[str]]
        """
        entity id
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        type of the entity. i.e. DBSERVER
        """
        id: NotRequired[pulumi.Input[str]]
        """
        id of maintenance window
        """
        maintenance_window_id: NotRequired[pulumi.Input[str]]
        """
        maintenance window id which has to be associated
        """
        maintenance_window_owner_id: NotRequired[pulumi.Input[str]]
        """
        maintenance window owner id
        """
        name: NotRequired[pulumi.Input[str]]
        """
        name of of maintenance window
        """
        owner_id: NotRequired[pulumi.Input[str]]
        """
        owner id of task
        """
        payloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadArgsDict']]]]
        """
        list of pre post commands of OS or DB task
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPropertyArgsDict']]]]
        """
        properties of task
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of task
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationTagArgsDict']]]]
        """
        tags of task
        """
        task_type: NotRequired[pulumi.Input[str]]
        """
        type of the task. OS or DB
        """
elif False:
    NdbMaintenanceTaskEntityTaskAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskEntityTaskAssociationArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 maintenance_window_id: Optional[pulumi.Input[str]] = None,
                 maintenance_window_owner_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 payloads: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadArgs']]]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationTagArgs']]]] = None,
                 task_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_level: access level of tasks
        :param pulumi.Input[str] date_created: created date of task
        :param pulumi.Input[str] date_modified: modified date of task
        :param pulumi.Input[str] description: description of maintenance window
        :param pulumi.Input[str] entity_id: entity id
        :param pulumi.Input[str] entity_type: type of the entity. i.e. DBSERVER
        :param pulumi.Input[str] id: id of maintenance window
        :param pulumi.Input[str] maintenance_window_id: maintenance window id which has to be associated
        :param pulumi.Input[str] maintenance_window_owner_id: maintenance window owner id
        :param pulumi.Input[str] name: name of of maintenance window
        :param pulumi.Input[str] owner_id: owner id of task
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadArgs']]] payloads: list of pre post commands of OS or DB task
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPropertyArgs']]] properties: properties of task
        :param pulumi.Input[str] status: status of task
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationTagArgs']]] tags: tags of task
        :param pulumi.Input[str] task_type: type of the task. OS or DB
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if maintenance_window_owner_id is not None:
            pulumi.set(__self__, "maintenance_window_owner_id", maintenance_window_owner_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if payloads is not None:
            pulumi.set(__self__, "payloads", payloads)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        access level of tasks
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        created date of task
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        modified date of task
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of maintenance window
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        entity id
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the entity. i.e. DBSERVER
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        id of maintenance window
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[str]]:
        """
        maintenance window id which has to be associated
        """
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @property
    @pulumi.getter(name="maintenanceWindowOwnerId")
    def maintenance_window_owner_id(self) -> Optional[pulumi.Input[str]]:
        """
        maintenance window owner id
        """
        return pulumi.get(self, "maintenance_window_owner_id")

    @maintenance_window_owner_id.setter
    def maintenance_window_owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_owner_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of of maintenance window
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        """
        owner id of task
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter
    def payloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadArgs']]]]:
        """
        list of pre post commands of OS or DB task
        """
        return pulumi.get(self, "payloads")

    @payloads.setter
    def payloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadArgs']]]]):
        pulumi.set(self, "payloads", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPropertyArgs']]]]:
        """
        properties of task
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of task
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationTagArgs']]]]:
        """
        tags of task
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the task. OS or DB
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_type", value)


if not MYPY:
    class NdbMaintenanceTaskEntityTaskAssociationPayloadArgsDict(TypedDict):
        pre_post_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgsDict']]]]
        """
        Pre Post command of Task
        """
elif False:
    NdbMaintenanceTaskEntityTaskAssociationPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskEntityTaskAssociationPayloadArgs:
    def __init__(__self__, *,
                 pre_post_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs']]] pre_post_commands: Pre Post command of Task
        """
        if pre_post_commands is not None:
            pulumi.set(__self__, "pre_post_commands", pre_post_commands)

    @property
    @pulumi.getter(name="prePostCommands")
    def pre_post_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs']]]]:
        """
        Pre Post command of Task
        """
        return pulumi.get(self, "pre_post_commands")

    @pre_post_commands.setter
    def pre_post_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs']]]]):
        pulumi.set(self, "pre_post_commands", value)


if not MYPY:
    class NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgsDict(TypedDict):
        post_command: NotRequired[pulumi.Input[str]]
        """
        post command of task
        """
        pre_command: NotRequired[pulumi.Input[str]]
        """
        pre command of task
        """
elif False:
    NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskEntityTaskAssociationPayloadPrePostCommandArgs:
    def __init__(__self__, *,
                 post_command: Optional[pulumi.Input[str]] = None,
                 pre_command: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] post_command: post command of task
        :param pulumi.Input[str] pre_command: pre command of task
        """
        if post_command is not None:
            pulumi.set(__self__, "post_command", post_command)
        if pre_command is not None:
            pulumi.set(__self__, "pre_command", pre_command)

    @property
    @pulumi.getter(name="postCommand")
    def post_command(self) -> Optional[pulumi.Input[str]]:
        """
        post command of task
        """
        return pulumi.get(self, "post_command")

    @post_command.setter
    def post_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_command", value)

    @property
    @pulumi.getter(name="preCommand")
    def pre_command(self) -> Optional[pulumi.Input[str]]:
        """
        pre command of task
        """
        return pulumi.get(self, "pre_command")

    @pre_command.setter
    def pre_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_command", value)


if not MYPY:
    class NdbMaintenanceTaskEntityTaskAssociationPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        name of of maintenance window
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceTaskEntityTaskAssociationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskEntityTaskAssociationPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: name of of maintenance window
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name of of maintenance window
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbMaintenanceTaskEntityTaskAssociationTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        """
        entity id
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        type of the entity. i.e. DBSERVER
        """
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceTaskEntityTaskAssociationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskEntityTaskAssociationTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] entity_id: entity id
        :param pulumi.Input[str] entity_type: type of the entity. i.e. DBSERVER
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        entity id
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the entity. i.e. DBSERVER
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbMaintenanceTaskTaskArgsDict(TypedDict):
        post_command: NotRequired[pulumi.Input[str]]
        """
        command that you want to run after patching the OS/DB
        """
        pre_command: NotRequired[pulumi.Input[str]]
        """
        command that you want to run before patching the OS/DB
        """
        task_type: NotRequired[pulumi.Input[str]]
        """
        type of task. Supports [ "OS_PATCHING", "DB_PATCHING" ]
        """
elif False:
    NdbMaintenanceTaskTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceTaskTaskArgs:
    def __init__(__self__, *,
                 post_command: Optional[pulumi.Input[str]] = None,
                 pre_command: Optional[pulumi.Input[str]] = None,
                 task_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] post_command: command that you want to run after patching the OS/DB
        :param pulumi.Input[str] pre_command: command that you want to run before patching the OS/DB
        :param pulumi.Input[str] task_type: type of task. Supports [ "OS_PATCHING", "DB_PATCHING" ]
        """
        if post_command is not None:
            pulumi.set(__self__, "post_command", post_command)
        if pre_command is not None:
            pulumi.set(__self__, "pre_command", pre_command)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="postCommand")
    def post_command(self) -> Optional[pulumi.Input[str]]:
        """
        command that you want to run after patching the OS/DB
        """
        return pulumi.get(self, "post_command")

    @post_command.setter
    def post_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_command", value)

    @property
    @pulumi.getter(name="preCommand")
    def pre_command(self) -> Optional[pulumi.Input[str]]:
        """
        command that you want to run before patching the OS/DB
        """
        return pulumi.get(self, "pre_command")

    @pre_command.setter
    def pre_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_command", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of task. Supports [ "OS_PATCHING", "DB_PATCHING" ]
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_type", value)


if not MYPY:
    class NdbMaintenanceWindowEntityTaskAssocArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        """
        access level
        """
        date_created: NotRequired[pulumi.Input[str]]
        """
        created date of maintenance window
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        modified date of maintenance window
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description for maintenance window
        """
        entity: NotRequired[pulumi.Input[str]]
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        maintenance_window_id: NotRequired[pulumi.Input[str]]
        maintenance_window_owner_id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name for the maintenance window.
        """
        owner_id: NotRequired[pulumi.Input[str]]
        """
        owner id of maintenance window
        """
        payloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadArgsDict']]]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPropertyArgsDict']]]]
        """
        properties of maintenance window
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of maintennace window
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocTagArgsDict']]]]
        """
        tags of maintenance window
        """
        task_type: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowEntityTaskAssocArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowEntityTaskAssocArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 entity: Optional[pulumi.Input[str]] = None,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 maintenance_window_id: Optional[pulumi.Input[str]] = None,
                 maintenance_window_owner_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 payloads: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadArgs']]]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocTagArgs']]]] = None,
                 task_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_level: access level
        :param pulumi.Input[str] date_created: created date of maintenance window
        :param pulumi.Input[str] date_modified: modified date of maintenance window
        :param pulumi.Input[str] description: Description for maintenance window
        :param pulumi.Input[str] name: Name for the maintenance window.
        :param pulumi.Input[str] owner_id: owner id of maintenance window
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPropertyArgs']]] properties: properties of maintenance window
        :param pulumi.Input[str] status: status of maintennace window
        :param pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocTagArgs']]] tags: tags of maintenance window
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entity is not None:
            pulumi.set(__self__, "entity", entity)
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if maintenance_window_id is not None:
            pulumi.set(__self__, "maintenance_window_id", maintenance_window_id)
        if maintenance_window_owner_id is not None:
            pulumi.set(__self__, "maintenance_window_owner_id", maintenance_window_owner_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if payloads is not None:
            pulumi.set(__self__, "payloads", payloads)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if task_type is not None:
            pulumi.set(__self__, "task_type", task_type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        """
        access level
        """
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        created date of maintenance window
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        modified date of maintenance window
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description for maintenance window
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def entity(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity")

    @entity.setter
    def entity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maintenanceWindowId")
    def maintenance_window_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_window_id")

    @maintenance_window_id.setter
    def maintenance_window_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_id", value)

    @property
    @pulumi.getter(name="maintenanceWindowOwnerId")
    def maintenance_window_owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_window_owner_id")

    @maintenance_window_owner_id.setter
    def maintenance_window_owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window_owner_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the maintenance window.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        """
        owner id of maintenance window
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter
    def payloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadArgs']]]]:
        return pulumi.get(self, "payloads")

    @payloads.setter
    def payloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadArgs']]]]):
        pulumi.set(self, "payloads", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPropertyArgs']]]]:
        """
        properties of maintenance window
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of maintennace window
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocTagArgs']]]]:
        """
        tags of maintenance window
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task_type", value)


if not MYPY:
    class NdbMaintenanceWindowEntityTaskAssocPayloadArgsDict(TypedDict):
        pre_post_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgsDict']]]]
elif False:
    NdbMaintenanceWindowEntityTaskAssocPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowEntityTaskAssocPayloadArgs:
    def __init__(__self__, *,
                 pre_post_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgs']]]] = None):
        if pre_post_commands is not None:
            pulumi.set(__self__, "pre_post_commands", pre_post_commands)

    @property
    @pulumi.getter(name="prePostCommands")
    def pre_post_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgs']]]]:
        return pulumi.get(self, "pre_post_commands")

    @pre_post_commands.setter
    def pre_post_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgs']]]]):
        pulumi.set(self, "pre_post_commands", value)


if not MYPY:
    class NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgsDict(TypedDict):
        post_command: NotRequired[pulumi.Input[str]]
        pre_command: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowEntityTaskAssocPayloadPrePostCommandArgs:
    def __init__(__self__, *,
                 post_command: Optional[pulumi.Input[str]] = None,
                 pre_command: Optional[pulumi.Input[str]] = None):
        if post_command is not None:
            pulumi.set(__self__, "post_command", post_command)
        if pre_command is not None:
            pulumi.set(__self__, "pre_command", pre_command)

    @property
    @pulumi.getter(name="postCommand")
    def post_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "post_command")

    @post_command.setter
    def post_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_command", value)

    @property
    @pulumi.getter(name="preCommand")
    def pre_command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pre_command")

    @pre_command.setter
    def pre_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pre_command", value)


if not MYPY:
    class NdbMaintenanceWindowEntityTaskAssocPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name for the maintenance window.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowEntityTaskAssocPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowEntityTaskAssocPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name for the maintenance window.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the maintenance window.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbMaintenanceWindowEntityTaskAssocTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowEntityTaskAssocTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowEntityTaskAssocTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbMaintenanceWindowPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name for the maintenance window.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name for the maintenance window.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the maintenance window.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbMaintenanceWindowScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        """
        Day of the week to trigger maintenance window. Supports [ MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ]
        """
        duration: NotRequired[pulumi.Input[int]]
        """
        duration in hours. Default is 2
        """
        hour: NotRequired[pulumi.Input[int]]
        minute: NotRequired[pulumi.Input[int]]
        recurrence: NotRequired[pulumi.Input[str]]
        """
        Supported values [ MONTHLY, WEEKLY ]
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        start time for maintenance window to trigger
        """
        threshold: NotRequired[pulumi.Input[str]]
        timezone: NotRequired[pulumi.Input[str]]
        """
        timezone . Default is Asia/Calcutta .
        """
        week_of_month: NotRequired[pulumi.Input[int]]
        """
        week of the month. Supports [1, 2, 3, 4] .
        """
elif False:
    NdbMaintenanceWindowScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 duration: Optional[pulumi.Input[int]] = None,
                 hour: Optional[pulumi.Input[int]] = None,
                 minute: Optional[pulumi.Input[int]] = None,
                 recurrence: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 week_of_month: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] day_of_week: Day of the week to trigger maintenance window. Supports [ MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ]
        :param pulumi.Input[int] duration: duration in hours. Default is 2
        :param pulumi.Input[str] recurrence: Supported values [ MONTHLY, WEEKLY ]
        :param pulumi.Input[str] start_time: start time for maintenance window to trigger
        :param pulumi.Input[str] timezone: timezone . Default is Asia/Calcutta .
        :param pulumi.Input[int] week_of_month: week of the month. Supports [1, 2, 3, 4] .
        """
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if minute is not None:
            pulumi.set(__self__, "minute", minute)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if week_of_month is not None:
            pulumi.set(__self__, "week_of_month", week_of_month)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        Day of the week to trigger maintenance window. Supports [ MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ]
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        duration in hours. Default is 2
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def minute(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minute")

    @minute.setter
    def minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minute", value)

    @property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input[str]]:
        """
        Supported values [ MONTHLY, WEEKLY ]
        """
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recurrence", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        start time for maintenance window to trigger
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone . Default is Asia/Calcutta .
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="weekOfMonth")
    def week_of_month(self) -> Optional[pulumi.Input[int]]:
        """
        week of the month. Supports [1, 2, 3, 4] .
        """
        return pulumi.get(self, "week_of_month")

    @week_of_month.setter
    def week_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "week_of_month", value)


if not MYPY:
    class NdbMaintenanceWindowTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbMaintenanceWindowTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbMaintenanceWindowTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbNetworkIpPoolArgsDict(TypedDict):
        addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbNetworkIpPoolAddressArgsDict']]]]
        end_ip: NotRequired[pulumi.Input[str]]
        """
        ending IP address range for new database servers
        """
        id: NotRequired[pulumi.Input[str]]
        modified_by: NotRequired[pulumi.Input[str]]
        start_ip: NotRequired[pulumi.Input[str]]
        """
        starting IP address range for new database servers
        """
elif False:
    NdbNetworkIpPoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbNetworkIpPoolArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input['NdbNetworkIpPoolAddressArgs']]]] = None,
                 end_ip: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 modified_by: Optional[pulumi.Input[str]] = None,
                 start_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_ip: ending IP address range for new database servers
        :param pulumi.Input[str] start_ip: starting IP address range for new database servers
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if end_ip is not None:
            pulumi.set(__self__, "end_ip", end_ip)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if modified_by is not None:
            pulumi.set(__self__, "modified_by", modified_by)
        if start_ip is not None:
            pulumi.set(__self__, "start_ip", start_ip)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbNetworkIpPoolAddressArgs']]]]:
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbNetworkIpPoolAddressArgs']]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter(name="endIp")
    def end_ip(self) -> Optional[pulumi.Input[str]]:
        """
        ending IP address range for new database servers
        """
        return pulumi.get(self, "end_ip")

    @end_ip.setter
    def end_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_ip", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="modifiedBy")
    def modified_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "modified_by")

    @modified_by.setter
    def modified_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modified_by", value)

    @property
    @pulumi.getter(name="startIp")
    def start_ip(self) -> Optional[pulumi.Input[str]]:
        """
        starting IP address range for new database servers
        """
        return pulumi.get(self, "start_ip")

    @start_ip.setter
    def start_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_ip", value)


if not MYPY:
    class NdbNetworkIpPoolAddressArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    NdbNetworkIpPoolAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbNetworkIpPoolAddressArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NdbNetworkPropertiesMapArgsDict(TypedDict):
        vlan_gateway: NotRequired[pulumi.Input[str]]
        vlan_primary_dns: NotRequired[pulumi.Input[str]]
        vlan_secondary_dns: NotRequired[pulumi.Input[str]]
        vlan_subnet_mask: NotRequired[pulumi.Input[str]]
elif False:
    NdbNetworkPropertiesMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbNetworkPropertiesMapArgs:
    def __init__(__self__, *,
                 vlan_gateway: Optional[pulumi.Input[str]] = None,
                 vlan_primary_dns: Optional[pulumi.Input[str]] = None,
                 vlan_secondary_dns: Optional[pulumi.Input[str]] = None,
                 vlan_subnet_mask: Optional[pulumi.Input[str]] = None):
        if vlan_gateway is not None:
            pulumi.set(__self__, "vlan_gateway", vlan_gateway)
        if vlan_primary_dns is not None:
            pulumi.set(__self__, "vlan_primary_dns", vlan_primary_dns)
        if vlan_secondary_dns is not None:
            pulumi.set(__self__, "vlan_secondary_dns", vlan_secondary_dns)
        if vlan_subnet_mask is not None:
            pulumi.set(__self__, "vlan_subnet_mask", vlan_subnet_mask)

    @property
    @pulumi.getter(name="vlanGateway")
    def vlan_gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_gateway")

    @vlan_gateway.setter
    def vlan_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_gateway", value)

    @property
    @pulumi.getter(name="vlanPrimaryDns")
    def vlan_primary_dns(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_primary_dns")

    @vlan_primary_dns.setter
    def vlan_primary_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_primary_dns", value)

    @property
    @pulumi.getter(name="vlanSecondaryDns")
    def vlan_secondary_dns(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_secondary_dns")

    @vlan_secondary_dns.setter
    def vlan_secondary_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_secondary_dns", value)

    @property
    @pulumi.getter(name="vlanSubnetMask")
    def vlan_subnet_mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_subnet_mask")

    @vlan_subnet_mask.setter
    def vlan_subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_subnet_mask", value)


if not MYPY:
    class NdbNetworkPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the vlan to be attached in NDB
        """
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbNetworkPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbNetworkPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the vlan to be attached in NDB
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the vlan to be attached in NDB
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbProfileClusterAvailabilityArgsDict(TypedDict):
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        nx_cluster_id: NotRequired[pulumi.Input[str]]
        """
        cluster on which profile created
        """
        owner_id: NotRequired[pulumi.Input[str]]
        profile_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of profile
        """
elif False:
    NdbProfileClusterAvailabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileClusterAvailabilityArgs:
    def __init__(__self__, *,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 nx_cluster_id: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 profile_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] nx_cluster_id: cluster on which profile created
        :param pulumi.Input[str] status: status of profile
        """
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if nx_cluster_id is not None:
            pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        cluster on which profile created
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of profile
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NdbProfileComputeProfileArgsDict(TypedDict):
        core_per_cpu: NotRequired[pulumi.Input[str]]
        """
        number of cores per vCPU for the database server VM.
        """
        cpus: NotRequired[pulumi.Input[str]]
        """
        number of vCPUs for the database server VM.
        """
        memory_size: NotRequired[pulumi.Input[str]]
        """
        amount of memory for the database server VM.
        """
elif False:
    NdbProfileComputeProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileComputeProfileArgs:
    def __init__(__self__, *,
                 core_per_cpu: Optional[pulumi.Input[str]] = None,
                 cpus: Optional[pulumi.Input[str]] = None,
                 memory_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] core_per_cpu: number of cores per vCPU for the database server VM.
        :param pulumi.Input[str] cpus: number of vCPUs for the database server VM.
        :param pulumi.Input[str] memory_size: amount of memory for the database server VM.
        """
        if core_per_cpu is not None:
            pulumi.set(__self__, "core_per_cpu", core_per_cpu)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)

    @property
    @pulumi.getter(name="corePerCpu")
    def core_per_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        number of cores per vCPU for the database server VM.
        """
        return pulumi.get(self, "core_per_cpu")

    @core_per_cpu.setter
    def core_per_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "core_per_cpu", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[str]]:
        """
        number of vCPUs for the database server VM.
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[pulumi.Input[str]]:
        """
        amount of memory for the database server VM.
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_size", value)


if not MYPY:
    class NdbProfileDatabaseParameterProfileArgsDict(TypedDict):
        postgres_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileDatabaseParameterProfilePostgresDatabaseArgsDict']]]]
        """
        Database parameters suuported for postgress.
        * `postgres_database.max_connections`: (Optional) Determines the maximum number of concurrent connections to the database server. The default is set to 100
        * `postgres_database.max_replication_slots`: (Optional) Specifies the maximum number of replication slots that the server can support. The default is zero. wal_level must be set to archive or higher to allow replication slots to be used. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting.
        * `postgres_database.effective_io_concurrency`: (Optional) Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel.
        * `postgres_database.timezone`: (Optional) Sets the time zone for displaying and interpreting time stamps. Defult is UTC .
        * `postgres_database.max_prepared_transactions`: (Optional) Sets the maximum number of transactions that can be in the prepared state simultaneously. Setting this parameter to zero (which is the default) disables the prepared-transaction feature.
        * `postgres_database.max_locks_per_transaction`: (Optional) This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. Default is 64.
        * `postgres_database.max_wal_senders`: (Optional) Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is 10.
        * `postgres_database.max_worker_processes`: (Optional) Sets the maximum number of background processes that the system can support. The default is 8.
        * `postgres_database.min_wal_size`: (Optional) As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB.
        * `postgres_database.max_wal_size`: (Optional) Maximum size to let the WAL grow to between automatic WAL checkpoints. The default is 1 GB
        * `postgres_database.checkpoint_timeout`: (Optional) Sets the maximum time between automatic WAL checkpoints . High Value gives Good Performance, but takes More Recovery Time, Reboot time. can reduce the I/O load on your system, especially when using large values for shared_buffers. Default is 5min
        * `postgres_database.autovacuum`: (Optional) Controls whether the server should run the autovacuum launcher daemon. This is on by default; however, track_counts must also be enabled for autovacuum to work.
        * `postgres_database.checkpoint_completion_target`: (Optional)
        Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval . Formula - (checkpoint_timeout - 2min) / checkpoint_timeout. The default is 0.5.
        * `postgres_database.autovacuum_freeze_max_age`: (Optional) Age at which to autovacuum a table to prevent transaction ID wraparound. Default is 200000000
        * `postgres_database.autovacuum_vacuum_threshold`: (Optional) Min number of row updates before vacuum. Minimum number of tuple updates or deletes prior to vacuum. Take value in KB. Default is 50 .
        * `postgres_database.autovacuum_vacuum_scale_factor`: (Optional) Number of tuple updates or deletes prior to vacuum as a fraction of reltuples. Default is 0.2
        * `postgres_database.autovacuum_work_mem`: (Optional) Sets the maximum memory to be used by each autovacuum worker process. Unit is in KB. Default is -1
        * `postgres_database.autovacuum_max_workers`: (Optional) Sets the maximum number of simultaneously running autovacuum worker processes. Default is 3
        * `postgres_database.autovacuum_vacuum_cost_delay`: (Optional) Vacuum cost delay in milliseconds, for autovacuum. Specifies the cost delay value that will be used in automatic VACUUM operation. Default is 2ms
        * `postgres_database.wal_buffers`: (Optional)
        Sets the number of disk-page buffers in shared memory for WAL. The amount of shared memory used for WAL data that has not yet been written to disk. The default is -1.
        * `postgres_database.synchronous_commit`: (Optional) Sets the current transaction's synchronization level. Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a success indication to the client. Default is on.
        * `postgres_database.random_page_cost`: (Optional) Sets the planner's estimate of the cost of a nonsequentially fetched disk page. Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0.
        * `postgres_database.wal_keep_segments`: (Optional) Sets the number of WAL files held for standby servers, Specifies the minimum number of past log file segments kept in the pg_wal directory. Default is 700 .
        """
elif False:
    NdbProfileDatabaseParameterProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileDatabaseParameterProfileArgs:
    def __init__(__self__, *,
                 postgres_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileDatabaseParameterProfilePostgresDatabaseArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NdbProfileDatabaseParameterProfilePostgresDatabaseArgs']]] postgres_databases: Database parameters suuported for postgress.
               * `postgres_database.max_connections`: (Optional) Determines the maximum number of concurrent connections to the database server. The default is set to 100
               * `postgres_database.max_replication_slots`: (Optional) Specifies the maximum number of replication slots that the server can support. The default is zero. wal_level must be set to archive or higher to allow replication slots to be used. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting.
               * `postgres_database.effective_io_concurrency`: (Optional) Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel.
               * `postgres_database.timezone`: (Optional) Sets the time zone for displaying and interpreting time stamps. Defult is UTC .
               * `postgres_database.max_prepared_transactions`: (Optional) Sets the maximum number of transactions that can be in the prepared state simultaneously. Setting this parameter to zero (which is the default) disables the prepared-transaction feature.
               * `postgres_database.max_locks_per_transaction`: (Optional) This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. Default is 64.
               * `postgres_database.max_wal_senders`: (Optional) Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is 10.
               * `postgres_database.max_worker_processes`: (Optional) Sets the maximum number of background processes that the system can support. The default is 8.
               * `postgres_database.min_wal_size`: (Optional) As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB.
               * `postgres_database.max_wal_size`: (Optional) Maximum size to let the WAL grow to between automatic WAL checkpoints. The default is 1 GB
               * `postgres_database.checkpoint_timeout`: (Optional) Sets the maximum time between automatic WAL checkpoints . High Value gives Good Performance, but takes More Recovery Time, Reboot time. can reduce the I/O load on your system, especially when using large values for shared_buffers. Default is 5min
               * `postgres_database.autovacuum`: (Optional) Controls whether the server should run the autovacuum launcher daemon. This is on by default; however, track_counts must also be enabled for autovacuum to work.
               * `postgres_database.checkpoint_completion_target`: (Optional)
               Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval . Formula - (checkpoint_timeout - 2min) / checkpoint_timeout. The default is 0.5.
               * `postgres_database.autovacuum_freeze_max_age`: (Optional) Age at which to autovacuum a table to prevent transaction ID wraparound. Default is 200000000
               * `postgres_database.autovacuum_vacuum_threshold`: (Optional) Min number of row updates before vacuum. Minimum number of tuple updates or deletes prior to vacuum. Take value in KB. Default is 50 .
               * `postgres_database.autovacuum_vacuum_scale_factor`: (Optional) Number of tuple updates or deletes prior to vacuum as a fraction of reltuples. Default is 0.2
               * `postgres_database.autovacuum_work_mem`: (Optional) Sets the maximum memory to be used by each autovacuum worker process. Unit is in KB. Default is -1
               * `postgres_database.autovacuum_max_workers`: (Optional) Sets the maximum number of simultaneously running autovacuum worker processes. Default is 3
               * `postgres_database.autovacuum_vacuum_cost_delay`: (Optional) Vacuum cost delay in milliseconds, for autovacuum. Specifies the cost delay value that will be used in automatic VACUUM operation. Default is 2ms
               * `postgres_database.wal_buffers`: (Optional)
               Sets the number of disk-page buffers in shared memory for WAL. The amount of shared memory used for WAL data that has not yet been written to disk. The default is -1.
               * `postgres_database.synchronous_commit`: (Optional) Sets the current transaction's synchronization level. Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a success indication to the client. Default is on.
               * `postgres_database.random_page_cost`: (Optional) Sets the planner's estimate of the cost of a nonsequentially fetched disk page. Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0.
               * `postgres_database.wal_keep_segments`: (Optional) Sets the number of WAL files held for standby servers, Specifies the minimum number of past log file segments kept in the pg_wal directory. Default is 700 .
        """
        if postgres_databases is not None:
            pulumi.set(__self__, "postgres_databases", postgres_databases)

    @property
    @pulumi.getter(name="postgresDatabases")
    def postgres_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileDatabaseParameterProfilePostgresDatabaseArgs']]]]:
        """
        Database parameters suuported for postgress.
        * `postgres_database.max_connections`: (Optional) Determines the maximum number of concurrent connections to the database server. The default is set to 100
        * `postgres_database.max_replication_slots`: (Optional) Specifies the maximum number of replication slots that the server can support. The default is zero. wal_level must be set to archive or higher to allow replication slots to be used. Setting it to a lower value than the number of currently existing replication slots will prevent the server from starting.
        * `postgres_database.effective_io_concurrency`: (Optional) Sets the number of concurrent disk I/O operations that PostgreSQL expects can be executed simultaneously. Raising this value will increase the number of I/O operations that any individual PostgreSQL session attempts to initiate in parallel.
        * `postgres_database.timezone`: (Optional) Sets the time zone for displaying and interpreting time stamps. Defult is UTC .
        * `postgres_database.max_prepared_transactions`: (Optional) Sets the maximum number of transactions that can be in the prepared state simultaneously. Setting this parameter to zero (which is the default) disables the prepared-transaction feature.
        * `postgres_database.max_locks_per_transaction`: (Optional) This parameter controls the average number of object locks allocated for each transaction; individual transactions can lock more objects as long as the locks of all transactions fit in the lock table. Default is 64.
        * `postgres_database.max_wal_senders`: (Optional) Specifies the maximum number of concurrent connections from standby servers or streaming base backup clients (i.e., the maximum number of simultaneously running WAL sender processes). The default is 10.
        * `postgres_database.max_worker_processes`: (Optional) Sets the maximum number of background processes that the system can support. The default is 8.
        * `postgres_database.min_wal_size`: (Optional) As long as WAL disk usage stays below this setting, old WAL files are always recycled for future use at a checkpoint, rather than removed. This can be used to ensure that enough WAL space is reserved to handle spikes in WAL usage, for example when running large batch jobs. The default is 80 MB.
        * `postgres_database.max_wal_size`: (Optional) Maximum size to let the WAL grow to between automatic WAL checkpoints. The default is 1 GB
        * `postgres_database.checkpoint_timeout`: (Optional) Sets the maximum time between automatic WAL checkpoints . High Value gives Good Performance, but takes More Recovery Time, Reboot time. can reduce the I/O load on your system, especially when using large values for shared_buffers. Default is 5min
        * `postgres_database.autovacuum`: (Optional) Controls whether the server should run the autovacuum launcher daemon. This is on by default; however, track_counts must also be enabled for autovacuum to work.
        * `postgres_database.checkpoint_completion_target`: (Optional)
        Specifies the target of checkpoint completion, as a fraction of total time between checkpoints. Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval . Formula - (checkpoint_timeout - 2min) / checkpoint_timeout. The default is 0.5.
        * `postgres_database.autovacuum_freeze_max_age`: (Optional) Age at which to autovacuum a table to prevent transaction ID wraparound. Default is 200000000
        * `postgres_database.autovacuum_vacuum_threshold`: (Optional) Min number of row updates before vacuum. Minimum number of tuple updates or deletes prior to vacuum. Take value in KB. Default is 50 .
        * `postgres_database.autovacuum_vacuum_scale_factor`: (Optional) Number of tuple updates or deletes prior to vacuum as a fraction of reltuples. Default is 0.2
        * `postgres_database.autovacuum_work_mem`: (Optional) Sets the maximum memory to be used by each autovacuum worker process. Unit is in KB. Default is -1
        * `postgres_database.autovacuum_max_workers`: (Optional) Sets the maximum number of simultaneously running autovacuum worker processes. Default is 3
        * `postgres_database.autovacuum_vacuum_cost_delay`: (Optional) Vacuum cost delay in milliseconds, for autovacuum. Specifies the cost delay value that will be used in automatic VACUUM operation. Default is 2ms
        * `postgres_database.wal_buffers`: (Optional)
        Sets the number of disk-page buffers in shared memory for WAL. The amount of shared memory used for WAL data that has not yet been written to disk. The default is -1.
        * `postgres_database.synchronous_commit`: (Optional) Sets the current transaction's synchronization level. Specifies whether transaction commit will wait for WAL records to be written to disk before the command returns a success indication to the client. Default is on.
        * `postgres_database.random_page_cost`: (Optional) Sets the planner's estimate of the cost of a nonsequentially fetched disk page. Sets the planner's estimate of the cost of a non-sequentially-fetched disk page. The default is 4.0.
        * `postgres_database.wal_keep_segments`: (Optional) Sets the number of WAL files held for standby servers, Specifies the minimum number of past log file segments kept in the pg_wal directory. Default is 700 .
        """
        return pulumi.get(self, "postgres_databases")

    @postgres_databases.setter
    def postgres_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileDatabaseParameterProfilePostgresDatabaseArgs']]]]):
        pulumi.set(self, "postgres_databases", value)


if not MYPY:
    class NdbProfileDatabaseParameterProfilePostgresDatabaseArgsDict(TypedDict):
        autovacuum: NotRequired[pulumi.Input[str]]
        autovacuum_freeze_max_age: NotRequired[pulumi.Input[str]]
        autovacuum_max_workers: NotRequired[pulumi.Input[str]]
        autovacuum_vacuum_cost_delay: NotRequired[pulumi.Input[str]]
        autovacuum_vacuum_scale_factor: NotRequired[pulumi.Input[str]]
        autovacuum_vacuum_threshold: NotRequired[pulumi.Input[str]]
        autovacuum_work_mem: NotRequired[pulumi.Input[str]]
        checkpoint_completion_target: NotRequired[pulumi.Input[str]]
        checkpoint_timeout: NotRequired[pulumi.Input[str]]
        effective_io_concurrency: NotRequired[pulumi.Input[str]]
        max_connections: NotRequired[pulumi.Input[str]]
        max_locks_per_transaction: NotRequired[pulumi.Input[str]]
        max_prepared_transactions: NotRequired[pulumi.Input[str]]
        max_replication_slots: NotRequired[pulumi.Input[str]]
        max_wal_senders: NotRequired[pulumi.Input[str]]
        max_wal_size: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        min_wal_size: NotRequired[pulumi.Input[str]]
        random_page_cost: NotRequired[pulumi.Input[str]]
        synchronous_commit: NotRequired[pulumi.Input[str]]
        timezone: NotRequired[pulumi.Input[str]]
        wal_buffers: NotRequired[pulumi.Input[str]]
        wal_keep_segments: NotRequired[pulumi.Input[str]]
elif False:
    NdbProfileDatabaseParameterProfilePostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileDatabaseParameterProfilePostgresDatabaseArgs:
    def __init__(__self__, *,
                 autovacuum: Optional[pulumi.Input[str]] = None,
                 autovacuum_freeze_max_age: Optional[pulumi.Input[str]] = None,
                 autovacuum_max_workers: Optional[pulumi.Input[str]] = None,
                 autovacuum_vacuum_cost_delay: Optional[pulumi.Input[str]] = None,
                 autovacuum_vacuum_scale_factor: Optional[pulumi.Input[str]] = None,
                 autovacuum_vacuum_threshold: Optional[pulumi.Input[str]] = None,
                 autovacuum_work_mem: Optional[pulumi.Input[str]] = None,
                 checkpoint_completion_target: Optional[pulumi.Input[str]] = None,
                 checkpoint_timeout: Optional[pulumi.Input[str]] = None,
                 effective_io_concurrency: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[str]] = None,
                 max_locks_per_transaction: Optional[pulumi.Input[str]] = None,
                 max_prepared_transactions: Optional[pulumi.Input[str]] = None,
                 max_replication_slots: Optional[pulumi.Input[str]] = None,
                 max_wal_senders: Optional[pulumi.Input[str]] = None,
                 max_wal_size: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 min_wal_size: Optional[pulumi.Input[str]] = None,
                 random_page_cost: Optional[pulumi.Input[str]] = None,
                 synchronous_commit: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 wal_buffers: Optional[pulumi.Input[str]] = None,
                 wal_keep_segments: Optional[pulumi.Input[str]] = None):
        if autovacuum is not None:
            pulumi.set(__self__, "autovacuum", autovacuum)
        if autovacuum_freeze_max_age is not None:
            pulumi.set(__self__, "autovacuum_freeze_max_age", autovacuum_freeze_max_age)
        if autovacuum_max_workers is not None:
            pulumi.set(__self__, "autovacuum_max_workers", autovacuum_max_workers)
        if autovacuum_vacuum_cost_delay is not None:
            pulumi.set(__self__, "autovacuum_vacuum_cost_delay", autovacuum_vacuum_cost_delay)
        if autovacuum_vacuum_scale_factor is not None:
            pulumi.set(__self__, "autovacuum_vacuum_scale_factor", autovacuum_vacuum_scale_factor)
        if autovacuum_vacuum_threshold is not None:
            pulumi.set(__self__, "autovacuum_vacuum_threshold", autovacuum_vacuum_threshold)
        if autovacuum_work_mem is not None:
            pulumi.set(__self__, "autovacuum_work_mem", autovacuum_work_mem)
        if checkpoint_completion_target is not None:
            pulumi.set(__self__, "checkpoint_completion_target", checkpoint_completion_target)
        if checkpoint_timeout is not None:
            pulumi.set(__self__, "checkpoint_timeout", checkpoint_timeout)
        if effective_io_concurrency is not None:
            pulumi.set(__self__, "effective_io_concurrency", effective_io_concurrency)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_locks_per_transaction is not None:
            pulumi.set(__self__, "max_locks_per_transaction", max_locks_per_transaction)
        if max_prepared_transactions is not None:
            pulumi.set(__self__, "max_prepared_transactions", max_prepared_transactions)
        if max_replication_slots is not None:
            pulumi.set(__self__, "max_replication_slots", max_replication_slots)
        if max_wal_senders is not None:
            pulumi.set(__self__, "max_wal_senders", max_wal_senders)
        if max_wal_size is not None:
            pulumi.set(__self__, "max_wal_size", max_wal_size)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if min_wal_size is not None:
            pulumi.set(__self__, "min_wal_size", min_wal_size)
        if random_page_cost is not None:
            pulumi.set(__self__, "random_page_cost", random_page_cost)
        if synchronous_commit is not None:
            pulumi.set(__self__, "synchronous_commit", synchronous_commit)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if wal_buffers is not None:
            pulumi.set(__self__, "wal_buffers", wal_buffers)
        if wal_keep_segments is not None:
            pulumi.set(__self__, "wal_keep_segments", wal_keep_segments)

    @property
    @pulumi.getter
    def autovacuum(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum")

    @autovacuum.setter
    def autovacuum(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum", value)

    @property
    @pulumi.getter(name="autovacuumFreezeMaxAge")
    def autovacuum_freeze_max_age(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_freeze_max_age")

    @autovacuum_freeze_max_age.setter
    def autovacuum_freeze_max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_freeze_max_age", value)

    @property
    @pulumi.getter(name="autovacuumMaxWorkers")
    def autovacuum_max_workers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_max_workers")

    @autovacuum_max_workers.setter
    def autovacuum_max_workers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_max_workers", value)

    @property
    @pulumi.getter(name="autovacuumVacuumCostDelay")
    def autovacuum_vacuum_cost_delay(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_vacuum_cost_delay")

    @autovacuum_vacuum_cost_delay.setter
    def autovacuum_vacuum_cost_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_vacuum_cost_delay", value)

    @property
    @pulumi.getter(name="autovacuumVacuumScaleFactor")
    def autovacuum_vacuum_scale_factor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_vacuum_scale_factor")

    @autovacuum_vacuum_scale_factor.setter
    def autovacuum_vacuum_scale_factor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_vacuum_scale_factor", value)

    @property
    @pulumi.getter(name="autovacuumVacuumThreshold")
    def autovacuum_vacuum_threshold(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_vacuum_threshold")

    @autovacuum_vacuum_threshold.setter
    def autovacuum_vacuum_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_vacuum_threshold", value)

    @property
    @pulumi.getter(name="autovacuumWorkMem")
    def autovacuum_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autovacuum_work_mem")

    @autovacuum_work_mem.setter
    def autovacuum_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autovacuum_work_mem", value)

    @property
    @pulumi.getter(name="checkpointCompletionTarget")
    def checkpoint_completion_target(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "checkpoint_completion_target")

    @checkpoint_completion_target.setter
    def checkpoint_completion_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "checkpoint_completion_target", value)

    @property
    @pulumi.getter(name="checkpointTimeout")
    def checkpoint_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "checkpoint_timeout")

    @checkpoint_timeout.setter
    def checkpoint_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "checkpoint_timeout", value)

    @property
    @pulumi.getter(name="effectiveIoConcurrency")
    def effective_io_concurrency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_io_concurrency")

    @effective_io_concurrency.setter
    def effective_io_concurrency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_io_concurrency", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxLocksPerTransaction")
    def max_locks_per_transaction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_locks_per_transaction")

    @max_locks_per_transaction.setter
    def max_locks_per_transaction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_locks_per_transaction", value)

    @property
    @pulumi.getter(name="maxPreparedTransactions")
    def max_prepared_transactions(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_prepared_transactions")

    @max_prepared_transactions.setter
    def max_prepared_transactions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_prepared_transactions", value)

    @property
    @pulumi.getter(name="maxReplicationSlots")
    def max_replication_slots(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_replication_slots")

    @max_replication_slots.setter
    def max_replication_slots(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_replication_slots", value)

    @property
    @pulumi.getter(name="maxWalSenders")
    def max_wal_senders(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_wal_senders")

    @max_wal_senders.setter
    def max_wal_senders(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_wal_senders", value)

    @property
    @pulumi.getter(name="maxWalSize")
    def max_wal_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_wal_size")

    @max_wal_size.setter
    def max_wal_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_wal_size", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="minWalSize")
    def min_wal_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_wal_size")

    @min_wal_size.setter
    def min_wal_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_wal_size", value)

    @property
    @pulumi.getter(name="randomPageCost")
    def random_page_cost(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "random_page_cost")

    @random_page_cost.setter
    def random_page_cost(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "random_page_cost", value)

    @property
    @pulumi.getter(name="synchronousCommit")
    def synchronous_commit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "synchronous_commit")

    @synchronous_commit.setter
    def synchronous_commit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "synchronous_commit", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="walBuffers")
    def wal_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "wal_buffers")

    @wal_buffers.setter
    def wal_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wal_buffers", value)

    @property
    @pulumi.getter(name="walKeepSegments")
    def wal_keep_segments(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "wal_keep_segments")

    @wal_keep_segments.setter
    def wal_keep_segments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "wal_keep_segments", value)


if not MYPY:
    class NdbProfileNetworkProfileArgsDict(TypedDict):
        topology: pulumi.Input[str]
        """
        Topology supported for network profile. Allowed values are "cluster" and "single"
        """
        postgres_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseArgsDict']]]]
        """
        Postgres Info to create network profile

        * `postgres_database.single_instance`: (Optional) Info for postgres database to create single instance network profile.
        * `postgres_database.single_instance.vlan_name`: (Required) specify the VLAN to provide the IP address used to connect the database from the public network.
        * `postgres_database.single_instance.enable_ip_address_selection`: (Optional) If Advanced Network Segmentation is enabled, then this vLAN needs to be a static vLAN and needs to be true.

        * `postgres_database.ha_instance`: (Optional) Info for craeting Network profile for HA instance
        * `postgres_database.ha_instance.vlan_name`: (Required) specify the VLANs for network
        * `postgres_database.ha_instance.cluster_name`: (Required) specify the cluster name associated with given VLANs
        * `postgres_database.ha_instance.cluster_id`: (Optional) specify the cluster ids associated with given VLANs
        * `postgres_database.ha_instance.num_of_clusters`: (Required) number of cluster attached to network profile
        """
        version_cluster_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfileVersionClusterAssociationArgsDict']]]]
        """
        cluster associated with VLAN. this is used with Single instance for postgres database.
        * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
elif False:
    NdbProfileNetworkProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileNetworkProfileArgs:
    def __init__(__self__, *,
                 topology: pulumi.Input[str],
                 postgres_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseArgs']]]] = None,
                 version_cluster_associations: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfileVersionClusterAssociationArgs']]]] = None):
        """
        :param pulumi.Input[str] topology: Topology supported for network profile. Allowed values are "cluster" and "single"
        :param pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseArgs']]] postgres_databases: Postgres Info to create network profile
               
               * `postgres_database.single_instance`: (Optional) Info for postgres database to create single instance network profile.
               * `postgres_database.single_instance.vlan_name`: (Required) specify the VLAN to provide the IP address used to connect the database from the public network.
               * `postgres_database.single_instance.enable_ip_address_selection`: (Optional) If Advanced Network Segmentation is enabled, then this vLAN needs to be a static vLAN and needs to be true.
               
               * `postgres_database.ha_instance`: (Optional) Info for craeting Network profile for HA instance
               * `postgres_database.ha_instance.vlan_name`: (Required) specify the VLANs for network
               * `postgres_database.ha_instance.cluster_name`: (Required) specify the cluster name associated with given VLANs
               * `postgres_database.ha_instance.cluster_id`: (Optional) specify the cluster ids associated with given VLANs
               * `postgres_database.ha_instance.num_of_clusters`: (Required) number of cluster attached to network profile
        :param pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfileVersionClusterAssociationArgs']]] version_cluster_associations: cluster associated with VLAN. this is used with Single instance for postgres database.
               * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
        pulumi.set(__self__, "topology", topology)
        if postgres_databases is not None:
            pulumi.set(__self__, "postgres_databases", postgres_databases)
        if version_cluster_associations is not None:
            pulumi.set(__self__, "version_cluster_associations", version_cluster_associations)

    @property
    @pulumi.getter
    def topology(self) -> pulumi.Input[str]:
        """
        Topology supported for network profile. Allowed values are "cluster" and "single"
        """
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology", value)

    @property
    @pulumi.getter(name="postgresDatabases")
    def postgres_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseArgs']]]]:
        """
        Postgres Info to create network profile

        * `postgres_database.single_instance`: (Optional) Info for postgres database to create single instance network profile.
        * `postgres_database.single_instance.vlan_name`: (Required) specify the VLAN to provide the IP address used to connect the database from the public network.
        * `postgres_database.single_instance.enable_ip_address_selection`: (Optional) If Advanced Network Segmentation is enabled, then this vLAN needs to be a static vLAN and needs to be true.

        * `postgres_database.ha_instance`: (Optional) Info for craeting Network profile for HA instance
        * `postgres_database.ha_instance.vlan_name`: (Required) specify the VLANs for network
        * `postgres_database.ha_instance.cluster_name`: (Required) specify the cluster name associated with given VLANs
        * `postgres_database.ha_instance.cluster_id`: (Optional) specify the cluster ids associated with given VLANs
        * `postgres_database.ha_instance.num_of_clusters`: (Required) number of cluster attached to network profile
        """
        return pulumi.get(self, "postgres_databases")

    @postgres_databases.setter
    def postgres_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseArgs']]]]):
        pulumi.set(self, "postgres_databases", value)

    @property
    @pulumi.getter(name="versionClusterAssociations")
    def version_cluster_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfileVersionClusterAssociationArgs']]]]:
        """
        cluster associated with VLAN. this is used with Single instance for postgres database.
        * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
        return pulumi.get(self, "version_cluster_associations")

    @version_cluster_associations.setter
    def version_cluster_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfileVersionClusterAssociationArgs']]]]):
        pulumi.set(self, "version_cluster_associations", value)


if not MYPY:
    class NdbProfileNetworkProfilePostgresDatabaseArgsDict(TypedDict):
        ha_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgsDict']]]]
        single_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgsDict']]]]
elif False:
    NdbProfileNetworkProfilePostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileNetworkProfilePostgresDatabaseArgs:
    def __init__(__self__, *,
                 ha_instances: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgs']]]] = None,
                 single_instances: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgs']]]] = None):
        if ha_instances is not None:
            pulumi.set(__self__, "ha_instances", ha_instances)
        if single_instances is not None:
            pulumi.set(__self__, "single_instances", single_instances)

    @property
    @pulumi.getter(name="haInstances")
    def ha_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgs']]]]:
        return pulumi.get(self, "ha_instances")

    @ha_instances.setter
    def ha_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgs']]]]):
        pulumi.set(self, "ha_instances", value)

    @property
    @pulumi.getter(name="singleInstances")
    def single_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgs']]]]:
        return pulumi.get(self, "single_instances")

    @single_instances.setter
    def single_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgs']]]]):
        pulumi.set(self, "single_instances", value)


if not MYPY:
    class NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgsDict(TypedDict):
        cluster_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cluster_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        num_of_clusters: NotRequired[pulumi.Input[str]]
        vlan_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileNetworkProfilePostgresDatabaseHaInstanceArgs:
    def __init__(__self__, *,
                 cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cluster_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 num_of_clusters: Optional[pulumi.Input[str]] = None,
                 vlan_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if cluster_ids is not None:
            pulumi.set(__self__, "cluster_ids", cluster_ids)
        if cluster_names is not None:
            pulumi.set(__self__, "cluster_names", cluster_names)
        if num_of_clusters is not None:
            pulumi.set(__self__, "num_of_clusters", num_of_clusters)
        if vlan_names is not None:
            pulumi.set(__self__, "vlan_names", vlan_names)

    @property
    @pulumi.getter(name="clusterIds")
    def cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "cluster_ids")

    @cluster_ids.setter
    def cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_ids", value)

    @property
    @pulumi.getter(name="clusterNames")
    def cluster_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "cluster_names")

    @cluster_names.setter
    def cluster_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cluster_names", value)

    @property
    @pulumi.getter(name="numOfClusters")
    def num_of_clusters(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "num_of_clusters")

    @num_of_clusters.setter
    def num_of_clusters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "num_of_clusters", value)

    @property
    @pulumi.getter(name="vlanNames")
    def vlan_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "vlan_names")

    @vlan_names.setter
    def vlan_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vlan_names", value)


if not MYPY:
    class NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgsDict(TypedDict):
        enable_ip_address_selection: NotRequired[pulumi.Input[str]]
        vlan_name: NotRequired[pulumi.Input[str]]
elif False:
    NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileNetworkProfilePostgresDatabaseSingleInstanceArgs:
    def __init__(__self__, *,
                 enable_ip_address_selection: Optional[pulumi.Input[str]] = None,
                 vlan_name: Optional[pulumi.Input[str]] = None):
        if enable_ip_address_selection is not None:
            pulumi.set(__self__, "enable_ip_address_selection", enable_ip_address_selection)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="enableIpAddressSelection")
    def enable_ip_address_selection(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "enable_ip_address_selection")

    @enable_ip_address_selection.setter
    def enable_ip_address_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_ip_address_selection", value)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_name")

    @vlan_name.setter
    def vlan_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_name", value)


if not MYPY:
    class NdbProfileNetworkProfileVersionClusterAssociationArgsDict(TypedDict):
        nx_cluster_id: pulumi.Input[str]
        """
        cluster on which profile created
        """
elif False:
    NdbProfileNetworkProfileVersionClusterAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileNetworkProfileVersionClusterAssociationArgs:
    def __init__(__self__, *,
                 nx_cluster_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] nx_cluster_id: cluster on which profile created
        """
        pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> pulumi.Input[str]:
        """
        cluster on which profile created
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "nx_cluster_id", value)


if not MYPY:
    class NdbProfileSoftwareProfileArgsDict(TypedDict):
        topology: pulumi.Input[str]
        """
        Topology of software profile. Allowed values are "cluster" and "single"
        """
        available_cluster_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        specify Nutanix clusters where this profile is available.
        """
        postgres_databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileSoftwareProfilePostgresDatabaseArgsDict']]]]
        """
        Software profile info about postgres database.
        * `postgres_database.source_dbserver_id`: source dbserver id where postgress software will be installed.
        * `postgres_database.base_profile_version_name`: name for the software profile version.
        * `postgres_database.base_profile_version_description`: description for the software profile version.
        * `postgres_database.os_notes`: a note to provide additional information about the operating system
        * `postgres_database.db_software_notes`: a note to provide additional information about the database software.
        """
elif False:
    NdbProfileSoftwareProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileSoftwareProfileArgs:
    def __init__(__self__, *,
                 topology: pulumi.Input[str],
                 available_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 postgres_databases: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileSoftwareProfilePostgresDatabaseArgs']]]] = None):
        """
        :param pulumi.Input[str] topology: Topology of software profile. Allowed values are "cluster" and "single"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] available_cluster_ids: specify Nutanix clusters where this profile is available.
        :param pulumi.Input[Sequence[pulumi.Input['NdbProfileSoftwareProfilePostgresDatabaseArgs']]] postgres_databases: Software profile info about postgres database.
               * `postgres_database.source_dbserver_id`: source dbserver id where postgress software will be installed.
               * `postgres_database.base_profile_version_name`: name for the software profile version.
               * `postgres_database.base_profile_version_description`: description for the software profile version.
               * `postgres_database.os_notes`: a note to provide additional information about the operating system
               * `postgres_database.db_software_notes`: a note to provide additional information about the database software.
        """
        pulumi.set(__self__, "topology", topology)
        if available_cluster_ids is not None:
            pulumi.set(__self__, "available_cluster_ids", available_cluster_ids)
        if postgres_databases is not None:
            pulumi.set(__self__, "postgres_databases", postgres_databases)

    @property
    @pulumi.getter
    def topology(self) -> pulumi.Input[str]:
        """
        Topology of software profile. Allowed values are "cluster" and "single"
        """
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: pulumi.Input[str]):
        pulumi.set(self, "topology", value)

    @property
    @pulumi.getter(name="availableClusterIds")
    def available_cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        specify Nutanix clusters where this profile is available.
        """
        return pulumi.get(self, "available_cluster_ids")

    @available_cluster_ids.setter
    def available_cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "available_cluster_ids", value)

    @property
    @pulumi.getter(name="postgresDatabases")
    def postgres_databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileSoftwareProfilePostgresDatabaseArgs']]]]:
        """
        Software profile info about postgres database.
        * `postgres_database.source_dbserver_id`: source dbserver id where postgress software will be installed.
        * `postgres_database.base_profile_version_name`: name for the software profile version.
        * `postgres_database.base_profile_version_description`: description for the software profile version.
        * `postgres_database.os_notes`: a note to provide additional information about the operating system
        * `postgres_database.db_software_notes`: a note to provide additional information about the database software.
        """
        return pulumi.get(self, "postgres_databases")

    @postgres_databases.setter
    def postgres_databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileSoftwareProfilePostgresDatabaseArgs']]]]):
        pulumi.set(self, "postgres_databases", value)


if not MYPY:
    class NdbProfileSoftwareProfilePostgresDatabaseArgsDict(TypedDict):
        base_profile_version_description: NotRequired[pulumi.Input[str]]
        base_profile_version_name: NotRequired[pulumi.Input[str]]
        db_software_notes: NotRequired[pulumi.Input[str]]
        os_notes: NotRequired[pulumi.Input[str]]
        source_dbserver_id: NotRequired[pulumi.Input[str]]
elif False:
    NdbProfileSoftwareProfilePostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileSoftwareProfilePostgresDatabaseArgs:
    def __init__(__self__, *,
                 base_profile_version_description: Optional[pulumi.Input[str]] = None,
                 base_profile_version_name: Optional[pulumi.Input[str]] = None,
                 db_software_notes: Optional[pulumi.Input[str]] = None,
                 os_notes: Optional[pulumi.Input[str]] = None,
                 source_dbserver_id: Optional[pulumi.Input[str]] = None):
        if base_profile_version_description is not None:
            pulumi.set(__self__, "base_profile_version_description", base_profile_version_description)
        if base_profile_version_name is not None:
            pulumi.set(__self__, "base_profile_version_name", base_profile_version_name)
        if db_software_notes is not None:
            pulumi.set(__self__, "db_software_notes", db_software_notes)
        if os_notes is not None:
            pulumi.set(__self__, "os_notes", os_notes)
        if source_dbserver_id is not None:
            pulumi.set(__self__, "source_dbserver_id", source_dbserver_id)

    @property
    @pulumi.getter(name="baseProfileVersionDescription")
    def base_profile_version_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_profile_version_description")

    @base_profile_version_description.setter
    def base_profile_version_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_profile_version_description", value)

    @property
    @pulumi.getter(name="baseProfileVersionName")
    def base_profile_version_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "base_profile_version_name")

    @base_profile_version_name.setter
    def base_profile_version_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_profile_version_name", value)

    @property
    @pulumi.getter(name="dbSoftwareNotes")
    def db_software_notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_software_notes")

    @db_software_notes.setter
    def db_software_notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_software_notes", value)

    @property
    @pulumi.getter(name="osNotes")
    def os_notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "os_notes")

    @os_notes.setter
    def os_notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_notes", value)

    @property
    @pulumi.getter(name="sourceDbserverId")
    def source_dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_dbserver_id")

    @source_dbserver_id.setter
    def source_dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dbserver_id", value)


if not MYPY:
    class NdbProfileVersionArgsDict(TypedDict):
        db_version: NotRequired[pulumi.Input[str]]
        deprecated: NotRequired[pulumi.Input[bool]]
        description: NotRequired[pulumi.Input[str]]
        """
        Description of profile
        """
        engine_type: NotRequired[pulumi.Input[str]]
        """
        Engine Type of database
        """
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of profile
        """
        owner: NotRequired[pulumi.Input[str]]
        """
        owner  of profile
        """
        profile_id: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionPropertyArgsDict']]]]
        properties_map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        published: NotRequired[pulumi.Input[bool]]
        """
        Publish for all users
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of profile
        """
        system_profile: NotRequired[pulumi.Input[bool]]
        topology: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
        version: NotRequired[pulumi.Input[str]]
        version_cluster_associations: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationArgsDict']]]]
        """
        cluster associated with VLAN. this is used with Single instance for postgres database.
        * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
elif False:
    NdbProfileVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileVersionArgs:
    def __init__(__self__, *,
                 db_version: Optional[pulumi.Input[str]] = None,
                 deprecated: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 engine_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 profile_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionPropertyArgs']]]] = None,
                 properties_map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 published: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 system_profile: Optional[pulumi.Input[bool]] = None,
                 topology: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None,
                 version_cluster_associations: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationArgs']]]] = None):
        """
        :param pulumi.Input[str] description: Description of profile
        :param pulumi.Input[str] engine_type: Engine Type of database
        :param pulumi.Input[str] name: Name of profile
        :param pulumi.Input[str] owner: owner  of profile
        :param pulumi.Input[bool] published: Publish for all users
        :param pulumi.Input[str] status: status of profile
        :param pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationArgs']]] version_cluster_associations: cluster associated with VLAN. this is used with Single instance for postgres database.
               * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if deprecated is not None:
            pulumi.set(__self__, "deprecated", deprecated)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_type is not None:
            pulumi.set(__self__, "engine_type", engine_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if properties_map is not None:
            pulumi.set(__self__, "properties_map", properties_map)
        if published is not None:
            pulumi.set(__self__, "published", published)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if system_profile is not None:
            pulumi.set(__self__, "system_profile", system_profile)
        if topology is not None:
            pulumi.set(__self__, "topology", topology)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if version_cluster_associations is not None:
            pulumi.set(__self__, "version_cluster_associations", version_cluster_associations)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter
    def deprecated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "deprecated")

    @deprecated.setter
    def deprecated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deprecated", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of profile
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="engineType")
    def engine_type(self) -> Optional[pulumi.Input[str]]:
        """
        Engine Type of database
        """
        return pulumi.get(self, "engine_type")

    @engine_type.setter
    def engine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        owner  of profile
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionPropertyArgs']]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="propertiesMap")
    def properties_map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "properties_map")

    @properties_map.setter
    def properties_map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties_map", value)

    @property
    @pulumi.getter
    def published(self) -> Optional[pulumi.Input[bool]]:
        """
        Publish for all users
        """
        return pulumi.get(self, "published")

    @published.setter
    def published(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "published", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of profile
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="systemProfile")
    def system_profile(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_profile")

    @system_profile.setter
    def system_profile(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_profile", value)

    @property
    @pulumi.getter
    def topology(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "topology")

    @topology.setter
    def topology(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topology", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="versionClusterAssociations")
    def version_cluster_associations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationArgs']]]]:
        """
        cluster associated with VLAN. this is used with Single instance for postgres database.
        * `version_cluster_association.nx_cluster_id`: (Required) cluster id for associated VLAN.
        """
        return pulumi.get(self, "version_cluster_associations")

    @version_cluster_associations.setter
    def version_cluster_associations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationArgs']]]]):
        pulumi.set(self, "version_cluster_associations", value)


if not MYPY:
    class NdbProfileVersionPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of profile
        """
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbProfileVersionPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileVersionPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of profile
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbProfileVersionVersionClusterAssociationArgsDict(TypedDict):
        date_created: NotRequired[pulumi.Input[str]]
        date_modified: NotRequired[pulumi.Input[str]]
        nx_cluster_id: NotRequired[pulumi.Input[str]]
        """
        cluster on which profile created
        """
        optimized_for_provisioning: NotRequired[pulumi.Input[bool]]
        owner_id: NotRequired[pulumi.Input[str]]
        profile_version_id: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationPropertyArgsDict']]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of profile
        """
elif False:
    NdbProfileVersionVersionClusterAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileVersionVersionClusterAssociationArgs:
    def __init__(__self__, *,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 nx_cluster_id: Optional[pulumi.Input[str]] = None,
                 optimized_for_provisioning: Optional[pulumi.Input[bool]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 profile_version_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] nx_cluster_id: cluster on which profile created
        :param pulumi.Input[str] status: status of profile
        """
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if nx_cluster_id is not None:
            pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if optimized_for_provisioning is not None:
            pulumi.set(__self__, "optimized_for_provisioning", optimized_for_provisioning)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if profile_version_id is not None:
            pulumi.set(__self__, "profile_version_id", profile_version_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        cluster on which profile created
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter(name="optimizedForProvisioning")
    def optimized_for_provisioning(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "optimized_for_provisioning")

    @optimized_for_provisioning.setter
    def optimized_for_provisioning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optimized_for_provisioning", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="profileVersionId")
    def profile_version_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "profile_version_id")

    @profile_version_id.setter
    def profile_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_version_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationPropertyArgs']]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbProfileVersionVersionClusterAssociationPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of profile
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NdbProfileVersionVersionClusterAssociationPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of profile
        """
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbProfileVersionVersionClusterAssociationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbProfileVersionVersionClusterAssociationPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of profile
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseActionargumentArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) name of argument
        """
        value: pulumi.Input[str]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseActionargumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseActionargumentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: - (Required) name of argument
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) name of argument
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        """
        status of database
        """
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeInfoArgsDict']]]]
        """
        info of instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodePropertyArgsDict']]]]
        """
        properties of database created
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeTagArgsDict']]]]
        """
        tags
        """
elif False:
    NdbRegisterDatabaseDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] database_status: status of database
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeInfoArgs']]] infos: info of instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeTagArgs']]] tags: tags
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        """
        status of database
        """
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeTagArgs']]]]:
        """
        tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbRegisterDatabaseDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        properties of database created
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbRegisterDatabaseDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[str] type: type of database
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbRegisterDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbRegisterDatabaseInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbRegisterDatabaseInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbRegisterDatabaseLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbRegisterDatabaseLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbRegisterDatabaseLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbRegisterDatabaseLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] delete_time_machine: - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) Delete the database's Time Machine (snapshots/logs) from the NDB. Default value is true
        """
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbRegisterDatabaseLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbRegisterDatabaseLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbRegisterDatabaseLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbRegisterDatabaseLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        """
        name of database
        """
        database_status: NotRequired[pulumi.Input[str]]
        """
        status of database
        """
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLinkedDatabaseInfoArgsDict']]]]
        """
        info of instance
        """
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        """
        parent database id
        """
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: name of database
        :param pulumi.Input[str] database_status: status of database
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLinkedDatabaseInfoArgs']]] infos: info of instance
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] parent_database_id: parent database id
        :param pulumi.Input[str] status: status of instance
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of database
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        """
        status of database
        """
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLinkedDatabaseInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        """
        parent database id
        """
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbRegisterDatabaseLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbRegisterDatabaseLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbRegisterDatabasePostgressInfoArgsDict(TypedDict):
        db_name: pulumi.Input[str]
        """
        name of the database server VM on which the instance you want to register is running.
        """
        db_password: pulumi.Input[str]
        """
        database password
        """
        listener_port: pulumi.Input[str]
        """
        listner port of database
        """
        postgres_software_home: pulumi.Input[str]
        """
        path to the PostgreSQL home directory in which the PostgreSQL software is installed.
        """
        allow_multiple_databases: NotRequired[pulumi.Input[bool]]
        """
        allow multiple databases. Default is true
        """
        backup_policy: NotRequired[pulumi.Input[str]]
        """
        backup policy of database. Default is prefer_secondary.
        """
        db_user: NotRequired[pulumi.Input[str]]
        """
        username of the NDB drive user account that has sudo access.
        """
        software_home: NotRequired[pulumi.Input[str]]
        """
        path to the directory in which the PostgreSQL software is installed.
        """
        switch_log: NotRequired[pulumi.Input[bool]]
        """
        switch log of database. Default is true
        """
        vm_ip: NotRequired[pulumi.Input[str]]
        """
        VM IP of the database server VM on which the instance you want to register is running.
        """
elif False:
    NdbRegisterDatabasePostgressInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabasePostgressInfoArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 db_password: pulumi.Input[str],
                 listener_port: pulumi.Input[str],
                 postgres_software_home: pulumi.Input[str],
                 allow_multiple_databases: Optional[pulumi.Input[bool]] = None,
                 backup_policy: Optional[pulumi.Input[str]] = None,
                 db_user: Optional[pulumi.Input[str]] = None,
                 software_home: Optional[pulumi.Input[str]] = None,
                 switch_log: Optional[pulumi.Input[bool]] = None,
                 vm_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: name of the database server VM on which the instance you want to register is running.
        :param pulumi.Input[str] db_password: database password
        :param pulumi.Input[str] listener_port: listner port of database
        :param pulumi.Input[str] postgres_software_home: path to the PostgreSQL home directory in which the PostgreSQL software is installed.
        :param pulumi.Input[bool] allow_multiple_databases: allow multiple databases. Default is true
        :param pulumi.Input[str] backup_policy: backup policy of database. Default is prefer_secondary.
        :param pulumi.Input[str] db_user: username of the NDB drive user account that has sudo access.
        :param pulumi.Input[str] software_home: path to the directory in which the PostgreSQL software is installed.
        :param pulumi.Input[bool] switch_log: switch log of database. Default is true
        :param pulumi.Input[str] vm_ip: VM IP of the database server VM on which the instance you want to register is running.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "db_password", db_password)
        pulumi.set(__self__, "listener_port", listener_port)
        pulumi.set(__self__, "postgres_software_home", postgres_software_home)
        if allow_multiple_databases is not None:
            pulumi.set(__self__, "allow_multiple_databases", allow_multiple_databases)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if software_home is not None:
            pulumi.set(__self__, "software_home", software_home)
        if switch_log is not None:
            pulumi.set(__self__, "switch_log", switch_log)
        if vm_ip is not None:
            pulumi.set(__self__, "vm_ip", vm_ip)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        name of the database server VM on which the instance you want to register is running.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbPassword")
    def db_password(self) -> pulumi.Input[str]:
        """
        database password
        """
        return pulumi.get(self, "db_password")

    @db_password.setter
    def db_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_password", value)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> pulumi.Input[str]:
        """
        listner port of database
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "listener_port", value)

    @property
    @pulumi.getter(name="postgresSoftwareHome")
    def postgres_software_home(self) -> pulumi.Input[str]:
        """
        path to the PostgreSQL home directory in which the PostgreSQL software is installed.
        """
        return pulumi.get(self, "postgres_software_home")

    @postgres_software_home.setter
    def postgres_software_home(self, value: pulumi.Input[str]):
        pulumi.set(self, "postgres_software_home", value)

    @property
    @pulumi.getter(name="allowMultipleDatabases")
    def allow_multiple_databases(self) -> Optional[pulumi.Input[bool]]:
        """
        allow multiple databases. Default is true
        """
        return pulumi.get(self, "allow_multiple_databases")

    @allow_multiple_databases.setter
    def allow_multiple_databases(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_multiple_databases", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        backup policy of database. Default is prefer_secondary.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[str]]:
        """
        username of the NDB drive user account that has sudo access.
        """
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_user", value)

    @property
    @pulumi.getter(name="softwareHome")
    def software_home(self) -> Optional[pulumi.Input[str]]:
        """
        path to the directory in which the PostgreSQL software is installed.
        """
        return pulumi.get(self, "software_home")

    @software_home.setter
    def software_home(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_home", value)

    @property
    @pulumi.getter(name="switchLog")
    def switch_log(self) -> Optional[pulumi.Input[bool]]:
        """
        switch log of database. Default is true
        """
        return pulumi.get(self, "switch_log")

    @switch_log.setter
    def switch_log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "switch_log", value)

    @property
    @pulumi.getter(name="vmIp")
    def vm_ip(self) -> Optional[pulumi.Input[str]]:
        """
        VM IP of the database server VM on which the instance you want to register is running.
        """
        return pulumi.get(self, "vm_ip")

    @vm_ip.setter
    def vm_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_ip", value)


if not MYPY:
    class NdbRegisterDatabasePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabasePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabasePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        """
        whether instance is cloned or not
        """
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        """
        clustered or not. Default is false
        """
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachinePropertyArgsDict']]]]
        """
        properties of database created
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleArgsDict']]]]
        """
        - (Optional) schedule for snapshots
        """
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineTagArgsDict']]]]
        """
        tags
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbRegisterDatabaseTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clone: whether instance is cloned or not
        :param pulumi.Input[bool] clustered: clustered or not. Default is false
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachinePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleArgs']]] schedules: - (Optional) schedule for snapshots
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineTagArgs']]] tags: tags
        :param pulumi.Input[str] type: type of database
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        """
        whether instance is cloned or not
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        """
        clustered or not. Default is false
        """
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachinePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleArgs']]]]:
        """
        - (Optional) schedule for snapshots
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineTagArgs']]]]:
        """
        tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) name of time machine
        """
        schedule: pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleArgsDict']
        """
        - (Optional) schedule for snapshots
        """
        autotunelogdrive: NotRequired[pulumi.Input[bool]]
        """
        - (Optional) enable auto tune log drive. Default: true
        """
        description: NotRequired[pulumi.Input[str]]
        """
        - (Optional) description of time machine
        """
        sla_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailArgsDict']]]]
        """
        -  (optional) SLA details for HA instance
        """
        slaid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) SLA ID for single instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoTagArgsDict']]]]
        """
        - (Optional) tags
        """
elif False:
    NdbRegisterDatabaseTimeMachineInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 schedule: pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleArgs'],
                 autotunelogdrive: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 sla_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs']]]] = None,
                 slaid: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoTagArgs']]]] = None):
        """
        :param pulumi.Input[str] name: - (Required) name of time machine
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleArgs'] schedule: - (Optional) schedule for snapshots
        :param pulumi.Input[bool] autotunelogdrive: - (Optional) enable auto tune log drive. Default: true
        :param pulumi.Input[str] description: - (Optional) description of time machine
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs']]] sla_details: -  (optional) SLA details for HA instance
        :param pulumi.Input[str] slaid: - (Optional) SLA ID for single instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoTagArgs']]] tags: - (Optional) tags
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedule", schedule)
        if autotunelogdrive is not None:
            pulumi.set(__self__, "autotunelogdrive", autotunelogdrive)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if sla_details is not None:
            pulumi.set(__self__, "sla_details", sla_details)
        if slaid is not None:
            pulumi.set(__self__, "slaid", slaid)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) name of time machine
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleArgs']:
        """
        - (Optional) schedule for snapshots
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleArgs']):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter
    def autotunelogdrive(self) -> Optional[pulumi.Input[bool]]:
        """
        - (Optional) enable auto tune log drive. Default: true
        """
        return pulumi.get(self, "autotunelogdrive")

    @autotunelogdrive.setter
    def autotunelogdrive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autotunelogdrive", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) description of time machine
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="slaDetails")
    def sla_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs']]]]:
        """
        -  (optional) SLA details for HA instance
        """
        return pulumi.get(self, "sla_details")

    @sla_details.setter
    def sla_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs']]]]):
        pulumi.set(self, "sla_details", value)

    @property
    @pulumi.getter
    def slaid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) SLA ID for single instance
        """
        return pulumi.get(self, "slaid")

    @slaid.setter
    def slaid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slaid", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoTagArgs']]]]:
        """
        - (Optional) tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleArgsDict(TypedDict):
        continuousschedule: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgsDict']]
        """
        - (Optional) snapshot freq and log config
        """
        monthlyschedule: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgsDict']]
        """
        - (Optional) monthly snapshot config
        """
        quartelyschedule: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgsDict']]
        """
        - (Optional) quaterly snapshot config
        """
        snapshottimeofday: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgsDict']]
        """
        - (Optional) daily snapshot config
        """
        weeklyschedule: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgsDict']]
        """
        - (Optional) weekly snapshot config
        """
        yearlyschedule: NotRequired[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgsDict']]
        """
        - (Optional) yearly snapshot config
        """
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleArgs:
    def __init__(__self__, *,
                 continuousschedule: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs']] = None,
                 monthlyschedule: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs']] = None,
                 quartelyschedule: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs']] = None,
                 snapshottimeofday: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs']] = None,
                 weeklyschedule: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs']] = None,
                 yearlyschedule: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs']] = None):
        """
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs'] continuousschedule: - (Optional) snapshot freq and log config
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs'] monthlyschedule: - (Optional) monthly snapshot config
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs'] quartelyschedule: - (Optional) quaterly snapshot config
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs'] snapshottimeofday: - (Optional) daily snapshot config
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs'] weeklyschedule: - (Optional) weekly snapshot config
        :param pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs'] yearlyschedule: - (Optional) yearly snapshot config
        """
        if continuousschedule is not None:
            pulumi.set(__self__, "continuousschedule", continuousschedule)
        if monthlyschedule is not None:
            pulumi.set(__self__, "monthlyschedule", monthlyschedule)
        if quartelyschedule is not None:
            pulumi.set(__self__, "quartelyschedule", quartelyschedule)
        if snapshottimeofday is not None:
            pulumi.set(__self__, "snapshottimeofday", snapshottimeofday)
        if weeklyschedule is not None:
            pulumi.set(__self__, "weeklyschedule", weeklyschedule)
        if yearlyschedule is not None:
            pulumi.set(__self__, "yearlyschedule", yearlyschedule)

    @property
    @pulumi.getter
    def continuousschedule(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs']]:
        """
        - (Optional) snapshot freq and log config
        """
        return pulumi.get(self, "continuousschedule")

    @continuousschedule.setter
    def continuousschedule(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs']]):
        pulumi.set(self, "continuousschedule", value)

    @property
    @pulumi.getter
    def monthlyschedule(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs']]:
        """
        - (Optional) monthly snapshot config
        """
        return pulumi.get(self, "monthlyschedule")

    @monthlyschedule.setter
    def monthlyschedule(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs']]):
        pulumi.set(self, "monthlyschedule", value)

    @property
    @pulumi.getter
    def quartelyschedule(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs']]:
        """
        - (Optional) quaterly snapshot config
        """
        return pulumi.get(self, "quartelyschedule")

    @quartelyschedule.setter
    def quartelyschedule(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs']]):
        pulumi.set(self, "quartelyschedule", value)

    @property
    @pulumi.getter
    def snapshottimeofday(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs']]:
        """
        - (Optional) daily snapshot config
        """
        return pulumi.get(self, "snapshottimeofday")

    @snapshottimeofday.setter
    def snapshottimeofday(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs']]):
        pulumi.set(self, "snapshottimeofday", value)

    @property
    @pulumi.getter
    def weeklyschedule(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs']]:
        """
        - (Optional) weekly snapshot config
        """
        return pulumi.get(self, "weeklyschedule")

    @weeklyschedule.setter
    def weeklyschedule(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs']]):
        pulumi.set(self, "weeklyschedule", value)

    @property
    @pulumi.getter
    def yearlyschedule(self) -> Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs']]:
        """
        - (Optional) yearly snapshot config
        """
        return pulumi.get(self, "yearlyschedule")

    @yearlyschedule.setter
    def yearlyschedule(self, value: Optional[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs']]):
        pulumi.set(self, "yearlyschedule", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        logbackupinterval: pulumi.Input[int]
        snapshotsperday: pulumi.Input[int]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleContinuousscheduleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 logbackupinterval: pulumi.Input[int],
                 snapshotsperday: pulumi.Input[int]):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "logbackupinterval", logbackupinterval)
        pulumi.set(__self__, "snapshotsperday", snapshotsperday)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def logbackupinterval(self) -> pulumi.Input[int]:
        return pulumi.get(self, "logbackupinterval")

    @logbackupinterval.setter
    def logbackupinterval(self, value: pulumi.Input[int]):
        pulumi.set(self, "logbackupinterval", value)

    @property
    @pulumi.getter
    def snapshotsperday(self) -> pulumi.Input[int]:
        return pulumi.get(self, "snapshotsperday")

    @snapshotsperday.setter
    def snapshotsperday(self, value: pulumi.Input[int]):
        pulumi.set(self, "snapshotsperday", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        enabled: pulumi.Input[bool]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleMonthlyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        enabled: pulumi.Input[bool]
        startmonth: pulumi.Input[str]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleQuartelyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool],
                 startmonth: pulumi.Input[str]):
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "startmonth", startmonth)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def startmonth(self) -> pulumi.Input[str]:
        return pulumi.get(self, "startmonth")

    @startmonth.setter
    def startmonth(self, value: pulumi.Input[str]):
        pulumi.set(self, "startmonth", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgsDict(TypedDict):
        hours: pulumi.Input[int]
        minutes: pulumi.Input[int]
        seconds: pulumi.Input[int]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleSnapshottimeofdayArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[int],
                 minutes: pulumi.Input[int],
                 seconds: pulumi.Input[int]):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> pulumi.Input[int]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[int]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[int]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgsDict(TypedDict):
        dayofweek: pulumi.Input[str]
        enabled: pulumi.Input[bool]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleWeeklyscheduleArgs:
    def __init__(__self__, *,
                 dayofweek: pulumi.Input[str],
                 enabled: pulumi.Input[bool]):
        pulumi.set(__self__, "dayofweek", dayofweek)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def dayofweek(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dayofweek")

    @dayofweek.setter
    def dayofweek(self, value: pulumi.Input[str]):
        pulumi.set(self, "dayofweek", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgsDict(TypedDict):
        dayofmonth: pulumi.Input[int]
        enabled: pulumi.Input[bool]
        month: pulumi.Input[str]
elif False:
    NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoScheduleYearlyscheduleArgs:
    def __init__(__self__, *,
                 dayofmonth: pulumi.Input[int],
                 enabled: pulumi.Input[bool],
                 month: pulumi.Input[str]):
        pulumi.set(__self__, "dayofmonth", dayofmonth)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "month", month)

    @property
    @pulumi.getter
    def dayofmonth(self) -> pulumi.Input[int]:
        return pulumi.get(self, "dayofmonth")

    @dayofmonth.setter
    def dayofmonth(self, value: pulumi.Input[int]):
        pulumi.set(self, "dayofmonth", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> pulumi.Input[str]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[str]):
        pulumi.set(self, "month", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoSlaDetailArgsDict(TypedDict):
        primary_slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgsDict']]]]
        """
        - (Required) primary sla details
        * `primary_sla.sla_id` :- (Required) sla id
        * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
elif False:
    NdbRegisterDatabaseTimeMachineInfoSlaDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoSlaDetailArgs:
    def __init__(__self__, *,
                 primary_slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs']]] primary_slas: - (Required) primary sla details
               * `primary_sla.sla_id` :- (Required) sla id
               * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
        if primary_slas is not None:
            pulumi.set(__self__, "primary_slas", primary_slas)

    @property
    @pulumi.getter(name="primarySlas")
    def primary_slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs']]]]:
        """
        - (Required) primary sla details
        * `primary_sla.sla_id` :- (Required) sla id
        * `primary_sla.nx_cluster_ids` -: (Optioanl) cluster ids
        """
        return pulumi.get(self, "primary_slas")

    @primary_slas.setter
    def primary_slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs']]]]):
        pulumi.set(self, "primary_slas", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgsDict(TypedDict):
        sla_id: pulumi.Input[str]
        """
        description of SLA ID.
        """
        nx_cluster_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoSlaDetailPrimarySlaArgs:
    def __init__(__self__, *,
                 sla_id: pulumi.Input[str],
                 nx_cluster_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] sla_id: description of SLA ID.
        """
        pulumi.set(__self__, "sla_id", sla_id)
        if nx_cluster_ids is not None:
            pulumi.set(__self__, "nx_cluster_ids", nx_cluster_ids)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> pulumi.Input[str]:
        """
        description of SLA ID.
        """
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="nxClusterIds")
    def nx_cluster_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "nx_cluster_ids")

    @nx_cluster_ids.setter
    def nx_cluster_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nx_cluster_ids", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineInfoTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseTimeMachineInfoTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineInfoTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        """
        timezone on which instance is created xw
        """
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] time_zone: timezone on which instance is created xw
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone on which instance is created xw
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        minutes: NotRequired[pulumi.Input[int]]
        seconds: NotRequired[pulumi.Input[int]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbRegisterDatabaseTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description
        :param pulumi.Input[str] name: Name of database instance
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbRegisterDatabaseTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        - (Required) value for argument
        """
elif False:
    NdbRegisterDatabaseTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDatabaseTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - (Required) value for argument
        """
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) value for argument
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDbserverCredentialArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        password of the NDB drive user account. Conflicts with ssh_key.
        """
        username: pulumi.Input[str]
        """
        username of the NDB drive user account that has sudo access
        """
        label: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDbserverCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDbserverCredentialArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: password of the NDB drive user account. Conflicts with ssh_key.
        :param pulumi.Input[str] username: username of the NDB drive user account that has sudo access
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        password of the NDB drive user account. Conflicts with ssh_key.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        username of the NDB drive user account that has sudo access
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class NdbRegisterDbserverPostgresDatabaseArgsDict(TypedDict):
        listener_port: NotRequired[pulumi.Input[str]]
        """
        listener port of db server
        """
        postgres_software_home: NotRequired[pulumi.Input[str]]
        """
        path to the PostgreSQL home directory in which the PostgreSQL software is installed
        """
elif False:
    NdbRegisterDbserverPostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDbserverPostgresDatabaseArgs:
    def __init__(__self__, *,
                 listener_port: Optional[pulumi.Input[str]] = None,
                 postgres_software_home: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] listener_port: listener port of db server
        :param pulumi.Input[str] postgres_software_home: path to the PostgreSQL home directory in which the PostgreSQL software is installed
        """
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if postgres_software_home is not None:
            pulumi.set(__self__, "postgres_software_home", postgres_software_home)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[str]]:
        """
        listener port of db server
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listener_port", value)

    @property
    @pulumi.getter(name="postgresSoftwareHome")
    def postgres_software_home(self) -> Optional[pulumi.Input[str]]:
        """
        path to the PostgreSQL home directory in which the PostgreSQL software is installed
        """
        return pulumi.get(self, "postgres_software_home")

    @postgres_software_home.setter
    def postgres_software_home(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "postgres_software_home", value)


if not MYPY:
    class NdbRegisterDbserverPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of db server vm. Should be used in Update Method only.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDbserverPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDbserverPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of db server vm. Should be used in Update Method only.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of db server vm. Should be used in Update Method only.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbRegisterDbserverTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbRegisterDbserverTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbRegisterDbserverTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodeArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        database_id: NotRequired[pulumi.Input[str]]
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        dbserver: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        dbserver_id: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeInfoArgsDict']]]]
        """
        info of instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        primary: NotRequired[pulumi.Input[bool]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodePropertyArgsDict']]]]
        """
        properties of database created
        """
        protection_domain_id: NotRequired[pulumi.Input[str]]
        protection_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainArgsDict']]]]
        software_installation_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
elif False:
    NdbScaleDatabaseDatabaseNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodeArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 dbserver: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 dbserver_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 primary: Optional[pulumi.Input[bool]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodePropertyArgs']]]] = None,
                 protection_domain_id: Optional[pulumi.Input[str]] = None,
                 protection_domains: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainArgs']]]] = None,
                 software_installation_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeTagArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeInfoArgs']]] infos: info of instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if dbserver is not None:
            pulumi.set(__self__, "dbserver", dbserver)
        if dbserver_id is not None:
            pulumi.set(__self__, "dbserver_id", dbserver_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if protection_domain_id is not None:
            pulumi.set(__self__, "protection_domain_id", protection_domain_id)
        if protection_domains is not None:
            pulumi.set(__self__, "protection_domains", protection_domains)
        if software_installation_id is not None:
            pulumi.set(__self__, "software_installation_id", software_installation_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def dbserver(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "dbserver")

    @dbserver.setter
    def dbserver(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "dbserver", value)

    @property
    @pulumi.getter(name="dbserverId")
    def dbserver_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dbserver_id")

    @dbserver_id.setter
    def dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dbserver_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="protectionDomainId")
    def protection_domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_domain_id")

    @protection_domain_id.setter
    def protection_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_domain_id", value)

    @property
    @pulumi.getter(name="protectionDomains")
    def protection_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainArgs']]]]:
        return pulumi.get(self, "protection_domains")

    @protection_domains.setter
    def protection_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainArgs']]]]):
        pulumi.set(self, "protection_domains", value)

    @property
    @pulumi.getter(name="softwareInstallationId")
    def software_installation_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "software_installation_id")

    @software_installation_id.setter
    def software_installation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "software_installation_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodeInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbScaleDatabaseDatabaseNodeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodeInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseDatabaseNodePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodeProtectionDomainArgsDict(TypedDict):
        assoc_entities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        cloud_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        era_created: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        primary_host: NotRequired[pulumi.Input[str]]
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgsDict']]]]
        """
        properties of database created
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbScaleDatabaseDatabaseNodeProtectionDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodeProtectionDomainArgs:
    def __init__(__self__, *,
                 assoc_entities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 cloud_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 era_created: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 primary_host: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[str] type: type of database
        """
        if assoc_entities is not None:
            pulumi.set(__self__, "assoc_entities", assoc_entities)
        if cloud_id is not None:
            pulumi.set(__self__, "cloud_id", cloud_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if era_created is not None:
            pulumi.set(__self__, "era_created", era_created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if primary_host is not None:
            pulumi.set(__self__, "primary_host", primary_host)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="assocEntities")
    def assoc_entities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "assoc_entities")

    @assoc_entities.setter
    def assoc_entities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "assoc_entities", value)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eraCreated")
    def era_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "era_created")

    @era_created.setter
    def era_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "era_created", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="primaryHost")
    def primary_host(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_host")

    @primary_host.setter
    def primary_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_host", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodeProtectionDomainPropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseDatabaseNodeTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseDatabaseNodeTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseDatabaseNodeTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseInfoArgsDict(TypedDict):
        bpg_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigArgsDict']]]]
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbScaleDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoArgs:
    def __init__(__self__, *,
                 bpg_configs: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigArgs']]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if bpg_configs is not None:
            pulumi.set(__self__, "bpg_configs", bpg_configs)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter(name="bpgConfigs")
    def bpg_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigArgs']]]]:
        return pulumi.get(self, "bpg_configs")

    @bpg_configs.setter
    def bpg_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigArgs']]]]):
        pulumi.set(self, "bpg_configs", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigArgsDict(TypedDict):
        bpg_db_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigBpgDbParamArgsDict']]]]
        storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArgsDict']]]]
        vm_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigVmPropertyArgsDict']]]]
elif False:
    NdbScaleDatabaseInfoBpgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigArgs:
    def __init__(__self__, *,
                 bpg_db_params: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigBpgDbParamArgs']]]] = None,
                 storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArgs']]]] = None,
                 vm_properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigVmPropertyArgs']]]] = None):
        if bpg_db_params is not None:
            pulumi.set(__self__, "bpg_db_params", bpg_db_params)
        if storages is not None:
            pulumi.set(__self__, "storages", storages)
        if vm_properties is not None:
            pulumi.set(__self__, "vm_properties", vm_properties)

    @property
    @pulumi.getter(name="bpgDbParams")
    def bpg_db_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigBpgDbParamArgs']]]]:
        return pulumi.get(self, "bpg_db_params")

    @bpg_db_params.setter
    def bpg_db_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigBpgDbParamArgs']]]]):
        pulumi.set(self, "bpg_db_params", value)

    @property
    @pulumi.getter
    def storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArgs']]]]:
        return pulumi.get(self, "storages")

    @storages.setter
    def storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArgs']]]]):
        pulumi.set(self, "storages", value)

    @property
    @pulumi.getter(name="vmProperties")
    def vm_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigVmPropertyArgs']]]]:
        return pulumi.get(self, "vm_properties")

    @vm_properties.setter
    def vm_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigVmPropertyArgs']]]]):
        pulumi.set(self, "vm_properties", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigBpgDbParamArgsDict(TypedDict):
        effective_cache_size: NotRequired[pulumi.Input[str]]
        maintenance_work_mem: NotRequired[pulumi.Input[str]]
        max_parallel_workers_per_gather: NotRequired[pulumi.Input[str]]
        max_worker_processes: NotRequired[pulumi.Input[str]]
        shared_buffers: NotRequired[pulumi.Input[str]]
        work_mem: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseInfoBpgConfigBpgDbParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigBpgDbParamArgs:
    def __init__(__self__, *,
                 effective_cache_size: Optional[pulumi.Input[str]] = None,
                 maintenance_work_mem: Optional[pulumi.Input[str]] = None,
                 max_parallel_workers_per_gather: Optional[pulumi.Input[str]] = None,
                 max_worker_processes: Optional[pulumi.Input[str]] = None,
                 shared_buffers: Optional[pulumi.Input[str]] = None,
                 work_mem: Optional[pulumi.Input[str]] = None):
        if effective_cache_size is not None:
            pulumi.set(__self__, "effective_cache_size", effective_cache_size)
        if maintenance_work_mem is not None:
            pulumi.set(__self__, "maintenance_work_mem", maintenance_work_mem)
        if max_parallel_workers_per_gather is not None:
            pulumi.set(__self__, "max_parallel_workers_per_gather", max_parallel_workers_per_gather)
        if max_worker_processes is not None:
            pulumi.set(__self__, "max_worker_processes", max_worker_processes)
        if shared_buffers is not None:
            pulumi.set(__self__, "shared_buffers", shared_buffers)
        if work_mem is not None:
            pulumi.set(__self__, "work_mem", work_mem)

    @property
    @pulumi.getter(name="effectiveCacheSize")
    def effective_cache_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_cache_size")

    @effective_cache_size.setter
    def effective_cache_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_cache_size", value)

    @property
    @pulumi.getter(name="maintenanceWorkMem")
    def maintenance_work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "maintenance_work_mem")

    @maintenance_work_mem.setter
    def maintenance_work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_work_mem", value)

    @property
    @pulumi.getter(name="maxParallelWorkersPerGather")
    def max_parallel_workers_per_gather(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_parallel_workers_per_gather")

    @max_parallel_workers_per_gather.setter
    def max_parallel_workers_per_gather(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_parallel_workers_per_gather", value)

    @property
    @pulumi.getter(name="maxWorkerProcesses")
    def max_worker_processes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_worker_processes")

    @max_worker_processes.setter
    def max_worker_processes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_worker_processes", value)

    @property
    @pulumi.getter(name="sharedBuffers")
    def shared_buffers(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_buffers")

    @shared_buffers.setter
    def shared_buffers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_buffers", value)

    @property
    @pulumi.getter(name="workMem")
    def work_mem(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "work_mem")

    @work_mem.setter
    def work_mem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "work_mem", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigStorageArgsDict(TypedDict):
        archive_storages: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgsDict']]]]
        data_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgsDict']]]]
        log_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgsDict']]]]
elif False:
    NdbScaleDatabaseInfoBpgConfigStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigStorageArgs:
    def __init__(__self__, *,
                 archive_storages: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]] = None,
                 data_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgs']]]] = None,
                 log_disks: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgs']]]] = None):
        if archive_storages is not None:
            pulumi.set(__self__, "archive_storages", archive_storages)
        if data_disks is not None:
            pulumi.set(__self__, "data_disks", data_disks)
        if log_disks is not None:
            pulumi.set(__self__, "log_disks", log_disks)

    @property
    @pulumi.getter(name="archiveStorages")
    def archive_storages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]:
        return pulumi.get(self, "archive_storages")

    @archive_storages.setter
    def archive_storages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgs']]]]):
        pulumi.set(self, "archive_storages", value)

    @property
    @pulumi.getter(name="dataDisks")
    def data_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgs']]]]:
        return pulumi.get(self, "data_disks")

    @data_disks.setter
    def data_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgs']]]]):
        pulumi.set(self, "data_disks", value)

    @property
    @pulumi.getter(name="logDisks")
    def log_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgs']]]]:
        return pulumi.get(self, "log_disks")

    @log_disks.setter
    def log_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgs']]]]):
        pulumi.set(self, "log_disks", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgsDict(TypedDict):
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigStorageArchiveStorageArgs:
    def __init__(__self__, *,
                 size: Optional[pulumi.Input[float]] = None):
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
elif False:
    NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigStorageDataDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgsDict(TypedDict):
        count: NotRequired[pulumi.Input[float]]
        size: NotRequired[pulumi.Input[float]]
elif False:
    NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigStorageLogDiskArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class NdbScaleDatabaseInfoBpgConfigVmPropertyArgsDict(TypedDict):
        dirty_background_ratio: NotRequired[pulumi.Input[float]]
        dirty_expire_centisecs: NotRequired[pulumi.Input[float]]
        dirty_ratio: NotRequired[pulumi.Input[float]]
        dirty_writeback_centisecs: NotRequired[pulumi.Input[float]]
        nr_hugepages: NotRequired[pulumi.Input[float]]
        overcommit_memory: NotRequired[pulumi.Input[float]]
        swappiness: NotRequired[pulumi.Input[float]]
elif False:
    NdbScaleDatabaseInfoBpgConfigVmPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseInfoBpgConfigVmPropertyArgs:
    def __init__(__self__, *,
                 dirty_background_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_expire_centisecs: Optional[pulumi.Input[float]] = None,
                 dirty_ratio: Optional[pulumi.Input[float]] = None,
                 dirty_writeback_centisecs: Optional[pulumi.Input[float]] = None,
                 nr_hugepages: Optional[pulumi.Input[float]] = None,
                 overcommit_memory: Optional[pulumi.Input[float]] = None,
                 swappiness: Optional[pulumi.Input[float]] = None):
        if dirty_background_ratio is not None:
            pulumi.set(__self__, "dirty_background_ratio", dirty_background_ratio)
        if dirty_expire_centisecs is not None:
            pulumi.set(__self__, "dirty_expire_centisecs", dirty_expire_centisecs)
        if dirty_ratio is not None:
            pulumi.set(__self__, "dirty_ratio", dirty_ratio)
        if dirty_writeback_centisecs is not None:
            pulumi.set(__self__, "dirty_writeback_centisecs", dirty_writeback_centisecs)
        if nr_hugepages is not None:
            pulumi.set(__self__, "nr_hugepages", nr_hugepages)
        if overcommit_memory is not None:
            pulumi.set(__self__, "overcommit_memory", overcommit_memory)
        if swappiness is not None:
            pulumi.set(__self__, "swappiness", swappiness)

    @property
    @pulumi.getter(name="dirtyBackgroundRatio")
    def dirty_background_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_background_ratio")

    @dirty_background_ratio.setter
    def dirty_background_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_background_ratio", value)

    @property
    @pulumi.getter(name="dirtyExpireCentisecs")
    def dirty_expire_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_expire_centisecs")

    @dirty_expire_centisecs.setter
    def dirty_expire_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_expire_centisecs", value)

    @property
    @pulumi.getter(name="dirtyRatio")
    def dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_ratio")

    @dirty_ratio.setter
    def dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_ratio", value)

    @property
    @pulumi.getter(name="dirtyWritebackCentisecs")
    def dirty_writeback_centisecs(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "dirty_writeback_centisecs")

    @dirty_writeback_centisecs.setter
    def dirty_writeback_centisecs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "dirty_writeback_centisecs", value)

    @property
    @pulumi.getter(name="nrHugepages")
    def nr_hugepages(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nr_hugepages")

    @nr_hugepages.setter
    def nr_hugepages(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nr_hugepages", value)

    @property
    @pulumi.getter(name="overcommitMemory")
    def overcommit_memory(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "overcommit_memory")

    @overcommit_memory.setter
    def overcommit_memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "overcommit_memory", value)

    @property
    @pulumi.getter
    def swappiness(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "swappiness")

    @swappiness.setter
    def swappiness(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "swappiness", value)


if not MYPY:
    class NdbScaleDatabaseLcmConfigArgsDict(TypedDict):
        expiry_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigExpiryDetailArgsDict']]]]
        post_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPostDeleteCommandArgsDict']]]]
        pre_delete_commands: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPreDeleteCommandArgsDict']]]]
        refresh_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigRefreshDetailArgsDict']]]]
elif False:
    NdbScaleDatabaseLcmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLcmConfigArgs:
    def __init__(__self__, *,
                 expiry_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigExpiryDetailArgs']]]] = None,
                 post_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPostDeleteCommandArgs']]]] = None,
                 pre_delete_commands: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPreDeleteCommandArgs']]]] = None,
                 refresh_details: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigRefreshDetailArgs']]]] = None):
        if expiry_details is not None:
            pulumi.set(__self__, "expiry_details", expiry_details)
        if post_delete_commands is not None:
            pulumi.set(__self__, "post_delete_commands", post_delete_commands)
        if pre_delete_commands is not None:
            pulumi.set(__self__, "pre_delete_commands", pre_delete_commands)
        if refresh_details is not None:
            pulumi.set(__self__, "refresh_details", refresh_details)

    @property
    @pulumi.getter(name="expiryDetails")
    def expiry_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigExpiryDetailArgs']]]]:
        return pulumi.get(self, "expiry_details")

    @expiry_details.setter
    def expiry_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigExpiryDetailArgs']]]]):
        pulumi.set(self, "expiry_details", value)

    @property
    @pulumi.getter(name="postDeleteCommands")
    def post_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPostDeleteCommandArgs']]]]:
        return pulumi.get(self, "post_delete_commands")

    @post_delete_commands.setter
    def post_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPostDeleteCommandArgs']]]]):
        pulumi.set(self, "post_delete_commands", value)

    @property
    @pulumi.getter(name="preDeleteCommands")
    def pre_delete_commands(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPreDeleteCommandArgs']]]]:
        return pulumi.get(self, "pre_delete_commands")

    @pre_delete_commands.setter
    def pre_delete_commands(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigPreDeleteCommandArgs']]]]):
        pulumi.set(self, "pre_delete_commands", value)

    @property
    @pulumi.getter(name="refreshDetails")
    def refresh_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigRefreshDetailArgs']]]]:
        return pulumi.get(self, "refresh_details")

    @refresh_details.setter
    def refresh_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLcmConfigRefreshDetailArgs']]]]):
        pulumi.set(self, "refresh_details", value)


if not MYPY:
    class NdbScaleDatabaseLcmConfigExpiryDetailArgsDict(TypedDict):
        delete_database: NotRequired[pulumi.Input[bool]]
        delete_time_machine: NotRequired[pulumi.Input[bool]]
        delete_vm: NotRequired[pulumi.Input[bool]]
        effective_timestamp: NotRequired[pulumi.Input[str]]
        expire_in_days: NotRequired[pulumi.Input[int]]
        expiry_date_timezone: NotRequired[pulumi.Input[str]]
        expiry_timestamp: NotRequired[pulumi.Input[str]]
        remind_before_in_days: NotRequired[pulumi.Input[int]]
        user_created: NotRequired[pulumi.Input[bool]]
elif False:
    NdbScaleDatabaseLcmConfigExpiryDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLcmConfigExpiryDetailArgs:
    def __init__(__self__, *,
                 delete_database: Optional[pulumi.Input[bool]] = None,
                 delete_time_machine: Optional[pulumi.Input[bool]] = None,
                 delete_vm: Optional[pulumi.Input[bool]] = None,
                 effective_timestamp: Optional[pulumi.Input[str]] = None,
                 expire_in_days: Optional[pulumi.Input[int]] = None,
                 expiry_date_timezone: Optional[pulumi.Input[str]] = None,
                 expiry_timestamp: Optional[pulumi.Input[str]] = None,
                 remind_before_in_days: Optional[pulumi.Input[int]] = None,
                 user_created: Optional[pulumi.Input[bool]] = None):
        if delete_database is not None:
            pulumi.set(__self__, "delete_database", delete_database)
        if delete_time_machine is not None:
            pulumi.set(__self__, "delete_time_machine", delete_time_machine)
        if delete_vm is not None:
            pulumi.set(__self__, "delete_vm", delete_vm)
        if effective_timestamp is not None:
            pulumi.set(__self__, "effective_timestamp", effective_timestamp)
        if expire_in_days is not None:
            pulumi.set(__self__, "expire_in_days", expire_in_days)
        if expiry_date_timezone is not None:
            pulumi.set(__self__, "expiry_date_timezone", expiry_date_timezone)
        if expiry_timestamp is not None:
            pulumi.set(__self__, "expiry_timestamp", expiry_timestamp)
        if remind_before_in_days is not None:
            pulumi.set(__self__, "remind_before_in_days", remind_before_in_days)
        if user_created is not None:
            pulumi.set(__self__, "user_created", user_created)

    @property
    @pulumi.getter(name="deleteDatabase")
    def delete_database(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_database")

    @delete_database.setter
    def delete_database(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_database", value)

    @property
    @pulumi.getter(name="deleteTimeMachine")
    def delete_time_machine(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_time_machine")

    @delete_time_machine.setter
    def delete_time_machine(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_time_machine", value)

    @property
    @pulumi.getter(name="deleteVm")
    def delete_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_vm")

    @delete_vm.setter
    def delete_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_vm", value)

    @property
    @pulumi.getter(name="effectiveTimestamp")
    def effective_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effective_timestamp")

    @effective_timestamp.setter
    def effective_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effective_timestamp", value)

    @property
    @pulumi.getter(name="expireInDays")
    def expire_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_in_days")

    @expire_in_days.setter
    def expire_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_in_days", value)

    @property
    @pulumi.getter(name="expiryDateTimezone")
    def expiry_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_date_timezone")

    @expiry_date_timezone.setter
    def expiry_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_date_timezone", value)

    @property
    @pulumi.getter(name="expiryTimestamp")
    def expiry_timestamp(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiry_timestamp")

    @expiry_timestamp.setter
    def expiry_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiry_timestamp", value)

    @property
    @pulumi.getter(name="remindBeforeInDays")
    def remind_before_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "remind_before_in_days")

    @remind_before_in_days.setter
    def remind_before_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "remind_before_in_days", value)

    @property
    @pulumi.getter(name="userCreated")
    def user_created(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "user_created")

    @user_created.setter
    def user_created(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "user_created", value)


if not MYPY:
    class NdbScaleDatabaseLcmConfigPostDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseLcmConfigPostDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLcmConfigPostDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbScaleDatabaseLcmConfigPreDeleteCommandArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseLcmConfigPreDeleteCommandArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLcmConfigPreDeleteCommandArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[str]] = None):
        if command is not None:
            pulumi.set(__self__, "command", command)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)


if not MYPY:
    class NdbScaleDatabaseLcmConfigRefreshDetailArgsDict(TypedDict):
        last_refresh_date: NotRequired[pulumi.Input[str]]
        next_refresh_date: NotRequired[pulumi.Input[str]]
        refresh_date_timezone: NotRequired[pulumi.Input[str]]
        refresh_in_days: NotRequired[pulumi.Input[int]]
        refresh_in_hours: NotRequired[pulumi.Input[int]]
        refresh_in_months: NotRequired[pulumi.Input[int]]
        refresh_time: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseLcmConfigRefreshDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLcmConfigRefreshDetailArgs:
    def __init__(__self__, *,
                 last_refresh_date: Optional[pulumi.Input[str]] = None,
                 next_refresh_date: Optional[pulumi.Input[str]] = None,
                 refresh_date_timezone: Optional[pulumi.Input[str]] = None,
                 refresh_in_days: Optional[pulumi.Input[int]] = None,
                 refresh_in_hours: Optional[pulumi.Input[int]] = None,
                 refresh_in_months: Optional[pulumi.Input[int]] = None,
                 refresh_time: Optional[pulumi.Input[str]] = None):
        if last_refresh_date is not None:
            pulumi.set(__self__, "last_refresh_date", last_refresh_date)
        if next_refresh_date is not None:
            pulumi.set(__self__, "next_refresh_date", next_refresh_date)
        if refresh_date_timezone is not None:
            pulumi.set(__self__, "refresh_date_timezone", refresh_date_timezone)
        if refresh_in_days is not None:
            pulumi.set(__self__, "refresh_in_days", refresh_in_days)
        if refresh_in_hours is not None:
            pulumi.set(__self__, "refresh_in_hours", refresh_in_hours)
        if refresh_in_months is not None:
            pulumi.set(__self__, "refresh_in_months", refresh_in_months)
        if refresh_time is not None:
            pulumi.set(__self__, "refresh_time", refresh_time)

    @property
    @pulumi.getter(name="lastRefreshDate")
    def last_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_refresh_date")

    @last_refresh_date.setter
    def last_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_refresh_date", value)

    @property
    @pulumi.getter(name="nextRefreshDate")
    def next_refresh_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_refresh_date")

    @next_refresh_date.setter
    def next_refresh_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_refresh_date", value)

    @property
    @pulumi.getter(name="refreshDateTimezone")
    def refresh_date_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_date_timezone")

    @refresh_date_timezone.setter
    def refresh_date_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_date_timezone", value)

    @property
    @pulumi.getter(name="refreshInDays")
    def refresh_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_days")

    @refresh_in_days.setter
    def refresh_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_days", value)

    @property
    @pulumi.getter(name="refreshInHours")
    def refresh_in_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_hours")

    @refresh_in_hours.setter
    def refresh_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_hours", value)

    @property
    @pulumi.getter(name="refreshInMonths")
    def refresh_in_months(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "refresh_in_months")

    @refresh_in_months.setter
    def refresh_in_months(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_in_months", value)

    @property
    @pulumi.getter(name="refreshTime")
    def refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "refresh_time")

    @refresh_time.setter
    def refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_time", value)


if not MYPY:
    class NdbScaleDatabaseLinkedDatabaseArgsDict(TypedDict):
        database_name: NotRequired[pulumi.Input[str]]
        """
        name of database
        """
        database_status: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLinkedDatabaseInfoArgsDict']]]]
        """
        info of instance
        """
        metric: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        parent_database_id: NotRequired[pulumi.Input[str]]
        """
        parent database id
        """
        parent_linked_database_id: NotRequired[pulumi.Input[str]]
        snapshot_id: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        timezone: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseLinkedDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLinkedDatabaseArgs:
    def __init__(__self__, *,
                 database_name: Optional[pulumi.Input[str]] = None,
                 database_status: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLinkedDatabaseInfoArgs']]]] = None,
                 metric: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_database_id: Optional[pulumi.Input[str]] = None,
                 parent_linked_database_id: Optional[pulumi.Input[str]] = None,
                 snapshot_id: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: name of database
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLinkedDatabaseInfoArgs']]] infos: info of instance
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] parent_database_id: parent database id
        :param pulumi.Input[str] status: status of instance
        """
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if database_status is not None:
            pulumi.set(__self__, "database_status", database_status)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_database_id is not None:
            pulumi.set(__self__, "parent_database_id", parent_database_id)
        if parent_linked_database_id is not None:
            pulumi.set(__self__, "parent_linked_database_id", parent_linked_database_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of database
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="databaseStatus")
    def database_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_status")

    @database_status.setter
    def database_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_status", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLinkedDatabaseInfoArgs']]]]:
        """
        info of instance
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseLinkedDatabaseInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentDatabaseId")
    def parent_database_id(self) -> Optional[pulumi.Input[str]]:
        """
        parent database id
        """
        return pulumi.get(self, "parent_database_id")

    @parent_database_id.setter
    def parent_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_database_id", value)

    @property
    @pulumi.getter(name="parentLinkedDatabaseId")
    def parent_linked_database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_linked_database_id")

    @parent_linked_database_id.setter
    def parent_linked_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_linked_database_id", value)

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_id", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class NdbScaleDatabaseLinkedDatabaseInfoArgsDict(TypedDict):
        info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        info of instance
        """
        secure_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    NdbScaleDatabaseLinkedDatabaseInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseLinkedDatabaseInfoArgs:
    def __init__(__self__, *,
                 info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 secure_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] info: info of instance
        """
        if info is not None:
            pulumi.set(__self__, "info", info)
        if secure_info is not None:
            pulumi.set(__self__, "secure_info", secure_info)

    @property
    @pulumi.getter
    def info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        info of instance
        """
        return pulumi.get(self, "info")

    @info.setter
    def info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "info", value)

    @property
    @pulumi.getter(name="secureInfo")
    def secure_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "secure_info")

    @secure_info.setter
    def secure_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "secure_info", value)


if not MYPY:
    class NdbScaleDatabasePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabasePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabasePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of database instance
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineArgsDict(TypedDict):
        access_level: NotRequired[pulumi.Input[str]]
        clone: NotRequired[pulumi.Input[bool]]
        """
        whether instance is cloned or not
        """
        clones: NotRequired[pulumi.Input[str]]
        clustered: NotRequired[pulumi.Input[bool]]
        database: NotRequired[pulumi.Input[str]]
        database_id: NotRequired[pulumi.Input[str]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        ea_status: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        metric: NotRequired[pulumi.Input[str]]
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachinePropertyArgsDict']]]]
        """
        properties of database created
        """
        schedule_id: NotRequired[pulumi.Input[str]]
        schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleArgsDict']]]]
        scope: NotRequired[pulumi.Input[str]]
        sla_id: NotRequired[pulumi.Input[str]]
        sla_update_in_progress: NotRequired[pulumi.Input[bool]]
        sla_update_metadata: NotRequired[pulumi.Input[str]]
        slas: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineSlaArgsDict']]]]
        source_nx_clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        status: NotRequired[pulumi.Input[str]]
        """
        status of instance
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineTagArgsDict']]]]
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of database
        """
elif False:
    NdbScaleDatabaseTimeMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineArgs:
    def __init__(__self__, *,
                 access_level: Optional[pulumi.Input[str]] = None,
                 clone: Optional[pulumi.Input[bool]] = None,
                 clones: Optional[pulumi.Input[str]] = None,
                 clustered: Optional[pulumi.Input[bool]] = None,
                 database: Optional[pulumi.Input[str]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ea_status: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachinePropertyArgs']]]] = None,
                 schedule_id: Optional[pulumi.Input[str]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleArgs']]]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 sla_id: Optional[pulumi.Input[str]] = None,
                 sla_update_in_progress: Optional[pulumi.Input[bool]] = None,
                 sla_update_metadata: Optional[pulumi.Input[str]] = None,
                 slas: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineSlaArgs']]]] = None,
                 source_nx_clusters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineTagArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] clone: whether instance is cloned or not
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] metric: Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachinePropertyArgs']]] properties: properties of database created
        :param pulumi.Input[str] status: status of instance
        :param pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineTagArgs']]] tags: allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        :param pulumi.Input[str] type: type of database
        """
        if access_level is not None:
            pulumi.set(__self__, "access_level", access_level)
        if clone is not None:
            pulumi.set(__self__, "clone", clone)
        if clones is not None:
            pulumi.set(__self__, "clones", clones)
        if clustered is not None:
            pulumi.set(__self__, "clustered", clustered)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ea_status is not None:
            pulumi.set(__self__, "ea_status", ea_status)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if schedule_id is not None:
            pulumi.set(__self__, "schedule_id", schedule_id)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if sla_id is not None:
            pulumi.set(__self__, "sla_id", sla_id)
        if sla_update_in_progress is not None:
            pulumi.set(__self__, "sla_update_in_progress", sla_update_in_progress)
        if sla_update_metadata is not None:
            pulumi.set(__self__, "sla_update_metadata", sla_update_metadata)
        if slas is not None:
            pulumi.set(__self__, "slas", slas)
        if source_nx_clusters is not None:
            pulumi.set(__self__, "source_nx_clusters", source_nx_clusters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessLevel")
    def access_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_level")

    @access_level.setter
    def access_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_level", value)

    @property
    @pulumi.getter
    def clone(self) -> Optional[pulumi.Input[bool]]:
        """
        whether instance is cloned or not
        """
        return pulumi.get(self, "clone")

    @clone.setter
    def clone(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clone", value)

    @property
    @pulumi.getter
    def clones(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "clones")

    @clones.setter
    def clones(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clones", value)

    @property
    @pulumi.getter
    def clustered(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "clustered")

    @clustered.setter
    def clustered(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clustered", value)

    @property
    @pulumi.getter
    def database(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="eaStatus")
    def ea_status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ea_status")

    @ea_status.setter
    def ea_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ea_status", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        Stores storage info regarding size, allocatedSize, usedSize and unit of calculation that seems to have been fetched from PRISM.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachinePropertyArgs']]]]:
        """
        properties of database created
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachinePropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="scheduleId")
    def schedule_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "schedule_id")

    @schedule_id.setter
    def schedule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schedule_id", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleArgs']]]]:
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleArgs']]]]):
        pulumi.set(self, "schedules", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="slaId")
    def sla_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_id")

    @sla_id.setter
    def sla_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_id", value)

    @property
    @pulumi.getter(name="slaUpdateInProgress")
    def sla_update_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sla_update_in_progress")

    @sla_update_in_progress.setter
    def sla_update_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sla_update_in_progress", value)

    @property
    @pulumi.getter(name="slaUpdateMetadata")
    def sla_update_metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sla_update_metadata")

    @sla_update_metadata.setter
    def sla_update_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sla_update_metadata", value)

    @property
    @pulumi.getter
    def slas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineSlaArgs']]]]:
        return pulumi.get(self, "slas")

    @slas.setter
    def slas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineSlaArgs']]]]):
        pulumi.set(self, "slas", value)

    @property
    @pulumi.getter(name="sourceNxClusters")
    def source_nx_clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "source_nx_clusters")

    @source_nx_clusters.setter
    def source_nx_clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_nx_clusters", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of instance
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineTagArgs']]]]:
        """
        allows you to assign metadata to entities (clones, time machines, databases, and database servers) by using tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of database
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachinePropertyArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        ref_id: NotRequired[pulumi.Input[str]]
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseTimeMachinePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachinePropertyArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 ref_id: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ref_id is not None:
            pulumi.set(__self__, "ref_id", ref_id)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="refId")
    def ref_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ref_id")

    @ref_id.setter
    def ref_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ref_id", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleArgsDict(TypedDict):
        continuous_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgsDict']]]]
        daily_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgsDict']]]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        global_policy: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        monthly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        quartely_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgsDict']]]]
        reference_count: NotRequired[pulumi.Input[int]]
        snapshot_time_of_days: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict']]]]
        start_time: NotRequired[pulumi.Input[str]]
        system_policy: NotRequired[pulumi.Input[bool]]
        time_zone: NotRequired[pulumi.Input[str]]
        """
        timezone on which instance is created xw
        """
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgsDict']]]]
        yearly_schedules: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgsDict']]]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleArgs:
    def __init__(__self__, *,
                 continuous_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgs']]]] = None,
                 daily_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgs']]]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 global_policy: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 quartely_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 snapshot_time_of_days: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 system_policy: Optional[pulumi.Input[bool]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]] = None,
                 yearly_schedules: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgs']]]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        :param pulumi.Input[str] time_zone: timezone on which instance is created xw
        """
        if continuous_schedules is not None:
            pulumi.set(__self__, "continuous_schedules", continuous_schedules)
        if daily_schedules is not None:
            pulumi.set(__self__, "daily_schedules", daily_schedules)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if global_policy is not None:
            pulumi.set(__self__, "global_policy", global_policy)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_schedules is not None:
            pulumi.set(__self__, "monthly_schedules", monthly_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if quartely_schedules is not None:
            pulumi.set(__self__, "quartely_schedules", quartely_schedules)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if snapshot_time_of_days is not None:
            pulumi.set(__self__, "snapshot_time_of_days", snapshot_time_of_days)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if system_policy is not None:
            pulumi.set(__self__, "system_policy", system_policy)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_schedules is not None:
            pulumi.set(__self__, "weekly_schedules", weekly_schedules)
        if yearly_schedules is not None:
            pulumi.set(__self__, "yearly_schedules", yearly_schedules)

    @property
    @pulumi.getter(name="continuousSchedules")
    def continuous_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]:
        return pulumi.get(self, "continuous_schedules")

    @continuous_schedules.setter
    def continuous_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgs']]]]):
        pulumi.set(self, "continuous_schedules", value)

    @property
    @pulumi.getter(name="dailySchedules")
    def daily_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgs']]]]:
        return pulumi.get(self, "daily_schedules")

    @daily_schedules.setter
    def daily_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgs']]]]):
        pulumi.set(self, "daily_schedules", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="globalPolicy")
    def global_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "global_policy")

    @global_policy.setter
    def global_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "global_policy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlySchedules")
    def monthly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]:
        return pulumi.get(self, "monthly_schedules")

    @monthly_schedules.setter
    def monthly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgs']]]]):
        pulumi.set(self, "monthly_schedules", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="quartelySchedules")
    def quartely_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]:
        return pulumi.get(self, "quartely_schedules")

    @quartely_schedules.setter
    def quartely_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgs']]]]):
        pulumi.set(self, "quartely_schedules", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="snapshotTimeOfDays")
    def snapshot_time_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]:
        return pulumi.get(self, "snapshot_time_of_days")

    @snapshot_time_of_days.setter
    def snapshot_time_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs']]]]):
        pulumi.set(self, "snapshot_time_of_days", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="systemPolicy")
    def system_policy(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_policy")

    @system_policy.setter
    def system_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_policy", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        timezone on which instance is created xw
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklySchedules")
    def weekly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]:
        return pulumi.get(self, "weekly_schedules")

    @weekly_schedules.setter
    def weekly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgs']]]]):
        pulumi.set(self, "weekly_schedules", value)

    @property
    @pulumi.getter(name="yearlySchedules")
    def yearly_schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]:
        return pulumi.get(self, "yearly_schedules")

    @yearly_schedules.setter
    def yearly_schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgs']]]]):
        pulumi.set(self, "yearly_schedules", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        log_backup_interval: NotRequired[pulumi.Input[int]]
        snapshots_per_day: NotRequired[pulumi.Input[int]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleContinuousScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 log_backup_interval: Optional[pulumi.Input[int]] = None,
                 snapshots_per_day: Optional[pulumi.Input[int]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_backup_interval is not None:
            pulumi.set(__self__, "log_backup_interval", log_backup_interval)
        if snapshots_per_day is not None:
            pulumi.set(__self__, "snapshots_per_day", snapshots_per_day)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logBackupInterval")
    def log_backup_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "log_backup_interval")

    @log_backup_interval.setter
    def log_backup_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_backup_interval", value)

    @property
    @pulumi.getter(name="snapshotsPerDay")
    def snapshots_per_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "snapshots_per_day")

    @snapshots_per_day.setter
    def snapshots_per_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshots_per_day", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleDailyScheduleArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleMonthlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        start_month: NotRequired[pulumi.Input[str]]
        start_month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleQuartelyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 start_month: Optional[pulumi.Input[str]] = None,
                 start_month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if start_month is not None:
            pulumi.set(__self__, "start_month", start_month)
        if start_month_value is not None:
            pulumi.set(__self__, "start_month_value", start_month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="startMonth")
    def start_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month")

    @start_month.setter
    def start_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month", value)

    @property
    @pulumi.getter(name="startMonthValue")
    def start_month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "start_month_value")

    @start_month_value.setter
    def start_month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_month_value", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict(TypedDict):
        extra: NotRequired[pulumi.Input[bool]]
        hours: NotRequired[pulumi.Input[int]]
        minutes: NotRequired[pulumi.Input[int]]
        seconds: NotRequired[pulumi.Input[int]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleSnapshotTimeOfDayArgs:
    def __init__(__self__, *,
                 extra: Optional[pulumi.Input[bool]] = None,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        if extra is not None:
            pulumi.set(__self__, "extra", extra)
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def extra(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "extra")

    @extra.setter
    def extra(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "extra", value)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgsDict(TypedDict):
        day_of_week: NotRequired[pulumi.Input[str]]
        day_of_week_value: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleWeeklyScheduleArgs:
    def __init__(__self__, *,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgsDict(TypedDict):
        day_of_month: NotRequired[pulumi.Input[int]]
        enabled: NotRequired[pulumi.Input[bool]]
        month: NotRequired[pulumi.Input[str]]
        month_value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineScheduleYearlyScheduleArgs:
    def __init__(__self__, *,
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 month_value: Optional[pulumi.Input[str]] = None):
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if month_value is not None:
            pulumi.set(__self__, "month_value", month_value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="monthValue")
    def month_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "month_value")

    @month_value.setter
    def month_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month_value", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineSlaArgsDict(TypedDict):
        continuous_retention: NotRequired[pulumi.Input[int]]
        current_active_frequency: NotRequired[pulumi.Input[str]]
        daily_retention: NotRequired[pulumi.Input[int]]
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created for db instance
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified for instance
        """
        description: NotRequired[pulumi.Input[str]]
        """
        description of database instance
        """
        id: NotRequired[pulumi.Input[str]]
        monthly_retention: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        """
        Name of database instance
        """
        owner_id: NotRequired[pulumi.Input[str]]
        pitr_enabled: NotRequired[pulumi.Input[bool]]
        quarterly_retention: NotRequired[pulumi.Input[int]]
        reference_count: NotRequired[pulumi.Input[int]]
        system_sla: NotRequired[pulumi.Input[bool]]
        unique_name: NotRequired[pulumi.Input[str]]
        weekly_retention: NotRequired[pulumi.Input[int]]
        yearly_retention: NotRequired[pulumi.Input[int]]
elif False:
    NdbScaleDatabaseTimeMachineSlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineSlaArgs:
    def __init__(__self__, *,
                 continuous_retention: Optional[pulumi.Input[int]] = None,
                 current_active_frequency: Optional[pulumi.Input[str]] = None,
                 daily_retention: Optional[pulumi.Input[int]] = None,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 monthly_retention: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 pitr_enabled: Optional[pulumi.Input[bool]] = None,
                 quarterly_retention: Optional[pulumi.Input[int]] = None,
                 reference_count: Optional[pulumi.Input[int]] = None,
                 system_sla: Optional[pulumi.Input[bool]] = None,
                 unique_name: Optional[pulumi.Input[str]] = None,
                 weekly_retention: Optional[pulumi.Input[int]] = None,
                 yearly_retention: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] date_created: date created for db instance
        :param pulumi.Input[str] date_modified: date modified for instance
        :param pulumi.Input[str] description: description of database instance
        :param pulumi.Input[str] name: Name of database instance
        """
        if continuous_retention is not None:
            pulumi.set(__self__, "continuous_retention", continuous_retention)
        if current_active_frequency is not None:
            pulumi.set(__self__, "current_active_frequency", current_active_frequency)
        if daily_retention is not None:
            pulumi.set(__self__, "daily_retention", daily_retention)
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if monthly_retention is not None:
            pulumi.set(__self__, "monthly_retention", monthly_retention)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if pitr_enabled is not None:
            pulumi.set(__self__, "pitr_enabled", pitr_enabled)
        if quarterly_retention is not None:
            pulumi.set(__self__, "quarterly_retention", quarterly_retention)
        if reference_count is not None:
            pulumi.set(__self__, "reference_count", reference_count)
        if system_sla is not None:
            pulumi.set(__self__, "system_sla", system_sla)
        if unique_name is not None:
            pulumi.set(__self__, "unique_name", unique_name)
        if weekly_retention is not None:
            pulumi.set(__self__, "weekly_retention", weekly_retention)
        if yearly_retention is not None:
            pulumi.set(__self__, "yearly_retention", yearly_retention)

    @property
    @pulumi.getter(name="continuousRetention")
    def continuous_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "continuous_retention")

    @continuous_retention.setter
    def continuous_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "continuous_retention", value)

    @property
    @pulumi.getter(name="currentActiveFrequency")
    def current_active_frequency(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "current_active_frequency")

    @current_active_frequency.setter
    def current_active_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_active_frequency", value)

    @property
    @pulumi.getter(name="dailyRetention")
    def daily_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "daily_retention")

    @daily_retention.setter
    def daily_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "daily_retention", value)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created for db instance
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified for instance
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description of database instance
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="monthlyRetention")
    def monthly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monthly_retention")

    @monthly_retention.setter
    def monthly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monthly_retention", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of database instance
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="pitrEnabled")
    def pitr_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "pitr_enabled")

    @pitr_enabled.setter
    def pitr_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pitr_enabled", value)

    @property
    @pulumi.getter(name="quarterlyRetention")
    def quarterly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "quarterly_retention")

    @quarterly_retention.setter
    def quarterly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quarterly_retention", value)

    @property
    @pulumi.getter(name="referenceCount")
    def reference_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_count")

    @reference_count.setter
    def reference_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_count", value)

    @property
    @pulumi.getter(name="systemSla")
    def system_sla(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "system_sla")

    @system_sla.setter
    def system_sla(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "system_sla", value)

    @property
    @pulumi.getter(name="uniqueName")
    def unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "unique_name")

    @unique_name.setter
    def unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unique_name", value)

    @property
    @pulumi.getter(name="weeklyRetention")
    def weekly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weekly_retention")

    @weekly_retention.setter
    def weekly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weekly_retention", value)

    @property
    @pulumi.getter(name="yearlyRetention")
    def yearly_retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "yearly_retention")

    @yearly_retention.setter
    def yearly_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "yearly_retention", value)


if not MYPY:
    class NdbScaleDatabaseTimeMachineTagArgsDict(TypedDict):
        entity_id: NotRequired[pulumi.Input[str]]
        entity_type: NotRequired[pulumi.Input[str]]
        tag_id: NotRequired[pulumi.Input[str]]
        tag_name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbScaleDatabaseTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbScaleDatabaseTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: Optional[pulumi.Input[str]] = None,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 tag_id: Optional[pulumi.Input[str]] = None,
                 tag_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if entity_id is not None:
            pulumi.set(__self__, "entity_id", entity_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if tag_id is not None:
            pulumi.set(__self__, "tag_id", tag_id)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbSoftwareVersionProfilePostgresDatabaseArgsDict(TypedDict):
        db_software_notes: NotRequired[pulumi.Input[str]]
        """
        db software notes
        """
        os_notes: NotRequired[pulumi.Input[str]]
        """
        os notes for software profile
        """
        source_dbserver_id: NotRequired[pulumi.Input[str]]
        """
        source dbserver id
        """
elif False:
    NdbSoftwareVersionProfilePostgresDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbSoftwareVersionProfilePostgresDatabaseArgs:
    def __init__(__self__, *,
                 db_software_notes: Optional[pulumi.Input[str]] = None,
                 os_notes: Optional[pulumi.Input[str]] = None,
                 source_dbserver_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_software_notes: db software notes
        :param pulumi.Input[str] os_notes: os notes for software profile
        :param pulumi.Input[str] source_dbserver_id: source dbserver id
        """
        if db_software_notes is not None:
            pulumi.set(__self__, "db_software_notes", db_software_notes)
        if os_notes is not None:
            pulumi.set(__self__, "os_notes", os_notes)
        if source_dbserver_id is not None:
            pulumi.set(__self__, "source_dbserver_id", source_dbserver_id)

    @property
    @pulumi.getter(name="dbSoftwareNotes")
    def db_software_notes(self) -> Optional[pulumi.Input[str]]:
        """
        db software notes
        """
        return pulumi.get(self, "db_software_notes")

    @db_software_notes.setter
    def db_software_notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_software_notes", value)

    @property
    @pulumi.getter(name="osNotes")
    def os_notes(self) -> Optional[pulumi.Input[str]]:
        """
        os notes for software profile
        """
        return pulumi.get(self, "os_notes")

    @os_notes.setter
    def os_notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_notes", value)

    @property
    @pulumi.getter(name="sourceDbserverId")
    def source_dbserver_id(self) -> Optional[pulumi.Input[str]]:
        """
        source dbserver id
        """
        return pulumi.get(self, "source_dbserver_id")

    @source_dbserver_id.setter
    def source_dbserver_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dbserver_id", value)


if not MYPY:
    class NdbSoftwareVersionProfilePropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of profile
        """
        secure: NotRequired[pulumi.Input[bool]]
        """
        secure or not
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of property
        """
elif False:
    NdbSoftwareVersionProfilePropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbSoftwareVersionProfilePropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of profile
        :param pulumi.Input[bool] secure: secure or not
        :param pulumi.Input[str] value: value of property
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        secure or not
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbSoftwareVersionProfileVersionClusterAssociationArgsDict(TypedDict):
        date_created: NotRequired[pulumi.Input[str]]
        """
        date created of profile
        """
        date_modified: NotRequired[pulumi.Input[str]]
        """
        date modified of profile
        """
        nx_cluster_id: NotRequired[pulumi.Input[str]]
        """
        nutanix cluster id
        """
        optimized_for_provisioning: NotRequired[pulumi.Input[bool]]
        """
        version optimized for provisioning
        """
        owner_id: NotRequired[pulumi.Input[str]]
        """
        owner id
        """
        profile_version_id: NotRequired[pulumi.Input[str]]
        """
        profile version id
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgsDict']]]]
        """
        properties of software profile
        """
        status: NotRequired[pulumi.Input[str]]
        """
        status of profile. Allowed Values are "deprecated", "published", "unpublished"
        """
elif False:
    NdbSoftwareVersionProfileVersionClusterAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbSoftwareVersionProfileVersionClusterAssociationArgs:
    def __init__(__self__, *,
                 date_created: Optional[pulumi.Input[str]] = None,
                 date_modified: Optional[pulumi.Input[str]] = None,
                 nx_cluster_id: Optional[pulumi.Input[str]] = None,
                 optimized_for_provisioning: Optional[pulumi.Input[bool]] = None,
                 owner_id: Optional[pulumi.Input[str]] = None,
                 profile_version_id: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs']]]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] date_created: date created of profile
        :param pulumi.Input[str] date_modified: date modified of profile
        :param pulumi.Input[str] nx_cluster_id: nutanix cluster id
        :param pulumi.Input[bool] optimized_for_provisioning: version optimized for provisioning
        :param pulumi.Input[str] owner_id: owner id
        :param pulumi.Input[str] profile_version_id: profile version id
        :param pulumi.Input[Sequence[pulumi.Input['NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs']]] properties: properties of software profile
        :param pulumi.Input[str] status: status of profile. Allowed Values are "deprecated", "published", "unpublished"
        """
        if date_created is not None:
            pulumi.set(__self__, "date_created", date_created)
        if date_modified is not None:
            pulumi.set(__self__, "date_modified", date_modified)
        if nx_cluster_id is not None:
            pulumi.set(__self__, "nx_cluster_id", nx_cluster_id)
        if optimized_for_provisioning is not None:
            pulumi.set(__self__, "optimized_for_provisioning", optimized_for_provisioning)
        if owner_id is not None:
            pulumi.set(__self__, "owner_id", owner_id)
        if profile_version_id is not None:
            pulumi.set(__self__, "profile_version_id", profile_version_id)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dateCreated")
    def date_created(self) -> Optional[pulumi.Input[str]]:
        """
        date created of profile
        """
        return pulumi.get(self, "date_created")

    @date_created.setter
    def date_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_created", value)

    @property
    @pulumi.getter(name="dateModified")
    def date_modified(self) -> Optional[pulumi.Input[str]]:
        """
        date modified of profile
        """
        return pulumi.get(self, "date_modified")

    @date_modified.setter
    def date_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_modified", value)

    @property
    @pulumi.getter(name="nxClusterId")
    def nx_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        nutanix cluster id
        """
        return pulumi.get(self, "nx_cluster_id")

    @nx_cluster_id.setter
    def nx_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nx_cluster_id", value)

    @property
    @pulumi.getter(name="optimizedForProvisioning")
    def optimized_for_provisioning(self) -> Optional[pulumi.Input[bool]]:
        """
        version optimized for provisioning
        """
        return pulumi.get(self, "optimized_for_provisioning")

    @optimized_for_provisioning.setter
    def optimized_for_provisioning(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "optimized_for_provisioning", value)

    @property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> Optional[pulumi.Input[str]]:
        """
        owner id
        """
        return pulumi.get(self, "owner_id")

    @owner_id.setter
    def owner_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_id", value)

    @property
    @pulumi.getter(name="profileVersionId")
    def profile_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        profile version id
        """
        return pulumi.get(self, "profile_version_id")

    @profile_version_id.setter
    def profile_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "profile_version_id", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs']]]]:
        """
        properties of software profile
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of profile. Allowed Values are "deprecated", "published", "unpublished"
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of profile
        """
        secure: NotRequired[pulumi.Input[bool]]
        """
        secure or not
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of property
        """
elif False:
    NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbSoftwareVersionProfileVersionClusterAssociationPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of profile
        :param pulumi.Input[bool] secure: secure or not
        :param pulumi.Input[str] value: value of property
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of profile
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        """
        secure or not
        """
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of property
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NdbStretchedVlanMetadataArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input[str]]
        subnet_mask: NotRequired[pulumi.Input[str]]
elif False:
    NdbStretchedVlanMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbStretchedVlanMetadataArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 subnet_mask: Optional[pulumi.Input[str]] = None):
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if subnet_mask is not None:
            pulumi.set(__self__, "subnet_mask", subnet_mask)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask", value)


if not MYPY:
    class NdbStretchedVlanVlansListArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        cluster id where network is present
        """
        id: NotRequired[pulumi.Input[str]]
        """
        network id
        """
        managed: NotRequired[pulumi.Input[bool]]
        """
        network managed by NDB or not
        """
        name: NotRequired[pulumi.Input[str]]
        """
        name for the stretched VLAN
        """
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertyArgsDict']]]]
        """
        properties of network
        """
        properties_maps: NotRequired[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertiesMapArgsDict']]]]
        """
        properties map of network
        """
        stretched_vlan_id: NotRequired[pulumi.Input[str]]
        """
        stretched vlan id
        """
        type: NotRequired[pulumi.Input[str]]
        """
        type of vlan. static VLANs that are managed in NDB can be added to a stretched VLAN.
        """
elif False:
    NdbStretchedVlanVlansListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbStretchedVlanVlansListArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 managed: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertyArgs']]]] = None,
                 properties_maps: Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertiesMapArgs']]]] = None,
                 stretched_vlan_id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_id: cluster id where network is present
        :param pulumi.Input[str] id: network id
        :param pulumi.Input[bool] managed: network managed by NDB or not
        :param pulumi.Input[str] name: name for the stretched VLAN
        :param pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertyArgs']]] properties: properties of network
        :param pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertiesMapArgs']]] properties_maps: properties map of network
        :param pulumi.Input[str] stretched_vlan_id: stretched vlan id
        :param pulumi.Input[str] type: type of vlan. static VLANs that are managed in NDB can be added to a stretched VLAN.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if managed is not None:
            pulumi.set(__self__, "managed", managed)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if properties_maps is not None:
            pulumi.set(__self__, "properties_maps", properties_maps)
        if stretched_vlan_id is not None:
            pulumi.set(__self__, "stretched_vlan_id", stretched_vlan_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        cluster id where network is present
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        network id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def managed(self) -> Optional[pulumi.Input[bool]]:
        """
        network managed by NDB or not
        """
        return pulumi.get(self, "managed")

    @managed.setter
    def managed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "managed", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name for the stretched VLAN
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertyArgs']]]]:
        """
        properties of network
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertyArgs']]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="propertiesMaps")
    def properties_maps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertiesMapArgs']]]]:
        """
        properties map of network
        """
        return pulumi.get(self, "properties_maps")

    @properties_maps.setter
    def properties_maps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NdbStretchedVlanVlansListPropertiesMapArgs']]]]):
        pulumi.set(self, "properties_maps", value)

    @property
    @pulumi.getter(name="stretchedVlanId")
    def stretched_vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        stretched vlan id
        """
        return pulumi.get(self, "stretched_vlan_id")

    @stretched_vlan_id.setter
    def stretched_vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stretched_vlan_id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        type of vlan. static VLANs that are managed in NDB can be added to a stretched VLAN.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NdbStretchedVlanVlansListPropertiesMapArgsDict(TypedDict):
        vlan_gateway: NotRequired[pulumi.Input[str]]
        """
        gateway of vlan
        """
        vlan_primary_dns: NotRequired[pulumi.Input[str]]
        """
        primary dns of vlan
        """
        vlan_secondary_dns: NotRequired[pulumi.Input[str]]
        """
        secondary dns of vlan
        """
        vlan_subnet_mask: NotRequired[pulumi.Input[str]]
        """
        subnet mask of vlan
        """
elif False:
    NdbStretchedVlanVlansListPropertiesMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbStretchedVlanVlansListPropertiesMapArgs:
    def __init__(__self__, *,
                 vlan_gateway: Optional[pulumi.Input[str]] = None,
                 vlan_primary_dns: Optional[pulumi.Input[str]] = None,
                 vlan_secondary_dns: Optional[pulumi.Input[str]] = None,
                 vlan_subnet_mask: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] vlan_gateway: gateway of vlan
        :param pulumi.Input[str] vlan_primary_dns: primary dns of vlan
        :param pulumi.Input[str] vlan_secondary_dns: secondary dns of vlan
        :param pulumi.Input[str] vlan_subnet_mask: subnet mask of vlan
        """
        if vlan_gateway is not None:
            pulumi.set(__self__, "vlan_gateway", vlan_gateway)
        if vlan_primary_dns is not None:
            pulumi.set(__self__, "vlan_primary_dns", vlan_primary_dns)
        if vlan_secondary_dns is not None:
            pulumi.set(__self__, "vlan_secondary_dns", vlan_secondary_dns)
        if vlan_subnet_mask is not None:
            pulumi.set(__self__, "vlan_subnet_mask", vlan_subnet_mask)

    @property
    @pulumi.getter(name="vlanGateway")
    def vlan_gateway(self) -> Optional[pulumi.Input[str]]:
        """
        gateway of vlan
        """
        return pulumi.get(self, "vlan_gateway")

    @vlan_gateway.setter
    def vlan_gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_gateway", value)

    @property
    @pulumi.getter(name="vlanPrimaryDns")
    def vlan_primary_dns(self) -> Optional[pulumi.Input[str]]:
        """
        primary dns of vlan
        """
        return pulumi.get(self, "vlan_primary_dns")

    @vlan_primary_dns.setter
    def vlan_primary_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_primary_dns", value)

    @property
    @pulumi.getter(name="vlanSecondaryDns")
    def vlan_secondary_dns(self) -> Optional[pulumi.Input[str]]:
        """
        secondary dns of vlan
        """
        return pulumi.get(self, "vlan_secondary_dns")

    @vlan_secondary_dns.setter
    def vlan_secondary_dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_secondary_dns", value)

    @property
    @pulumi.getter(name="vlanSubnetMask")
    def vlan_subnet_mask(self) -> Optional[pulumi.Input[str]]:
        """
        subnet mask of vlan
        """
        return pulumi.get(self, "vlan_subnet_mask")

    @vlan_subnet_mask.setter
    def vlan_subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_subnet_mask", value)


if not MYPY:
    class NdbStretchedVlanVlansListPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        name for the stretched VLAN
        """
        secure: NotRequired[pulumi.Input[bool]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NdbStretchedVlanVlansListPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NdbStretchedVlanVlansListPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 secure: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: name for the stretched VLAN
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        name for the stretched VLAN
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def secure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "secure")

    @secure.setter
    def secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secure", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkSecurityPolicyV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityPolicyV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleArgsDict(TypedDict):
        specs: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecArgsDict']]]
        """
        Spec for rules.
        """
        type: pulumi.Input[str]
        """
        The type for a rulethe value chosen here restricts which specification can be chosen. Acceptable values are "QUARANTINE", "TWO_ENV_ISOLATION", "APPLICATION", "INTRA_GROUP".
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A user defined annotation for a rule.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
elif False:
    NetworkSecurityPolicyV2RuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleArgs:
    def __init__(__self__, *,
                 specs: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecArgs']]],
                 type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleLinkArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecArgs']]] specs: Spec for rules.
        :param pulumi.Input[str] type: The type for a rulethe value chosen here restricts which specification can be chosen. Acceptable values are "QUARANTINE", "TWO_ENV_ISOLATION", "APPLICATION", "INTRA_GROUP".
        :param pulumi.Input[str] description: A user defined annotation for a rule.
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        pulumi.set(__self__, "specs", specs)
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)

    @property
    @pulumi.getter
    def specs(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecArgs']]]:
        """
        Spec for rules.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecArgs']]]):
        pulumi.set(self, "specs", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type for a rulethe value chosen here restricts which specification can be chosen. Acceptable values are "QUARANTINE", "TWO_ENV_ISOLATION", "APPLICATION", "INTRA_GROUP".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A user defined annotation for a rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleLinkArgs']]]]):
        pulumi.set(self, "links", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityPolicyV2RuleLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecArgsDict(TypedDict):
        application_rule_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgsDict']]]]
        """
        Application Rule Spec.
        """
        intra_entity_group_rule_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgsDict']]]]
        """
        Intra entity group Rule Spec
        """
        multi_env_isolation_rule_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgsDict']]]]
        """
        Multi Environment Isolation Rule Spec.
        """
        two_env_isolation_rule_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgsDict']]]]
        """
        Two Environment Isolation Rule Spec.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecArgs:
    def __init__(__self__, *,
                 application_rule_specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs']]]] = None,
                 intra_entity_group_rule_specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs']]]] = None,
                 multi_env_isolation_rule_specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs']]]] = None,
                 two_env_isolation_rule_specs: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs']]] application_rule_specs: Application Rule Spec.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs']]] intra_entity_group_rule_specs: Intra entity group Rule Spec
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs']]] multi_env_isolation_rule_specs: Multi Environment Isolation Rule Spec.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs']]] two_env_isolation_rule_specs: Two Environment Isolation Rule Spec.
        """
        if application_rule_specs is not None:
            pulumi.set(__self__, "application_rule_specs", application_rule_specs)
        if intra_entity_group_rule_specs is not None:
            pulumi.set(__self__, "intra_entity_group_rule_specs", intra_entity_group_rule_specs)
        if multi_env_isolation_rule_specs is not None:
            pulumi.set(__self__, "multi_env_isolation_rule_specs", multi_env_isolation_rule_specs)
        if two_env_isolation_rule_specs is not None:
            pulumi.set(__self__, "two_env_isolation_rule_specs", two_env_isolation_rule_specs)

    @property
    @pulumi.getter(name="applicationRuleSpecs")
    def application_rule_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs']]]]:
        """
        Application Rule Spec.
        """
        return pulumi.get(self, "application_rule_specs")

    @application_rule_specs.setter
    def application_rule_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs']]]]):
        pulumi.set(self, "application_rule_specs", value)

    @property
    @pulumi.getter(name="intraEntityGroupRuleSpecs")
    def intra_entity_group_rule_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs']]]]:
        """
        Intra entity group Rule Spec
        """
        return pulumi.get(self, "intra_entity_group_rule_specs")

    @intra_entity_group_rule_specs.setter
    def intra_entity_group_rule_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs']]]]):
        pulumi.set(self, "intra_entity_group_rule_specs", value)

    @property
    @pulumi.getter(name="multiEnvIsolationRuleSpecs")
    def multi_env_isolation_rule_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs']]]]:
        """
        Multi Environment Isolation Rule Spec.
        """
        return pulumi.get(self, "multi_env_isolation_rule_specs")

    @multi_env_isolation_rule_specs.setter
    def multi_env_isolation_rule_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs']]]]):
        pulumi.set(self, "multi_env_isolation_rule_specs", value)

    @property
    @pulumi.getter(name="twoEnvIsolationRuleSpecs")
    def two_env_isolation_rule_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs']]]]:
        """
        Two Environment Isolation Rule Spec.
        """
        return pulumi.get(self, "two_env_isolation_rule_specs")

    @two_env_isolation_rule_specs.setter
    def two_env_isolation_rule_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs']]]]):
        pulumi.set(self, "two_env_isolation_rule_specs", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgsDict(TypedDict):
        secured_group_category_references: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
        """
        dest_address_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of address group references.
        """
        dest_allow_spec: NotRequired[pulumi.Input[str]]
        """
        A specification to how allow mode traffic should be applied, either ALL or NONE.
        """
        dest_category_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of categories that define a set of network endpoints as outbound.
        """
        dest_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgsDict']]]]
        """
        destination subnet value
        """
        icmp_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgsDict']]]]
        """
        icmp services
        """
        is_all_protocol_allowed: NotRequired[pulumi.Input[bool]]
        """
        Denotes if rule allows traffic for all protocol.
        """
        network_function_chain_reference: NotRequired[pulumi.Input[str]]
        """
        A reference to the network function chain in the rule.
        """
        service_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of service group references.
        """
        src_address_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of address group references.
        """
        src_allow_spec: NotRequired[pulumi.Input[str]]
        """
        A specification to how allow mode traffic should be applied, either ALL or NONE.
        """
        src_category_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of categories that define a set of network endpoints as inbound.
        """
        src_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgsDict']]]]
        """
        source subnet value
        """
        tcp_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgsDict']]]]
        """
        tcp services
        """
        udp_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgsDict']]]]
        """
        udp services
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecArgs:
    def __init__(__self__, *,
                 secured_group_category_references: pulumi.Input[Sequence[pulumi.Input[str]]],
                 dest_address_group_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dest_allow_spec: Optional[pulumi.Input[str]] = None,
                 dest_category_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dest_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs']]]] = None,
                 icmp_services: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs']]]] = None,
                 is_all_protocol_allowed: Optional[pulumi.Input[bool]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[str]] = None,
                 service_group_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 src_address_group_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 src_allow_spec: Optional[pulumi.Input[str]] = None,
                 src_category_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 src_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs']]]] = None,
                 tcp_services: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs']]]] = None,
                 udp_services: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] secured_group_category_references: A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dest_address_group_references: A list of address group references.
        :param pulumi.Input[str] dest_allow_spec: A specification to how allow mode traffic should be applied, either ALL or NONE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dest_category_references: List of categories that define a set of network endpoints as outbound.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs']]] dest_subnets: destination subnet value
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs']]] icmp_services: icmp services
        :param pulumi.Input[bool] is_all_protocol_allowed: Denotes if rule allows traffic for all protocol.
        :param pulumi.Input[str] network_function_chain_reference: A reference to the network function chain in the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_group_references: A list of service group references.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] src_address_group_references: A list of address group references.
        :param pulumi.Input[str] src_allow_spec: A specification to how allow mode traffic should be applied, either ALL or NONE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] src_category_references: List of categories that define a set of network endpoints as inbound.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs']]] src_subnets: source subnet value
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs']]] tcp_services: tcp services
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs']]] udp_services: udp services
        """
        pulumi.set(__self__, "secured_group_category_references", secured_group_category_references)
        if dest_address_group_references is not None:
            pulumi.set(__self__, "dest_address_group_references", dest_address_group_references)
        if dest_allow_spec is not None:
            pulumi.set(__self__, "dest_allow_spec", dest_allow_spec)
        if dest_category_references is not None:
            pulumi.set(__self__, "dest_category_references", dest_category_references)
        if dest_subnets is not None:
            pulumi.set(__self__, "dest_subnets", dest_subnets)
        if icmp_services is not None:
            pulumi.set(__self__, "icmp_services", icmp_services)
        if is_all_protocol_allowed is not None:
            pulumi.set(__self__, "is_all_protocol_allowed", is_all_protocol_allowed)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if service_group_references is not None:
            pulumi.set(__self__, "service_group_references", service_group_references)
        if src_address_group_references is not None:
            pulumi.set(__self__, "src_address_group_references", src_address_group_references)
        if src_allow_spec is not None:
            pulumi.set(__self__, "src_allow_spec", src_allow_spec)
        if src_category_references is not None:
            pulumi.set(__self__, "src_category_references", src_category_references)
        if src_subnets is not None:
            pulumi.set(__self__, "src_subnets", src_subnets)
        if tcp_services is not None:
            pulumi.set(__self__, "tcp_services", tcp_services)
        if udp_services is not None:
            pulumi.set(__self__, "udp_services", udp_services)

    @property
    @pulumi.getter(name="securedGroupCategoryReferences")
    def secured_group_category_references(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of network endpoints which is protected by a Network Security Policy and defined as a list of categories.
        """
        return pulumi.get(self, "secured_group_category_references")

    @secured_group_category_references.setter
    def secured_group_category_references(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "secured_group_category_references", value)

    @property
    @pulumi.getter(name="destAddressGroupReferences")
    def dest_address_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of address group references.
        """
        return pulumi.get(self, "dest_address_group_references")

    @dest_address_group_references.setter
    def dest_address_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dest_address_group_references", value)

    @property
    @pulumi.getter(name="destAllowSpec")
    def dest_allow_spec(self) -> Optional[pulumi.Input[str]]:
        """
        A specification to how allow mode traffic should be applied, either ALL or NONE.
        """
        return pulumi.get(self, "dest_allow_spec")

    @dest_allow_spec.setter
    def dest_allow_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dest_allow_spec", value)

    @property
    @pulumi.getter(name="destCategoryReferences")
    def dest_category_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of categories that define a set of network endpoints as outbound.
        """
        return pulumi.get(self, "dest_category_references")

    @dest_category_references.setter
    def dest_category_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dest_category_references", value)

    @property
    @pulumi.getter(name="destSubnets")
    def dest_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs']]]]:
        """
        destination subnet value
        """
        return pulumi.get(self, "dest_subnets")

    @dest_subnets.setter
    def dest_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs']]]]):
        pulumi.set(self, "dest_subnets", value)

    @property
    @pulumi.getter(name="icmpServices")
    def icmp_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs']]]]:
        """
        icmp services
        """
        return pulumi.get(self, "icmp_services")

    @icmp_services.setter
    def icmp_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs']]]]):
        pulumi.set(self, "icmp_services", value)

    @property
    @pulumi.getter(name="isAllProtocolAllowed")
    def is_all_protocol_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes if rule allows traffic for all protocol.
        """
        return pulumi.get(self, "is_all_protocol_allowed")

    @is_all_protocol_allowed.setter
    def is_all_protocol_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_all_protocol_allowed", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[str]]:
        """
        A reference to the network function chain in the rule.
        """
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="serviceGroupReferences")
    def service_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of service group references.
        """
        return pulumi.get(self, "service_group_references")

    @service_group_references.setter
    def service_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_group_references", value)

    @property
    @pulumi.getter(name="srcAddressGroupReferences")
    def src_address_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of address group references.
        """
        return pulumi.get(self, "src_address_group_references")

    @src_address_group_references.setter
    def src_address_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "src_address_group_references", value)

    @property
    @pulumi.getter(name="srcAllowSpec")
    def src_allow_spec(self) -> Optional[pulumi.Input[str]]:
        """
        A specification to how allow mode traffic should be applied, either ALL or NONE.
        """
        return pulumi.get(self, "src_allow_spec")

    @src_allow_spec.setter
    def src_allow_spec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_allow_spec", value)

    @property
    @pulumi.getter(name="srcCategoryReferences")
    def src_category_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of categories that define a set of network endpoints as inbound.
        """
        return pulumi.get(self, "src_category_references")

    @src_category_references.setter
    def src_category_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "src_category_references", value)

    @property
    @pulumi.getter(name="srcSubnets")
    def src_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs']]]]:
        """
        source subnet value
        """
        return pulumi.get(self, "src_subnets")

    @src_subnets.setter
    def src_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs']]]]):
        pulumi.set(self, "src_subnets", value)

    @property
    @pulumi.getter(name="tcpServices")
    def tcp_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs']]]]:
        """
        tcp services
        """
        return pulumi.get(self, "tcp_services")

    @tcp_services.setter
    def tcp_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs']]]]):
        pulumi.set(self, "tcp_services", value)

    @property
    @pulumi.getter(name="udpServices")
    def udp_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs']]]]:
        """
        udp services
        """
        return pulumi.get(self, "udp_services")

    @udp_services.setter
    def udp_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs']]]]):
        pulumi.set(self, "udp_services", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecDestSubnetArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        Icmp service Code. Ignore this field if Code has to be ANY.
        """
        is_all_allowed: NotRequired[pulumi.Input[bool]]
        """
        Set this field to true if both Type and Code is ANY.
        """
        type: NotRequired[pulumi.Input[int]]
        """
        Icmp service Type. Ignore this field if Type has to be ANY.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecIcmpServiceArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 is_all_allowed: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] code: Icmp service Code. Ignore this field if Code has to be ANY.
        :param pulumi.Input[bool] is_all_allowed: Set this field to true if both Type and Code is ANY.
        :param pulumi.Input[int] type: Icmp service Type. Ignore this field if Type has to be ANY.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if is_all_allowed is not None:
            pulumi.set(__self__, "is_all_allowed", is_all_allowed)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        Icmp service Code. Ignore this field if Code has to be ANY.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="isAllAllowed")
    def is_all_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this field to true if both Type and Code is ANY.
        """
        return pulumi.get(self, "is_all_allowed")

    @is_all_allowed.setter
    def is_all_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_all_allowed", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        """
        Icmp service Type. Ignore this field if Type has to be ANY.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecSrcSubnetArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        """
        end port
        """
        start_port: pulumi.Input[int]
        """
        start port
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecTcpServiceArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end_port: end port
        :param pulumi.Input[int] start_port: start port
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        """
        end port
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        start port
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        """
        end port
        """
        start_port: pulumi.Input[int]
        """
        start port
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecApplicationRuleSpecUdpServiceArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end_port: end port
        :param pulumi.Input[int] start_port: start port
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        """
        end port
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        start port
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgsDict(TypedDict):
        secured_group_action: NotRequired[pulumi.Input[str]]
        """
        List of secured group action.
        """
        secured_group_category_references: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A specification to whether traffic between intra secured group entities should be allowed or denied.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecIntraEntityGroupRuleSpecArgs:
    def __init__(__self__, *,
                 secured_group_action: Optional[pulumi.Input[str]] = None,
                 secured_group_category_references: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] secured_group_action: List of secured group action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] secured_group_category_references: A specification to whether traffic between intra secured group entities should be allowed or denied.
        """
        if secured_group_action is not None:
            pulumi.set(__self__, "secured_group_action", secured_group_action)
        if secured_group_category_references is not None:
            pulumi.set(__self__, "secured_group_category_references", secured_group_category_references)

    @property
    @pulumi.getter(name="securedGroupAction")
    def secured_group_action(self) -> Optional[pulumi.Input[str]]:
        """
        List of secured group action.
        """
        return pulumi.get(self, "secured_group_action")

    @secured_group_action.setter
    def secured_group_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secured_group_action", value)

    @property
    @pulumi.getter(name="securedGroupCategoryReferences")
    def secured_group_category_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A specification to whether traffic between intra secured group entities should be allowed or denied.
        """
        return pulumi.get(self, "secured_group_category_references")

    @secured_group_category_references.setter
    def secured_group_category_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "secured_group_category_references", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgsDict(TypedDict):
        specs: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgsDict']]]
        """
        Multi Environment Isolation Rule Spec.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecArgs:
    def __init__(__self__, *,
                 specs: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs']]] specs: Multi Environment Isolation Rule Spec.
        """
        pulumi.set(__self__, "specs", specs)

    @property
    @pulumi.getter
    def specs(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs']]]:
        """
        Multi Environment Isolation Rule Spec.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs']]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgsDict(TypedDict):
        all_to_all_isolation_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgsDict']]]]
        """
        all to all isolation groups
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecArgs:
    def __init__(__self__, *,
                 all_to_all_isolation_groups: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs']]] all_to_all_isolation_groups: all to all isolation groups
        """
        if all_to_all_isolation_groups is not None:
            pulumi.set(__self__, "all_to_all_isolation_groups", all_to_all_isolation_groups)

    @property
    @pulumi.getter(name="allToAllIsolationGroups")
    def all_to_all_isolation_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs']]]]:
        """
        all to all isolation groups
        """
        return pulumi.get(self, "all_to_all_isolation_groups")

    @all_to_all_isolation_groups.setter
    def all_to_all_isolation_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs']]]]):
        pulumi.set(self, "all_to_all_isolation_groups", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgsDict(TypedDict):
        isolation_groups: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgsDict']]]
        """
        Denotes the list of secured groups that will be used in All to All mutual isolation.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupArgs:
    def __init__(__self__, *,
                 isolation_groups: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs']]] isolation_groups: Denotes the list of secured groups that will be used in All to All mutual isolation.
        """
        pulumi.set(__self__, "isolation_groups", isolation_groups)

    @property
    @pulumi.getter(name="isolationGroups")
    def isolation_groups(self) -> pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs']]]:
        """
        Denotes the list of secured groups that will be used in All to All mutual isolation.
        """
        return pulumi.get(self, "isolation_groups")

    @isolation_groups.setter
    def isolation_groups(self, value: pulumi.Input[Sequence[pulumi.Input['NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs']]]):
        pulumi.set(self, "isolation_groups", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgsDict(TypedDict):
        group_category_references: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        External identifiers of categories belonging to the isolation group.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecMultiEnvIsolationRuleSpecSpecAllToAllIsolationGroupIsolationGroupArgs:
    def __init__(__self__, *,
                 group_category_references: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_category_references: External identifiers of categories belonging to the isolation group.
        """
        pulumi.set(__self__, "group_category_references", group_category_references)

    @property
    @pulumi.getter(name="groupCategoryReferences")
    def group_category_references(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        External identifiers of categories belonging to the isolation group.
        """
        return pulumi.get(self, "group_category_references")

    @group_category_references.setter
    def group_category_references(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "group_category_references", value)


if not MYPY:
    class NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgsDict(TypedDict):
        first_isolation_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Denotes the first group of category uuids that will be used in an isolation policy.
        """
        second_isolation_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Denotes the second group of category uuids that will be used in an isolation policy.
        """
elif False:
    NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityPolicyV2RuleSpecTwoEnvIsolationRuleSpecArgs:
    def __init__(__self__, *,
                 first_isolation_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 second_isolation_groups: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] first_isolation_groups: Denotes the first group of category uuids that will be used in an isolation policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] second_isolation_groups: Denotes the second group of category uuids that will be used in an isolation policy.
        """
        pulumi.set(__self__, "first_isolation_groups", first_isolation_groups)
        pulumi.set(__self__, "second_isolation_groups", second_isolation_groups)

    @property
    @pulumi.getter(name="firstIsolationGroups")
    def first_isolation_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Denotes the first group of category uuids that will be used in an isolation policy.
        """
        return pulumi.get(self, "first_isolation_groups")

    @first_isolation_groups.setter
    def first_isolation_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "first_isolation_groups", value)

    @property
    @pulumi.getter(name="secondIsolationGroups")
    def second_isolation_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Denotes the second group of category uuids that will be used in an isolation policy.
        """
        return pulumi.get(self, "second_isolation_groups")

    @second_isolation_groups.setter
    def second_isolation_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "second_isolation_groups", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListArgsDict(TypedDict):
        address_group_inclusion_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgsDict']]]]
        expiration_time: NotRequired[pulumi.Input[str]]
        filter_kind_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        filter_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgsDict']]]]
        filter_type: NotRequired[pulumi.Input[str]]
        icmp_type_code_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgsDict']]]]
        ip_subnet: NotRequired[pulumi.Input[str]]
        ip_subnet_prefix_length: NotRequired[pulumi.Input[str]]
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        peer_specification_type: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_group_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgsDict']]]]
        tcp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgsDict']]]]
        udp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgsDict']]]]
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListArgs:
    def __init__(__self__, *,
                 address_group_inclusion_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgs']]]] = None,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 filter_kind_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 filter_params: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgs']]]] = None,
                 filter_type: Optional[pulumi.Input[str]] = None,
                 icmp_type_code_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgs']]]] = None,
                 ip_subnet: Optional[pulumi.Input[str]] = None,
                 ip_subnet_prefix_length: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 peer_specification_type: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgs']]]] = None,
                 tcp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgs']]]] = None,
                 udp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgs']]]] = None):
        if address_group_inclusion_lists is not None:
            pulumi.set(__self__, "address_group_inclusion_lists", address_group_inclusion_lists)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if filter_kind_lists is not None:
            pulumi.set(__self__, "filter_kind_lists", filter_kind_lists)
        if filter_params is not None:
            pulumi.set(__self__, "filter_params", filter_params)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if icmp_type_code_lists is not None:
            pulumi.set(__self__, "icmp_type_code_lists", icmp_type_code_lists)
        if ip_subnet is not None:
            pulumi.set(__self__, "ip_subnet", ip_subnet)
        if ip_subnet_prefix_length is not None:
            pulumi.set(__self__, "ip_subnet_prefix_length", ip_subnet_prefix_length)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if peer_specification_type is not None:
            pulumi.set(__self__, "peer_specification_type", peer_specification_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_group_lists is not None:
            pulumi.set(__self__, "service_group_lists", service_group_lists)
        if tcp_port_range_lists is not None:
            pulumi.set(__self__, "tcp_port_range_lists", tcp_port_range_lists)
        if udp_port_range_lists is not None:
            pulumi.set(__self__, "udp_port_range_lists", udp_port_range_lists)

    @property
    @pulumi.getter(name="addressGroupInclusionLists")
    def address_group_inclusion_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgs']]]]:
        return pulumi.get(self, "address_group_inclusion_lists")

    @address_group_inclusion_lists.setter
    def address_group_inclusion_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgs']]]]):
        pulumi.set(self, "address_group_inclusion_lists", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="filterKindLists")
    def filter_kind_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_kind_lists")

    @filter_kind_lists.setter
    def filter_kind_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_kind_lists", value)

    @property
    @pulumi.getter(name="filterParams")
    def filter_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgs']]]]:
        return pulumi.get(self, "filter_params")

    @filter_params.setter
    def filter_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgs']]]]):
        pulumi.set(self, "filter_params", value)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter(name="icmpTypeCodeLists")
    def icmp_type_code_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgs']]]]:
        return pulumi.get(self, "icmp_type_code_lists")

    @icmp_type_code_lists.setter
    def icmp_type_code_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgs']]]]):
        pulumi.set(self, "icmp_type_code_lists", value)

    @property
    @pulumi.getter(name="ipSubnet")
    def ip_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet")

    @ip_subnet.setter
    def ip_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet", value)

    @property
    @pulumi.getter(name="ipSubnetPrefixLength")
    def ip_subnet_prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet_prefix_length")

    @ip_subnet_prefix_length.setter
    def ip_subnet_prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet_prefix_length", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="peerSpecificationType")
    def peer_specification_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "peer_specification_type")

    @peer_specification_type.setter
    def peer_specification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "peer_specification_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceGroupLists")
    def service_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgs']]]]:
        return pulumi.get(self, "service_group_lists")

    @service_group_lists.setter
    def service_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgs']]]]):
        pulumi.set(self, "service_group_lists", value)

    @property
    @pulumi.getter(name="tcpPortRangeLists")
    def tcp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgs']]]]:
        return pulumi.get(self, "tcp_port_range_lists")

    @tcp_port_range_lists.setter
    def tcp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgs']]]]):
        pulumi.set(self, "tcp_port_range_lists", value)

    @property
    @pulumi.getter(name="udpPortRangeLists")
    def udp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgs']]]]:
        return pulumi.get(self, "udp_port_range_lists")

    @udp_port_range_lists.setter
    def udp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgs']]]]):
        pulumi.set(self, "udp_port_range_lists", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListAddressGroupInclusionListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListIcmpTypeCodeListArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListServiceGroupListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListTcpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleInboundAllowListUdpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListArgsDict(TypedDict):
        address_group_inclusion_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgsDict']]]]
        expiration_time: NotRequired[pulumi.Input[str]]
        filter_kind_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        filter_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgsDict']]]]
        filter_type: NotRequired[pulumi.Input[str]]
        icmp_type_code_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgsDict']]]]
        ip_subnet: NotRequired[pulumi.Input[str]]
        ip_subnet_prefix_length: NotRequired[pulumi.Input[str]]
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        peer_specification_type: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_group_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgsDict']]]]
        tcp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgsDict']]]]
        udp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgsDict']]]]
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListArgs:
    def __init__(__self__, *,
                 address_group_inclusion_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgs']]]] = None,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 filter_kind_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 filter_params: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgs']]]] = None,
                 filter_type: Optional[pulumi.Input[str]] = None,
                 icmp_type_code_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgs']]]] = None,
                 ip_subnet: Optional[pulumi.Input[str]] = None,
                 ip_subnet_prefix_length: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 peer_specification_type: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgs']]]] = None,
                 tcp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgs']]]] = None,
                 udp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgs']]]] = None):
        if address_group_inclusion_lists is not None:
            pulumi.set(__self__, "address_group_inclusion_lists", address_group_inclusion_lists)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if filter_kind_lists is not None:
            pulumi.set(__self__, "filter_kind_lists", filter_kind_lists)
        if filter_params is not None:
            pulumi.set(__self__, "filter_params", filter_params)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if icmp_type_code_lists is not None:
            pulumi.set(__self__, "icmp_type_code_lists", icmp_type_code_lists)
        if ip_subnet is not None:
            pulumi.set(__self__, "ip_subnet", ip_subnet)
        if ip_subnet_prefix_length is not None:
            pulumi.set(__self__, "ip_subnet_prefix_length", ip_subnet_prefix_length)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if peer_specification_type is not None:
            pulumi.set(__self__, "peer_specification_type", peer_specification_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_group_lists is not None:
            pulumi.set(__self__, "service_group_lists", service_group_lists)
        if tcp_port_range_lists is not None:
            pulumi.set(__self__, "tcp_port_range_lists", tcp_port_range_lists)
        if udp_port_range_lists is not None:
            pulumi.set(__self__, "udp_port_range_lists", udp_port_range_lists)

    @property
    @pulumi.getter(name="addressGroupInclusionLists")
    def address_group_inclusion_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgs']]]]:
        return pulumi.get(self, "address_group_inclusion_lists")

    @address_group_inclusion_lists.setter
    def address_group_inclusion_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgs']]]]):
        pulumi.set(self, "address_group_inclusion_lists", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="filterKindLists")
    def filter_kind_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_kind_lists")

    @filter_kind_lists.setter
    def filter_kind_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_kind_lists", value)

    @property
    @pulumi.getter(name="filterParams")
    def filter_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgs']]]]:
        return pulumi.get(self, "filter_params")

    @filter_params.setter
    def filter_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgs']]]]):
        pulumi.set(self, "filter_params", value)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter(name="icmpTypeCodeLists")
    def icmp_type_code_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgs']]]]:
        return pulumi.get(self, "icmp_type_code_lists")

    @icmp_type_code_lists.setter
    def icmp_type_code_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgs']]]]):
        pulumi.set(self, "icmp_type_code_lists", value)

    @property
    @pulumi.getter(name="ipSubnet")
    def ip_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet")

    @ip_subnet.setter
    def ip_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet", value)

    @property
    @pulumi.getter(name="ipSubnetPrefixLength")
    def ip_subnet_prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet_prefix_length")

    @ip_subnet_prefix_length.setter
    def ip_subnet_prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet_prefix_length", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="peerSpecificationType")
    def peer_specification_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "peer_specification_type")

    @peer_specification_type.setter
    def peer_specification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "peer_specification_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceGroupLists")
    def service_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgs']]]]:
        return pulumi.get(self, "service_group_lists")

    @service_group_lists.setter
    def service_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgs']]]]):
        pulumi.set(self, "service_group_lists", value)

    @property
    @pulumi.getter(name="tcpPortRangeLists")
    def tcp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgs']]]]:
        return pulumi.get(self, "tcp_port_range_lists")

    @tcp_port_range_lists.setter
    def tcp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgs']]]]):
        pulumi.set(self, "tcp_port_range_lists", value)

    @property
    @pulumi.getter(name="udpPortRangeLists")
    def udp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgs']]]]:
        return pulumi.get(self, "udp_port_range_lists")

    @udp_port_range_lists.setter
    def udp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgs']]]]):
        pulumi.set(self, "udp_port_range_lists", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListAddressGroupInclusionListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListIcmpTypeCodeListArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListServiceGroupListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListTcpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleOutboundAllowListUdpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAdRuleTargetGroupFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAdRuleTargetGroupFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAdRuleTargetGroupFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListArgsDict(TypedDict):
        address_group_inclusion_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgsDict']]]]
        expiration_time: NotRequired[pulumi.Input[str]]
        filter_kind_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        filter_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgsDict']]]]
        filter_type: NotRequired[pulumi.Input[str]]
        icmp_type_code_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgsDict']]]]
        ip_subnet: NotRequired[pulumi.Input[str]]
        ip_subnet_prefix_length: NotRequired[pulumi.Input[str]]
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        peer_specification_type: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_group_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgsDict']]]]
        tcp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgsDict']]]]
        udp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgsDict']]]]
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListArgs:
    def __init__(__self__, *,
                 address_group_inclusion_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgs']]]] = None,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 filter_kind_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 filter_params: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgs']]]] = None,
                 filter_type: Optional[pulumi.Input[str]] = None,
                 icmp_type_code_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgs']]]] = None,
                 ip_subnet: Optional[pulumi.Input[str]] = None,
                 ip_subnet_prefix_length: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 peer_specification_type: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgs']]]] = None,
                 tcp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgs']]]] = None,
                 udp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgs']]]] = None):
        if address_group_inclusion_lists is not None:
            pulumi.set(__self__, "address_group_inclusion_lists", address_group_inclusion_lists)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if filter_kind_lists is not None:
            pulumi.set(__self__, "filter_kind_lists", filter_kind_lists)
        if filter_params is not None:
            pulumi.set(__self__, "filter_params", filter_params)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if icmp_type_code_lists is not None:
            pulumi.set(__self__, "icmp_type_code_lists", icmp_type_code_lists)
        if ip_subnet is not None:
            pulumi.set(__self__, "ip_subnet", ip_subnet)
        if ip_subnet_prefix_length is not None:
            pulumi.set(__self__, "ip_subnet_prefix_length", ip_subnet_prefix_length)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if peer_specification_type is not None:
            pulumi.set(__self__, "peer_specification_type", peer_specification_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_group_lists is not None:
            pulumi.set(__self__, "service_group_lists", service_group_lists)
        if tcp_port_range_lists is not None:
            pulumi.set(__self__, "tcp_port_range_lists", tcp_port_range_lists)
        if udp_port_range_lists is not None:
            pulumi.set(__self__, "udp_port_range_lists", udp_port_range_lists)

    @property
    @pulumi.getter(name="addressGroupInclusionLists")
    def address_group_inclusion_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgs']]]]:
        return pulumi.get(self, "address_group_inclusion_lists")

    @address_group_inclusion_lists.setter
    def address_group_inclusion_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgs']]]]):
        pulumi.set(self, "address_group_inclusion_lists", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="filterKindLists")
    def filter_kind_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_kind_lists")

    @filter_kind_lists.setter
    def filter_kind_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_kind_lists", value)

    @property
    @pulumi.getter(name="filterParams")
    def filter_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgs']]]]:
        return pulumi.get(self, "filter_params")

    @filter_params.setter
    def filter_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgs']]]]):
        pulumi.set(self, "filter_params", value)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter(name="icmpTypeCodeLists")
    def icmp_type_code_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgs']]]]:
        return pulumi.get(self, "icmp_type_code_lists")

    @icmp_type_code_lists.setter
    def icmp_type_code_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgs']]]]):
        pulumi.set(self, "icmp_type_code_lists", value)

    @property
    @pulumi.getter(name="ipSubnet")
    def ip_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet")

    @ip_subnet.setter
    def ip_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet", value)

    @property
    @pulumi.getter(name="ipSubnetPrefixLength")
    def ip_subnet_prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet_prefix_length")

    @ip_subnet_prefix_length.setter
    def ip_subnet_prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet_prefix_length", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="peerSpecificationType")
    def peer_specification_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "peer_specification_type")

    @peer_specification_type.setter
    def peer_specification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "peer_specification_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceGroupLists")
    def service_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgs']]]]:
        return pulumi.get(self, "service_group_lists")

    @service_group_lists.setter
    def service_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgs']]]]):
        pulumi.set(self, "service_group_lists", value)

    @property
    @pulumi.getter(name="tcpPortRangeLists")
    def tcp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgs']]]]:
        return pulumi.get(self, "tcp_port_range_lists")

    @tcp_port_range_lists.setter
    def tcp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgs']]]]):
        pulumi.set(self, "tcp_port_range_lists", value)

    @property
    @pulumi.getter(name="udpPortRangeLists")
    def udp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgs']]]]:
        return pulumi.get(self, "udp_port_range_lists")

    @udp_port_range_lists.setter
    def udp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgs']]]]):
        pulumi.set(self, "udp_port_range_lists", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListAddressGroupInclusionListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListIcmpTypeCodeListArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListServiceGroupListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListTcpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleInboundAllowListUdpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListArgsDict(TypedDict):
        address_group_inclusion_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgsDict']]]]
        expiration_time: NotRequired[pulumi.Input[str]]
        filter_kind_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        filter_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgsDict']]]]
        filter_type: NotRequired[pulumi.Input[str]]
        icmp_type_code_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgsDict']]]]
        ip_subnet: NotRequired[pulumi.Input[str]]
        ip_subnet_prefix_length: NotRequired[pulumi.Input[str]]
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        peer_specification_type: NotRequired[pulumi.Input[str]]
        protocol: NotRequired[pulumi.Input[str]]
        service_group_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgsDict']]]]
        tcp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgsDict']]]]
        udp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgsDict']]]]
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListArgs:
    def __init__(__self__, *,
                 address_group_inclusion_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgs']]]] = None,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 filter_kind_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 filter_params: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgs']]]] = None,
                 filter_type: Optional[pulumi.Input[str]] = None,
                 icmp_type_code_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgs']]]] = None,
                 ip_subnet: Optional[pulumi.Input[str]] = None,
                 ip_subnet_prefix_length: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 peer_specification_type: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 service_group_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgs']]]] = None,
                 tcp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgs']]]] = None,
                 udp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgs']]]] = None):
        if address_group_inclusion_lists is not None:
            pulumi.set(__self__, "address_group_inclusion_lists", address_group_inclusion_lists)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if filter_kind_lists is not None:
            pulumi.set(__self__, "filter_kind_lists", filter_kind_lists)
        if filter_params is not None:
            pulumi.set(__self__, "filter_params", filter_params)
        if filter_type is not None:
            pulumi.set(__self__, "filter_type", filter_type)
        if icmp_type_code_lists is not None:
            pulumi.set(__self__, "icmp_type_code_lists", icmp_type_code_lists)
        if ip_subnet is not None:
            pulumi.set(__self__, "ip_subnet", ip_subnet)
        if ip_subnet_prefix_length is not None:
            pulumi.set(__self__, "ip_subnet_prefix_length", ip_subnet_prefix_length)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if peer_specification_type is not None:
            pulumi.set(__self__, "peer_specification_type", peer_specification_type)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if service_group_lists is not None:
            pulumi.set(__self__, "service_group_lists", service_group_lists)
        if tcp_port_range_lists is not None:
            pulumi.set(__self__, "tcp_port_range_lists", tcp_port_range_lists)
        if udp_port_range_lists is not None:
            pulumi.set(__self__, "udp_port_range_lists", udp_port_range_lists)

    @property
    @pulumi.getter(name="addressGroupInclusionLists")
    def address_group_inclusion_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgs']]]]:
        return pulumi.get(self, "address_group_inclusion_lists")

    @address_group_inclusion_lists.setter
    def address_group_inclusion_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgs']]]]):
        pulumi.set(self, "address_group_inclusion_lists", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="filterKindLists")
    def filter_kind_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "filter_kind_lists")

    @filter_kind_lists.setter
    def filter_kind_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "filter_kind_lists", value)

    @property
    @pulumi.getter(name="filterParams")
    def filter_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgs']]]]:
        return pulumi.get(self, "filter_params")

    @filter_params.setter
    def filter_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgs']]]]):
        pulumi.set(self, "filter_params", value)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter(name="icmpTypeCodeLists")
    def icmp_type_code_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgs']]]]:
        return pulumi.get(self, "icmp_type_code_lists")

    @icmp_type_code_lists.setter
    def icmp_type_code_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgs']]]]):
        pulumi.set(self, "icmp_type_code_lists", value)

    @property
    @pulumi.getter(name="ipSubnet")
    def ip_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet")

    @ip_subnet.setter
    def ip_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet", value)

    @property
    @pulumi.getter(name="ipSubnetPrefixLength")
    def ip_subnet_prefix_length(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_subnet_prefix_length")

    @ip_subnet_prefix_length.setter
    def ip_subnet_prefix_length(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_subnet_prefix_length", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="peerSpecificationType")
    def peer_specification_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "peer_specification_type")

    @peer_specification_type.setter
    def peer_specification_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "peer_specification_type", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="serviceGroupLists")
    def service_group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgs']]]]:
        return pulumi.get(self, "service_group_lists")

    @service_group_lists.setter
    def service_group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgs']]]]):
        pulumi.set(self, "service_group_lists", value)

    @property
    @pulumi.getter(name="tcpPortRangeLists")
    def tcp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgs']]]]:
        return pulumi.get(self, "tcp_port_range_lists")

    @tcp_port_range_lists.setter
    def tcp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgs']]]]):
        pulumi.set(self, "tcp_port_range_lists", value)

    @property
    @pulumi.getter(name="udpPortRangeLists")
    def udp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgs']]]]:
        return pulumi.get(self, "udp_port_range_lists")

    @udp_port_range_lists.setter
    def udp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgs']]]]):
        pulumi.set(self, "udp_port_range_lists", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListAddressGroupInclusionListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListIcmpTypeCodeListArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListServiceGroupListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListTcpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleOutboundAllowListUdpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class NetworkSecurityRuleAppRuleTargetGroupFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleAppRuleTargetGroupFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleAppRuleTargetGroupFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the network_security_rule.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    NetworkSecurityRuleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NetworkSecurityRuleIsolationRuleFirstEntityFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleIsolationRuleFirstEntityFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleIsolationRuleFirstEntityFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NetworkSecurityRuleIsolationRuleSecondEntityFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        - (Required) The name for the network_security_rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    NetworkSecurityRuleIsolationRuleSecondEntityFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkSecurityRuleIsolationRuleSecondEntityFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: - (Required) The name for the network_security_rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name for the network_security_rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class NgtInstallationV2CredentialArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        - (Required) password to sign in to server
        """
        username: pulumi.Input[str]
        """
        - (Required) username to sign in to server
        """
elif False:
    NgtInstallationV2CredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgtInstallationV2CredentialArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: - (Required) password to sign in to server
        :param pulumi.Input[str] username: - (Required) username to sign in to server
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        - (Required) password to sign in to server
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        - (Required) username to sign in to server
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class NgtInstallationV2RebootPreferenceArgsDict(TypedDict):
        schedule_type: pulumi.Input[str]
        """
        - Schedule type for restart.
        * `LATER` : Schedule a restart for a specific time.
        * `SKIP` : Do not schedule a restart.
        * `IMMEDIATE` : Schedule an immediate restart.
        """
        schedule: NotRequired[pulumi.Input['NgtInstallationV2RebootPreferenceScheduleArgsDict']]
        """
        - Restart schedule.
        """
elif False:
    NgtInstallationV2RebootPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgtInstallationV2RebootPreferenceArgs:
    def __init__(__self__, *,
                 schedule_type: pulumi.Input[str],
                 schedule: Optional[pulumi.Input['NgtInstallationV2RebootPreferenceScheduleArgs']] = None):
        """
        :param pulumi.Input[str] schedule_type: - Schedule type for restart.
               * `LATER` : Schedule a restart for a specific time.
               * `SKIP` : Do not schedule a restart.
               * `IMMEDIATE` : Schedule an immediate restart.
        :param pulumi.Input['NgtInstallationV2RebootPreferenceScheduleArgs'] schedule: - Restart schedule.
        """
        pulumi.set(__self__, "schedule_type", schedule_type)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[str]:
        """
        - Schedule type for restart.
        * `LATER` : Schedule a restart for a specific time.
        * `SKIP` : Do not schedule a restart.
        * `IMMEDIATE` : Schedule an immediate restart.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['NgtInstallationV2RebootPreferenceScheduleArgs']]:
        """
        - Restart schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['NgtInstallationV2RebootPreferenceScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class NgtInstallationV2RebootPreferenceScheduleArgsDict(TypedDict):
        start_time: pulumi.Input[str]
        """
        - The start time for a scheduled restart.
        """
elif False:
    NgtInstallationV2RebootPreferenceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgtInstallationV2RebootPreferenceScheduleArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] start_time: - The start time for a scheduled restart.
        """
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        - The start time for a scheduled restart.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class NgtUpgradeV2RebootPreferenceArgsDict(TypedDict):
        schedule_type: pulumi.Input[str]
        """
        - Schedule type for restart.
        * `LATER` : Schedule a restart for a specific time.
        * `SKIP` : Do not schedule a restart.
        * `IMMEDIATE` : Schedule an immediate restart.
        """
        schedule: NotRequired[pulumi.Input['NgtUpgradeV2RebootPreferenceScheduleArgsDict']]
        """
        - Restart schedule.
        """
elif False:
    NgtUpgradeV2RebootPreferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgtUpgradeV2RebootPreferenceArgs:
    def __init__(__self__, *,
                 schedule_type: pulumi.Input[str],
                 schedule: Optional[pulumi.Input['NgtUpgradeV2RebootPreferenceScheduleArgs']] = None):
        """
        :param pulumi.Input[str] schedule_type: - Schedule type for restart.
               * `LATER` : Schedule a restart for a specific time.
               * `SKIP` : Do not schedule a restart.
               * `IMMEDIATE` : Schedule an immediate restart.
        :param pulumi.Input['NgtUpgradeV2RebootPreferenceScheduleArgs'] schedule: - Restart schedule.
        """
        pulumi.set(__self__, "schedule_type", schedule_type)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[str]:
        """
        - Schedule type for restart.
        * `LATER` : Schedule a restart for a specific time.
        * `SKIP` : Do not schedule a restart.
        * `IMMEDIATE` : Schedule an immediate restart.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['NgtUpgradeV2RebootPreferenceScheduleArgs']]:
        """
        - Restart schedule.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['NgtUpgradeV2RebootPreferenceScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class NgtUpgradeV2RebootPreferenceScheduleArgsDict(TypedDict):
        start_time: pulumi.Input[str]
        """
        - The start time for a scheduled restart.
        """
elif False:
    NgtUpgradeV2RebootPreferenceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgtUpgradeV2RebootPreferenceScheduleArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] start_time: - The start time for a scheduled restart.
        """
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        - The start time for a scheduled restart.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class PbrDestinationArgsDict(TypedDict):
        address_type: NotRequired[pulumi.Input[str]]
        prefix_length: NotRequired[pulumi.Input[int]]
        subnet_ip: NotRequired[pulumi.Input[str]]
elif False:
    PbrDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrDestinationArgs:
    def __init__(__self__, *,
                 address_type: Optional[pulumi.Input[str]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 subnet_ip: Optional[pulumi.Input[str]] = None):
        if address_type is not None:
            pulumi.set(__self__, "address_type", address_type)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet_ip is not None:
            pulumi.set(__self__, "subnet_ip", subnet_ip)

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address_type")

    @address_type.setter
    def address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_type", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="subnetIp")
    def subnet_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_ip")

    @subnet_ip.setter
    def subnet_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_ip", value)


if not MYPY:
    class PbrProtocolParametersArgsDict(TypedDict):
        icmp: NotRequired[pulumi.Input['PbrProtocolParametersIcmpArgsDict']]
        protocol_number: NotRequired[pulumi.Input[str]]
        tcp: NotRequired[pulumi.Input['PbrProtocolParametersTcpArgsDict']]
        udp: NotRequired[pulumi.Input['PbrProtocolParametersUdpArgsDict']]
elif False:
    PbrProtocolParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersArgs:
    def __init__(__self__, *,
                 icmp: Optional[pulumi.Input['PbrProtocolParametersIcmpArgs']] = None,
                 protocol_number: Optional[pulumi.Input[str]] = None,
                 tcp: Optional[pulumi.Input['PbrProtocolParametersTcpArgs']] = None,
                 udp: Optional[pulumi.Input['PbrProtocolParametersUdpArgs']] = None):
        if icmp is not None:
            pulumi.set(__self__, "icmp", icmp)
        if protocol_number is not None:
            pulumi.set(__self__, "protocol_number", protocol_number)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if udp is not None:
            pulumi.set(__self__, "udp", udp)

    @property
    @pulumi.getter
    def icmp(self) -> Optional[pulumi.Input['PbrProtocolParametersIcmpArgs']]:
        return pulumi.get(self, "icmp")

    @icmp.setter
    def icmp(self, value: Optional[pulumi.Input['PbrProtocolParametersIcmpArgs']]):
        pulumi.set(self, "icmp", value)

    @property
    @pulumi.getter(name="protocolNumber")
    def protocol_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protocol_number")

    @protocol_number.setter
    def protocol_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_number", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['PbrProtocolParametersTcpArgs']]:
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['PbrProtocolParametersTcpArgs']]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def udp(self) -> Optional[pulumi.Input['PbrProtocolParametersUdpArgs']]:
        return pulumi.get(self, "udp")

    @udp.setter
    def udp(self, value: Optional[pulumi.Input['PbrProtocolParametersUdpArgs']]):
        pulumi.set(self, "udp", value)


if not MYPY:
    class PbrProtocolParametersIcmpArgsDict(TypedDict):
        icmp_code: pulumi.Input[int]
        icmp_type: pulumi.Input[int]
elif False:
    PbrProtocolParametersIcmpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersIcmpArgs:
    def __init__(__self__, *,
                 icmp_code: pulumi.Input[int],
                 icmp_type: pulumi.Input[int]):
        pulumi.set(__self__, "icmp_code", icmp_code)
        pulumi.set(__self__, "icmp_type", icmp_type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> pulumi.Input[int]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: pulumi.Input[int]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> pulumi.Input[int]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: pulumi.Input[int]):
        pulumi.set(self, "icmp_type", value)


if not MYPY:
    class PbrProtocolParametersTcpArgsDict(TypedDict):
        destination_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpDestinationPortRangeListArgsDict']]]]
        source_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpSourcePortRangeListArgsDict']]]]
elif False:
    PbrProtocolParametersTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersTcpArgs:
    def __init__(__self__, *,
                 destination_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpDestinationPortRangeListArgs']]]] = None,
                 source_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpSourcePortRangeListArgs']]]] = None):
        if destination_port_range_lists is not None:
            pulumi.set(__self__, "destination_port_range_lists", destination_port_range_lists)
        if source_port_range_lists is not None:
            pulumi.set(__self__, "source_port_range_lists", source_port_range_lists)

    @property
    @pulumi.getter(name="destinationPortRangeLists")
    def destination_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpDestinationPortRangeListArgs']]]]:
        return pulumi.get(self, "destination_port_range_lists")

    @destination_port_range_lists.setter
    def destination_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpDestinationPortRangeListArgs']]]]):
        pulumi.set(self, "destination_port_range_lists", value)

    @property
    @pulumi.getter(name="sourcePortRangeLists")
    def source_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpSourcePortRangeListArgs']]]]:
        return pulumi.get(self, "source_port_range_lists")

    @source_port_range_lists.setter
    def source_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersTcpSourcePortRangeListArgs']]]]):
        pulumi.set(self, "source_port_range_lists", value)


if not MYPY:
    class PbrProtocolParametersTcpDestinationPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    PbrProtocolParametersTcpDestinationPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersTcpDestinationPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrProtocolParametersTcpSourcePortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    PbrProtocolParametersTcpSourcePortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersTcpSourcePortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrProtocolParametersUdpArgsDict(TypedDict):
        destination_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpDestinationPortRangeListArgsDict']]]]
        source_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpSourcePortRangeListArgsDict']]]]
elif False:
    PbrProtocolParametersUdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersUdpArgs:
    def __init__(__self__, *,
                 destination_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpDestinationPortRangeListArgs']]]] = None,
                 source_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpSourcePortRangeListArgs']]]] = None):
        if destination_port_range_lists is not None:
            pulumi.set(__self__, "destination_port_range_lists", destination_port_range_lists)
        if source_port_range_lists is not None:
            pulumi.set(__self__, "source_port_range_lists", source_port_range_lists)

    @property
    @pulumi.getter(name="destinationPortRangeLists")
    def destination_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpDestinationPortRangeListArgs']]]]:
        return pulumi.get(self, "destination_port_range_lists")

    @destination_port_range_lists.setter
    def destination_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpDestinationPortRangeListArgs']]]]):
        pulumi.set(self, "destination_port_range_lists", value)

    @property
    @pulumi.getter(name="sourcePortRangeLists")
    def source_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpSourcePortRangeListArgs']]]]:
        return pulumi.get(self, "source_port_range_lists")

    @source_port_range_lists.setter
    def source_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrProtocolParametersUdpSourcePortRangeListArgs']]]]):
        pulumi.set(self, "source_port_range_lists", value)


if not MYPY:
    class PbrProtocolParametersUdpDestinationPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    PbrProtocolParametersUdpDestinationPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersUdpDestinationPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrProtocolParametersUdpSourcePortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    PbrProtocolParametersUdpSourcePortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrProtocolParametersUdpSourcePortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrSourceArgsDict(TypedDict):
        address_type: NotRequired[pulumi.Input[str]]
        prefix_length: NotRequired[pulumi.Input[int]]
        subnet_ip: NotRequired[pulumi.Input[str]]
elif False:
    PbrSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrSourceArgs:
    def __init__(__self__, *,
                 address_type: Optional[pulumi.Input[str]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 subnet_ip: Optional[pulumi.Input[str]] = None):
        if address_type is not None:
            pulumi.set(__self__, "address_type", address_type)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if subnet_ip is not None:
            pulumi.set(__self__, "subnet_ip", subnet_ip)

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address_type")

    @address_type.setter
    def address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_type", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="subnetIp")
    def subnet_ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_ip")

    @subnet_ip.setter
    def subnet_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_ip", value)


if not MYPY:
    class PbrV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class PbrV2MetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2MetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class PbrV2PolicyArgsDict(TypedDict):
        policy_actions: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionArgsDict']]]
        policy_matches: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchArgsDict']]]
        is_bidirectional: NotRequired[pulumi.Input[bool]]
elif False:
    PbrV2PolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyArgs:
    def __init__(__self__, *,
                 policy_actions: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionArgs']]],
                 policy_matches: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchArgs']]],
                 is_bidirectional: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "policy_actions", policy_actions)
        pulumi.set(__self__, "policy_matches", policy_matches)
        if is_bidirectional is not None:
            pulumi.set(__self__, "is_bidirectional", is_bidirectional)

    @property
    @pulumi.getter(name="policyActions")
    def policy_actions(self) -> pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionArgs']]]:
        return pulumi.get(self, "policy_actions")

    @policy_actions.setter
    def policy_actions(self, value: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionArgs']]]):
        pulumi.set(self, "policy_actions", value)

    @property
    @pulumi.getter(name="policyMatches")
    def policy_matches(self) -> pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchArgs']]]:
        return pulumi.get(self, "policy_matches")

    @policy_matches.setter
    def policy_matches(self, value: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchArgs']]]):
        pulumi.set(self, "policy_matches", value)

    @property
    @pulumi.getter(name="isBidirectional")
    def is_bidirectional(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_bidirectional")

    @is_bidirectional.setter
    def is_bidirectional(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_bidirectional", value)


if not MYPY:
    class PbrV2PolicyPolicyActionArgsDict(TypedDict):
        action_type: pulumi.Input[str]
        nexthop_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressArgsDict']]]]
        reroute_params: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 nexthop_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressArgs']]]] = None,
                 reroute_params: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamArgs']]]] = None):
        pulumi.set(__self__, "action_type", action_type)
        if nexthop_ip_addresses is not None:
            pulumi.set(__self__, "nexthop_ip_addresses", nexthop_ip_addresses)
        if reroute_params is not None:
            pulumi.set(__self__, "reroute_params", reroute_params)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="nexthopIpAddresses")
    def nexthop_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressArgs']]]]:
        return pulumi.get(self, "nexthop_ip_addresses")

    @nexthop_ip_addresses.setter
    def nexthop_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressArgs']]]]):
        pulumi.set(self, "nexthop_ip_addresses", value)

    @property
    @pulumi.getter(name="rerouteParams")
    def reroute_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamArgs']]]]:
        return pulumi.get(self, "reroute_params")

    @reroute_params.setter
    def reroute_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamArgs']]]]):
        pulumi.set(self, "reroute_params", value)


if not MYPY:
    class PbrV2PolicyPolicyActionNexthopIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionNexthopIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionNexthopIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionNexthopIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyActionNexthopIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionNexthopIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionNexthopIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionNexthopIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionNexthopIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionNexthopIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamArgsDict(TypedDict):
        egress_service_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgsDict']]]]
        ingress_service_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgsDict']]]]
        reroute_fallback_action: NotRequired[pulumi.Input[str]]
        service_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamArgs:
    def __init__(__self__, *,
                 egress_service_ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgs']]]] = None,
                 ingress_service_ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgs']]]] = None,
                 reroute_fallback_action: Optional[pulumi.Input[str]] = None,
                 service_ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpArgs']]]] = None):
        if egress_service_ips is not None:
            pulumi.set(__self__, "egress_service_ips", egress_service_ips)
        if ingress_service_ips is not None:
            pulumi.set(__self__, "ingress_service_ips", ingress_service_ips)
        if reroute_fallback_action is not None:
            pulumi.set(__self__, "reroute_fallback_action", reroute_fallback_action)
        if service_ips is not None:
            pulumi.set(__self__, "service_ips", service_ips)

    @property
    @pulumi.getter(name="egressServiceIps")
    def egress_service_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgs']]]]:
        return pulumi.get(self, "egress_service_ips")

    @egress_service_ips.setter
    def egress_service_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgs']]]]):
        pulumi.set(self, "egress_service_ips", value)

    @property
    @pulumi.getter(name="ingressServiceIps")
    def ingress_service_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgs']]]]:
        return pulumi.get(self, "ingress_service_ips")

    @ingress_service_ips.setter
    def ingress_service_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgs']]]]):
        pulumi.set(self, "ingress_service_ips", value)

    @property
    @pulumi.getter(name="rerouteFallbackAction")
    def reroute_fallback_action(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reroute_fallback_action")

    @reroute_fallback_action.setter
    def reroute_fallback_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reroute_fallback_action", value)

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpArgs']]]]:
        return pulumi.get(self, "service_ips")

    @service_ips.setter
    def service_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpArgs']]]]):
        pulumi.set(self, "service_ips", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamEgressServiceIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamIngressServiceIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamServiceIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamServiceIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamServiceIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamServiceIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyActionRerouteParamServiceIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchArgsDict(TypedDict):
        destinations: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationArgsDict']]]
        protocol_type: pulumi.Input[str]
        sources: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceArgsDict']]]
        protocol_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchArgs:
    def __init__(__self__, *,
                 destinations: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationArgs']]],
                 protocol_type: pulumi.Input[str],
                 sources: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceArgs']]],
                 protocol_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterArgs']]]] = None):
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "protocol_type", protocol_type)
        pulumi.set(__self__, "sources", sources)
        if protocol_parameters is not None:
            pulumi.set(__self__, "protocol_parameters", protocol_parameters)

    @property
    @pulumi.getter
    def destinations(self) -> pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationArgs']]]:
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationArgs']]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="protocolType")
    def protocol_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol_type")

    @protocol_type.setter
    def protocol_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol_type", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceArgs']]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceArgs']]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="protocolParameters")
    def protocol_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterArgs']]]]:
        return pulumi.get(self, "protocol_parameters")

    @protocol_parameters.setter
    def protocol_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterArgs']]]]):
        pulumi.set(self, "protocol_parameters", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationArgsDict(TypedDict):
        address_type: pulumi.Input[str]
        subnet_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationArgs:
    def __init__(__self__, *,
                 address_type: pulumi.Input[str],
                 subnet_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgs']]]] = None):
        pulumi.set(__self__, "address_type", address_type)
        if subnet_prefixes is not None:
            pulumi.set(__self__, "subnet_prefixes", subnet_prefixes)

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "address_type")

    @address_type.setter
    def address_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_type", value)

    @property
    @pulumi.getter(name="subnetPrefixes")
    def subnet_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgs']]]]:
        return pulumi.get(self, "subnet_prefixes")

    @subnet_prefixes.setter
    def subnet_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgs']]]]):
        pulumi.set(self, "subnet_prefixes", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationSubnetPrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchDestinationSubnetPrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterArgsDict(TypedDict):
        icmp_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgsDict']]]]
        layer_four_protocol_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgsDict']]]]
        protocol_number_objects: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterArgs:
    def __init__(__self__, *,
                 icmp_objects: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgs']]]] = None,
                 layer_four_protocol_objects: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgs']]]] = None,
                 protocol_number_objects: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgs']]]] = None):
        if icmp_objects is not None:
            pulumi.set(__self__, "icmp_objects", icmp_objects)
        if layer_four_protocol_objects is not None:
            pulumi.set(__self__, "layer_four_protocol_objects", layer_four_protocol_objects)
        if protocol_number_objects is not None:
            pulumi.set(__self__, "protocol_number_objects", protocol_number_objects)

    @property
    @pulumi.getter(name="icmpObjects")
    def icmp_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgs']]]]:
        return pulumi.get(self, "icmp_objects")

    @icmp_objects.setter
    def icmp_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgs']]]]):
        pulumi.set(self, "icmp_objects", value)

    @property
    @pulumi.getter(name="layerFourProtocolObjects")
    def layer_four_protocol_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgs']]]]:
        return pulumi.get(self, "layer_four_protocol_objects")

    @layer_four_protocol_objects.setter
    def layer_four_protocol_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgs']]]]):
        pulumi.set(self, "layer_four_protocol_objects", value)

    @property
    @pulumi.getter(name="protocolNumberObjects")
    def protocol_number_objects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgs']]]]:
        return pulumi.get(self, "protocol_number_objects")

    @protocol_number_objects.setter
    def protocol_number_objects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgs']]]]):
        pulumi.set(self, "protocol_number_objects", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgsDict(TypedDict):
        icmp_code: NotRequired[pulumi.Input[int]]
        icmp_type: NotRequired[pulumi.Input[int]]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterIcmpObjectArgs:
    def __init__(__self__, *,
                 icmp_code: Optional[pulumi.Input[int]] = None,
                 icmp_type: Optional[pulumi.Input[int]] = None):
        if icmp_code is not None:
            pulumi.set(__self__, "icmp_code", icmp_code)
        if icmp_type is not None:
            pulumi.set(__self__, "icmp_type", icmp_type)

    @property
    @pulumi.getter(name="icmpCode")
    def icmp_code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "icmp_code")

    @icmp_code.setter
    def icmp_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_code", value)

    @property
    @pulumi.getter(name="icmpType")
    def icmp_type(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "icmp_type")

    @icmp_type.setter
    def icmp_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "icmp_type", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgsDict(TypedDict):
        destination_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgsDict']]]]
        source_port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectArgs:
    def __init__(__self__, *,
                 destination_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgs']]]] = None,
                 source_port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgs']]]] = None):
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgs']]]]:
        return pulumi.get(self, "destination_port_ranges")

    @destination_port_ranges.setter
    def destination_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgs']]]]):
        pulumi.set(self, "destination_port_ranges", value)

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgs']]]]:
        return pulumi.get(self, "source_port_ranges")

    @source_port_ranges.setter
    def source_port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgs']]]]):
        pulumi.set(self, "source_port_ranges", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        start_port: pulumi.Input[int]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectDestinationPortRangeArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        start_port: pulumi.Input[int]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterLayerFourProtocolObjectSourcePortRangeArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgsDict(TypedDict):
        protocol_number: pulumi.Input[int]
elif False:
    PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchProtocolParameterProtocolNumberObjectArgs:
    def __init__(__self__, *,
                 protocol_number: pulumi.Input[int]):
        pulumi.set(__self__, "protocol_number", protocol_number)

    @property
    @pulumi.getter(name="protocolNumber")
    def protocol_number(self) -> pulumi.Input[int]:
        return pulumi.get(self, "protocol_number")

    @protocol_number.setter
    def protocol_number(self, value: pulumi.Input[int]):
        pulumi.set(self, "protocol_number", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceArgsDict(TypedDict):
        address_type: pulumi.Input[str]
        subnet_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceArgs:
    def __init__(__self__, *,
                 address_type: pulumi.Input[str],
                 subnet_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixArgs']]]] = None):
        pulumi.set(__self__, "address_type", address_type)
        if subnet_prefixes is not None:
            pulumi.set(__self__, "subnet_prefixes", subnet_prefixes)

    @property
    @pulumi.getter(name="addressType")
    def address_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "address_type")

    @address_type.setter
    def address_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_type", value)

    @property
    @pulumi.getter(name="subnetPrefixes")
    def subnet_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixArgs']]]]:
        return pulumi.get(self, "subnet_prefixes")

    @subnet_prefixes.setter
    def subnet_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixArgs']]]]):
        pulumi.set(self, "subnet_prefixes", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceSubnetPrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6ArgsDict']]]]
elif False:
    PbrV2PolicyPolicyMatchSourceSubnetPrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceSubnetPrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2PolicyPolicyMatchSourceSubnetPrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PbrV2VpcArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
elif False:
    PbrV2VpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PbrV2VpcArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PcRegistrationV2ConfigArgsDict(TypedDict):
        bootstrap_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigArgsDict']]]]
        build_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBuildInfoArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        resource_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigResourceConfigArgsDict']]]]
        should_enable_lockdown_mode: NotRequired[pulumi.Input[bool]]
        size: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2ConfigArgs:
    def __init__(__self__, *,
                 bootstrap_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigArgs']]]] = None,
                 build_infos: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBuildInfoArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 resource_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigResourceConfigArgs']]]] = None,
                 should_enable_lockdown_mode: Optional[pulumi.Input[bool]] = None,
                 size: Optional[pulumi.Input[str]] = None):
        if bootstrap_configs is not None:
            pulumi.set(__self__, "bootstrap_configs", bootstrap_configs)
        if build_infos is not None:
            pulumi.set(__self__, "build_infos", build_infos)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resource_configs is not None:
            pulumi.set(__self__, "resource_configs", resource_configs)
        if should_enable_lockdown_mode is not None:
            pulumi.set(__self__, "should_enable_lockdown_mode", should_enable_lockdown_mode)
        if size is not None:
            pulumi.set(__self__, "size", size)

    @property
    @pulumi.getter(name="bootstrapConfigs")
    def bootstrap_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigArgs']]]]:
        return pulumi.get(self, "bootstrap_configs")

    @bootstrap_configs.setter
    def bootstrap_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigArgs']]]]):
        pulumi.set(self, "bootstrap_configs", value)

    @property
    @pulumi.getter(name="buildInfos")
    def build_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBuildInfoArgs']]]]:
        return pulumi.get(self, "build_infos")

    @build_infos.setter
    def build_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBuildInfoArgs']]]]):
        pulumi.set(self, "build_infos", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="resourceConfigs")
    def resource_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigResourceConfigArgs']]]]:
        return pulumi.get(self, "resource_configs")

    @resource_configs.setter
    def resource_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigResourceConfigArgs']]]]):
        pulumi.set(self, "resource_configs", value)

    @property
    @pulumi.getter(name="shouldEnableLockdownMode")
    def should_enable_lockdown_mode(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_enable_lockdown_mode")

    @should_enable_lockdown_mode.setter
    def should_enable_lockdown_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_enable_lockdown_mode", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)


if not MYPY:
    class PcRegistrationV2ConfigBootstrapConfigArgsDict(TypedDict):
        environment_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgsDict']]]]
elif False:
    PcRegistrationV2ConfigBootstrapConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2ConfigBootstrapConfigArgs:
    def __init__(__self__, *,
                 environment_infos: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgs']]]] = None):
        if environment_infos is not None:
            pulumi.set(__self__, "environment_infos", environment_infos)

    @property
    @pulumi.getter(name="environmentInfos")
    def environment_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgs']]]]:
        return pulumi.get(self, "environment_infos")

    @environment_infos.setter
    def environment_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgs']]]]):
        pulumi.set(self, "environment_infos", value)


if not MYPY:
    class PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgsDict(TypedDict):
        provider_type: NotRequired[pulumi.Input[str]]
        provisioning_type: NotRequired[pulumi.Input[str]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2ConfigBootstrapConfigEnvironmentInfoArgs:
    def __init__(__self__, *,
                 provider_type: Optional[pulumi.Input[str]] = None,
                 provisioning_type: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if provider_type is not None:
            pulumi.set(__self__, "provider_type", provider_type)
        if provisioning_type is not None:
            pulumi.set(__self__, "provisioning_type", provisioning_type)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="providerType")
    def provider_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider_type")

    @provider_type.setter
    def provider_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_type", value)

    @property
    @pulumi.getter(name="provisioningType")
    def provisioning_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provisioning_type")

    @provisioning_type.setter
    def provisioning_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_type", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PcRegistrationV2ConfigBuildInfoArgsDict(TypedDict):
        version: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2ConfigBuildInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2ConfigBuildInfoArgs:
    def __init__(__self__, *,
                 version: Optional[pulumi.Input[str]] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PcRegistrationV2ConfigResourceConfigArgsDict(TypedDict):
        container_ext_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        data_disk_size_bytes: NotRequired[pulumi.Input[int]]
        memory_size_bytes: NotRequired[pulumi.Input[int]]
        num_vcpus: NotRequired[pulumi.Input[int]]
elif False:
    PcRegistrationV2ConfigResourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2ConfigResourceConfigArgs:
    def __init__(__self__, *,
                 container_ext_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 data_disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 memory_size_bytes: Optional[pulumi.Input[int]] = None,
                 num_vcpus: Optional[pulumi.Input[int]] = None):
        if container_ext_ids is not None:
            pulumi.set(__self__, "container_ext_ids", container_ext_ids)
        if data_disk_size_bytes is not None:
            pulumi.set(__self__, "data_disk_size_bytes", data_disk_size_bytes)
        if memory_size_bytes is not None:
            pulumi.set(__self__, "memory_size_bytes", memory_size_bytes)
        if num_vcpus is not None:
            pulumi.set(__self__, "num_vcpus", num_vcpus)

    @property
    @pulumi.getter(name="containerExtIds")
    def container_ext_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "container_ext_ids")

    @container_ext_ids.setter
    def container_ext_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_ext_ids", value)

    @property
    @pulumi.getter(name="dataDiskSizeBytes")
    def data_disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "data_disk_size_bytes")

    @data_disk_size_bytes.setter
    def data_disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_disk_size_bytes", value)

    @property
    @pulumi.getter(name="memorySizeBytes")
    def memory_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_size_bytes")

    @memory_size_bytes.setter
    def memory_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_size_bytes", value)

    @property
    @pulumi.getter(name="numVcpus")
    def num_vcpus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_vcpus")

    @num_vcpus.setter
    def num_vcpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_vcpus", value)


if not MYPY:
    class PcRegistrationV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class PcRegistrationV2NetworkArgsDict(TypedDict):
        external_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressArgsDict']]]]
        external_networks: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkArgsDict']]]]
        fqdn: NotRequired[pulumi.Input[str]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerArgsDict']]]]
        ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerArgsDict']]]]
elif False:
    PcRegistrationV2NetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkArgs:
    def __init__(__self__, *,
                 external_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressArgs']]]] = None,
                 external_networks: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkArgs']]]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None,
                 name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerArgs']]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerArgs']]]] = None):
        """
        :param pulumi.Input[str] fqdn: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        if external_addresses is not None:
            pulumi.set(__self__, "external_addresses", external_addresses)
        if external_networks is not None:
            pulumi.set(__self__, "external_networks", external_networks)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if name_servers is not None:
            pulumi.set(__self__, "name_servers", name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="externalAddresses")
    def external_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressArgs']]]]:
        return pulumi.get(self, "external_addresses")

    @external_addresses.setter
    def external_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressArgs']]]]):
        pulumi.set(self, "external_addresses", value)

    @property
    @pulumi.getter(name="externalNetworks")
    def external_networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkArgs']]]]:
        return pulumi.get(self, "external_networks")

    @external_networks.setter
    def external_networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkArgs']]]]):
        pulumi.set(self, "external_networks", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="nameServers")
    def name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerArgs']]]]:
        return pulumi.get(self, "name_servers")

    @name_servers.setter
    def name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerArgs']]]]):
        pulumi.set(self, "name_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerArgs']]]]:
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerArgs']]]]):
        pulumi.set(self, "ntp_servers", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkExternalAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkArgsDict(TypedDict):
        default_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgsDict']]]]
        ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeArgsDict']]]]
        network_ext_id: NotRequired[pulumi.Input[str]]
        subnet_masks: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskArgsDict']]]]
elif False:
    PcRegistrationV2NetworkExternalNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkArgs:
    def __init__(__self__, *,
                 default_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgs']]]] = None,
                 ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeArgs']]]] = None,
                 network_ext_id: Optional[pulumi.Input[str]] = None,
                 subnet_masks: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskArgs']]]] = None):
        if default_gateways is not None:
            pulumi.set(__self__, "default_gateways", default_gateways)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if network_ext_id is not None:
            pulumi.set(__self__, "network_ext_id", network_ext_id)
        if subnet_masks is not None:
            pulumi.set(__self__, "subnet_masks", subnet_masks)

    @property
    @pulumi.getter(name="defaultGateways")
    def default_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgs']]]]:
        return pulumi.get(self, "default_gateways")

    @default_gateways.setter
    def default_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgs']]]]):
        pulumi.set(self, "default_gateways", value)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeArgs']]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeArgs']]]]):
        pulumi.set(self, "ip_ranges", value)

    @property
    @pulumi.getter(name="networkExtId")
    def network_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_ext_id")

    @network_ext_id.setter
    def network_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_ext_id", value)

    @property
    @pulumi.getter(name="subnetMasks")
    def subnet_masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskArgs']]]]:
        return pulumi.get(self, "subnet_masks")

    @subnet_masks.setter
    def subnet_masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskArgs']]]]):
        pulumi.set(self, "subnet_masks", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkDefaultGatewayArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkDefaultGatewayFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkDefaultGatewayIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeArgsDict(TypedDict):
        begins: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgsDict']]]]
        ends: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndArgsDict']]]]
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeArgs:
    def __init__(__self__, *,
                 begins: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgs']]]] = None,
                 ends: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndArgs']]]] = None):
        if begins is not None:
            pulumi.set(__self__, "begins", begins)
        if ends is not None:
            pulumi.set(__self__, "ends", ends)

    @property
    @pulumi.getter
    def begins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgs']]]]:
        return pulumi.get(self, "begins")

    @begins.setter
    def begins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgs']]]]):
        pulumi.set(self, "begins", value)

    @property
    @pulumi.getter
    def ends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndArgs']]]]:
        return pulumi.get(self, "ends")

    @ends.setter
    def ends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndArgs']]]]):
        pulumi.set(self, "ends", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeBeginArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeBeginIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeEndArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeEndArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeEndArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkIpRangeEndIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkSubnetMaskArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkSubnetMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkSubnetMaskArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkSubnetMaskFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkExternalNetworkSubnetMaskIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNameServerArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNameServerArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkNameServerFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2NetworkNameServerFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNameServerFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNtpServerArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkNtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNtpServerArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2NetworkNtpServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2NetworkNtpServerFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2NetworkNtpServerFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNtpServerFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNtpServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
elif False:
    PcRegistrationV2NetworkNtpServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNtpServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2NetworkNtpServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    PcRegistrationV2NetworkNtpServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2NetworkNtpServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterArgsDict(TypedDict):
        aos_remote_cluster_spec: NotRequired[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgsDict']]
        """
        - The registration request consists of the remote cluster details.
        """
        cluster_reference: NotRequired[pulumi.Input['PcRegistrationV2RemoteClusterClusterReferenceArgsDict']]
        """
        - The registration request consists of the remote cluster details. using the cluster reference.
        """
        domain_manager_remote_cluster_spec: NotRequired[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgsDict']]
        """
        - The registration request consists of the remote cluster details. and cloud type.
        """
elif False:
    PcRegistrationV2RemoteClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterArgs:
    def __init__(__self__, *,
                 aos_remote_cluster_spec: Optional[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs']] = None,
                 cluster_reference: Optional[pulumi.Input['PcRegistrationV2RemoteClusterClusterReferenceArgs']] = None,
                 domain_manager_remote_cluster_spec: Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs']] = None):
        """
        :param pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs'] aos_remote_cluster_spec: - The registration request consists of the remote cluster details.
        :param pulumi.Input['PcRegistrationV2RemoteClusterClusterReferenceArgs'] cluster_reference: - The registration request consists of the remote cluster details. using the cluster reference.
        :param pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs'] domain_manager_remote_cluster_spec: - The registration request consists of the remote cluster details. and cloud type.
        """
        if aos_remote_cluster_spec is not None:
            pulumi.set(__self__, "aos_remote_cluster_spec", aos_remote_cluster_spec)
        if cluster_reference is not None:
            pulumi.set(__self__, "cluster_reference", cluster_reference)
        if domain_manager_remote_cluster_spec is not None:
            pulumi.set(__self__, "domain_manager_remote_cluster_spec", domain_manager_remote_cluster_spec)

    @property
    @pulumi.getter(name="aosRemoteClusterSpec")
    def aos_remote_cluster_spec(self) -> Optional[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs']]:
        """
        - The registration request consists of the remote cluster details.
        """
        return pulumi.get(self, "aos_remote_cluster_spec")

    @aos_remote_cluster_spec.setter
    def aos_remote_cluster_spec(self, value: Optional[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs']]):
        pulumi.set(self, "aos_remote_cluster_spec", value)

    @property
    @pulumi.getter(name="clusterReference")
    def cluster_reference(self) -> Optional[pulumi.Input['PcRegistrationV2RemoteClusterClusterReferenceArgs']]:
        """
        - The registration request consists of the remote cluster details. using the cluster reference.
        """
        return pulumi.get(self, "cluster_reference")

    @cluster_reference.setter
    def cluster_reference(self, value: Optional[pulumi.Input['PcRegistrationV2RemoteClusterClusterReferenceArgs']]):
        pulumi.set(self, "cluster_reference", value)

    @property
    @pulumi.getter(name="domainManagerRemoteClusterSpec")
    def domain_manager_remote_cluster_spec(self) -> Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs']]:
        """
        - The registration request consists of the remote cluster details. and cloud type.
        """
        return pulumi.get(self, "domain_manager_remote_cluster_spec")

    @domain_manager_remote_cluster_spec.setter
    def domain_manager_remote_cluster_spec(self, value: Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs']]):
        pulumi.set(self, "domain_manager_remote_cluster_spec", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgsDict(TypedDict):
        remote_cluster: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgsDict']
        """
        -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecArgs:
    def __init__(__self__, *,
                 remote_cluster: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs']):
        """
        :param pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs'] remote_cluster: -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
        pulumi.set(__self__, "remote_cluster", remote_cluster)

    @property
    @pulumi.getter(name="remoteCluster")
    def remote_cluster(self) -> pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs']:
        """
        -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
        return pulumi.get(self, "remote_cluster")

    @remote_cluster.setter
    def remote_cluster(self, value: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs']):
        pulumi.set(self, "remote_cluster", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgsDict']]]
        """
        -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        """
        credentials: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgsDict']
        """
        -(Required)  Credentials to connect to a remote cluster.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs']]],
                 credentials: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs']]] addresses: -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        :param pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs'] credentials: -(Required)  Credentials to connect to a remote cluster.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs']]]:
        """
        -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs']]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs']:
        """
        -(Required)  Credentials to connect to a remote cluster.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs']):
        pulumi.set(self, "credentials", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgsDict(TypedDict):
        authentication: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict']
        """
        -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']):
        """
        :param pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs'] authentication: -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
        pulumi.set(__self__, "authentication", authentication)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']:
        """
        -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']):
        pulumi.set(self, "authentication", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        -(Required)  Password required for the basic auth scheme.

        See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        """
        username: pulumi.Input[str]
        """
        -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
elif False:
    PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterAosRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: -(Required)  Password required for the basic auth scheme.
               
               See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        :param pulumi.Input[str] username: -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        -(Required)  Password required for the basic auth scheme.

        See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterClusterReferenceArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
        """
        -(Required)  Cluster UUID of a remote cluster.
        """
elif False:
    PcRegistrationV2RemoteClusterClusterReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterClusterReferenceArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] ext_id: -(Required)  Cluster UUID of a remote cluster.
        """
        pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        """
        -(Required)  Cluster UUID of a remote cluster.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgsDict(TypedDict):
        cloud_type: pulumi.Input[str]
        """
        -(Required)  Enum denoting whether the domain manager (Prism Central) instance is reachable with its physical address or reachable through the My Nutanix portal. Based on the above description, the allowed enum values are:
        * `NUTANIX_HOSTED_CLOUD` : Domain manager (Prism Central) reachable through My Nutanix portal.
        * `ONPREM_CLOUD`: Domain manager (Prism Central) reachable on it's physical address.
        """
        remote_cluster: NotRequired[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgsDict']]
        """
        -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecArgs:
    def __init__(__self__, *,
                 cloud_type: pulumi.Input[str],
                 remote_cluster: Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs']] = None):
        """
        :param pulumi.Input[str] cloud_type: -(Required)  Enum denoting whether the domain manager (Prism Central) instance is reachable with its physical address or reachable through the My Nutanix portal. Based on the above description, the allowed enum values are:
               * `NUTANIX_HOSTED_CLOUD` : Domain manager (Prism Central) reachable through My Nutanix portal.
               * `ONPREM_CLOUD`: Domain manager (Prism Central) reachable on it's physical address.
        :param pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs'] remote_cluster: -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
        pulumi.set(__self__, "cloud_type", cloud_type)
        if remote_cluster is not None:
            pulumi.set(__self__, "remote_cluster", remote_cluster)

    @property
    @pulumi.getter(name="cloudType")
    def cloud_type(self) -> pulumi.Input[str]:
        """
        -(Required)  Enum denoting whether the domain manager (Prism Central) instance is reachable with its physical address or reachable through the My Nutanix portal. Based on the above description, the allowed enum values are:
        * `NUTANIX_HOSTED_CLOUD` : Domain manager (Prism Central) reachable through My Nutanix portal.
        * `ONPREM_CLOUD`: Domain manager (Prism Central) reachable on it's physical address.
        """
        return pulumi.get(self, "cloud_type")

    @cloud_type.setter
    def cloud_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_type", value)

    @property
    @pulumi.getter(name="remoteCluster")
    def remote_cluster(self) -> Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs']]:
        """
        -(Required)  Address configuration of a remote cluster. It requires the address of the remote, that is an IP or domain name along with the basic authentication credentials.
        """
        return pulumi.get(self, "remote_cluster")

    @remote_cluster.setter
    def remote_cluster(self, value: Optional[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs']]):
        pulumi.set(self, "remote_cluster", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgsDict(TypedDict):
        addresses: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgsDict']]]
        """
        -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        """
        credentials: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgsDict']
        """
        -(Required)  Credentials to connect to a remote cluster.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs']]],
                 credentials: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs']]] addresses: -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        :param pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs'] credentials: -(Required)  Credentials to connect to a remote cluster.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "credentials", credentials)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs']]]:
        """
        -(Required)  An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format or a Fully Qualified Domain Name.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs']]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs']:
        """
        -(Required)  Credentials to connect to a remote cluster.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs']):
        pulumi.set(self, "credentials", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgsDict']]]]
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict']]]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs']]] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args']]] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args']]] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]]:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args']]]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name of the host.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name of the host.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name of the host.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4/IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgsDict(TypedDict):
        authentication: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict']
        """
        -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsArgs:
    def __init__(__self__, *,
                 authentication: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']):
        """
        :param pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs'] authentication: -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
        pulumi.set(__self__, "authentication", authentication)

    @property
    @pulumi.getter
    def authentication(self) -> pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']:
        """
        -(Required)  An authentication scheme that requires the client to present a username and password. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: pulumi.Input['PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs']):
        pulumi.set(self, "authentication", value)


if not MYPY:
    class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        -(Required)  Password required for the basic auth scheme.

        See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        """
        username: pulumi.Input[str]
        """
        -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
elif False:
    PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PcRegistrationV2RemoteClusterDomainManagerRemoteClusterSpecRemoteClusterCredentialsAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: -(Required)  Password required for the basic auth scheme.
               
               See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        :param pulumi.Input[str] username: -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        -(Required)  Password required for the basic auth scheme.

        See detailed information in [Nutanix Register a PC Docs](https://developers.nutanix.com/api-reference?namespace=prism&version=v4.0#tag/DomainManager/operation/register).
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        -(Required)  Username required for the basic auth scheme. As per RFC 2617 usernames might be case sensitive.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectAccountReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectAccountReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAccountReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectAcpArgsDict(TypedDict):
        role_reference: pulumi.Input['ProjectAcpRoleReferenceArgsDict']
        """
        Reference to role.
        """
        context_filter_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListArgsDict']]]]
        """
        The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description for project.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
        user_group_reference_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserGroupReferenceListArgsDict']]]]
        """
        List of Reference of users groups.
        """
        user_reference_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserReferenceListArgsDict']]]]
        """
        List of Reference of users.
        """
elif False:
    ProjectAcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpArgs:
    def __init__(__self__, *,
                 role_reference: pulumi.Input['ProjectAcpRoleReferenceArgs'],
                 context_filter_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 user_group_reference_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserGroupReferenceListArgs']]]] = None,
                 user_reference_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserReferenceListArgs']]]] = None):
        """
        :param pulumi.Input['ProjectAcpRoleReferenceArgs'] role_reference: Reference to role.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListArgs']]] context_filter_lists: The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
        :param pulumi.Input[str] description: A description for project.
        :param pulumi.Input[str] name: The name for the project.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserGroupReferenceListArgs']]] user_group_reference_lists: List of Reference of users groups.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserReferenceListArgs']]] user_reference_lists: List of Reference of users.
        """
        pulumi.set(__self__, "role_reference", role_reference)
        if context_filter_lists is not None:
            pulumi.set(__self__, "context_filter_lists", context_filter_lists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if user_group_reference_lists is not None:
            pulumi.set(__self__, "user_group_reference_lists", user_group_reference_lists)
        if user_reference_lists is not None:
            pulumi.set(__self__, "user_reference_lists", user_reference_lists)

    @property
    @pulumi.getter(name="roleReference")
    def role_reference(self) -> pulumi.Input['ProjectAcpRoleReferenceArgs']:
        """
        Reference to role.
        """
        return pulumi.get(self, "role_reference")

    @role_reference.setter
    def role_reference(self, value: pulumi.Input['ProjectAcpRoleReferenceArgs']):
        pulumi.set(self, "role_reference", value)

    @property
    @pulumi.getter(name="contextFilterLists")
    def context_filter_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListArgs']]]]:
        """
        The list of context filters. These are OR filters. The scope-expression-list defines the context, and the filter works in conjunction with the entity-expression-list.
        """
        return pulumi.get(self, "context_filter_lists")

    @context_filter_lists.setter
    def context_filter_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListArgs']]]]):
        pulumi.set(self, "context_filter_lists", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description for project.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="userGroupReferenceLists")
    def user_group_reference_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserGroupReferenceListArgs']]]]:
        """
        List of Reference of users groups.
        """
        return pulumi.get(self, "user_group_reference_lists")

    @user_group_reference_lists.setter
    def user_group_reference_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserGroupReferenceListArgs']]]]):
        pulumi.set(self, "user_group_reference_lists", value)

    @property
    @pulumi.getter(name="userReferenceLists")
    def user_reference_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserReferenceListArgs']]]]:
        """
        List of Reference of users.
        """
        return pulumi.get(self, "user_reference_lists")

    @user_reference_lists.setter
    def user_reference_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpUserReferenceListArgs']]]]):
        pulumi.set(self, "user_reference_lists", value)


if not MYPY:
    class ProjectAcpContextFilterListArgsDict(TypedDict):
        entity_filter_expression_lists: pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListArgsDict']]]
        """
        (Required) A list of Entity filter expressions.
        """
        scope_filter_expression_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListArgsDict']]]]
        """
        - (Optional) Filter the scope of an Access Control Policy.
        """
elif False:
    ProjectAcpContextFilterListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListArgs:
    def __init__(__self__, *,
                 entity_filter_expression_lists: pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListArgs']]],
                 scope_filter_expression_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListArgs']]] entity_filter_expression_lists: (Required) A list of Entity filter expressions.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListArgs']]] scope_filter_expression_lists: - (Optional) Filter the scope of an Access Control Policy.
        """
        pulumi.set(__self__, "entity_filter_expression_lists", entity_filter_expression_lists)
        if scope_filter_expression_lists is not None:
            pulumi.set(__self__, "scope_filter_expression_lists", scope_filter_expression_lists)

    @property
    @pulumi.getter(name="entityFilterExpressionLists")
    def entity_filter_expression_lists(self) -> pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListArgs']]]:
        """
        (Required) A list of Entity filter expressions.
        """
        return pulumi.get(self, "entity_filter_expression_lists")

    @entity_filter_expression_lists.setter
    def entity_filter_expression_lists(self, value: pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListArgs']]]):
        pulumi.set(self, "entity_filter_expression_lists", value)

    @property
    @pulumi.getter(name="scopeFilterExpressionLists")
    def scope_filter_expression_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListArgs']]]]:
        """
        - (Optional) Filter the scope of an Access Control Policy.
        """
        return pulumi.get(self, "scope_filter_expression_lists")

    @scope_filter_expression_lists.setter
    def scope_filter_expression_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListArgs']]]]):
        pulumi.set(self, "scope_filter_expression_lists", value)


if not MYPY:
    class ProjectAcpContextFilterListEntityFilterExpressionListArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        - (Required) The operator in the filter expression.
        """
        right_hand_side: pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgsDict']
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        left_hand_side_entity_type: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  The LHS of the filter expression - the entity type.
        """
elif False:
    ProjectAcpContextFilterListEntityFilterExpressionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListEntityFilterExpressionListArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 right_hand_side: pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs'],
                 left_hand_side_entity_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: - (Required) The operator in the filter expression.
        :param pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs'] right_hand_side: - (Required) The right hand side (RHS) of an scope expression.
        :param pulumi.Input[str] left_hand_side_entity_type: - (Optional)  The LHS of the filter expression - the entity type.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "right_hand_side", right_hand_side)
        if left_hand_side_entity_type is not None:
            pulumi.set(__self__, "left_hand_side_entity_type", left_hand_side_entity_type)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        - (Required) The operator in the filter expression.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="rightHandSide")
    def right_hand_side(self) -> pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs']:
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        return pulumi.get(self, "right_hand_side")

    @right_hand_side.setter
    def right_hand_side(self, value: pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs']):
        pulumi.set(self, "right_hand_side", value)

    @property
    @pulumi.getter(name="leftHandSideEntityType")
    def left_hand_side_entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  The LHS of the filter expression - the entity type.
        """
        return pulumi.get(self, "left_hand_side_entity_type")

    @left_hand_side_entity_type.setter
    def left_hand_side_entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "left_hand_side_entity_type", value)


if not MYPY:
    class ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict']]
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        collection: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        uuid_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
elif False:
    ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']] = None,
                 collection: Optional[pulumi.Input[str]] = None,
                 uuid_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs'] categories: - (Optional) The category values represented as a dictionary of key > list of values.
        :param pulumi.Input[str] collection: - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uuid_lists: - (Optional) The explicit list of UUIDs for the given kind.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if uuid_lists is not None:
            pulumi.set(__self__, "uuid_lists", uuid_lists)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']]:
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input['ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs']]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="uuidLists")
    def uuid_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
        return pulumi.get(self, "uuid_lists")

    @uuid_lists.setter
    def uuid_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uuid_lists", value)


if not MYPY:
    class ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        value of the key.
        """
elif False:
    ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListEntityFilterExpressionListRightHandSideCategoriesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the project.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        value of the key.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectAcpContextFilterListScopeFilterExpressionListArgsDict(TypedDict):
        left_hand_side: pulumi.Input[str]
        """
        - (Optional)  The LHS of the filter expression - the scope type.
        """
        operator: pulumi.Input[str]
        """
        - (Required) The operator in the filter expression.
        """
        right_hand_side: pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgsDict']
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
elif False:
    ProjectAcpContextFilterListScopeFilterExpressionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListScopeFilterExpressionListArgs:
    def __init__(__self__, *,
                 left_hand_side: pulumi.Input[str],
                 operator: pulumi.Input[str],
                 right_hand_side: pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs']):
        """
        :param pulumi.Input[str] left_hand_side: - (Optional)  The LHS of the filter expression - the scope type.
        :param pulumi.Input[str] operator: - (Required) The operator in the filter expression.
        :param pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs'] right_hand_side: - (Required) The right hand side (RHS) of an scope expression.
        """
        pulumi.set(__self__, "left_hand_side", left_hand_side)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "right_hand_side", right_hand_side)

    @property
    @pulumi.getter(name="leftHandSide")
    def left_hand_side(self) -> pulumi.Input[str]:
        """
        - (Optional)  The LHS of the filter expression - the scope type.
        """
        return pulumi.get(self, "left_hand_side")

    @left_hand_side.setter
    def left_hand_side(self, value: pulumi.Input[str]):
        pulumi.set(self, "left_hand_side", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        - (Required) The operator in the filter expression.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="rightHandSide")
    def right_hand_side(self) -> pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs']:
        """
        - (Required) The right hand side (RHS) of an scope expression.
        """
        return pulumi.get(self, "right_hand_side")

    @right_hand_side.setter
    def right_hand_side(self, value: pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs']):
        pulumi.set(self, "right_hand_side", value)


if not MYPY:
    class ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgsDict(TypedDict):
        categories: NotRequired[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict']]
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        collection: NotRequired[pulumi.Input[str]]
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        uuid_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
elif False:
    ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideArgs:
    def __init__(__self__, *,
                 categories: Optional[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']] = None,
                 collection: Optional[pulumi.Input[str]] = None,
                 uuid_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs'] categories: - (Optional) The category values represented as a dictionary of key > list of values.
        :param pulumi.Input[str] collection: - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uuid_lists: - (Optional) The explicit list of UUIDs for the given kind.
        """
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if uuid_lists is not None:
            pulumi.set(__self__, "uuid_lists", uuid_lists)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']]:
        """
        - (Optional) The category values represented as a dictionary of key > list of values.
        """
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input['ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs']]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional)  A representative term for supported groupings of entities. ALL = All the entities of a given kind.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="uuidLists")
    def uuid_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - (Optional) The explicit list of UUIDs for the given kind.
        """
        return pulumi.get(self, "uuid_lists")

    @uuid_lists.setter
    def uuid_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uuid_lists", value)


if not MYPY:
    class ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        value of the key.
        """
elif False:
    ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpContextFilterListScopeFilterExpressionListRightHandSideCategoriesArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name for the project.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        value of the key.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProjectAcpRoleReferenceArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Required) The kind name (Default value: `project`).
        """
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectAcpRoleReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpRoleReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 uuid: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "uuid", uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectAcpUserGroupReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectAcpUserGroupReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpUserGroupReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectAcpUserReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectAcpUserReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectAcpUserReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of the key.
        """
elif False:
    ProjectCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the project.
        :param pulumi.Input[str] value: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectClusterReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectClusterReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectClusterReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectDefaultEnvironmentReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectDefaultEnvironmentReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDefaultEnvironmentReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectDefaultSubnetReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectDefaultSubnetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectDefaultSubnetReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectEnvironmentReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectEnvironmentReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectEnvironmentReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectExternalNetworkListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectExternalNetworkListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectExternalNetworkListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectExternalUserGroupReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectExternalUserGroupReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectExternalUserGroupReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectResourceDomainArgsDict(TypedDict):
        resources: pulumi.Input[Sequence[pulumi.Input['ProjectResourceDomainResourceArgsDict']]]
elif False:
    ProjectResourceDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceDomainArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input[Sequence[pulumi.Input['ProjectResourceDomainResourceArgs']]]):
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input['ProjectResourceDomainResourceArgs']]]:
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input['ProjectResourceDomainResourceArgs']]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ProjectResourceDomainResourceArgsDict(TypedDict):
        limit: pulumi.Input[int]
        resource_type: pulumi.Input[str]
        units: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[int]]
        """
        value of the key.
        """
elif False:
    ProjectResourceDomainResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceDomainResourceArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input[int],
                 resource_type: pulumi.Input[str],
                 units: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] value: value of the key.
        """
        pulumi.set(__self__, "limit", limit)
        pulumi.set(__self__, "resource_type", resource_type)
        if units is not None:
            pulumi.set(__self__, "units", units)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProjectSubnetReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectSubnetReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectSubnetReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectTunnelReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectTunnelReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectTunnelReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectUserGroupListArgsDict(TypedDict):
        directory_service_ous: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceOusArgsDict']]]]
        directory_service_user_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceUserGroupArgsDict']]]]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        saml_user_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListSamlUserGroupArgsDict']]]]
elif False:
    ProjectUserGroupListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserGroupListArgs:
    def __init__(__self__, *,
                 directory_service_ous: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceOusArgs']]]] = None,
                 directory_service_user_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceUserGroupArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 saml_user_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListSamlUserGroupArgs']]]] = None):
        if directory_service_ous is not None:
            pulumi.set(__self__, "directory_service_ous", directory_service_ous)
        if directory_service_user_groups is not None:
            pulumi.set(__self__, "directory_service_user_groups", directory_service_user_groups)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if saml_user_groups is not None:
            pulumi.set(__self__, "saml_user_groups", saml_user_groups)

    @property
    @pulumi.getter(name="directoryServiceOus")
    def directory_service_ous(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceOusArgs']]]]:
        return pulumi.get(self, "directory_service_ous")

    @directory_service_ous.setter
    def directory_service_ous(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceOusArgs']]]]):
        pulumi.set(self, "directory_service_ous", value)

    @property
    @pulumi.getter(name="directoryServiceUserGroups")
    def directory_service_user_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceUserGroupArgs']]]]:
        return pulumi.get(self, "directory_service_user_groups")

    @directory_service_user_groups.setter
    def directory_service_user_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListDirectoryServiceUserGroupArgs']]]]):
        pulumi.set(self, "directory_service_user_groups", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="samlUserGroups")
    def saml_user_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListSamlUserGroupArgs']]]]:
        return pulumi.get(self, "saml_user_groups")

    @saml_user_groups.setter
    def saml_user_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectUserGroupListSamlUserGroupArgs']]]]):
        pulumi.set(self, "saml_user_groups", value)


if not MYPY:
    class ProjectUserGroupListDirectoryServiceOusArgsDict(TypedDict):
        distinguished_name: pulumi.Input[str]
elif False:
    ProjectUserGroupListDirectoryServiceOusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserGroupListDirectoryServiceOusArgs:
    def __init__(__self__, *,
                 distinguished_name: pulumi.Input[str]):
        pulumi.set(__self__, "distinguished_name", distinguished_name)

    @property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "distinguished_name")

    @distinguished_name.setter
    def distinguished_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "distinguished_name", value)


if not MYPY:
    class ProjectUserGroupListDirectoryServiceUserGroupArgsDict(TypedDict):
        distinguished_name: pulumi.Input[str]
elif False:
    ProjectUserGroupListDirectoryServiceUserGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserGroupListDirectoryServiceUserGroupArgs:
    def __init__(__self__, *,
                 distinguished_name: pulumi.Input[str]):
        pulumi.set(__self__, "distinguished_name", distinguished_name)

    @property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "distinguished_name")

    @distinguished_name.setter
    def distinguished_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "distinguished_name", value)


if not MYPY:
    class ProjectUserGroupListSamlUserGroupArgsDict(TypedDict):
        idp_uuid: pulumi.Input[str]
        name: pulumi.Input[str]
        """
        The name for the project.
        """
elif False:
    ProjectUserGroupListSamlUserGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserGroupListSamlUserGroupArgs:
    def __init__(__self__, *,
                 idp_uuid: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "idp_uuid", idp_uuid)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="idpUuid")
    def idp_uuid(self) -> pulumi.Input[str]:
        return pulumi.get(self, "idp_uuid")

    @idp_uuid.setter
    def idp_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_uuid", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectUserListArgsDict(TypedDict):
        directory_service_user: NotRequired[pulumi.Input['ProjectUserListDirectoryServiceUserArgsDict']]
        identity_provider_user: NotRequired[pulumi.Input['ProjectUserListIdentityProviderUserArgsDict']]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    ProjectUserListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserListArgs:
    def __init__(__self__, *,
                 directory_service_user: Optional[pulumi.Input['ProjectUserListDirectoryServiceUserArgs']] = None,
                 identity_provider_user: Optional[pulumi.Input['ProjectUserListIdentityProviderUserArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if directory_service_user is not None:
            pulumi.set(__self__, "directory_service_user", directory_service_user)
        if identity_provider_user is not None:
            pulumi.set(__self__, "identity_provider_user", identity_provider_user)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="directoryServiceUser")
    def directory_service_user(self) -> Optional[pulumi.Input['ProjectUserListDirectoryServiceUserArgs']]:
        return pulumi.get(self, "directory_service_user")

    @directory_service_user.setter
    def directory_service_user(self, value: Optional[pulumi.Input['ProjectUserListDirectoryServiceUserArgs']]):
        pulumi.set(self, "directory_service_user", value)

    @property
    @pulumi.getter(name="identityProviderUser")
    def identity_provider_user(self) -> Optional[pulumi.Input['ProjectUserListIdentityProviderUserArgs']]:
        return pulumi.get(self, "identity_provider_user")

    @identity_provider_user.setter
    def identity_provider_user(self, value: Optional[pulumi.Input['ProjectUserListIdentityProviderUserArgs']]):
        pulumi.set(self, "identity_provider_user", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class ProjectUserListDirectoryServiceUserArgsDict(TypedDict):
        directory_service_reference: pulumi.Input['ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgsDict']
        default_user_principal_name: NotRequired[pulumi.Input[str]]
        user_principal_name: NotRequired[pulumi.Input[str]]
elif False:
    ProjectUserListDirectoryServiceUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserListDirectoryServiceUserArgs:
    def __init__(__self__, *,
                 directory_service_reference: pulumi.Input['ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgs'],
                 default_user_principal_name: Optional[pulumi.Input[str]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "directory_service_reference", directory_service_reference)
        if default_user_principal_name is not None:
            pulumi.set(__self__, "default_user_principal_name", default_user_principal_name)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="directoryServiceReference")
    def directory_service_reference(self) -> pulumi.Input['ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgs']:
        return pulumi.get(self, "directory_service_reference")

    @directory_service_reference.setter
    def directory_service_reference(self, value: pulumi.Input['ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgs']):
        pulumi.set(self, "directory_service_reference", value)

    @property
    @pulumi.getter(name="defaultUserPrincipalName")
    def default_user_principal_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_user_principal_name")

    @default_user_principal_name.setter
    def default_user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_user_principal_name", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserListDirectoryServiceUserDirectoryServiceReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectUserListIdentityProviderUserArgsDict(TypedDict):
        identity_provider_reference: pulumi.Input['ProjectUserListIdentityProviderUserIdentityProviderReferenceArgsDict']
        username: NotRequired[pulumi.Input[str]]
elif False:
    ProjectUserListIdentityProviderUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserListIdentityProviderUserArgs:
    def __init__(__self__, *,
                 identity_provider_reference: pulumi.Input['ProjectUserListIdentityProviderUserIdentityProviderReferenceArgs'],
                 username: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "identity_provider_reference", identity_provider_reference)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="identityProviderReference")
    def identity_provider_reference(self) -> pulumi.Input['ProjectUserListIdentityProviderUserIdentityProviderReferenceArgs']:
        return pulumi.get(self, "identity_provider_reference")

    @identity_provider_reference.setter
    def identity_provider_reference(self, value: pulumi.Input['ProjectUserListIdentityProviderUserIdentityProviderReferenceArgs']):
        pulumi.set(self, "identity_provider_reference", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ProjectUserListIdentityProviderUserIdentityProviderReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectUserListIdentityProviderUserIdentityProviderReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserListIdentityProviderUserIdentityProviderReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectUserReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectUserReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectUserReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProjectVpcReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the project.
        """
elif False:
    ProjectVpcReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectVpcReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the project.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProtectionRuleAvailabilityZoneConnectivityListArgsDict(TypedDict):
        destination_availability_zone_index: NotRequired[pulumi.Input[int]]
        snapshot_schedule_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgsDict']]]]
        source_availability_zone_index: NotRequired[pulumi.Input[int]]
elif False:
    ProtectionRuleAvailabilityZoneConnectivityListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleAvailabilityZoneConnectivityListArgs:
    def __init__(__self__, *,
                 destination_availability_zone_index: Optional[pulumi.Input[int]] = None,
                 snapshot_schedule_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgs']]]] = None,
                 source_availability_zone_index: Optional[pulumi.Input[int]] = None):
        if destination_availability_zone_index is not None:
            pulumi.set(__self__, "destination_availability_zone_index", destination_availability_zone_index)
        if snapshot_schedule_lists is not None:
            pulumi.set(__self__, "snapshot_schedule_lists", snapshot_schedule_lists)
        if source_availability_zone_index is not None:
            pulumi.set(__self__, "source_availability_zone_index", source_availability_zone_index)

    @property
    @pulumi.getter(name="destinationAvailabilityZoneIndex")
    def destination_availability_zone_index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "destination_availability_zone_index")

    @destination_availability_zone_index.setter
    def destination_availability_zone_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "destination_availability_zone_index", value)

    @property
    @pulumi.getter(name="snapshotScheduleLists")
    def snapshot_schedule_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgs']]]]:
        return pulumi.get(self, "snapshot_schedule_lists")

    @snapshot_schedule_lists.setter
    def snapshot_schedule_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgs']]]]):
        pulumi.set(self, "snapshot_schedule_lists", value)

    @property
    @pulumi.getter(name="sourceAvailabilityZoneIndex")
    def source_availability_zone_index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "source_availability_zone_index")

    @source_availability_zone_index.setter
    def source_availability_zone_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "source_availability_zone_index", value)


if not MYPY:
    class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgsDict(TypedDict):
        recovery_point_objective_secs: pulumi.Input[int]
        auto_suspend_timeout_secs: NotRequired[pulumi.Input[int]]
        local_snapshot_retention_policy: NotRequired[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgsDict']]
        remote_snapshot_retention_policy: NotRequired[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgsDict']]
        snapshot_type: NotRequired[pulumi.Input[str]]
elif False:
    ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListArgs:
    def __init__(__self__, *,
                 recovery_point_objective_secs: pulumi.Input[int],
                 auto_suspend_timeout_secs: Optional[pulumi.Input[int]] = None,
                 local_snapshot_retention_policy: Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgs']] = None,
                 remote_snapshot_retention_policy: Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgs']] = None,
                 snapshot_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "recovery_point_objective_secs", recovery_point_objective_secs)
        if auto_suspend_timeout_secs is not None:
            pulumi.set(__self__, "auto_suspend_timeout_secs", auto_suspend_timeout_secs)
        if local_snapshot_retention_policy is not None:
            pulumi.set(__self__, "local_snapshot_retention_policy", local_snapshot_retention_policy)
        if remote_snapshot_retention_policy is not None:
            pulumi.set(__self__, "remote_snapshot_retention_policy", remote_snapshot_retention_policy)
        if snapshot_type is not None:
            pulumi.set(__self__, "snapshot_type", snapshot_type)

    @property
    @pulumi.getter(name="recoveryPointObjectiveSecs")
    def recovery_point_objective_secs(self) -> pulumi.Input[int]:
        return pulumi.get(self, "recovery_point_objective_secs")

    @recovery_point_objective_secs.setter
    def recovery_point_objective_secs(self, value: pulumi.Input[int]):
        pulumi.set(self, "recovery_point_objective_secs", value)

    @property
    @pulumi.getter(name="autoSuspendTimeoutSecs")
    def auto_suspend_timeout_secs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "auto_suspend_timeout_secs")

    @auto_suspend_timeout_secs.setter
    def auto_suspend_timeout_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auto_suspend_timeout_secs", value)

    @property
    @pulumi.getter(name="localSnapshotRetentionPolicy")
    def local_snapshot_retention_policy(self) -> Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgs']]:
        return pulumi.get(self, "local_snapshot_retention_policy")

    @local_snapshot_retention_policy.setter
    def local_snapshot_retention_policy(self, value: Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgs']]):
        pulumi.set(self, "local_snapshot_retention_policy", value)

    @property
    @pulumi.getter(name="remoteSnapshotRetentionPolicy")
    def remote_snapshot_retention_policy(self) -> Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgs']]:
        return pulumi.get(self, "remote_snapshot_retention_policy")

    @remote_snapshot_retention_policy.setter
    def remote_snapshot_retention_policy(self, value: Optional[pulumi.Input['ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgs']]):
        pulumi.set(self, "remote_snapshot_retention_policy", value)

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snapshot_type")

    @snapshot_type.setter
    def snapshot_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_type", value)


if not MYPY:
    class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgsDict(TypedDict):
        num_snapshots: NotRequired[pulumi.Input[int]]
        rollup_retention_policy_multiple: NotRequired[pulumi.Input[int]]
        rollup_retention_policy_snapshot_interval_type: NotRequired[pulumi.Input[str]]
elif False:
    ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListLocalSnapshotRetentionPolicyArgs:
    def __init__(__self__, *,
                 num_snapshots: Optional[pulumi.Input[int]] = None,
                 rollup_retention_policy_multiple: Optional[pulumi.Input[int]] = None,
                 rollup_retention_policy_snapshot_interval_type: Optional[pulumi.Input[str]] = None):
        if num_snapshots is not None:
            pulumi.set(__self__, "num_snapshots", num_snapshots)
        if rollup_retention_policy_multiple is not None:
            pulumi.set(__self__, "rollup_retention_policy_multiple", rollup_retention_policy_multiple)
        if rollup_retention_policy_snapshot_interval_type is not None:
            pulumi.set(__self__, "rollup_retention_policy_snapshot_interval_type", rollup_retention_policy_snapshot_interval_type)

    @property
    @pulumi.getter(name="numSnapshots")
    def num_snapshots(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_snapshots")

    @num_snapshots.setter
    def num_snapshots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_snapshots", value)

    @property
    @pulumi.getter(name="rollupRetentionPolicyMultiple")
    def rollup_retention_policy_multiple(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rollup_retention_policy_multiple")

    @rollup_retention_policy_multiple.setter
    def rollup_retention_policy_multiple(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rollup_retention_policy_multiple", value)

    @property
    @pulumi.getter(name="rollupRetentionPolicySnapshotIntervalType")
    def rollup_retention_policy_snapshot_interval_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rollup_retention_policy_snapshot_interval_type")

    @rollup_retention_policy_snapshot_interval_type.setter
    def rollup_retention_policy_snapshot_interval_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rollup_retention_policy_snapshot_interval_type", value)


if not MYPY:
    class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgsDict(TypedDict):
        num_snapshots: NotRequired[pulumi.Input[int]]
        rollup_retention_policy_multiple: NotRequired[pulumi.Input[int]]
        rollup_retention_policy_snapshot_interval_type: NotRequired[pulumi.Input[str]]
elif False:
    ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleAvailabilityZoneConnectivityListSnapshotScheduleListRemoteSnapshotRetentionPolicyArgs:
    def __init__(__self__, *,
                 num_snapshots: Optional[pulumi.Input[int]] = None,
                 rollup_retention_policy_multiple: Optional[pulumi.Input[int]] = None,
                 rollup_retention_policy_snapshot_interval_type: Optional[pulumi.Input[str]] = None):
        if num_snapshots is not None:
            pulumi.set(__self__, "num_snapshots", num_snapshots)
        if rollup_retention_policy_multiple is not None:
            pulumi.set(__self__, "rollup_retention_policy_multiple", rollup_retention_policy_multiple)
        if rollup_retention_policy_snapshot_interval_type is not None:
            pulumi.set(__self__, "rollup_retention_policy_snapshot_interval_type", rollup_retention_policy_snapshot_interval_type)

    @property
    @pulumi.getter(name="numSnapshots")
    def num_snapshots(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_snapshots")

    @num_snapshots.setter
    def num_snapshots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_snapshots", value)

    @property
    @pulumi.getter(name="rollupRetentionPolicyMultiple")
    def rollup_retention_policy_multiple(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "rollup_retention_policy_multiple")

    @rollup_retention_policy_multiple.setter
    def rollup_retention_policy_multiple(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rollup_retention_policy_multiple", value)

    @property
    @pulumi.getter(name="rollupRetentionPolicySnapshotIntervalType")
    def rollup_retention_policy_snapshot_interval_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rollup_retention_policy_snapshot_interval_type")

    @rollup_retention_policy_snapshot_interval_type.setter
    def rollup_retention_policy_snapshot_interval_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rollup_retention_policy_snapshot_interval_type", value)


if not MYPY:
    class ProtectionRuleCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the protection rule.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of the key.
        """
elif False:
    ProtectionRuleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the protection rule.
        :param pulumi.Input[str] value: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the protection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ProtectionRuleCategoryFilterArgsDict(TypedDict):
        kind_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        params: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleCategoryFilterParamArgsDict']]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    ProtectionRuleCategoryFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleCategoryFilterArgs:
    def __init__(__self__, *,
                 kind_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 params: Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleCategoryFilterParamArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if kind_lists is not None:
            pulumi.set(__self__, "kind_lists", kind_lists)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="kindLists")
    def kind_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "kind_lists")

    @kind_lists.setter
    def kind_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kind_lists", value)

    @property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleCategoryFilterParamArgs']]]]:
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProtectionRuleCategoryFilterParamArgs']]]]):
        pulumi.set(self, "params", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ProtectionRuleCategoryFilterParamArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name for the protection rule.
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    ProtectionRuleCategoryFilterParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleCategoryFilterParamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name for the protection rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the protection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ProtectionRuleOrderedAvailabilityZoneListArgsDict(TypedDict):
        availability_zone_url: NotRequired[pulumi.Input[str]]
        cluster_uuid: NotRequired[pulumi.Input[str]]
elif False:
    ProtectionRuleOrderedAvailabilityZoneListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleOrderedAvailabilityZoneListArgs:
    def __init__(__self__, *,
                 availability_zone_url: Optional[pulumi.Input[str]] = None,
                 cluster_uuid: Optional[pulumi.Input[str]] = None):
        if availability_zone_url is not None:
            pulumi.set(__self__, "availability_zone_url", availability_zone_url)
        if cluster_uuid is not None:
            pulumi.set(__self__, "cluster_uuid", cluster_uuid)

    @property
    @pulumi.getter(name="availabilityZoneUrl")
    def availability_zone_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability_zone_url")

    @availability_zone_url.setter
    def availability_zone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone_url", value)

    @property
    @pulumi.getter(name="clusterUuid")
    def cluster_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_uuid")

    @cluster_uuid.setter
    def cluster_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_uuid", value)


if not MYPY:
    class ProtectionRuleOwnerReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the protection rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    ProtectionRuleOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleOwnerReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the protection rule.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the protection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class ProtectionRuleProjectReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the protection rule.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    ProtectionRuleProjectReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProtectionRuleProjectReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the protection rule.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the protection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of the key.
        """
elif False:
    RecoveryPlanCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] value: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecoveryPlanOwnerReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanOwnerReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersArgsDict(TypedDict):
        floating_ip_assignment_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListArgsDict']]]]
        network_mapping_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListArgsDict']]]]
elif False:
    RecoveryPlanParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersArgs:
    def __init__(__self__, *,
                 floating_ip_assignment_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListArgs']]]] = None,
                 network_mapping_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListArgs']]]] = None):
        if floating_ip_assignment_lists is not None:
            pulumi.set(__self__, "floating_ip_assignment_lists", floating_ip_assignment_lists)
        if network_mapping_lists is not None:
            pulumi.set(__self__, "network_mapping_lists", network_mapping_lists)

    @property
    @pulumi.getter(name="floatingIpAssignmentLists")
    def floating_ip_assignment_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListArgs']]]]:
        return pulumi.get(self, "floating_ip_assignment_lists")

    @floating_ip_assignment_lists.setter
    def floating_ip_assignment_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListArgs']]]]):
        pulumi.set(self, "floating_ip_assignment_lists", value)

    @property
    @pulumi.getter(name="networkMappingLists")
    def network_mapping_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListArgs']]]]:
        return pulumi.get(self, "network_mapping_lists")

    @network_mapping_lists.setter
    def network_mapping_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListArgs']]]]):
        pulumi.set(self, "network_mapping_lists", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListArgsDict(TypedDict):
        availability_zone_url: pulumi.Input[str]
        vm_ip_assignment_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgsDict']]]
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListArgs:
    def __init__(__self__, *,
                 availability_zone_url: pulumi.Input[str],
                 vm_ip_assignment_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgs']]]):
        pulumi.set(__self__, "availability_zone_url", availability_zone_url)
        pulumi.set(__self__, "vm_ip_assignment_lists", vm_ip_assignment_lists)

    @property
    @pulumi.getter(name="availabilityZoneUrl")
    def availability_zone_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "availability_zone_url")

    @availability_zone_url.setter
    def availability_zone_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone_url", value)

    @property
    @pulumi.getter(name="vmIpAssignmentLists")
    def vm_ip_assignment_lists(self) -> pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgs']]]:
        return pulumi.get(self, "vm_ip_assignment_lists")

    @vm_ip_assignment_lists.setter
    def vm_ip_assignment_lists(self, value: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgs']]]):
        pulumi.set(self, "vm_ip_assignment_lists", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgsDict(TypedDict):
        vm_nic_information: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgsDict']
        vm_reference: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgsDict']
        recovery_floating_ip_config: NotRequired[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgsDict']]
        test_floating_ip_config: NotRequired[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgsDict']]
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListArgs:
    def __init__(__self__, *,
                 vm_nic_information: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgs'],
                 vm_reference: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgs'],
                 recovery_floating_ip_config: Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgs']] = None,
                 test_floating_ip_config: Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgs']] = None):
        pulumi.set(__self__, "vm_nic_information", vm_nic_information)
        pulumi.set(__self__, "vm_reference", vm_reference)
        if recovery_floating_ip_config is not None:
            pulumi.set(__self__, "recovery_floating_ip_config", recovery_floating_ip_config)
        if test_floating_ip_config is not None:
            pulumi.set(__self__, "test_floating_ip_config", test_floating_ip_config)

    @property
    @pulumi.getter(name="vmNicInformation")
    def vm_nic_information(self) -> pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgs']:
        return pulumi.get(self, "vm_nic_information")

    @vm_nic_information.setter
    def vm_nic_information(self, value: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgs']):
        pulumi.set(self, "vm_nic_information", value)

    @property
    @pulumi.getter(name="vmReference")
    def vm_reference(self) -> pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgs']:
        return pulumi.get(self, "vm_reference")

    @vm_reference.setter
    def vm_reference(self, value: pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgs']):
        pulumi.set(self, "vm_reference", value)

    @property
    @pulumi.getter(name="recoveryFloatingIpConfig")
    def recovery_floating_ip_config(self) -> Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgs']]:
        return pulumi.get(self, "recovery_floating_ip_config")

    @recovery_floating_ip_config.setter
    def recovery_floating_ip_config(self, value: Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgs']]):
        pulumi.set(self, "recovery_floating_ip_config", value)

    @property
    @pulumi.getter(name="testFloatingIpConfig")
    def test_floating_ip_config(self) -> Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgs']]:
        return pulumi.get(self, "test_floating_ip_config")

    @test_floating_ip_config.setter
    def test_floating_ip_config(self, value: Optional[pulumi.Input['RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgs']]):
        pulumi.set(self, "test_floating_ip_config", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        should_allocate_dynamically: NotRequired[pulumi.Input[bool]]
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListRecoveryFloatingIpConfigArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 should_allocate_dynamically: Optional[pulumi.Input[bool]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if should_allocate_dynamically is not None:
            pulumi.set(__self__, "should_allocate_dynamically", should_allocate_dynamically)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="shouldAllocateDynamically")
    def should_allocate_dynamically(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allocate_dynamically")

    @should_allocate_dynamically.setter
    def should_allocate_dynamically(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allocate_dynamically", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        should_allocate_dynamically: NotRequired[pulumi.Input[bool]]
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListTestFloatingIpConfigArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 should_allocate_dynamically: Optional[pulumi.Input[bool]] = None):
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if should_allocate_dynamically is not None:
            pulumi.set(__self__, "should_allocate_dynamically", should_allocate_dynamically)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="shouldAllocateDynamically")
    def should_allocate_dynamically(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allocate_dynamically")

    @should_allocate_dynamically.setter
    def should_allocate_dynamically(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allocate_dynamically", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        ip: NotRequired[pulumi.Input[str]]
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmNicInformationArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "uuid", uuid)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Required) The kind name (Default value: `project`).
        """
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
elif False:
    RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersFloatingIpAssignmentListVmIpAssignmentListVmReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 uuid: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "uuid", uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListArgsDict(TypedDict):
        are_networks_stretched: NotRequired[pulumi.Input[bool]]
        availability_zone_network_mapping_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgsDict']]]]
elif False:
    RecoveryPlanParametersNetworkMappingListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListArgs:
    def __init__(__self__, *,
                 are_networks_stretched: Optional[pulumi.Input[bool]] = None,
                 availability_zone_network_mapping_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgs']]]] = None):
        if are_networks_stretched is not None:
            pulumi.set(__self__, "are_networks_stretched", are_networks_stretched)
        if availability_zone_network_mapping_lists is not None:
            pulumi.set(__self__, "availability_zone_network_mapping_lists", availability_zone_network_mapping_lists)

    @property
    @pulumi.getter(name="areNetworksStretched")
    def are_networks_stretched(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "are_networks_stretched")

    @are_networks_stretched.setter
    def are_networks_stretched(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_networks_stretched", value)

    @property
    @pulumi.getter(name="availabilityZoneNetworkMappingLists")
    def availability_zone_network_mapping_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgs']]]]:
        return pulumi.get(self, "availability_zone_network_mapping_lists")

    @availability_zone_network_mapping_lists.setter
    def availability_zone_network_mapping_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgs']]]]):
        pulumi.set(self, "availability_zone_network_mapping_lists", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgsDict(TypedDict):
        availability_zone_url: NotRequired[pulumi.Input[str]]
        cluster_reference_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgsDict']]]]
        recovery_ip_assignment_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgsDict']]]]
        recovery_network: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgsDict']]
        test_ip_assignment_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgsDict']]]]
        test_network: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgsDict']]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListArgs:
    def __init__(__self__, *,
                 availability_zone_url: Optional[pulumi.Input[str]] = None,
                 cluster_reference_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgs']]]] = None,
                 recovery_ip_assignment_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgs']]]] = None,
                 recovery_network: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgs']] = None,
                 test_ip_assignment_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgs']]]] = None,
                 test_network: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgs']] = None):
        if availability_zone_url is not None:
            pulumi.set(__self__, "availability_zone_url", availability_zone_url)
        if cluster_reference_lists is not None:
            pulumi.set(__self__, "cluster_reference_lists", cluster_reference_lists)
        if recovery_ip_assignment_lists is not None:
            pulumi.set(__self__, "recovery_ip_assignment_lists", recovery_ip_assignment_lists)
        if recovery_network is not None:
            pulumi.set(__self__, "recovery_network", recovery_network)
        if test_ip_assignment_lists is not None:
            pulumi.set(__self__, "test_ip_assignment_lists", test_ip_assignment_lists)
        if test_network is not None:
            pulumi.set(__self__, "test_network", test_network)

    @property
    @pulumi.getter(name="availabilityZoneUrl")
    def availability_zone_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "availability_zone_url")

    @availability_zone_url.setter
    def availability_zone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone_url", value)

    @property
    @pulumi.getter(name="clusterReferenceLists")
    def cluster_reference_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgs']]]]:
        return pulumi.get(self, "cluster_reference_lists")

    @cluster_reference_lists.setter
    def cluster_reference_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgs']]]]):
        pulumi.set(self, "cluster_reference_lists", value)

    @property
    @pulumi.getter(name="recoveryIpAssignmentLists")
    def recovery_ip_assignment_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgs']]]]:
        return pulumi.get(self, "recovery_ip_assignment_lists")

    @recovery_ip_assignment_lists.setter
    def recovery_ip_assignment_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgs']]]]):
        pulumi.set(self, "recovery_ip_assignment_lists", value)

    @property
    @pulumi.getter(name="recoveryNetwork")
    def recovery_network(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgs']]:
        return pulumi.get(self, "recovery_network")

    @recovery_network.setter
    def recovery_network(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgs']]):
        pulumi.set(self, "recovery_network", value)

    @property
    @pulumi.getter(name="testIpAssignmentLists")
    def test_ip_assignment_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgs']]]]:
        return pulumi.get(self, "test_ip_assignment_lists")

    @test_ip_assignment_lists.setter
    def test_ip_assignment_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgs']]]]):
        pulumi.set(self, "test_ip_assignment_lists", value)

    @property
    @pulumi.getter(name="testNetwork")
    def test_network(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgs']]:
        return pulumi.get(self, "test_network")

    @test_network.setter
    def test_network(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgs']]):
        pulumi.set(self, "test_network", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Required) The kind name (Default value: `project`).
        """
        uuid: pulumi.Input[str]
        """
        (Required) the UUID.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListClusterReferenceListArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 uuid: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] uuid: (Required) the UUID.
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "uuid", uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgsDict(TypedDict):
        ip_config_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgsDict']]]
        vm_reference: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgsDict']
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListArgs:
    def __init__(__self__, *,
                 ip_config_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgs']]],
                 vm_reference: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgs']):
        pulumi.set(__self__, "ip_config_lists", ip_config_lists)
        pulumi.set(__self__, "vm_reference", vm_reference)

    @property
    @pulumi.getter(name="ipConfigLists")
    def ip_config_lists(self) -> pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgs']]]:
        return pulumi.get(self, "ip_config_lists")

    @ip_config_lists.setter
    def ip_config_lists(self, value: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgs']]]):
        pulumi.set(self, "ip_config_lists", value)

    @property
    @pulumi.getter(name="vmReference")
    def vm_reference(self) -> pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgs']:
        return pulumi.get(self, "vm_reference")

    @vm_reference.setter
    def vm_reference(self, value: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgs']):
        pulumi.set(self, "vm_reference", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgsDict(TypedDict):
        ip_address: pulumi.Input[str]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListIpConfigListArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[str]):
        pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryIpAssignmentListVmReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        subnet_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgsDict']]]]
        use_vpc_reference: NotRequired[pulumi.Input[bool]]
        virtual_network_reference: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgsDict']]
        vpc_reference: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgsDict']]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 subnet_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgs']]]] = None,
                 use_vpc_reference: Optional[pulumi.Input[bool]] = None,
                 virtual_network_reference: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgs']] = None,
                 vpc_reference: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet_lists is not None:
            pulumi.set(__self__, "subnet_lists", subnet_lists)
        if use_vpc_reference is not None:
            pulumi.set(__self__, "use_vpc_reference", use_vpc_reference)
        if virtual_network_reference is not None:
            pulumi.set(__self__, "virtual_network_reference", virtual_network_reference)
        if vpc_reference is not None:
            pulumi.set(__self__, "vpc_reference", vpc_reference)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subnetLists")
    def subnet_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgs']]]]:
        return pulumi.get(self, "subnet_lists")

    @subnet_lists.setter
    def subnet_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgs']]]]):
        pulumi.set(self, "subnet_lists", value)

    @property
    @pulumi.getter(name="useVpcReference")
    def use_vpc_reference(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_vpc_reference")

    @use_vpc_reference.setter
    def use_vpc_reference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_vpc_reference", value)

    @property
    @pulumi.getter(name="virtualNetworkReference")
    def virtual_network_reference(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgs']]:
        return pulumi.get(self, "virtual_network_reference")

    @virtual_network_reference.setter
    def virtual_network_reference(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgs']]):
        pulumi.set(self, "virtual_network_reference", value)

    @property
    @pulumi.getter(name="vpcReference")
    def vpc_reference(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgs']]:
        return pulumi.get(self, "vpc_reference")

    @vpc_reference.setter
    def vpc_reference(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgs']]):
        pulumi.set(self, "vpc_reference", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgsDict(TypedDict):
        gateway_ip: pulumi.Input[str]
        prefix_length: pulumi.Input[int]
        external_connectivity_state: NotRequired[pulumi.Input[str]]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkSubnetListArgs:
    def __init__(__self__, *,
                 gateway_ip: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 external_connectivity_state: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "gateway_ip", gateway_ip)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if external_connectivity_state is not None:
            pulumi.set(__self__, "external_connectivity_state", external_connectivity_state)

    @property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="externalConnectivityState")
    def external_connectivity_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_connectivity_state")

    @external_connectivity_state.setter
    def external_connectivity_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_connectivity_state", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVirtualNetworkReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListRecoveryNetworkVpcReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgsDict(TypedDict):
        ip_config_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgsDict']]]
        vm_reference: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgsDict']
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListArgs:
    def __init__(__self__, *,
                 ip_config_lists: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgs']]],
                 vm_reference: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgs']):
        pulumi.set(__self__, "ip_config_lists", ip_config_lists)
        pulumi.set(__self__, "vm_reference", vm_reference)

    @property
    @pulumi.getter(name="ipConfigLists")
    def ip_config_lists(self) -> pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgs']]]:
        return pulumi.get(self, "ip_config_lists")

    @ip_config_lists.setter
    def ip_config_lists(self, value: pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgs']]]):
        pulumi.set(self, "ip_config_lists", value)

    @property
    @pulumi.getter(name="vmReference")
    def vm_reference(self) -> pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgs']:
        return pulumi.get(self, "vm_reference")

    @vm_reference.setter
    def vm_reference(self, value: pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgs']):
        pulumi.set(self, "vm_reference", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgsDict(TypedDict):
        ip_address: pulumi.Input[str]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListIpConfigListArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[str]):
        pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestIpAssignmentListVmReferenceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        subnet_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgsDict']]]]
        use_vpc_reference: NotRequired[pulumi.Input[bool]]
        virtual_network_reference: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgsDict']]
        vpc_reference: NotRequired[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgsDict']]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 subnet_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgs']]]] = None,
                 use_vpc_reference: Optional[pulumi.Input[bool]] = None,
                 virtual_network_reference: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgs']] = None,
                 vpc_reference: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgs']] = None):
        """
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if subnet_lists is not None:
            pulumi.set(__self__, "subnet_lists", subnet_lists)
        if use_vpc_reference is not None:
            pulumi.set(__self__, "use_vpc_reference", use_vpc_reference)
        if virtual_network_reference is not None:
            pulumi.set(__self__, "virtual_network_reference", virtual_network_reference)
        if vpc_reference is not None:
            pulumi.set(__self__, "vpc_reference", vpc_reference)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="subnetLists")
    def subnet_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgs']]]]:
        return pulumi.get(self, "subnet_lists")

    @subnet_lists.setter
    def subnet_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgs']]]]):
        pulumi.set(self, "subnet_lists", value)

    @property
    @pulumi.getter(name="useVpcReference")
    def use_vpc_reference(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_vpc_reference")

    @use_vpc_reference.setter
    def use_vpc_reference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_vpc_reference", value)

    @property
    @pulumi.getter(name="virtualNetworkReference")
    def virtual_network_reference(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgs']]:
        return pulumi.get(self, "virtual_network_reference")

    @virtual_network_reference.setter
    def virtual_network_reference(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgs']]):
        pulumi.set(self, "virtual_network_reference", value)

    @property
    @pulumi.getter(name="vpcReference")
    def vpc_reference(self) -> Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgs']]:
        return pulumi.get(self, "vpc_reference")

    @vpc_reference.setter
    def vpc_reference(self, value: Optional[pulumi.Input['RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgs']]):
        pulumi.set(self, "vpc_reference", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgsDict(TypedDict):
        gateway_ip: pulumi.Input[str]
        prefix_length: pulumi.Input[int]
        external_connectivity_state: NotRequired[pulumi.Input[str]]
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkSubnetListArgs:
    def __init__(__self__, *,
                 gateway_ip: pulumi.Input[str],
                 prefix_length: pulumi.Input[int],
                 external_connectivity_state: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "gateway_ip", gateway_ip)
        pulumi.set(__self__, "prefix_length", prefix_length)
        if external_connectivity_state is not None:
            pulumi.set(__self__, "external_connectivity_state", external_connectivity_state)

    @property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> pulumi.Input[str]:
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway_ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter(name="externalConnectivityState")
    def external_connectivity_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_connectivity_state")

    @external_connectivity_state.setter
    def external_connectivity_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_connectivity_state", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVirtualNetworkReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanParametersNetworkMappingListAvailabilityZoneNetworkMappingListTestNetworkVpcReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanProjectReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        (Required) The kind name (Default value: `project`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        (Required) the UUID.
        """
elif False:
    RecoveryPlanProjectReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanProjectReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Required) The kind name (Default value: `project`).
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] uuid: (Required) the UUID.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RecoveryPlanStageListArgsDict(TypedDict):
        stage_work: pulumi.Input['RecoveryPlanStageListStageWorkArgsDict']
        delay_time_secs: NotRequired[pulumi.Input[int]]
        stage_uuid: NotRequired[pulumi.Input[str]]
elif False:
    RecoveryPlanStageListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListArgs:
    def __init__(__self__, *,
                 stage_work: pulumi.Input['RecoveryPlanStageListStageWorkArgs'],
                 delay_time_secs: Optional[pulumi.Input[int]] = None,
                 stage_uuid: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "stage_work", stage_work)
        if delay_time_secs is not None:
            pulumi.set(__self__, "delay_time_secs", delay_time_secs)
        if stage_uuid is not None:
            pulumi.set(__self__, "stage_uuid", stage_uuid)

    @property
    @pulumi.getter(name="stageWork")
    def stage_work(self) -> pulumi.Input['RecoveryPlanStageListStageWorkArgs']:
        return pulumi.get(self, "stage_work")

    @stage_work.setter
    def stage_work(self, value: pulumi.Input['RecoveryPlanStageListStageWorkArgs']):
        pulumi.set(self, "stage_work", value)

    @property
    @pulumi.getter(name="delayTimeSecs")
    def delay_time_secs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "delay_time_secs")

    @delay_time_secs.setter
    def delay_time_secs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay_time_secs", value)

    @property
    @pulumi.getter(name="stageUuid")
    def stage_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "stage_uuid")

    @stage_uuid.setter
    def stage_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stage_uuid", value)


if not MYPY:
    class RecoveryPlanStageListStageWorkArgsDict(TypedDict):
        recover_entities: NotRequired[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesArgsDict']]
elif False:
    RecoveryPlanStageListStageWorkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListStageWorkArgs:
    def __init__(__self__, *,
                 recover_entities: Optional[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesArgs']] = None):
        if recover_entities is not None:
            pulumi.set(__self__, "recover_entities", recover_entities)

    @property
    @pulumi.getter(name="recoverEntities")
    def recover_entities(self) -> Optional[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesArgs']]:
        return pulumi.get(self, "recover_entities")

    @recover_entities.setter
    def recover_entities(self, value: Optional[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesArgs']]):
        pulumi.set(self, "recover_entities", value)


if not MYPY:
    class RecoveryPlanStageListStageWorkRecoverEntitiesArgsDict(TypedDict):
        entity_info_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgsDict']]]]
elif False:
    RecoveryPlanStageListStageWorkRecoverEntitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListStageWorkRecoverEntitiesArgs:
    def __init__(__self__, *,
                 entity_info_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgs']]]] = None):
        if entity_info_lists is not None:
            pulumi.set(__self__, "entity_info_lists", entity_info_lists)

    @property
    @pulumi.getter(name="entityInfoLists")
    def entity_info_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgs']]]]:
        return pulumi.get(self, "entity_info_lists")

    @entity_info_lists.setter
    def entity_info_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgs']]]]):
        pulumi.set(self, "entity_info_lists", value)


if not MYPY:
    class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgsDict(TypedDict):
        any_entity_reference_kind: NotRequired[pulumi.Input[str]]
        any_entity_reference_name: NotRequired[pulumi.Input[str]]
        any_entity_reference_uuid: NotRequired[pulumi.Input[str]]
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgsDict']]]]
        script_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgsDict']]]]
elif False:
    RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListArgs:
    def __init__(__self__, *,
                 any_entity_reference_kind: Optional[pulumi.Input[str]] = None,
                 any_entity_reference_name: Optional[pulumi.Input[str]] = None,
                 any_entity_reference_uuid: Optional[pulumi.Input[str]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgs']]]] = None,
                 script_lists: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgs']]]] = None):
        if any_entity_reference_kind is not None:
            pulumi.set(__self__, "any_entity_reference_kind", any_entity_reference_kind)
        if any_entity_reference_name is not None:
            pulumi.set(__self__, "any_entity_reference_name", any_entity_reference_name)
        if any_entity_reference_uuid is not None:
            pulumi.set(__self__, "any_entity_reference_uuid", any_entity_reference_uuid)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if script_lists is not None:
            pulumi.set(__self__, "script_lists", script_lists)

    @property
    @pulumi.getter(name="anyEntityReferenceKind")
    def any_entity_reference_kind(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "any_entity_reference_kind")

    @any_entity_reference_kind.setter
    def any_entity_reference_kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "any_entity_reference_kind", value)

    @property
    @pulumi.getter(name="anyEntityReferenceName")
    def any_entity_reference_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "any_entity_reference_name")

    @any_entity_reference_name.setter
    def any_entity_reference_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "any_entity_reference_name", value)

    @property
    @pulumi.getter(name="anyEntityReferenceUuid")
    def any_entity_reference_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "any_entity_reference_uuid")

    @any_entity_reference_uuid.setter
    def any_entity_reference_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "any_entity_reference_uuid", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgs']]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="scriptLists")
    def script_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgs']]]]:
        return pulumi.get(self, "script_lists")

    @script_lists.setter
    def script_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgs']]]]):
        pulumi.set(self, "script_lists", value)


if not MYPY:
    class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name for the Recovery Plan.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of the key.
        """
elif False:
    RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the Recovery Plan.
        :param pulumi.Input[str] value: value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the Recovery Plan.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgsDict(TypedDict):
        enable_script_exec: pulumi.Input[bool]
        timeout: NotRequired[pulumi.Input[str]]
elif False:
    RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPlanStageListStageWorkRecoverEntitiesEntityInfoListScriptListArgs:
    def __init__(__self__, *,
                 enable_script_exec: pulumi.Input[bool],
                 timeout: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "enable_script_exec", enable_script_exec)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="enableScriptExec")
    def enable_script_exec(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enable_script_exec")

    @enable_script_exec.setter
    def enable_script_exec(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_script_exec", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RecoveryPointRestoreV2VmRecoveryPointRestoreOverrideArgsDict(TypedDict):
        vm_recovery_point_ext_id: pulumi.Input[str]
        """
        -(Required) External identifier of a VM recovery point, that is a part of the top-level recovery point.
        """
elif False:
    RecoveryPointRestoreV2VmRecoveryPointRestoreOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointRestoreV2VmRecoveryPointRestoreOverrideArgs:
    def __init__(__self__, *,
                 vm_recovery_point_ext_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] vm_recovery_point_ext_id: -(Required) External identifier of a VM recovery point, that is a part of the top-level recovery point.
        """
        pulumi.set(__self__, "vm_recovery_point_ext_id", vm_recovery_point_ext_id)

    @property
    @pulumi.getter(name="vmRecoveryPointExtId")
    def vm_recovery_point_ext_id(self) -> pulumi.Input[str]:
        """
        -(Required) External identifier of a VM recovery point, that is a part of the top-level recovery point.
        """
        return pulumi.get(self, "vm_recovery_point_ext_id")

    @vm_recovery_point_ext_id.setter
    def vm_recovery_point_ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_recovery_point_ext_id", value)


if not MYPY:
    class RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideArgsDict(TypedDict):
        volume_group_recovery_point_ext_id: pulumi.Input[str]
        """
        -(Required) External identifier of a volume group recovery point, that is a part of the top-level recovery point.
        """
        volume_group_override_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgsDict']]]]
        """
        -(Optional) Protected resource/recovery point restore that overrides the volume group configuration. The specified properties will be overridden for the restored volume group.
        """
elif False:
    RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideArgs:
    def __init__(__self__, *,
                 volume_group_recovery_point_ext_id: pulumi.Input[str],
                 volume_group_override_specs: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs']]]] = None):
        """
        :param pulumi.Input[str] volume_group_recovery_point_ext_id: -(Required) External identifier of a volume group recovery point, that is a part of the top-level recovery point.
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs']]] volume_group_override_specs: -(Optional) Protected resource/recovery point restore that overrides the volume group configuration. The specified properties will be overridden for the restored volume group.
        """
        pulumi.set(__self__, "volume_group_recovery_point_ext_id", volume_group_recovery_point_ext_id)
        if volume_group_override_specs is not None:
            pulumi.set(__self__, "volume_group_override_specs", volume_group_override_specs)

    @property
    @pulumi.getter(name="volumeGroupRecoveryPointExtId")
    def volume_group_recovery_point_ext_id(self) -> pulumi.Input[str]:
        """
        -(Required) External identifier of a volume group recovery point, that is a part of the top-level recovery point.
        """
        return pulumi.get(self, "volume_group_recovery_point_ext_id")

    @volume_group_recovery_point_ext_id.setter
    def volume_group_recovery_point_ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_group_recovery_point_ext_id", value)

    @property
    @pulumi.getter(name="volumeGroupOverrideSpecs")
    def volume_group_override_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs']]]]:
        """
        -(Optional) Protected resource/recovery point restore that overrides the volume group configuration. The specified properties will be overridden for the restored volume group.
        """
        return pulumi.get(self, "volume_group_override_specs")

    @volume_group_override_specs.setter
    def volume_group_override_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs']]]]):
        pulumi.set(self, "volume_group_override_specs", value)


if not MYPY:
    class RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        -(Optional) The name of the restored volume group.
        """
elif False:
    RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointRestoreV2VolumeGroupRecoveryPointRestoreOverrideVolumeGroupOverrideSpecArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: -(Optional) The name of the restored volume group.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        -(Optional) The name of the restored volume group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RecoveryPointsV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    RecoveryPointsV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class RecoveryPointsV2LocationReferenceArgsDict(TypedDict):
        location_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the cluster where the recovery point is present.
        """
elif False:
    RecoveryPointsV2LocationReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2LocationReferenceArgs:
    def __init__(__self__, *,
                 location_ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location_ext_id: External identifier of the cluster where the recovery point is present.
        """
        if location_ext_id is not None:
            pulumi.set(__self__, "location_ext_id", location_ext_id)

    @property
    @pulumi.getter(name="locationExtId")
    def location_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the cluster where the recovery point is present.
        """
        return pulumi.get(self, "location_ext_id")

    @location_ext_id.setter
    def location_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_ext_id", value)


if not MYPY:
    class RecoveryPointsV2VmRecoveryPointArgsDict(TypedDict):
        vm_ext_id: pulumi.Input[str]
        """
        VM external identifier which is captured as a part of this recovery point.
        """
        application_consistent_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgsDict']]]]
        """
        User-defined application-consistent properties for the recovery point.
        """
        consistency_group_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        """
        creation_time: NotRequired[pulumi.Input[str]]
        """
        The UTC date and time in ISO-8601 format when the Recovery point is created.
        """
        disk_recovery_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgsDict']]]]
        """
        array of disk recovery points.
        """
        expiration_time: NotRequired[pulumi.Input[str]]
        """
        The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        recovery point UUID
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        location_agnostic_id: NotRequired[pulumi.Input[str]]
        """
        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Recovery point.
        """
        recovery_point_type: NotRequired[pulumi.Input[str]]
        """
        Type of the Recovery point.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
        * supported values:
        * `COMPLETE`: - The Recovery point is in a complete state and ready to be consumed.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the tenant that owns this entity
        """
        vm_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' is displayed as 'dept/hr'.
        """
elif False:
    RecoveryPointsV2VmRecoveryPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VmRecoveryPointArgs:
    def __init__(__self__, *,
                 vm_ext_id: pulumi.Input[str],
                 application_consistent_properties: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs']]]] = None,
                 consistency_group_ext_id: Optional[pulumi.Input[str]] = None,
                 creation_time: Optional[pulumi.Input[str]] = None,
                 disk_recovery_points: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs']]]] = None,
                 expiration_time: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointLinkArgs']]]] = None,
                 location_agnostic_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 recovery_point_type: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vm_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] vm_ext_id: VM external identifier which is captured as a part of this recovery point.
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs']]] application_consistent_properties: User-defined application-consistent properties for the recovery point.
        :param pulumi.Input[str] consistency_group_ext_id: External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        :param pulumi.Input[str] creation_time: The UTC date and time in ISO-8601 format when the Recovery point is created.
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs']]] disk_recovery_points: array of disk recovery points.
        :param pulumi.Input[str] expiration_time: The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
        :param pulumi.Input[str] ext_id: recovery point UUID
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[str] location_agnostic_id: Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        :param pulumi.Input[str] name: The name of the Recovery point.
        :param pulumi.Input[str] recovery_point_type: Type of the Recovery point.
        :param pulumi.Input[str] status: The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
               * supported values:
               * `COMPLETE`: - The Recovery point is in a complete state and ready to be consumed.
        :param pulumi.Input[str] tenant_id: A globally unique identifier that represents the tenant that owns this entity
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vm_categories: Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' is displayed as 'dept/hr'.
        """
        pulumi.set(__self__, "vm_ext_id", vm_ext_id)
        if application_consistent_properties is not None:
            pulumi.set(__self__, "application_consistent_properties", application_consistent_properties)
        if consistency_group_ext_id is not None:
            pulumi.set(__self__, "consistency_group_ext_id", consistency_group_ext_id)
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if disk_recovery_points is not None:
            pulumi.set(__self__, "disk_recovery_points", disk_recovery_points)
        if expiration_time is not None:
            pulumi.set(__self__, "expiration_time", expiration_time)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if location_agnostic_id is not None:
            pulumi.set(__self__, "location_agnostic_id", location_agnostic_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if recovery_point_type is not None:
            pulumi.set(__self__, "recovery_point_type", recovery_point_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vm_categories is not None:
            pulumi.set(__self__, "vm_categories", vm_categories)

    @property
    @pulumi.getter(name="vmExtId")
    def vm_ext_id(self) -> pulumi.Input[str]:
        """
        VM external identifier which is captured as a part of this recovery point.
        """
        return pulumi.get(self, "vm_ext_id")

    @vm_ext_id.setter
    def vm_ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_ext_id", value)

    @property
    @pulumi.getter(name="applicationConsistentProperties")
    def application_consistent_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs']]]]:
        """
        User-defined application-consistent properties for the recovery point.
        """
        return pulumi.get(self, "application_consistent_properties")

    @application_consistent_properties.setter
    def application_consistent_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs']]]]):
        pulumi.set(self, "application_consistent_properties", value)

    @property
    @pulumi.getter(name="consistencyGroupExtId")
    def consistency_group_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        """
        return pulumi.get(self, "consistency_group_ext_id")

    @consistency_group_ext_id.setter
    def consistency_group_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consistency_group_ext_id", value)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[pulumi.Input[str]]:
        """
        The UTC date and time in ISO-8601 format when the Recovery point is created.
        """
        return pulumi.get(self, "creation_time")

    @creation_time.setter
    def creation_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_time", value)

    @property
    @pulumi.getter(name="diskRecoveryPoints")
    def disk_recovery_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs']]]]:
        """
        array of disk recovery points.
        """
        return pulumi.get(self, "disk_recovery_points")

    @disk_recovery_points.setter
    def disk_recovery_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs']]]]):
        pulumi.set(self, "disk_recovery_points", value)

    @property
    @pulumi.getter(name="expirationTime")
    def expiration_time(self) -> Optional[pulumi.Input[str]]:
        """
        The UTC date and time in ISO-8601 format when the current Recovery point expires and will be garbage collected.
        """
        return pulumi.get(self, "expiration_time")

    @expiration_time.setter
    def expiration_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_time", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        recovery point UUID
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VmRecoveryPointLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="locationAgnosticId")
    def location_agnostic_id(self) -> Optional[pulumi.Input[str]]:
        """
        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        """
        return pulumi.get(self, "location_agnostic_id")

    @location_agnostic_id.setter
    def location_agnostic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_agnostic_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Recovery point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="recoveryPointType")
    def recovery_point_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the Recovery point.
        """
        return pulumi.get(self, "recovery_point_type")

    @recovery_point_type.setter
    def recovery_point_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_point_type", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Recovery point, which indicates whether this Recovery point is fit to be consumed.
        * supported values:
        * `COMPLETE`: - The Recovery point is in a complete state and ready to be consumed.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the tenant that owns this entity
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="vmCategories")
    def vm_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Category key-value pairs associated with the VM at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' is displayed as 'dept/hr'.
        """
        return pulumi.get(self, "vm_categories")

    @vm_categories.setter
    def vm_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vm_categories", value)


if not MYPY:
    class RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgsDict(TypedDict):
        backup_type: pulumi.Input[str]
        """
        -(Required) The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
        * supported values:
        * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
        * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
        """
        object_type: pulumi.Input[str]
        """
        -(Required) value: `dataprotection.v4.common.VssProperties`
        """
        should_include_writers: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
        """
        should_store_vss_metadata: NotRequired[pulumi.Input[bool]]
        """
        -(Optional) Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
        """
        writers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        -(Optional) List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
        """
elif False:
    RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VmRecoveryPointApplicationConsistentPropertyArgs:
    def __init__(__self__, *,
                 backup_type: pulumi.Input[str],
                 object_type: pulumi.Input[str],
                 should_include_writers: Optional[pulumi.Input[bool]] = None,
                 should_store_vss_metadata: Optional[pulumi.Input[bool]] = None,
                 writers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] backup_type: -(Required) The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
               * supported values:
               * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
               * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
        :param pulumi.Input[str] object_type: -(Required) value: `dataprotection.v4.common.VssProperties`
        :param pulumi.Input[bool] should_include_writers: -(Optional) Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
        :param pulumi.Input[bool] should_store_vss_metadata: -(Optional) Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] writers: -(Optional) List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "object_type", object_type)
        if should_include_writers is not None:
            pulumi.set(__self__, "should_include_writers", should_include_writers)
        if should_store_vss_metadata is not None:
            pulumi.set(__self__, "should_store_vss_metadata", should_store_vss_metadata)
        if writers is not None:
            pulumi.set(__self__, "writers", writers)

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> pulumi.Input[str]:
        """
        -(Required) The backup type specifies the criteria for identifying the files to be backed up. This property should be specified to the application-consistent recovery points for Windows VMs/agents. The following backup types are supported for the application-consistent recovery points:
        * supported values:
        * `FULL_BACKUP`: -  All the files are backed up irrespective of their last backup date/time or state. Also, this backup type updates the backup history of each file that participated in the recovery point. If not explicitly specified, this is the default backup type.
        * `COPY_BACKUP`: -  this backup type does not update the backup history of individual files involved in the recovery point.
        """
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_type", value)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        -(Required) value: `dataprotection.v4.common.VssProperties`
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="shouldIncludeWriters")
    def should_include_writers(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates whether the given set of VSS writers' UUIDs should be included or excluded from the application consistent recovery point. By default, the value is set to false, indicating that all listed VSS writers' UUIDs will be excluded.
        """
        return pulumi.get(self, "should_include_writers")

    @should_include_writers.setter
    def should_include_writers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_include_writers", value)

    @property
    @pulumi.getter(name="shouldStoreVssMetadata")
    def should_store_vss_metadata(self) -> Optional[pulumi.Input[bool]]:
        """
        -(Optional) Indicates whether to store the VSS metadata if the user is interested in application-specific backup/restore. The VSS metadata consists of VSS writers and requester metadata details. These are compressed into a cabinet file(.cab file) during a VSS backup operation. This cabinet file must be saved to the backup media during a backup operation, as it is required during the restore operation.
        """
        return pulumi.get(self, "should_store_vss_metadata")

    @should_store_vss_metadata.setter
    def should_store_vss_metadata(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_store_vss_metadata", value)

    @property
    @pulumi.getter
    def writers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        -(Optional) List of VSS writer UUIDs that are used in an application consistent recovery point. The default values are the system and the registry writer UUIDs.
        """
        return pulumi.get(self, "writers")

    @writers.setter
    def writers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "writers", value)


if not MYPY:
    class RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgsDict(TypedDict):
        disk_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the disk.
        """
        disk_recovery_point_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the disk recovery point.
        """
elif False:
    RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VmRecoveryPointDiskRecoveryPointArgs:
    def __init__(__self__, *,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_recovery_point_ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disk_ext_id: External identifier of the disk.
        :param pulumi.Input[str] disk_recovery_point_ext_id: External identifier of the disk recovery point.
        """
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_recovery_point_ext_id is not None:
            pulumi.set(__self__, "disk_recovery_point_ext_id", disk_recovery_point_ext_id)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the disk.
        """
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskRecoveryPointExtId")
    def disk_recovery_point_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the disk recovery point.
        """
        return pulumi.get(self, "disk_recovery_point_ext_id")

    @disk_recovery_point_ext_id.setter
    def disk_recovery_point_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_recovery_point_ext_id", value)


if not MYPY:
    class RecoveryPointsV2VmRecoveryPointLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    RecoveryPointsV2VmRecoveryPointLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VmRecoveryPointLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class RecoveryPointsV2VolumeGroupRecoveryPointArgsDict(TypedDict):
        volume_group_ext_id: pulumi.Input[str]
        """
        Volume Group external identifier which is captured as part of this recovery point.
        """
        consistency_group_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        """
        disk_recovery_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgsDict']]]]
        """
        array of disk recovery points.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        recovery point UUID
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointLinkArgsDict']]]]
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        location_agnostic_id: NotRequired[pulumi.Input[str]]
        """
        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the tenant that owns this entity
        """
        volume_group_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
        """
elif False:
    RecoveryPointsV2VolumeGroupRecoveryPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VolumeGroupRecoveryPointArgs:
    def __init__(__self__, *,
                 volume_group_ext_id: pulumi.Input[str],
                 consistency_group_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_recovery_points: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs']]]] = None,
                 location_agnostic_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 volume_group_categories: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] volume_group_ext_id: Volume Group external identifier which is captured as part of this recovery point.
        :param pulumi.Input[str] consistency_group_ext_id: External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs']]] disk_recovery_points: array of disk recovery points.
        :param pulumi.Input[str] ext_id: recovery point UUID
        :param pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs']]] links: A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[str] location_agnostic_id: Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        :param pulumi.Input[str] tenant_id: A globally unique identifier that represents the tenant that owns this entity
        :param pulumi.Input[Sequence[pulumi.Input[str]]] volume_group_categories: Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
        """
        pulumi.set(__self__, "volume_group_ext_id", volume_group_ext_id)
        if consistency_group_ext_id is not None:
            pulumi.set(__self__, "consistency_group_ext_id", consistency_group_ext_id)
        if disk_recovery_points is not None:
            pulumi.set(__self__, "disk_recovery_points", disk_recovery_points)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if location_agnostic_id is not None:
            pulumi.set(__self__, "location_agnostic_id", location_agnostic_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if volume_group_categories is not None:
            pulumi.set(__self__, "volume_group_categories", volume_group_categories)

    @property
    @pulumi.getter(name="volumeGroupExtId")
    def volume_group_ext_id(self) -> pulumi.Input[str]:
        """
        Volume Group external identifier which is captured as part of this recovery point.
        """
        return pulumi.get(self, "volume_group_ext_id")

    @volume_group_ext_id.setter
    def volume_group_ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_group_ext_id", value)

    @property
    @pulumi.getter(name="consistencyGroupExtId")
    def consistency_group_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the Consistency group which the entity was part of at the time of recovery point creation.
        """
        return pulumi.get(self, "consistency_group_ext_id")

    @consistency_group_ext_id.setter
    def consistency_group_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consistency_group_ext_id", value)

    @property
    @pulumi.getter(name="diskRecoveryPoints")
    def disk_recovery_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs']]]]:
        """
        array of disk recovery points.
        """
        return pulumi.get(self, "disk_recovery_points")

    @disk_recovery_points.setter
    def disk_recovery_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs']]]]):
        pulumi.set(self, "disk_recovery_points", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        recovery point UUID
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs']]]]:
        """
        A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="locationAgnosticId")
    def location_agnostic_id(self) -> Optional[pulumi.Input[str]]:
        """
        Location agnostic identifier of the recovery point. This identifier is used to identify the same instances of a recovery point across different sites.
        """
        return pulumi.get(self, "location_agnostic_id")

    @location_agnostic_id.setter
    def location_agnostic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_agnostic_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the tenant that owns this entity
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="volumeGroupCategories")
    def volume_group_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Category key-value pairs associated with the volume group at the time of recovery point creation. The category key and value are separated by '/'. For example, a category with key 'dept' and value 'hr' will be represented as 'dept/hr'.
        """
        return pulumi.get(self, "volume_group_categories")

    @volume_group_categories.setter
    def volume_group_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "volume_group_categories", value)


if not MYPY:
    class RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgsDict(TypedDict):
        disk_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the disk.
        """
        disk_recovery_point_ext_id: NotRequired[pulumi.Input[str]]
        """
        External identifier of the disk recovery point.
        """
elif False:
    RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VolumeGroupRecoveryPointDiskRecoveryPointArgs:
    def __init__(__self__, *,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_recovery_point_ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] disk_ext_id: External identifier of the disk.
        :param pulumi.Input[str] disk_recovery_point_ext_id: External identifier of the disk recovery point.
        """
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_recovery_point_ext_id is not None:
            pulumi.set(__self__, "disk_recovery_point_ext_id", disk_recovery_point_ext_id)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the disk.
        """
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskRecoveryPointExtId")
    def disk_recovery_point_ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        External identifier of the disk recovery point.
        """
        return pulumi.get(self, "disk_recovery_point_ext_id")

    @disk_recovery_point_ext_id.setter
    def disk_recovery_point_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_recovery_point_ext_id", value)


if not MYPY:
    class RecoveryPointsV2VolumeGroupRecoveryPointLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    RecoveryPointsV2VolumeGroupRecoveryPointLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecoveryPointsV2VolumeGroupRecoveryPointLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class RoleCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the role.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - value of the key.
        """
elif False:
    RoleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Optional) Name of the role.
        :param pulumi.Input[str] value: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RoleOwnerReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the role.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    RoleOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleOwnerReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the role.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RolePermissionReferenceListArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the role.
        """
elif False:
    RolePermissionReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolePermissionReferenceListArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the role.
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RoleProjectReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Name of the role.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    RoleProjectReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleProjectReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Optional) Name of the role.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class RolesV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    RolesV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RolesV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class RoutesV2DestinationArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input['RoutesV2DestinationIpv4ArgsDict']]
        """
        IPv4 Subnet Object
        * `ipv4.ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 format.
        * `ipv4.ip.value`: (Required) The IPv4 address of the host.
        * `ipv4.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv4 address belongs.
        * `ipv4.prefix_length`: (Required) The prefix length of the network to which this host IPv4 address belongs.
        """
        ipv6: NotRequired[pulumi.Input['RoutesV2DestinationIpv6ArgsDict']]
        """
        IPv6 Subnet Object
        * `ipv6.ip`: (Required) IP address format
        * `ipv6.ip.value`: (Required) The IPv6 address of the host.
        * `ipv6.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv6 address belongs.
        * `ipv6.prefix_length`: (Required) The prefix length of the network to which this host IPv6 address belongs.
        """
elif False:
    RoutesV2DestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2DestinationArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input['RoutesV2DestinationIpv4Args']] = None,
                 ipv6: Optional[pulumi.Input['RoutesV2DestinationIpv6Args']] = None):
        """
        :param pulumi.Input['RoutesV2DestinationIpv4Args'] ipv4: IPv4 Subnet Object
               * `ipv4.ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 format.
               * `ipv4.ip.value`: (Required) The IPv4 address of the host.
               * `ipv4.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv4 address belongs.
               * `ipv4.prefix_length`: (Required) The prefix length of the network to which this host IPv4 address belongs.
        :param pulumi.Input['RoutesV2DestinationIpv6Args'] ipv6: IPv6 Subnet Object
               * `ipv6.ip`: (Required) IP address format
               * `ipv6.ip.value`: (Required) The IPv6 address of the host.
               * `ipv6.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv6 address belongs.
               * `ipv6.prefix_length`: (Required) The prefix length of the network to which this host IPv6 address belongs.
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input['RoutesV2DestinationIpv4Args']]:
        """
        IPv4 Subnet Object
        * `ipv4.ip`: (Required) An unique address that identifies a device on the internet or a local network in IPv4 format.
        * `ipv4.ip.value`: (Required) The IPv4 address of the host.
        * `ipv4.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv4 address belongs.
        * `ipv4.prefix_length`: (Required) The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input['RoutesV2DestinationIpv4Args']]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input['RoutesV2DestinationIpv6Args']]:
        """
        IPv6 Subnet Object
        * `ipv6.ip`: (Required) IP address format
        * `ipv6.ip.value`: (Required) The IPv6 address of the host.
        * `ipv6.ip.prefix_length`: (Optional) The prefix length of the network to which this host IPv6 address belongs.
        * `ipv6.prefix_length`: (Required) The prefix length of the network to which this host IPv6 address belongs.
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input['RoutesV2DestinationIpv6Args']]):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class RoutesV2DestinationIpv4ArgsDict(TypedDict):
        ip: pulumi.Input['RoutesV2DestinationIpv4IpArgsDict']
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2DestinationIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2DestinationIpv4Args:
    def __init__(__self__, *,
                 ip: pulumi.Input['RoutesV2DestinationIpv4IpArgs'],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "ip", ip)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input['RoutesV2DestinationIpv4IpArgs']:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input['RoutesV2DestinationIpv4IpArgs']):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class RoutesV2DestinationIpv4IpArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        value of IP address
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2DestinationIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2DestinationIpv4IpArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: value of IP address
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        value of IP address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class RoutesV2DestinationIpv6ArgsDict(TypedDict):
        ip: pulumi.Input['RoutesV2DestinationIpv6IpArgsDict']
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2DestinationIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2DestinationIpv6Args:
    def __init__(__self__, *,
                 ip: pulumi.Input['RoutesV2DestinationIpv6IpArgs'],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "ip", ip)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input['RoutesV2DestinationIpv6IpArgs']:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input['RoutesV2DestinationIpv6IpArgs']):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class RoutesV2DestinationIpv6IpArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        value of IP address
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2DestinationIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2DestinationIpv6IpArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: value of IP address
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        value of IP address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class RoutesV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    RoutesV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class RoutesV2MetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of globally unique identifiers that represent all the categories the resource is associated with.
        """
        owner_reference_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the owner of this resource.
        """
        owner_user_name: NotRequired[pulumi.Input[str]]
        """
        The userName of the owner of this resource.
        """
        project_name: NotRequired[pulumi.Input[str]]
        """
        The name of the project this resource belongs to.
        """
        project_reference_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier that represents the project this resource belongs to.
        """
elif False:
    RoutesV2MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2MetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] category_ids: A list of globally unique identifiers that represent all the categories the resource is associated with.
        :param pulumi.Input[str] owner_reference_id: A globally unique identifier that represents the owner of this resource.
        :param pulumi.Input[str] owner_user_name: The userName of the owner of this resource.
        :param pulumi.Input[str] project_name: The name of the project this resource belongs to.
        :param pulumi.Input[str] project_reference_id: A globally unique identifier that represents the project this resource belongs to.
        """
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of globally unique identifiers that represent all the categories the resource is associated with.
        """
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the owner of this resource.
        """
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The userName of the owner of this resource.
        """
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the project this resource belongs to.
        """
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier that represents the project this resource belongs to.
        """
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class RoutesV2NextHopArgsDict(TypedDict):
        next_hop_type: pulumi.Input[str]
        next_hop_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['RoutesV2NextHopNextHopIpAddressArgsDict']]]]
        next_hop_name: NotRequired[pulumi.Input[str]]
        next_hop_reference: NotRequired[pulumi.Input[str]]
elif False:
    RoutesV2NextHopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2NextHopArgs:
    def __init__(__self__, *,
                 next_hop_type: pulumi.Input[str],
                 next_hop_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['RoutesV2NextHopNextHopIpAddressArgs']]]] = None,
                 next_hop_name: Optional[pulumi.Input[str]] = None,
                 next_hop_reference: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "next_hop_type", next_hop_type)
        if next_hop_ip_addresses is not None:
            pulumi.set(__self__, "next_hop_ip_addresses", next_hop_ip_addresses)
        if next_hop_name is not None:
            pulumi.set(__self__, "next_hop_name", next_hop_name)
        if next_hop_reference is not None:
            pulumi.set(__self__, "next_hop_reference", next_hop_reference)

    @property
    @pulumi.getter(name="nextHopType")
    def next_hop_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "next_hop_type")

    @next_hop_type.setter
    def next_hop_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "next_hop_type", value)

    @property
    @pulumi.getter(name="nextHopIpAddresses")
    def next_hop_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoutesV2NextHopNextHopIpAddressArgs']]]]:
        return pulumi.get(self, "next_hop_ip_addresses")

    @next_hop_ip_addresses.setter
    def next_hop_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoutesV2NextHopNextHopIpAddressArgs']]]]):
        pulumi.set(self, "next_hop_ip_addresses", value)

    @property
    @pulumi.getter(name="nextHopName")
    def next_hop_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_hop_name")

    @next_hop_name.setter
    def next_hop_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_name", value)

    @property
    @pulumi.getter(name="nextHopReference")
    def next_hop_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_hop_reference")

    @next_hop_reference.setter
    def next_hop_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_hop_reference", value)


if not MYPY:
    class RoutesV2NextHopNextHopIpAddressArgsDict(TypedDict):
        ipv4: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv4ArgsDict']
        """
        IPv4 Address
        """
        ipv6: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv6ArgsDict']
        """
        IPv6 Address
        """
elif False:
    RoutesV2NextHopNextHopIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2NextHopNextHopIpAddressArgs:
    def __init__(__self__, *,
                 ipv4: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv4Args'],
                 ipv6: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv6Args']):
        """
        :param pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv4Args'] ipv4: IPv4 Address
        :param pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv6Args'] ipv6: IPv6 Address
        """
        pulumi.set(__self__, "ipv4", ipv4)
        pulumi.set(__self__, "ipv6", ipv6)

    @property
    @pulumi.getter
    def ipv4(self) -> pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv4Args']:
        """
        IPv4 Address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv4Args']):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv6Args']:
        """
        IPv6 Address
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: pulumi.Input['RoutesV2NextHopNextHopIpAddressIpv6Args']):
        pulumi.set(self, "ipv6", value)


if not MYPY:
    class RoutesV2NextHopNextHopIpAddressIpv4ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        value of IP address
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2NextHopNextHopIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2NextHopNextHopIpAddressIpv4Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: value of IP address
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        value of IP address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class RoutesV2NextHopNextHopIpAddressIpv6ArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        value of IP address
        """
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
elif False:
    RoutesV2NextHopNextHopIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutesV2NextHopNextHopIpAddressIpv6Args:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] value: value of IP address
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        value of IP address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SamlIdentityProvidersV2IdpMetadataArgsDict(TypedDict):
        certificate: pulumi.Input[str]
        entity_id: pulumi.Input[str]
        login_url: pulumi.Input[str]
        error_url: NotRequired[pulumi.Input[str]]
        logout_url: NotRequired[pulumi.Input[str]]
        name_id_policy_format: NotRequired[pulumi.Input[str]]
elif False:
    SamlIdentityProvidersV2IdpMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamlIdentityProvidersV2IdpMetadataArgs:
    def __init__(__self__, *,
                 certificate: pulumi.Input[str],
                 entity_id: pulumi.Input[str],
                 login_url: pulumi.Input[str],
                 error_url: Optional[pulumi.Input[str]] = None,
                 logout_url: Optional[pulumi.Input[str]] = None,
                 name_id_policy_format: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "certificate", certificate)
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "login_url", login_url)
        if error_url is not None:
            pulumi.set(__self__, "error_url", error_url)
        if logout_url is not None:
            pulumi.set(__self__, "logout_url", logout_url)
        if name_id_policy_format is not None:
            pulumi.set(__self__, "name_id_policy_format", name_id_policy_format)

    @property
    @pulumi.getter
    def certificate(self) -> pulumi.Input[str]:
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="loginUrl")
    def login_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "login_url")

    @login_url.setter
    def login_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "login_url", value)

    @property
    @pulumi.getter(name="errorUrl")
    def error_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "error_url")

    @error_url.setter
    def error_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_url", value)

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "logout_url")

    @logout_url.setter
    def logout_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_url", value)

    @property
    @pulumi.getter(name="nameIdPolicyFormat")
    def name_id_policy_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name_id_policy_format")

    @name_id_policy_format.setter
    def name_id_policy_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name_id_policy_format", value)


if not MYPY:
    class ServiceGroupServiceListArgsDict(TypedDict):
        icmp_type_code_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListIcmpTypeCodeListArgsDict']]]]
        """
        - (Optional) ICMP type code list
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The UserPrincipalName of the user from the directory service.
        """
        tcp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListTcpPortRangeListArgsDict']]]]
        """
        - (Optional) TCP Port range list
        """
        udp_port_range_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListUdpPortRangeListArgsDict']]]]
        """
        - (Optional) UDP port range list
        """
elif False:
    ServiceGroupServiceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupServiceListArgs:
    def __init__(__self__, *,
                 icmp_type_code_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListIcmpTypeCodeListArgs']]]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 tcp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListTcpPortRangeListArgs']]]] = None,
                 udp_port_range_lists: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListUdpPortRangeListArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListIcmpTypeCodeListArgs']]] icmp_type_code_lists: - (Optional) ICMP type code list
        :param pulumi.Input[str] protocol: - (Optional) The UserPrincipalName of the user from the directory service.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListTcpPortRangeListArgs']]] tcp_port_range_lists: - (Optional) TCP Port range list
        :param pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListUdpPortRangeListArgs']]] udp_port_range_lists: - (Optional) UDP port range list
        """
        if icmp_type_code_lists is not None:
            pulumi.set(__self__, "icmp_type_code_lists", icmp_type_code_lists)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tcp_port_range_lists is not None:
            pulumi.set(__self__, "tcp_port_range_lists", tcp_port_range_lists)
        if udp_port_range_lists is not None:
            pulumi.set(__self__, "udp_port_range_lists", udp_port_range_lists)

    @property
    @pulumi.getter(name="icmpTypeCodeLists")
    def icmp_type_code_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListIcmpTypeCodeListArgs']]]]:
        """
        - (Optional) ICMP type code list
        """
        return pulumi.get(self, "icmp_type_code_lists")

    @icmp_type_code_lists.setter
    def icmp_type_code_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListIcmpTypeCodeListArgs']]]]):
        pulumi.set(self, "icmp_type_code_lists", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The UserPrincipalName of the user from the directory service.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="tcpPortRangeLists")
    def tcp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListTcpPortRangeListArgs']]]]:
        """
        - (Optional) TCP Port range list
        """
        return pulumi.get(self, "tcp_port_range_lists")

    @tcp_port_range_lists.setter
    def tcp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListTcpPortRangeListArgs']]]]):
        pulumi.set(self, "tcp_port_range_lists", value)

    @property
    @pulumi.getter(name="udpPortRangeLists")
    def udp_port_range_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListUdpPortRangeListArgs']]]]:
        """
        - (Optional) UDP port range list
        """
        return pulumi.get(self, "udp_port_range_lists")

    @udp_port_range_lists.setter
    def udp_port_range_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceGroupServiceListUdpPortRangeListArgs']]]]):
        pulumi.set(self, "udp_port_range_lists", value)


if not MYPY:
    class ServiceGroupServiceListIcmpTypeCodeListArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Code as text
        """
        type: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Type as text
        """
elif False:
    ServiceGroupServiceListIcmpTypeCodeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupServiceListIcmpTypeCodeListArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] code: - (Optional) Code as text
        :param pulumi.Input[str] type: - (Optional) Type as text
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Code as text
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Type as text
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceGroupServiceListTcpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    ServiceGroupServiceListTcpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupServiceListTcpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class ServiceGroupServiceListUdpPortRangeListArgsDict(TypedDict):
        end_port: NotRequired[pulumi.Input[int]]
        start_port: NotRequired[pulumi.Input[int]]
elif False:
    ServiceGroupServiceListUdpPortRangeListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupServiceListUdpPortRangeListArgs:
    def __init__(__self__, *,
                 end_port: Optional[pulumi.Input[int]] = None,
                 start_port: Optional[pulumi.Input[int]] = None):
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class ServiceGroupsV2IcmpServiceArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        Icmp service Code. Ignore this field if Code has to be ANY
        """
        is_all_allowed: NotRequired[pulumi.Input[bool]]
        """
        Set this field to true if both Type and Code is ANY. Default is False.
        """
        type: NotRequired[pulumi.Input[int]]
        """
        Icmp service Type. Ignore this field if Type has to be ANY.
        """
elif False:
    ServiceGroupsV2IcmpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupsV2IcmpServiceArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 is_all_allowed: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] code: Icmp service Code. Ignore this field if Code has to be ANY
        :param pulumi.Input[bool] is_all_allowed: Set this field to true if both Type and Code is ANY. Default is False.
        :param pulumi.Input[int] type: Icmp service Type. Ignore this field if Type has to be ANY.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if is_all_allowed is not None:
            pulumi.set(__self__, "is_all_allowed", is_all_allowed)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        Icmp service Code. Ignore this field if Code has to be ANY
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="isAllAllowed")
    def is_all_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this field to true if both Type and Code is ANY. Default is False.
        """
        return pulumi.get(self, "is_all_allowed")

    @is_all_allowed.setter
    def is_all_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_all_allowed", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[int]]:
        """
        Icmp service Type. Ignore this field if Type has to be ANY.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceGroupsV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    ServiceGroupsV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupsV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class ServiceGroupsV2TcpServiceArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        """
        end port
        """
        start_port: pulumi.Input[int]
        """
        start port
        """
elif False:
    ServiceGroupsV2TcpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupsV2TcpServiceArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end_port: end port
        :param pulumi.Input[int] start_port: start port
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        """
        end port
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        start port
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class ServiceGroupsV2UdpServiceArgsDict(TypedDict):
        end_port: pulumi.Input[int]
        """
        end port
        """
        start_port: pulumi.Input[int]
        """
        start port
        """
elif False:
    ServiceGroupsV2UdpServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGroupsV2UdpServiceArgs:
    def __init__(__self__, *,
                 end_port: pulumi.Input[int],
                 start_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end_port: end port
        :param pulumi.Input[int] start_port: start port
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> pulumi.Input[int]:
        """
        end port
        """
        return pulumi.get(self, "end_port")

    @end_port.setter
    def end_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "end_port", value)

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> pulumi.Input[int]:
        """
        start port
        """
        return pulumi.get(self, "start_port")

    @start_port.setter
    def start_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_port", value)


if not MYPY:
    class StaticRoutesDefaultRouteNexthopArgsDict(TypedDict):
        external_subnet_reference_uuid: NotRequired[pulumi.Input[str]]
        """
        Reference to a subnet.
        """
elif False:
    StaticRoutesDefaultRouteNexthopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticRoutesDefaultRouteNexthopArgs:
    def __init__(__self__, *,
                 external_subnet_reference_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] external_subnet_reference_uuid: Reference to a subnet.
        """
        if external_subnet_reference_uuid is not None:
            pulumi.set(__self__, "external_subnet_reference_uuid", external_subnet_reference_uuid)

    @property
    @pulumi.getter(name="externalSubnetReferenceUuid")
    def external_subnet_reference_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to a subnet.
        """
        return pulumi.get(self, "external_subnet_reference_uuid")

    @external_subnet_reference_uuid.setter
    def external_subnet_reference_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_subnet_reference_uuid", value)


if not MYPY:
    class StaticRoutesStaticRoutesListArgsDict(TypedDict):
        destination: pulumi.Input[str]
        """
        Destination ip with prefix.
        """
        external_subnet_reference_uuid: NotRequired[pulumi.Input[str]]
        """
        Reference to a subnet. Supported with 2022.x .
        """
        vpn_connection_reference_uuid: NotRequired[pulumi.Input[str]]
        """
        Reference to a vpn connection.
        """
elif False:
    StaticRoutesStaticRoutesListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StaticRoutesStaticRoutesListArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 external_subnet_reference_uuid: Optional[pulumi.Input[str]] = None,
                 vpn_connection_reference_uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: Destination ip with prefix.
        :param pulumi.Input[str] external_subnet_reference_uuid: Reference to a subnet. Supported with 2022.x .
        :param pulumi.Input[str] vpn_connection_reference_uuid: Reference to a vpn connection.
        """
        pulumi.set(__self__, "destination", destination)
        if external_subnet_reference_uuid is not None:
            pulumi.set(__self__, "external_subnet_reference_uuid", external_subnet_reference_uuid)
        if vpn_connection_reference_uuid is not None:
            pulumi.set(__self__, "vpn_connection_reference_uuid", vpn_connection_reference_uuid)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        Destination ip with prefix.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="externalSubnetReferenceUuid")
    def external_subnet_reference_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to a subnet. Supported with 2022.x .
        """
        return pulumi.get(self, "external_subnet_reference_uuid")

    @external_subnet_reference_uuid.setter
    def external_subnet_reference_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_subnet_reference_uuid", value)

    @property
    @pulumi.getter(name="vpnConnectionReferenceUuid")
    def vpn_connection_reference_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        Reference to a vpn connection.
        """
        return pulumi.get(self, "vpn_connection_reference_uuid")

    @vpn_connection_reference_uuid.setter
    def vpn_connection_reference_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpn_connection_reference_uuid", value)


if not MYPY:
    class StorageContainersV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    StorageContainersV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageContainersV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class StorageContainersV2NfsWhitelistAddressArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressFqdnArgsDict']]]]
        """
        Reference to address configuration
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv4ArgsDict']]]]
        """
        Reference to address configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv6ArgsDict']]]]
        """
        Reference to address configuration
        """
elif False:
    StorageContainersV2NfsWhitelistAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageContainersV2NfsWhitelistAddressArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressFqdnArgs']]] fqdns: Reference to address configuration
        :param pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv4Args']]] ipv4s: Reference to address configuration
        :param pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv6Args']]] ipv6s: Reference to address configuration
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressFqdnArgs']]]]:
        """
        Reference to address configuration
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv4Args']]]]:
        """
        Reference to address configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv6Args']]]]:
        """
        Reference to address configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StorageContainersV2NfsWhitelistAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class StorageContainersV2NfsWhitelistAddressFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        value of fqdn address
        """
elif False:
    StorageContainersV2NfsWhitelistAddressFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageContainersV2NfsWhitelistAddressFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: value of fqdn address
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of fqdn address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StorageContainersV2NfsWhitelistAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of fqdn address
        """
elif False:
    StorageContainersV2NfsWhitelistAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageContainersV2NfsWhitelistAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: value of fqdn address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of fqdn address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StorageContainersV2NfsWhitelistAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        value of fqdn address
        """
elif False:
    StorageContainersV2NfsWhitelistAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageContainersV2NfsWhitelistAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param pulumi.Input[str] value: value of fqdn address
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of fqdn address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) Subnet name (Readonly).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - value of the key.
        """
elif False:
    SubnetCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Optional) Subnet name (Readonly).
        :param pulumi.Input[str] value: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) Subnet name (Readonly).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DhcpOptionArgsDict(TypedDict):
        boot_file_name: NotRequired[pulumi.Input[str]]
        domain_name: NotRequired[pulumi.Input[str]]
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerArgsDict']]]]
        ntp_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerArgsDict']]]]
        search_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        tftp_server_name: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionArgs:
    def __init__(__self__, *,
                 boot_file_name: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerArgs']]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerArgs']]]] = None,
                 search_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tftp_server_name: Optional[pulumi.Input[str]] = None):
        if boot_file_name is not None:
            pulumi.set(__self__, "boot_file_name", boot_file_name)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)
        if search_domains is not None:
            pulumi.set(__self__, "search_domains", search_domains)
        if tftp_server_name is not None:
            pulumi.set(__self__, "tftp_server_name", tftp_server_name)

    @property
    @pulumi.getter(name="bootFileName")
    def boot_file_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "boot_file_name")

    @boot_file_name.setter
    def boot_file_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_file_name", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerArgs']]]]:
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerArgs']]]]:
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerArgs']]]]):
        pulumi.set(self, "ntp_servers", value)

    @property
    @pulumi.getter(name="searchDomains")
    def search_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "search_domains")

    @search_domains.setter
    def search_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domains", value)

    @property
    @pulumi.getter(name="tftpServerName")
    def tftp_server_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tftp_server_name")

    @tftp_server_name.setter
    def tftp_server_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tftp_server_name", value)


if not MYPY:
    class SubnetV2DhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv6ArgsDict']]]]
elif False:
    SubnetV2DhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2DhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DhcpOptionNtpServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv6ArgsDict']]]]
elif False:
    SubnetV2DhcpOptionNtpServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionNtpServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DhcpOptionNtpServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2DhcpOptionNtpServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DhcpOptionNtpServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionNtpServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DhcpOptionNtpServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DhcpOptionNtpServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DhcpOptionNtpServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DynamicIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv6ArgsDict']]]]
elif False:
    SubnetV2DynamicIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DynamicIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2DynamicIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2DynamicIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DynamicIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DynamicIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2DynamicIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2DynamicIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2DynamicIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6ArgsDict']]]]
elif False:
    SubnetV2IpConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2IpConfigIpv4ArgsDict(TypedDict):
        default_gateway_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DefaultGatewayIpArgsDict']]]]
        dhcp_server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DhcpServerAddressArgsDict']]]]
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetArgsDict']]]]
        pool_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListArgsDict']]]]
elif False:
    SubnetV2IpConfigIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4Args:
    def __init__(__self__, *,
                 default_gateway_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DefaultGatewayIpArgs']]]] = None,
                 dhcp_server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DhcpServerAddressArgs']]]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetArgs']]]] = None,
                 pool_lists: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListArgs']]]] = None):
        if default_gateway_ips is not None:
            pulumi.set(__self__, "default_gateway_ips", default_gateway_ips)
        if dhcp_server_addresses is not None:
            pulumi.set(__self__, "dhcp_server_addresses", dhcp_server_addresses)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if pool_lists is not None:
            pulumi.set(__self__, "pool_lists", pool_lists)

    @property
    @pulumi.getter(name="defaultGatewayIps")
    def default_gateway_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DefaultGatewayIpArgs']]]]:
        return pulumi.get(self, "default_gateway_ips")

    @default_gateway_ips.setter
    def default_gateway_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DefaultGatewayIpArgs']]]]):
        pulumi.set(self, "default_gateway_ips", value)

    @property
    @pulumi.getter(name="dhcpServerAddresses")
    def dhcp_server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DhcpServerAddressArgs']]]]:
        return pulumi.get(self, "dhcp_server_addresses")

    @dhcp_server_addresses.setter
    def dhcp_server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4DhcpServerAddressArgs']]]]):
        pulumi.set(self, "dhcp_server_addresses", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetArgs']]]]:
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetArgs']]]]):
        pulumi.set(self, "ip_subnets", value)

    @property
    @pulumi.getter(name="poolLists")
    def pool_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListArgs']]]]:
        return pulumi.get(self, "pool_lists")

    @pool_lists.setter
    def pool_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListArgs']]]]):
        pulumi.set(self, "pool_lists", value)


if not MYPY:
    class SubnetV2IpConfigIpv4DefaultGatewayIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv4DefaultGatewayIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4DefaultGatewayIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv4DhcpServerAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv4DhcpServerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4DhcpServerAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv4IpSubnetArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2IpConfigIpv4IpSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4IpSubnetArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4IpSubnetIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SubnetV2IpConfigIpv4IpSubnetIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv4IpSubnetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4IpSubnetIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv4PoolListArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListStartIpArgsDict']]]]
elif False:
    SubnetV2IpConfigIpv4PoolListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4PoolListArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv4PoolListStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class SubnetV2IpConfigIpv4PoolListEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv4PoolListEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4PoolListEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv4PoolListStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv4PoolListStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv4PoolListStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv6ArgsDict(TypedDict):
        default_gateway_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DefaultGatewayIpArgsDict']]]]
        dhcp_server_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DhcpServerAddressArgsDict']]]]
        ip_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetArgsDict']]]]
        pool_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListArgsDict']]]]
elif False:
    SubnetV2IpConfigIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6Args:
    def __init__(__self__, *,
                 default_gateway_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DefaultGatewayIpArgs']]]] = None,
                 dhcp_server_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DhcpServerAddressArgs']]]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetArgs']]]] = None,
                 pool_lists: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListArgs']]]] = None):
        if default_gateway_ips is not None:
            pulumi.set(__self__, "default_gateway_ips", default_gateway_ips)
        if dhcp_server_addresses is not None:
            pulumi.set(__self__, "dhcp_server_addresses", dhcp_server_addresses)
        if ip_subnets is not None:
            pulumi.set(__self__, "ip_subnets", ip_subnets)
        if pool_lists is not None:
            pulumi.set(__self__, "pool_lists", pool_lists)

    @property
    @pulumi.getter(name="defaultGatewayIps")
    def default_gateway_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DefaultGatewayIpArgs']]]]:
        return pulumi.get(self, "default_gateway_ips")

    @default_gateway_ips.setter
    def default_gateway_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DefaultGatewayIpArgs']]]]):
        pulumi.set(self, "default_gateway_ips", value)

    @property
    @pulumi.getter(name="dhcpServerAddresses")
    def dhcp_server_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DhcpServerAddressArgs']]]]:
        return pulumi.get(self, "dhcp_server_addresses")

    @dhcp_server_addresses.setter
    def dhcp_server_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6DhcpServerAddressArgs']]]]):
        pulumi.set(self, "dhcp_server_addresses", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetArgs']]]]:
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetArgs']]]]):
        pulumi.set(self, "ip_subnets", value)

    @property
    @pulumi.getter(name="poolLists")
    def pool_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListArgs']]]]:
        return pulumi.get(self, "pool_lists")

    @pool_lists.setter
    def pool_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListArgs']]]]):
        pulumi.set(self, "pool_lists", value)


if not MYPY:
    class SubnetV2IpConfigIpv6DefaultGatewayIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv6DefaultGatewayIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6DefaultGatewayIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv6DhcpServerAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv6DhcpServerAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6DhcpServerAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv6IpSubnetArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2IpConfigIpv6IpSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6IpSubnetArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6IpSubnetIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SubnetV2IpConfigIpv6IpSubnetIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv6IpSubnetIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6IpSubnetIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv6PoolListArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListStartIpArgsDict']]]]
elif False:
    SubnetV2IpConfigIpv6PoolListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6PoolListArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpConfigIpv6PoolListStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class SubnetV2IpConfigIpv6PoolListEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv6PoolListEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6PoolListEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpConfigIpv6PoolListStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpConfigIpv6PoolListStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpConfigIpv6PoolListStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpUsageArgsDict(TypedDict):
        ip_pool_usages: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageArgsDict']]]]
        num_assigned_ips: NotRequired[pulumi.Input[int]]
        num_free_ips: NotRequired[pulumi.Input[int]]
        num_macs: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2IpUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpUsageArgs:
    def __init__(__self__, *,
                 ip_pool_usages: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageArgs']]]] = None,
                 num_assigned_ips: Optional[pulumi.Input[int]] = None,
                 num_free_ips: Optional[pulumi.Input[int]] = None,
                 num_macs: Optional[pulumi.Input[int]] = None):
        if ip_pool_usages is not None:
            pulumi.set(__self__, "ip_pool_usages", ip_pool_usages)
        if num_assigned_ips is not None:
            pulumi.set(__self__, "num_assigned_ips", num_assigned_ips)
        if num_free_ips is not None:
            pulumi.set(__self__, "num_free_ips", num_free_ips)
        if num_macs is not None:
            pulumi.set(__self__, "num_macs", num_macs)

    @property
    @pulumi.getter(name="ipPoolUsages")
    def ip_pool_usages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageArgs']]]]:
        return pulumi.get(self, "ip_pool_usages")

    @ip_pool_usages.setter
    def ip_pool_usages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageArgs']]]]):
        pulumi.set(self, "ip_pool_usages", value)

    @property
    @pulumi.getter(name="numAssignedIps")
    def num_assigned_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_assigned_ips")

    @num_assigned_ips.setter
    def num_assigned_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_assigned_ips", value)

    @property
    @pulumi.getter(name="numFreeIps")
    def num_free_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_free_ips")

    @num_free_ips.setter
    def num_free_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_free_ips", value)

    @property
    @pulumi.getter(name="numMacs")
    def num_macs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_macs")

    @num_macs.setter
    def num_macs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_macs", value)


if not MYPY:
    class SubnetV2IpUsageIpPoolUsageArgsDict(TypedDict):
        num_free_ips: NotRequired[pulumi.Input[int]]
        num_total_ips: NotRequired[pulumi.Input[int]]
        ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeArgsDict']]]]
elif False:
    SubnetV2IpUsageIpPoolUsageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpUsageIpPoolUsageArgs:
    def __init__(__self__, *,
                 num_free_ips: Optional[pulumi.Input[int]] = None,
                 num_total_ips: Optional[pulumi.Input[int]] = None,
                 ranges: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeArgs']]]] = None):
        if num_free_ips is not None:
            pulumi.set(__self__, "num_free_ips", num_free_ips)
        if num_total_ips is not None:
            pulumi.set(__self__, "num_total_ips", num_total_ips)
        if ranges is not None:
            pulumi.set(__self__, "ranges", ranges)

    @property
    @pulumi.getter(name="numFreeIps")
    def num_free_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_free_ips")

    @num_free_ips.setter
    def num_free_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_free_ips", value)

    @property
    @pulumi.getter(name="numTotalIps")
    def num_total_ips(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_total_ips")

    @num_total_ips.setter
    def num_total_ips(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_total_ips", value)

    @property
    @pulumi.getter
    def ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeArgs']]]]:
        return pulumi.get(self, "ranges")

    @ranges.setter
    def ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeArgs']]]]):
        pulumi.set(self, "ranges", value)


if not MYPY:
    class SubnetV2IpUsageIpPoolUsageRangeArgsDict(TypedDict):
        end_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeEndIpArgsDict']]]]
        start_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeStartIpArgsDict']]]]
elif False:
    SubnetV2IpUsageIpPoolUsageRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpUsageIpPoolUsageRangeArgs:
    def __init__(__self__, *,
                 end_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeEndIpArgs']]]] = None,
                 start_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeStartIpArgs']]]] = None):
        if end_ips is not None:
            pulumi.set(__self__, "end_ips", end_ips)
        if start_ips is not None:
            pulumi.set(__self__, "start_ips", start_ips)

    @property
    @pulumi.getter(name="endIps")
    def end_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeEndIpArgs']]]]:
        return pulumi.get(self, "end_ips")

    @end_ips.setter
    def end_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeEndIpArgs']]]]):
        pulumi.set(self, "end_ips", value)

    @property
    @pulumi.getter(name="startIps")
    def start_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeStartIpArgs']]]]:
        return pulumi.get(self, "start_ips")

    @start_ips.setter
    def start_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2IpUsageIpPoolUsageRangeStartIpArgs']]]]):
        pulumi.set(self, "start_ips", value)


if not MYPY:
    class SubnetV2IpUsageIpPoolUsageRangeEndIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpUsageIpPoolUsageRangeEndIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpUsageIpPoolUsageRangeEndIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2IpUsageIpPoolUsageRangeStartIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2IpUsageIpPoolUsageRangeStartIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2IpUsageIpPoolUsageRangeStartIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class SubnetV2ReservedIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2ReservedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2ReservedIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VirtualSwitchArgsDict(TypedDict):
        bond_mode: NotRequired[pulumi.Input[bool]]
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterArgsDict']]]]
        description: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
        has_deployment_error: NotRequired[pulumi.Input[bool]]
        is_default: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchLinkArgsDict']]]]
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchMetadataArgsDict']]]]
        mtu: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VirtualSwitchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchArgs:
    def __init__(__self__, *,
                 bond_mode: Optional[pulumi.Input[bool]] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 has_deployment_error: Optional[pulumi.Input[bool]] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchLinkArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchMetadataArgs']]]] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if bond_mode is not None:
            pulumi.set(__self__, "bond_mode", bond_mode)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if has_deployment_error is not None:
            pulumi.set(__self__, "has_deployment_error", has_deployment_error)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="bondMode")
    def bond_mode(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "bond_mode")

    @bond_mode.setter
    def bond_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bond_mode", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="hasDeploymentError")
    def has_deployment_error(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "has_deployment_error")

    @has_deployment_error.setter
    def has_deployment_error(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "has_deployment_error", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchMetadataArgs']]]]:
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class SubnetV2VirtualSwitchClusterArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        gateway_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterGatewayIpAddressArgsDict']]]]
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostArgsDict']]]]
elif False:
    SubnetV2VirtualSwitchClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchClusterArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 gateway_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterGatewayIpAddressArgs']]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostArgs']]]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if gateway_ip_addresses is not None:
            pulumi.set(__self__, "gateway_ip_addresses", gateway_ip_addresses)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="gatewayIpAddresses")
    def gateway_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterGatewayIpAddressArgs']]]]:
        return pulumi.get(self, "gateway_ip_addresses")

    @gateway_ip_addresses.setter
    def gateway_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterGatewayIpAddressArgs']]]]):
        pulumi.set(self, "gateway_ip_addresses", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostArgs']]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostArgs']]]]):
        pulumi.set(self, "hosts", value)


if not MYPY:
    class SubnetV2VirtualSwitchClusterGatewayIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VirtualSwitchClusterGatewayIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchClusterGatewayIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VirtualSwitchClusterHostArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        host_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        internal_bridge_name: NotRequired[pulumi.Input[str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressArgsDict']]]]
        route_table: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2VirtualSwitchClusterHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchClusterHostArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 host_nics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 internal_bridge_name: Optional[pulumi.Input[str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressArgs']]]] = None,
                 route_table: Optional[pulumi.Input[int]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if host_nics is not None:
            pulumi.set(__self__, "host_nics", host_nics)
        if internal_bridge_name is not None:
            pulumi.set(__self__, "internal_bridge_name", internal_bridge_name)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="hostNics")
    def host_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "host_nics")

    @host_nics.setter
    def host_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "host_nics", value)

    @property
    @pulumi.getter(name="internalBridgeName")
    def internal_bridge_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_bridge_name")

    @internal_bridge_name.setter
    def internal_bridge_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_bridge_name", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "route_table")

    @route_table.setter
    def route_table(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "route_table", value)


if not MYPY:
    class SubnetV2VirtualSwitchClusterHostIpAddressArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressIpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2VirtualSwitchClusterHostIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchClusterHostIpAddressArgs:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressIpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressIpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VirtualSwitchClusterHostIpAddressIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SubnetV2VirtualSwitchClusterHostIpAddressIpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VirtualSwitchClusterHostIpAddressIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchClusterHostIpAddressIpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VirtualSwitchLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VirtualSwitchLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class SubnetV2VirtualSwitchMetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VirtualSwitchMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VirtualSwitchMetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class SubnetV2VpcArgsDict(TypedDict):
        common_dhcp_options: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionArgsDict']]]]
        description: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
        external_routing_domain_reference: NotRequired[pulumi.Input[str]]
        external_subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetArgsDict']]]]
        externally_routable_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixArgsDict']]]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcLinkArgsDict']]]]
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcMetadataArgsDict']]]]
        name: NotRequired[pulumi.Input[str]]
        snat_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        vpc_type: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcArgs:
    def __init__(__self__, *,
                 common_dhcp_options: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 external_routing_domain_reference: Optional[pulumi.Input[str]] = None,
                 external_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetArgs']]]] = None,
                 externally_routable_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixArgs']]]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcLinkArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcMetadataArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 snat_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vpc_type: Optional[pulumi.Input[str]] = None):
        if common_dhcp_options is not None:
            pulumi.set(__self__, "common_dhcp_options", common_dhcp_options)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if external_routing_domain_reference is not None:
            pulumi.set(__self__, "external_routing_domain_reference", external_routing_domain_reference)
        if external_subnets is not None:
            pulumi.set(__self__, "external_subnets", external_subnets)
        if externally_routable_prefixes is not None:
            pulumi.set(__self__, "externally_routable_prefixes", externally_routable_prefixes)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if snat_ips is not None:
            pulumi.set(__self__, "snat_ips", snat_ips)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vpc_type is not None:
            pulumi.set(__self__, "vpc_type", vpc_type)

    @property
    @pulumi.getter(name="commonDhcpOptions")
    def common_dhcp_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionArgs']]]]:
        return pulumi.get(self, "common_dhcp_options")

    @common_dhcp_options.setter
    def common_dhcp_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionArgs']]]]):
        pulumi.set(self, "common_dhcp_options", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="externalRoutingDomainReference")
    def external_routing_domain_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_routing_domain_reference")

    @external_routing_domain_reference.setter
    def external_routing_domain_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_routing_domain_reference", value)

    @property
    @pulumi.getter(name="externalSubnets")
    def external_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetArgs']]]]:
        return pulumi.get(self, "external_subnets")

    @external_subnets.setter
    def external_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetArgs']]]]):
        pulumi.set(self, "external_subnets", value)

    @property
    @pulumi.getter(name="externallyRoutablePrefixes")
    def externally_routable_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixArgs']]]]:
        return pulumi.get(self, "externally_routable_prefixes")

    @externally_routable_prefixes.setter
    def externally_routable_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixArgs']]]]):
        pulumi.set(self, "externally_routable_prefixes", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcMetadataArgs']]]]:
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="snatIps")
    def snat_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpArgs']]]]:
        return pulumi.get(self, "snat_ips")

    @snat_ips.setter
    def snat_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpArgs']]]]):
        pulumi.set(self, "snat_ips", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="vpcType")
    def vpc_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc_type")

    @vpc_type.setter
    def vpc_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_type", value)


if not MYPY:
    class SubnetV2VpcCommonDhcpOptionArgsDict(TypedDict):
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerArgsDict']]]]
elif False:
    SubnetV2VpcCommonDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcCommonDhcpOptionArgs:
    def __init__(__self__, *,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerArgs']]]] = None):
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerArgs']]]]:
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)


if not MYPY:
    class SubnetV2VpcCommonDhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict']]]]
elif False:
    SubnetV2VpcCommonDhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcCommonDhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcCommonDhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcCommonDhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetArgsDict(TypedDict):
        active_gateway_count: NotRequired[pulumi.Input[int]]
        active_gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeArgsDict']]]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpArgsDict']]]]
        gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        subnet_reference: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetArgs:
    def __init__(__self__, *,
                 active_gateway_count: Optional[pulumi.Input[int]] = None,
                 active_gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeArgs']]]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpArgs']]]] = None,
                 gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_reference: Optional[pulumi.Input[str]] = None):
        if active_gateway_count is not None:
            pulumi.set(__self__, "active_gateway_count", active_gateway_count)
        if active_gateway_nodes is not None:
            pulumi.set(__self__, "active_gateway_nodes", active_gateway_nodes)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if gateway_nodes is not None:
            pulumi.set(__self__, "gateway_nodes", gateway_nodes)
        if subnet_reference is not None:
            pulumi.set(__self__, "subnet_reference", subnet_reference)

    @property
    @pulumi.getter(name="activeGatewayCount")
    def active_gateway_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_gateway_count")

    @active_gateway_count.setter
    def active_gateway_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_gateway_count", value)

    @property
    @pulumi.getter(name="activeGatewayNodes")
    def active_gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeArgs']]]]:
        return pulumi.get(self, "active_gateway_nodes")

    @active_gateway_nodes.setter
    def active_gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeArgs']]]]):
        pulumi.set(self, "active_gateway_nodes", value)

    @property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpArgs']]]]:
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpArgs']]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="gatewayNodes")
    def gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "gateway_nodes")

    @gateway_nodes.setter
    def gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_nodes", value)

    @property
    @pulumi.getter(name="subnetReference")
    def subnet_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_reference")

    @subnet_reference.setter
    def subnet_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_reference", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetActiveGatewayNodeArgsDict(TypedDict):
        node_id: NotRequired[pulumi.Input[str]]
        node_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict']]]]
elif False:
    SubnetV2VpcExternalSubnetActiveGatewayNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetActiveGatewayNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 node_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]] = None):
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if node_ip_addresses is not None:
            pulumi.set(__self__, "node_ip_addresses", node_ip_addresses)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="nodeIpAddresses")
    def node_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]:
        return pulumi.get(self, "node_ip_addresses")

    @node_ip_addresses.setter
    def node_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]):
        pulumi.set(self, "node_ip_addresses", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict']]]]
elif False:
    SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetExternalIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv6ArgsDict']]]]
elif False:
    SubnetV2VpcExternalSubnetExternalIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetExternalIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternalSubnetExternalIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetExternalIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternalSubnetExternalIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetExternalIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternalSubnetExternalIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternalSubnetExternalIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternalSubnetExternalIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternallyRoutablePrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6ArgsDict']]]]
elif False:
    SubnetV2VpcExternallyRoutablePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternallyRoutablePrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2VpcExternallyRoutablePrefixIpv4ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2VpcExternallyRoutablePrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternallyRoutablePrefixIpv4Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SubnetV2VpcExternallyRoutablePrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternallyRoutablePrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternallyRoutablePrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcExternallyRoutablePrefixIpv6ArgsDict(TypedDict):
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6IpArgsDict']]]]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    SubnetV2VpcExternallyRoutablePrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternallyRoutablePrefixIpv6Args:
    def __init__(__self__, *,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6IpArgs']]]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None):
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcExternallyRoutablePrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class SubnetV2VpcExternallyRoutablePrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcExternallyRoutablePrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcExternallyRoutablePrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class SubnetV2VpcMetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcMetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class SubnetV2VpcSnatIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv6ArgsDict']]]]
elif False:
    SubnetV2VpcSnatIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcSnatIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SubnetV2VpcSnatIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class SubnetV2VpcSnatIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcSnatIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcSnatIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SubnetV2VpcSnatIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    SubnetV2VpcSnatIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetV2VpcSnatIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2CreatedByArgsDict(TypedDict):
        user_type: pulumi.Input[str]
        username: pulumi.Input[str]
        additional_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeArgsDict']]]]
        creation_type: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        display_name: NotRequired[pulumi.Input[str]]
        email_id: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
        first_name: NotRequired[pulumi.Input[str]]
        idp_id: NotRequired[pulumi.Input[str]]
        is_force_reset_password_enabled: NotRequired[pulumi.Input[bool]]
        last_name: NotRequired[pulumi.Input[str]]
        locale: NotRequired[pulumi.Input[str]]
        middle_initial: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2CreatedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2CreatedByArgs:
    def __init__(__self__, *,
                 user_type: pulumi.Input[str],
                 username: pulumi.Input[str],
                 additional_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeArgs']]]] = None,
                 creation_type: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 email_id: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 idp_id: Optional[pulumi.Input[str]] = None,
                 is_force_reset_password_enabled: Optional[pulumi.Input[bool]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 locale: Optional[pulumi.Input[str]] = None,
                 middle_initial: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "user_type", user_type)
        pulumi.set(__self__, "username", username)
        if additional_attributes is not None:
            pulumi.set(__self__, "additional_attributes", additional_attributes)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_id is not None:
            pulumi.set(__self__, "email_id", email_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if is_force_reset_password_enabled is not None:
            pulumi.set(__self__, "is_force_reset_password_enabled", is_force_reset_password_enabled)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if middle_initial is not None:
            pulumi.set(__self__, "middle_initial", middle_initial)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_type", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="additionalAttributes")
    def additional_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeArgs']]]]:
        return pulumi.get(self, "additional_attributes")

    @additional_attributes.setter
    def additional_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeArgs']]]]):
        pulumi.set(self, "additional_attributes", value)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_id")

    @email_id.setter
    def email_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_id", value)

    @property
    @pulumi.getter(name="isForceResetPasswordEnabled")
    def is_force_reset_password_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_force_reset_password_enabled")

    @is_force_reset_password_enabled.setter
    def is_force_reset_password_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_force_reset_password_enabled", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter(name="middleInitial")
    def middle_initial(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "middle_initial")

    @middle_initial.setter
    def middle_initial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "middle_initial", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TemplateV2CreatedByAdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueArgsDict']]]]
elif False:
    TemplateV2CreatedByAdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2CreatedByAdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2CreatedByAdditionalAttributeValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2CreatedByAdditionalAttributeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2CreatedByAdditionalAttributeValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2CreatedByAdditionalAttributeValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2GuestUpdateStatusArgsDict(TypedDict):
        deployed_vm_reference: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2GuestUpdateStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2GuestUpdateStatusArgs:
    def __init__(__self__, *,
                 deployed_vm_reference: Optional[pulumi.Input[str]] = None):
        if deployed_vm_reference is not None:
            pulumi.set(__self__, "deployed_vm_reference", deployed_vm_reference)

    @property
    @pulumi.getter(name="deployedVmReference")
    def deployed_vm_reference(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "deployed_vm_reference")

    @deployed_vm_reference.setter
    def deployed_vm_reference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployed_vm_reference", value)


if not MYPY:
    class TemplateV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecArgsDict(TypedDict):
        version_source: pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceArgsDict']
        create_time: NotRequired[pulumi.Input[str]]
        created_bies: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        is_active_version: NotRequired[pulumi.Input[bool]]
        is_gc_override_enabled: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecLinkArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        version_description: NotRequired[pulumi.Input[str]]
        version_name: NotRequired[pulumi.Input[str]]
        version_source_discriminator: NotRequired[pulumi.Input[str]]
        vm_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecArgs:
    def __init__(__self__, *,
                 version_source: pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceArgs'],
                 create_time: Optional[pulumi.Input[str]] = None,
                 created_bies: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 is_active_version: Optional[pulumi.Input[bool]] = None,
                 is_gc_override_enabled: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecLinkArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 version_description: Optional[pulumi.Input[str]] = None,
                 version_name: Optional[pulumi.Input[str]] = None,
                 version_source_discriminator: Optional[pulumi.Input[str]] = None,
                 vm_specs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecArgs']]]] = None):
        pulumi.set(__self__, "version_source", version_source)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if created_bies is not None:
            pulumi.set(__self__, "created_bies", created_bies)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if is_active_version is not None:
            pulumi.set(__self__, "is_active_version", is_active_version)
        if is_gc_override_enabled is not None:
            pulumi.set(__self__, "is_gc_override_enabled", is_gc_override_enabled)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if version_description is not None:
            pulumi.set(__self__, "version_description", version_description)
        if version_name is not None:
            pulumi.set(__self__, "version_name", version_name)
        if version_source_discriminator is not None:
            pulumi.set(__self__, "version_source_discriminator", version_source_discriminator)
        if vm_specs is not None:
            pulumi.set(__self__, "vm_specs", vm_specs)

    @property
    @pulumi.getter(name="versionSource")
    def version_source(self) -> pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceArgs']:
        return pulumi.get(self, "version_source")

    @version_source.setter
    def version_source(self, value: pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceArgs']):
        pulumi.set(self, "version_source", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="createdBies")
    def created_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByArgs']]]]:
        return pulumi.get(self, "created_bies")

    @created_bies.setter
    def created_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByArgs']]]]):
        pulumi.set(self, "created_bies", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="isActiveVersion")
    def is_active_version(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_active_version")

    @is_active_version.setter
    def is_active_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active_version", value)

    @property
    @pulumi.getter(name="isGcOverrideEnabled")
    def is_gc_override_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_gc_override_enabled")

    @is_gc_override_enabled.setter
    def is_gc_override_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_gc_override_enabled", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="versionDescription")
    def version_description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version_description")

    @version_description.setter
    def version_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_description", value)

    @property
    @pulumi.getter(name="versionName")
    def version_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version_name")

    @version_name.setter
    def version_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_name", value)

    @property
    @pulumi.getter(name="versionSourceDiscriminator")
    def version_source_discriminator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version_source_discriminator")

    @version_source_discriminator.setter
    def version_source_discriminator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_source_discriminator", value)

    @property
    @pulumi.getter(name="vmSpecs")
    def vm_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecArgs']]]]:
        return pulumi.get(self, "vm_specs")

    @vm_specs.setter
    def vm_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecArgs']]]]):
        pulumi.set(self, "vm_specs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecCreatedByArgsDict(TypedDict):
        user_type: pulumi.Input[str]
        username: pulumi.Input[str]
        additional_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgsDict']]]]
        creation_type: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        display_name: NotRequired[pulumi.Input[str]]
        email_id: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
        first_name: NotRequired[pulumi.Input[str]]
        idp_id: NotRequired[pulumi.Input[str]]
        is_force_reset_password_enabled: NotRequired[pulumi.Input[bool]]
        last_name: NotRequired[pulumi.Input[str]]
        locale: NotRequired[pulumi.Input[str]]
        middle_initial: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecCreatedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecCreatedByArgs:
    def __init__(__self__, *,
                 user_type: pulumi.Input[str],
                 username: pulumi.Input[str],
                 additional_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgs']]]] = None,
                 creation_type: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 email_id: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 idp_id: Optional[pulumi.Input[str]] = None,
                 is_force_reset_password_enabled: Optional[pulumi.Input[bool]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 locale: Optional[pulumi.Input[str]] = None,
                 middle_initial: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "user_type", user_type)
        pulumi.set(__self__, "username", username)
        if additional_attributes is not None:
            pulumi.set(__self__, "additional_attributes", additional_attributes)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_id is not None:
            pulumi.set(__self__, "email_id", email_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if is_force_reset_password_enabled is not None:
            pulumi.set(__self__, "is_force_reset_password_enabled", is_force_reset_password_enabled)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if middle_initial is not None:
            pulumi.set(__self__, "middle_initial", middle_initial)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_type", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="additionalAttributes")
    def additional_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgs']]]]:
        return pulumi.get(self, "additional_attributes")

    @additional_attributes.setter
    def additional_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgs']]]]):
        pulumi.set(self, "additional_attributes", value)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_id")

    @email_id.setter
    def email_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_id", value)

    @property
    @pulumi.getter(name="isForceResetPasswordEnabled")
    def is_force_reset_password_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_force_reset_password_enabled")

    @is_force_reset_password_enabled.setter
    def is_force_reset_password_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_force_reset_password_enabled", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter(name="middleInitial")
    def middle_initial(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "middle_initial")

    @middle_initial.setter
    def middle_initial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "middle_initial", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecCreatedByAdditionalAttributeValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceArgsDict(TypedDict):
        template_version_reference: NotRequired[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgsDict']]
        template_vm_reference: NotRequired[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgsDict']]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceArgs:
    def __init__(__self__, *,
                 template_version_reference: Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgs']] = None,
                 template_vm_reference: Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgs']] = None):
        if template_version_reference is not None:
            pulumi.set(__self__, "template_version_reference", template_version_reference)
        if template_vm_reference is not None:
            pulumi.set(__self__, "template_vm_reference", template_vm_reference)

    @property
    @pulumi.getter(name="templateVersionReference")
    def template_version_reference(self) -> Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgs']]:
        return pulumi.get(self, "template_version_reference")

    @template_version_reference.setter
    def template_version_reference(self, value: Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgs']]):
        pulumi.set(self, "template_version_reference", value)

    @property
    @pulumi.getter(name="templateVmReference")
    def template_vm_reference(self) -> Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgs']]:
        return pulumi.get(self, "template_vm_reference")

    @template_vm_reference.setter
    def template_vm_reference(self, value: Optional[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgs']]):
        pulumi.set(self, "template_vm_reference", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgsDict(TypedDict):
        override_vm_configs: pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgsDict']]]
        version_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceArgs:
    def __init__(__self__, *,
                 override_vm_configs: pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgs']]],
                 version_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "override_vm_configs", override_vm_configs)
        if version_id is not None:
            pulumi.set(__self__, "version_id", version_id)

    @property
    @pulumi.getter(name="overrideVmConfigs")
    def override_vm_configs(self) -> pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgs']]]:
        return pulumi.get(self, "override_vm_configs")

    @override_vm_configs.setter
    def override_vm_configs(self, value: pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgs']]]):
        pulumi.set(self, "override_vm_configs", value)

    @property
    @pulumi.getter(name="versionId")
    def version_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version_id")

    @version_id.setter
    def version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgsDict(TypedDict):
        guest_customizations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgsDict']]]]
        memory_size_bytes: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgsDict']]]]
        num_cores_per_socket: NotRequired[pulumi.Input[int]]
        num_sockets: NotRequired[pulumi.Input[int]]
        num_threads_per_core: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigArgs:
    def __init__(__self__, *,
                 guest_customizations: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgs']]]] = None,
                 memory_size_bytes: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nics: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgs']]]] = None,
                 num_cores_per_socket: Optional[pulumi.Input[int]] = None,
                 num_sockets: Optional[pulumi.Input[int]] = None,
                 num_threads_per_core: Optional[pulumi.Input[int]] = None):
        if guest_customizations is not None:
            pulumi.set(__self__, "guest_customizations", guest_customizations)
        if memory_size_bytes is not None:
            pulumi.set(__self__, "memory_size_bytes", memory_size_bytes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if num_cores_per_socket is not None:
            pulumi.set(__self__, "num_cores_per_socket", num_cores_per_socket)
        if num_sockets is not None:
            pulumi.set(__self__, "num_sockets", num_sockets)
        if num_threads_per_core is not None:
            pulumi.set(__self__, "num_threads_per_core", num_threads_per_core)

    @property
    @pulumi.getter(name="guestCustomizations")
    def guest_customizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgs']]]]:
        return pulumi.get(self, "guest_customizations")

    @guest_customizations.setter
    def guest_customizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgs']]]]):
        pulumi.set(self, "guest_customizations", value)

    @property
    @pulumi.getter(name="memorySizeBytes")
    def memory_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_size_bytes")

    @memory_size_bytes.setter
    def memory_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_size_bytes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgs']]]]:
        return pulumi.get(self, "nics")

    @nics.setter
    def nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgs']]]]):
        pulumi.set(self, "nics", value)

    @property
    @pulumi.getter(name="numCoresPerSocket")
    def num_cores_per_socket(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cores_per_socket")

    @num_cores_per_socket.setter
    def num_cores_per_socket(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cores_per_socket", value)

    @property
    @pulumi.getter(name="numSockets")
    def num_sockets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_sockets")

    @num_sockets.setter
    def num_sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_sockets", value)

    @property
    @pulumi.getter(name="numThreadsPerCore")
    def num_threads_per_core(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_threads_per_core")

    @num_threads_per_core.setter
    def num_threads_per_core(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_threads_per_core", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgs']]]] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgs']]]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgsDict']]]]
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgs']]]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgs']]]]:
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgsDict(TypedDict):
        is_connected: NotRequired[pulumi.Input[bool]]
        mac_address: NotRequired[pulumi.Input[str]]
        model: NotRequired[pulumi.Input[str]]
        num_queues: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicBackingInfoArgs:
    def __init__(__self__, *,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None):
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgsDict(TypedDict):
        ipv4_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgsDict']]]]
        ipv4_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgsDict']]]]
        network_function_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgsDict']]]]
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        nic_type: NotRequired[pulumi.Input[str]]
        should_allow_unknown_macs: NotRequired[pulumi.Input[bool]]
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgsDict']]]]
        trunked_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        vlan_mode: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoArgs:
    def __init__(__self__, *,
                 ipv4_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgs']]]] = None,
                 ipv4_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgs']]]] = None,
                 network_function_chains: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgs']]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 should_allow_unknown_macs: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgs']]]] = None,
                 trunked_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 vlan_mode: Optional[pulumi.Input[str]] = None):
        if ipv4_configs is not None:
            pulumi.set(__self__, "ipv4_configs", ipv4_configs)
        if ipv4_infos is not None:
            pulumi.set(__self__, "ipv4_infos", ipv4_infos)
        if network_function_chains is not None:
            pulumi.set(__self__, "network_function_chains", network_function_chains)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if should_allow_unknown_macs is not None:
            pulumi.set(__self__, "should_allow_unknown_macs", should_allow_unknown_macs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if trunked_vlans is not None:
            pulumi.set(__self__, "trunked_vlans", trunked_vlans)
        if vlan_mode is not None:
            pulumi.set(__self__, "vlan_mode", vlan_mode)

    @property
    @pulumi.getter(name="ipv4Configs")
    def ipv4_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgs']]]]:
        return pulumi.get(self, "ipv4_configs")

    @ipv4_configs.setter
    def ipv4_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgs']]]]):
        pulumi.set(self, "ipv4_configs", value)

    @property
    @pulumi.getter(name="ipv4Infos")
    def ipv4_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgs']]]]:
        return pulumi.get(self, "ipv4_infos")

    @ipv4_infos.setter
    def ipv4_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgs']]]]):
        pulumi.set(self, "ipv4_infos", value)

    @property
    @pulumi.getter(name="networkFunctionChains")
    def network_function_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgs']]]]:
        return pulumi.get(self, "network_function_chains")

    @network_function_chains.setter
    def network_function_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgs']]]]):
        pulumi.set(self, "network_function_chains", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="shouldAllowUnknownMacs")
    def should_allow_unknown_macs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allow_unknown_macs")

    @should_allow_unknown_macs.setter
    def should_allow_unknown_macs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_unknown_macs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgs']]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="trunkedVlans")
    def trunked_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "trunked_vlans")

    @trunked_vlans.setter
    def trunked_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "trunked_vlans", value)

    @property
    @pulumi.getter(name="vlanMode")
    def vlan_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_mode")

    @vlan_mode.setter
    def vlan_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_mode", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgsDict']]]]
        secondary_ip_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict']]]]
        should_assign_ip: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgs']]]] = None,
                 secondary_ip_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]] = None,
                 should_assign_ip: Optional[pulumi.Input[bool]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if secondary_ip_address_lists is not None:
            pulumi.set(__self__, "secondary_ip_address_lists", secondary_ip_address_lists)
        if should_assign_ip is not None:
            pulumi.set(__self__, "should_assign_ip", should_assign_ip)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="secondaryIpAddressLists")
    def secondary_ip_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]:
        return pulumi.get(self, "secondary_ip_address_lists")

    @secondary_ip_address_lists.setter
    def secondary_ip_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]):
        pulumi.set(self, "secondary_ip_address_lists", value)

    @property
    @pulumi.getter(name="shouldAssignIp")
    def should_assign_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_assign_ip")

    @should_assign_ip.setter
    def should_assign_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_assign_ip", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgsDict(TypedDict):
        learned_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoArgs:
    def __init__(__self__, *,
                 learned_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]] = None):
        if learned_ip_addresses is not None:
            pulumi.set(__self__, "learned_ip_addresses", learned_ip_addresses)

    @property
    @pulumi.getter(name="learnedIpAddresses")
    def learned_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]:
        return pulumi.get(self, "learned_ip_addresses")

    @learned_ip_addresses.setter
    def learned_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]):
        pulumi.set(self, "learned_ip_addresses", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoIpv4InfoLearnedIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoNetworkFunctionChainArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVersionReferenceOverrideVmConfigNicNetworkInfoSubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
        guest_customizations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str],
                 guest_customizations: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgs']]]] = None):
        pulumi.set(__self__, "ext_id", ext_id)
        if guest_customizations is not None:
            pulumi.set(__self__, "guest_customizations", guest_customizations)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="guestCustomizations")
    def guest_customizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgs']]]]:
        return pulumi.get(self, "guest_customizations")

    @guest_customizations.setter
    def guest_customizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgs']]]]):
        pulumi.set(self, "guest_customizations", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgs']]]] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgs']]]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVersionSourceTemplateVmReferenceGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecArgsDict(TypedDict):
        apc_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigArgsDict']]]]
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgsDict']]]]
        bios_uuid: NotRequired[pulumi.Input[str]]
        boot_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigArgsDict']]]]
        categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCategoryArgsDict']]]]
        cd_roms: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomArgsDict']]]]
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecClusterArgsDict']]]]
        create_time: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskArgsDict']]]]
        enabled_cpu_features: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        ext_id: NotRequired[pulumi.Input[str]]
        generation_uuid: NotRequired[pulumi.Input[str]]
        gpuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusArgsDict']]]]
        guest_customizations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgsDict']]]]
        guest_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestToolArgsDict']]]]
        hardware_clock_timezone: NotRequired[pulumi.Input[str]]
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecHostArgsDict']]]]
        is_agent_vm: NotRequired[pulumi.Input[bool]]
        is_branding_enabled: NotRequired[pulumi.Input[bool]]
        is_cpu_hotplug_enabled: NotRequired[pulumi.Input[bool]]
        is_cpu_passthrough_enabled: NotRequired[pulumi.Input[bool]]
        is_cross_cluster_migration_in_progress: NotRequired[pulumi.Input[bool]]
        is_gpu_console_enabled: NotRequired[pulumi.Input[bool]]
        is_live_migrate_capable: NotRequired[pulumi.Input[bool]]
        is_memory_overcommit_enabled: NotRequired[pulumi.Input[bool]]
        is_scsi_controller_enabled: NotRequired[pulumi.Input[bool]]
        is_vcpu_hard_pinning_enabled: NotRequired[pulumi.Input[bool]]
        is_vga_console_enabled: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecLinkArgsDict']]]]
        machine_type: NotRequired[pulumi.Input[str]]
        memory_size_bytes: NotRequired[pulumi.Input[int]]
        name: NotRequired[pulumi.Input[str]]
        nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicArgsDict']]]]
        num_cores_per_socket: NotRequired[pulumi.Input[int]]
        num_numa_nodes: NotRequired[pulumi.Input[int]]
        num_sockets: NotRequired[pulumi.Input[int]]
        num_threads_per_core: NotRequired[pulumi.Input[int]]
        ownership_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgsDict']]]]
        pci_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceArgsDict']]]]
        power_state: NotRequired[pulumi.Input[str]]
        protection_policy_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgsDict']]]]
        protection_type: NotRequired[pulumi.Input[str]]
        serial_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortArgsDict']]]]
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSourceArgsDict']]]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        update_time: NotRequired[pulumi.Input[str]]
        vtpm_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecArgs:
    def __init__(__self__, *,
                 apc_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigArgs']]]] = None,
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgs']]]] = None,
                 bios_uuid: Optional[pulumi.Input[str]] = None,
                 boot_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigArgs']]]] = None,
                 categories: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCategoryArgs']]]] = None,
                 cd_roms: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomArgs']]]] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecClusterArgs']]]] = None,
                 create_time: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 disks: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskArgs']]]] = None,
                 enabled_cpu_features: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 generation_uuid: Optional[pulumi.Input[str]] = None,
                 gpuses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusArgs']]]] = None,
                 guest_customizations: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgs']]]] = None,
                 guest_tools: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestToolArgs']]]] = None,
                 hardware_clock_timezone: Optional[pulumi.Input[str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecHostArgs']]]] = None,
                 is_agent_vm: Optional[pulumi.Input[bool]] = None,
                 is_branding_enabled: Optional[pulumi.Input[bool]] = None,
                 is_cpu_hotplug_enabled: Optional[pulumi.Input[bool]] = None,
                 is_cpu_passthrough_enabled: Optional[pulumi.Input[bool]] = None,
                 is_cross_cluster_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 is_gpu_console_enabled: Optional[pulumi.Input[bool]] = None,
                 is_live_migrate_capable: Optional[pulumi.Input[bool]] = None,
                 is_memory_overcommit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_scsi_controller_enabled: Optional[pulumi.Input[bool]] = None,
                 is_vcpu_hard_pinning_enabled: Optional[pulumi.Input[bool]] = None,
                 is_vga_console_enabled: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecLinkArgs']]]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 memory_size_bytes: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 nics: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicArgs']]]] = None,
                 num_cores_per_socket: Optional[pulumi.Input[int]] = None,
                 num_numa_nodes: Optional[pulumi.Input[int]] = None,
                 num_sockets: Optional[pulumi.Input[int]] = None,
                 num_threads_per_core: Optional[pulumi.Input[int]] = None,
                 ownership_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgs']]]] = None,
                 pci_devices: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceArgs']]]] = None,
                 power_state: Optional[pulumi.Input[str]] = None,
                 protection_policy_states: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgs']]]] = None,
                 protection_type: Optional[pulumi.Input[str]] = None,
                 serial_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSourceArgs']]]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None,
                 vtpm_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgs']]]] = None):
        if apc_configs is not None:
            pulumi.set(__self__, "apc_configs", apc_configs)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if bios_uuid is not None:
            pulumi.set(__self__, "bios_uuid", bios_uuid)
        if boot_configs is not None:
            pulumi.set(__self__, "boot_configs", boot_configs)
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if cd_roms is not None:
            pulumi.set(__self__, "cd_roms", cd_roms)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disks is not None:
            pulumi.set(__self__, "disks", disks)
        if enabled_cpu_features is not None:
            pulumi.set(__self__, "enabled_cpu_features", enabled_cpu_features)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if generation_uuid is not None:
            pulumi.set(__self__, "generation_uuid", generation_uuid)
        if gpuses is not None:
            pulumi.set(__self__, "gpuses", gpuses)
        if guest_customizations is not None:
            pulumi.set(__self__, "guest_customizations", guest_customizations)
        if guest_tools is not None:
            pulumi.set(__self__, "guest_tools", guest_tools)
        if hardware_clock_timezone is not None:
            pulumi.set(__self__, "hardware_clock_timezone", hardware_clock_timezone)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if is_agent_vm is not None:
            pulumi.set(__self__, "is_agent_vm", is_agent_vm)
        if is_branding_enabled is not None:
            pulumi.set(__self__, "is_branding_enabled", is_branding_enabled)
        if is_cpu_hotplug_enabled is not None:
            pulumi.set(__self__, "is_cpu_hotplug_enabled", is_cpu_hotplug_enabled)
        if is_cpu_passthrough_enabled is not None:
            pulumi.set(__self__, "is_cpu_passthrough_enabled", is_cpu_passthrough_enabled)
        if is_cross_cluster_migration_in_progress is not None:
            pulumi.set(__self__, "is_cross_cluster_migration_in_progress", is_cross_cluster_migration_in_progress)
        if is_gpu_console_enabled is not None:
            pulumi.set(__self__, "is_gpu_console_enabled", is_gpu_console_enabled)
        if is_live_migrate_capable is not None:
            pulumi.set(__self__, "is_live_migrate_capable", is_live_migrate_capable)
        if is_memory_overcommit_enabled is not None:
            pulumi.set(__self__, "is_memory_overcommit_enabled", is_memory_overcommit_enabled)
        if is_scsi_controller_enabled is not None:
            pulumi.set(__self__, "is_scsi_controller_enabled", is_scsi_controller_enabled)
        if is_vcpu_hard_pinning_enabled is not None:
            pulumi.set(__self__, "is_vcpu_hard_pinning_enabled", is_vcpu_hard_pinning_enabled)
        if is_vga_console_enabled is not None:
            pulumi.set(__self__, "is_vga_console_enabled", is_vga_console_enabled)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if memory_size_bytes is not None:
            pulumi.set(__self__, "memory_size_bytes", memory_size_bytes)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if nics is not None:
            pulumi.set(__self__, "nics", nics)
        if num_cores_per_socket is not None:
            pulumi.set(__self__, "num_cores_per_socket", num_cores_per_socket)
        if num_numa_nodes is not None:
            pulumi.set(__self__, "num_numa_nodes", num_numa_nodes)
        if num_sockets is not None:
            pulumi.set(__self__, "num_sockets", num_sockets)
        if num_threads_per_core is not None:
            pulumi.set(__self__, "num_threads_per_core", num_threads_per_core)
        if ownership_infos is not None:
            pulumi.set(__self__, "ownership_infos", ownership_infos)
        if pci_devices is not None:
            pulumi.set(__self__, "pci_devices", pci_devices)
        if power_state is not None:
            pulumi.set(__self__, "power_state", power_state)
        if protection_policy_states is not None:
            pulumi.set(__self__, "protection_policy_states", protection_policy_states)
        if protection_type is not None:
            pulumi.set(__self__, "protection_type", protection_type)
        if serial_ports is not None:
            pulumi.set(__self__, "serial_ports", serial_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if vtpm_configs is not None:
            pulumi.set(__self__, "vtpm_configs", vtpm_configs)

    @property
    @pulumi.getter(name="apcConfigs")
    def apc_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigArgs']]]]:
        return pulumi.get(self, "apc_configs")

    @apc_configs.setter
    def apc_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigArgs']]]]):
        pulumi.set(self, "apc_configs", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgs']]]]:
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgs']]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter(name="biosUuid")
    def bios_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bios_uuid")

    @bios_uuid.setter
    def bios_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bios_uuid", value)

    @property
    @pulumi.getter(name="bootConfigs")
    def boot_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigArgs']]]]:
        return pulumi.get(self, "boot_configs")

    @boot_configs.setter
    def boot_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigArgs']]]]):
        pulumi.set(self, "boot_configs", value)

    @property
    @pulumi.getter
    def categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCategoryArgs']]]]:
        return pulumi.get(self, "categories")

    @categories.setter
    def categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCategoryArgs']]]]):
        pulumi.set(self, "categories", value)

    @property
    @pulumi.getter(name="cdRoms")
    def cd_roms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomArgs']]]]:
        return pulumi.get(self, "cd_roms")

    @cd_roms.setter
    def cd_roms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomArgs']]]]):
        pulumi.set(self, "cd_roms", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecClusterArgs']]]]:
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecClusterArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskArgs']]]]:
        return pulumi.get(self, "disks")

    @disks.setter
    def disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskArgs']]]]):
        pulumi.set(self, "disks", value)

    @property
    @pulumi.getter(name="enabledCpuFeatures")
    def enabled_cpu_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "enabled_cpu_features")

    @enabled_cpu_features.setter
    def enabled_cpu_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enabled_cpu_features", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="generationUuid")
    def generation_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "generation_uuid")

    @generation_uuid.setter
    def generation_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "generation_uuid", value)

    @property
    @pulumi.getter
    def gpuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusArgs']]]]:
        return pulumi.get(self, "gpuses")

    @gpuses.setter
    def gpuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusArgs']]]]):
        pulumi.set(self, "gpuses", value)

    @property
    @pulumi.getter(name="guestCustomizations")
    def guest_customizations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgs']]]]:
        return pulumi.get(self, "guest_customizations")

    @guest_customizations.setter
    def guest_customizations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgs']]]]):
        pulumi.set(self, "guest_customizations", value)

    @property
    @pulumi.getter(name="guestTools")
    def guest_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestToolArgs']]]]:
        return pulumi.get(self, "guest_tools")

    @guest_tools.setter
    def guest_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestToolArgs']]]]):
        pulumi.set(self, "guest_tools", value)

    @property
    @pulumi.getter(name="hardwareClockTimezone")
    def hardware_clock_timezone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hardware_clock_timezone")

    @hardware_clock_timezone.setter
    def hardware_clock_timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hardware_clock_timezone", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecHostArgs']]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter(name="isAgentVm")
    def is_agent_vm(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_agent_vm")

    @is_agent_vm.setter
    def is_agent_vm(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_agent_vm", value)

    @property
    @pulumi.getter(name="isBrandingEnabled")
    def is_branding_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_branding_enabled")

    @is_branding_enabled.setter
    def is_branding_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_branding_enabled", value)

    @property
    @pulumi.getter(name="isCpuHotplugEnabled")
    def is_cpu_hotplug_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_cpu_hotplug_enabled")

    @is_cpu_hotplug_enabled.setter
    def is_cpu_hotplug_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cpu_hotplug_enabled", value)

    @property
    @pulumi.getter(name="isCpuPassthroughEnabled")
    def is_cpu_passthrough_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_cpu_passthrough_enabled")

    @is_cpu_passthrough_enabled.setter
    def is_cpu_passthrough_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cpu_passthrough_enabled", value)

    @property
    @pulumi.getter(name="isCrossClusterMigrationInProgress")
    def is_cross_cluster_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_cross_cluster_migration_in_progress")

    @is_cross_cluster_migration_in_progress.setter
    def is_cross_cluster_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cross_cluster_migration_in_progress", value)

    @property
    @pulumi.getter(name="isGpuConsoleEnabled")
    def is_gpu_console_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_gpu_console_enabled")

    @is_gpu_console_enabled.setter
    def is_gpu_console_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_gpu_console_enabled", value)

    @property
    @pulumi.getter(name="isLiveMigrateCapable")
    def is_live_migrate_capable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_live_migrate_capable")

    @is_live_migrate_capable.setter
    def is_live_migrate_capable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_live_migrate_capable", value)

    @property
    @pulumi.getter(name="isMemoryOvercommitEnabled")
    def is_memory_overcommit_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_memory_overcommit_enabled")

    @is_memory_overcommit_enabled.setter
    def is_memory_overcommit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_memory_overcommit_enabled", value)

    @property
    @pulumi.getter(name="isScsiControllerEnabled")
    def is_scsi_controller_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_scsi_controller_enabled")

    @is_scsi_controller_enabled.setter
    def is_scsi_controller_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_scsi_controller_enabled", value)

    @property
    @pulumi.getter(name="isVcpuHardPinningEnabled")
    def is_vcpu_hard_pinning_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vcpu_hard_pinning_enabled")

    @is_vcpu_hard_pinning_enabled.setter
    def is_vcpu_hard_pinning_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vcpu_hard_pinning_enabled", value)

    @property
    @pulumi.getter(name="isVgaConsoleEnabled")
    def is_vga_console_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vga_console_enabled")

    @is_vga_console_enabled.setter
    def is_vga_console_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vga_console_enabled", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="memorySizeBytes")
    def memory_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "memory_size_bytes")

    @memory_size_bytes.setter
    def memory_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_size_bytes", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicArgs']]]]:
        return pulumi.get(self, "nics")

    @nics.setter
    def nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicArgs']]]]):
        pulumi.set(self, "nics", value)

    @property
    @pulumi.getter(name="numCoresPerSocket")
    def num_cores_per_socket(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_cores_per_socket")

    @num_cores_per_socket.setter
    def num_cores_per_socket(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_cores_per_socket", value)

    @property
    @pulumi.getter(name="numNumaNodes")
    def num_numa_nodes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_numa_nodes")

    @num_numa_nodes.setter
    def num_numa_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_numa_nodes", value)

    @property
    @pulumi.getter(name="numSockets")
    def num_sockets(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_sockets")

    @num_sockets.setter
    def num_sockets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_sockets", value)

    @property
    @pulumi.getter(name="numThreadsPerCore")
    def num_threads_per_core(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_threads_per_core")

    @num_threads_per_core.setter
    def num_threads_per_core(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_threads_per_core", value)

    @property
    @pulumi.getter(name="ownershipInfos")
    def ownership_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgs']]]]:
        return pulumi.get(self, "ownership_infos")

    @ownership_infos.setter
    def ownership_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgs']]]]):
        pulumi.set(self, "ownership_infos", value)

    @property
    @pulumi.getter(name="pciDevices")
    def pci_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceArgs']]]]:
        return pulumi.get(self, "pci_devices")

    @pci_devices.setter
    def pci_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceArgs']]]]):
        pulumi.set(self, "pci_devices", value)

    @property
    @pulumi.getter(name="powerState")
    def power_state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "power_state")

    @power_state.setter
    def power_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "power_state", value)

    @property
    @pulumi.getter(name="protectionPolicyStates")
    def protection_policy_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgs']]]]:
        return pulumi.get(self, "protection_policy_states")

    @protection_policy_states.setter
    def protection_policy_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgs']]]]):
        pulumi.set(self, "protection_policy_states", value)

    @property
    @pulumi.getter(name="protectionType")
    def protection_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "protection_type")

    @protection_type.setter
    def protection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protection_type", value)

    @property
    @pulumi.getter(name="serialPorts")
    def serial_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortArgs']]]]:
        return pulumi.get(self, "serial_ports")

    @serial_ports.setter
    def serial_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortArgs']]]]):
        pulumi.set(self, "serial_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSourceArgs']]]]:
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)

    @property
    @pulumi.getter(name="vtpmConfigs")
    def vtpm_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgs']]]]:
        return pulumi.get(self, "vtpm_configs")

    @vtpm_configs.setter
    def vtpm_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgs']]]]):
        pulumi.set(self, "vtpm_configs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecApcConfigArgsDict(TypedDict):
        cpu_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgsDict']]]]
        is_apc_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecApcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecApcConfigArgs:
    def __init__(__self__, *,
                 cpu_models: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgs']]]] = None,
                 is_apc_enabled: Optional[pulumi.Input[bool]] = None):
        if cpu_models is not None:
            pulumi.set(__self__, "cpu_models", cpu_models)
        if is_apc_enabled is not None:
            pulumi.set(__self__, "is_apc_enabled", is_apc_enabled)

    @property
    @pulumi.getter(name="cpuModels")
    def cpu_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgs']]]]:
        return pulumi.get(self, "cpu_models")

    @cpu_models.setter
    def cpu_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgs']]]]):
        pulumi.set(self, "cpu_models", value)

    @property
    @pulumi.getter(name="isApcEnabled")
    def is_apc_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_apc_enabled")

    @is_apc_enabled.setter
    def is_apc_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_apc_enabled", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecApcConfigCpuModelArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecAvailabilityZoneArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigArgsDict(TypedDict):
        legacy_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgsDict']]]]
        uefi_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigArgs:
    def __init__(__self__, *,
                 legacy_boots: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgs']]]] = None,
                 uefi_boots: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgs']]]] = None):
        if legacy_boots is not None:
            pulumi.set(__self__, "legacy_boots", legacy_boots)
        if uefi_boots is not None:
            pulumi.set(__self__, "uefi_boots", uefi_boots)

    @property
    @pulumi.getter(name="legacyBoots")
    def legacy_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgs']]]]:
        return pulumi.get(self, "legacy_boots")

    @legacy_boots.setter
    def legacy_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgs']]]]):
        pulumi.set(self, "legacy_boots", value)

    @property
    @pulumi.getter(name="uefiBoots")
    def uefi_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgs']]]]:
        return pulumi.get(self, "uefi_boots")

    @uefi_boots.setter
    def uefi_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgs']]]]):
        pulumi.set(self, "uefi_boots", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgsDict(TypedDict):
        boot_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgsDict']]]]
        boot_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootArgs:
    def __init__(__self__, *,
                 boot_devices: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgs']]]] = None,
                 boot_orders: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boot_devices is not None:
            pulumi.set(__self__, "boot_devices", boot_devices)
        if boot_orders is not None:
            pulumi.set(__self__, "boot_orders", boot_orders)

    @property
    @pulumi.getter(name="bootDevices")
    def boot_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgs']]]]:
        return pulumi.get(self, "boot_devices")

    @boot_devices.setter
    def boot_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgs']]]]):
        pulumi.set(self, "boot_devices", value)

    @property
    @pulumi.getter(name="bootOrders")
    def boot_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "boot_orders")

    @boot_orders.setter
    def boot_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "boot_orders", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgsDict(TypedDict):
        boot_device_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict']]]]
        boot_device_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceArgs:
    def __init__(__self__, *,
                 boot_device_disks: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]] = None,
                 boot_device_nics: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]] = None):
        if boot_device_disks is not None:
            pulumi.set(__self__, "boot_device_disks", boot_device_disks)
        if boot_device_nics is not None:
            pulumi.set(__self__, "boot_device_nics", boot_device_nics)

    @property
    @pulumi.getter(name="bootDeviceDisks")
    def boot_device_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]:
        return pulumi.get(self, "boot_device_disks")

    @boot_device_disks.setter
    def boot_device_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]):
        pulumi.set(self, "boot_device_disks", value)

    @property
    @pulumi.getter(name="bootDeviceNics")
    def boot_device_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]:
        return pulumi.get(self, "boot_device_nics")

    @boot_device_nics.setter
    def boot_device_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]):
        pulumi.set(self, "boot_device_nics", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgsDict(TypedDict):
        mac_address: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigLegacyBootBootDeviceBootDeviceNicArgs:
    def __init__(__self__, *,
                 mac_address: Optional[pulumi.Input[str]] = None):
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgsDict(TypedDict):
        boot_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgsDict']]]]
        boot_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        is_secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        nvram_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootArgs:
    def __init__(__self__, *,
                 boot_devices: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgs']]]] = None,
                 boot_orders: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 nvram_devices: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgs']]]] = None):
        if boot_devices is not None:
            pulumi.set(__self__, "boot_devices", boot_devices)
        if boot_orders is not None:
            pulumi.set(__self__, "boot_orders", boot_orders)
        if is_secure_boot_enabled is not None:
            pulumi.set(__self__, "is_secure_boot_enabled", is_secure_boot_enabled)
        if nvram_devices is not None:
            pulumi.set(__self__, "nvram_devices", nvram_devices)

    @property
    @pulumi.getter(name="bootDevices")
    def boot_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgs']]]]:
        return pulumi.get(self, "boot_devices")

    @boot_devices.setter
    def boot_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgs']]]]):
        pulumi.set(self, "boot_devices", value)

    @property
    @pulumi.getter(name="bootOrders")
    def boot_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "boot_orders")

    @boot_orders.setter
    def boot_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "boot_orders", value)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="nvramDevices")
    def nvram_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgs']]]]:
        return pulumi.get(self, "nvram_devices")

    @nvram_devices.setter
    def nvram_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgs']]]]):
        pulumi.set(self, "nvram_devices", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgsDict(TypedDict):
        boot_device_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgsDict']]]]
        boot_device_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceArgs:
    def __init__(__self__, *,
                 boot_device_disks: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgs']]]] = None,
                 boot_device_nics: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgs']]]] = None):
        if boot_device_disks is not None:
            pulumi.set(__self__, "boot_device_disks", boot_device_disks)
        if boot_device_nics is not None:
            pulumi.set(__self__, "boot_device_nics", boot_device_nics)

    @property
    @pulumi.getter(name="bootDeviceDisks")
    def boot_device_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgs']]]]:
        return pulumi.get(self, "boot_device_disks")

    @boot_device_disks.setter
    def boot_device_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgs']]]]):
        pulumi.set(self, "boot_device_disks", value)

    @property
    @pulumi.getter(name="bootDeviceNics")
    def boot_device_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgs']]]]:
        return pulumi.get(self, "boot_device_nics")

    @boot_device_nics.setter
    def boot_device_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgs']]]]):
        pulumi.set(self, "boot_device_nics", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceDiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgsDict(TypedDict):
        mac_address: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootBootDeviceBootDeviceNicArgs:
    def __init__(__self__, *,
                 mac_address: Optional[pulumi.Input[str]] = None):
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgsDict(TypedDict):
        backing_storage_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceArgs:
    def __init__(__self__, *,
                 backing_storage_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]] = None):
        if backing_storage_infos is not None:
            pulumi.set(__self__, "backing_storage_infos", backing_storage_infos)

    @property
    @pulumi.getter(name="backingStorageInfos")
    def backing_storage_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]:
        return pulumi.get(self, "backing_storage_infos")

    @backing_storage_infos.setter
    def backing_storage_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]):
        pulumi.set(self, "backing_storage_infos", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecBootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCategoryArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCategoryArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgsDict']]]]
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        iso_type: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 iso_type: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if iso_type is not None:
            pulumi.set(__self__, "iso_type", iso_type)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="isoType")
    def iso_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iso_type")

    @iso_type.setter
    def iso_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iso_type", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomBackingInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecCdRomLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecClusterArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecClusterArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgsDict']]]]
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskLinkArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskLinkArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgsDict(TypedDict):
        adfs_volume_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgsDict']]]]
        vm_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoArgs:
    def __init__(__self__, *,
                 adfs_volume_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgs']]]] = None,
                 vm_disks: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgs']]]] = None):
        if adfs_volume_group_references is not None:
            pulumi.set(__self__, "adfs_volume_group_references", adfs_volume_group_references)
        if vm_disks is not None:
            pulumi.set(__self__, "vm_disks", vm_disks)

    @property
    @pulumi.getter(name="adfsVolumeGroupReferences")
    def adfs_volume_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]:
        return pulumi.get(self, "adfs_volume_group_references")

    @adfs_volume_group_references.setter
    def adfs_volume_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]):
        pulumi.set(self, "adfs_volume_group_references", value)

    @property
    @pulumi.getter(name="vmDisks")
    def vm_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgs']]]]:
        return pulumi.get(self, "vm_disks")

    @vm_disks.setter
    def vm_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgs']]]]):
        pulumi.set(self, "vm_disks", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgsDict(TypedDict):
        volume_group_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoAdfsVolumeGroupReferenceArgs:
    def __init__(__self__, *,
                 volume_group_ext_id: Optional[pulumi.Input[str]] = None):
        if volume_group_ext_id is not None:
            pulumi.set(__self__, "volume_group_ext_id", volume_group_ext_id)

    @property
    @pulumi.getter(name="volumeGroupExtId")
    def volume_group_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_group_ext_id")

    @volume_group_ext_id.setter
    def volume_group_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskBackingInfoVmDiskStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecDiskLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecDiskLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecDiskLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGpusArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[int]]
        ext_id: NotRequired[pulumi.Input[str]]
        fraction: NotRequired[pulumi.Input[int]]
        frame_buffer_size_bytes: NotRequired[pulumi.Input[int]]
        guest_driver_version: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusLinkArgsDict']]]]
        mode: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        num_virtual_display_heads: NotRequired[pulumi.Input[int]]
        pci_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
        vendor: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGpusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGpusArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[int]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 fraction: Optional[pulumi.Input[int]] = None,
                 frame_buffer_size_bytes: Optional[pulumi.Input[int]] = None,
                 guest_driver_version: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusLinkArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_virtual_display_heads: Optional[pulumi.Input[int]] = None,
                 pci_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if fraction is not None:
            pulumi.set(__self__, "fraction", fraction)
        if frame_buffer_size_bytes is not None:
            pulumi.set(__self__, "frame_buffer_size_bytes", frame_buffer_size_bytes)
        if guest_driver_version is not None:
            pulumi.set(__self__, "guest_driver_version", guest_driver_version)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_virtual_display_heads is not None:
            pulumi.set(__self__, "num_virtual_display_heads", num_virtual_display_heads)
        if pci_addresses is not None:
            pulumi.set(__self__, "pci_addresses", pci_addresses)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def fraction(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fraction")

    @fraction.setter
    def fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fraction", value)

    @property
    @pulumi.getter(name="frameBufferSizeBytes")
    def frame_buffer_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frame_buffer_size_bytes")

    @frame_buffer_size_bytes.setter
    def frame_buffer_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frame_buffer_size_bytes", value)

    @property
    @pulumi.getter(name="guestDriverVersion")
    def guest_driver_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_driver_version")

    @guest_driver_version.setter
    def guest_driver_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_driver_version", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numVirtualDisplayHeads")
    def num_virtual_display_heads(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_virtual_display_heads")

    @num_virtual_display_heads.setter
    def num_virtual_display_heads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_display_heads", value)

    @property
    @pulumi.getter(name="pciAddresses")
    def pci_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgs']]]]:
        return pulumi.get(self, "pci_addresses")

    @pci_addresses.setter
    def pci_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgs']]]]):
        pulumi.set(self, "pci_addresses", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGpusLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGpusLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGpusLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgsDict(TypedDict):
        bus: NotRequired[pulumi.Input[int]]
        device: NotRequired[pulumi.Input[int]]
        func: NotRequired[pulumi.Input[int]]
        segment: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGpusPciAddressArgs:
    def __init__(__self__, *,
                 bus: Optional[pulumi.Input[int]] = None,
                 device: Optional[pulumi.Input[int]] = None,
                 func: Optional[pulumi.Input[int]] = None,
                 segment: Optional[pulumi.Input[int]] = None):
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if func is not None:
            pulumi.set(__self__, "func", func)
        if segment is not None:
            pulumi.set(__self__, "segment", segment)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def func(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "func")

    @func.setter
    def func(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "func", value)

    @property
    @pulumi.getter
    def segment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "segment", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgs']]]] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgs']]]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecGuestToolArgsDict(TypedDict):
        available_version: NotRequired[pulumi.Input[str]]
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        guest_os_version: NotRequired[pulumi.Input[str]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        is_installed: NotRequired[pulumi.Input[bool]]
        is_iso_inserted: NotRequired[pulumi.Input[bool]]
        is_reachable: NotRequired[pulumi.Input[bool]]
        is_vm_mobility_drivers_installed: NotRequired[pulumi.Input[bool]]
        is_vss_snapshot_capable: NotRequired[pulumi.Input[bool]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecGuestToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecGuestToolArgs:
    def __init__(__self__, *,
                 available_version: Optional[pulumi.Input[str]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 guest_os_version: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_installed: Optional[pulumi.Input[bool]] = None,
                 is_iso_inserted: Optional[pulumi.Input[bool]] = None,
                 is_reachable: Optional[pulumi.Input[bool]] = None,
                 is_vm_mobility_drivers_installed: Optional[pulumi.Input[bool]] = None,
                 is_vss_snapshot_capable: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        if available_version is not None:
            pulumi.set(__self__, "available_version", available_version)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if guest_os_version is not None:
            pulumi.set(__self__, "guest_os_version", guest_os_version)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if is_iso_inserted is not None:
            pulumi.set(__self__, "is_iso_inserted", is_iso_inserted)
        if is_reachable is not None:
            pulumi.set(__self__, "is_reachable", is_reachable)
        if is_vm_mobility_drivers_installed is not None:
            pulumi.set(__self__, "is_vm_mobility_drivers_installed", is_vm_mobility_drivers_installed)
        if is_vss_snapshot_capable is not None:
            pulumi.set(__self__, "is_vss_snapshot_capable", is_vss_snapshot_capable)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="availableVersion")
    def available_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "available_version")

    @available_version.setter
    def available_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "available_version", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="guestOsVersion")
    def guest_os_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_os_version")

    @guest_os_version.setter
    def guest_os_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_os_version", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_installed", value)

    @property
    @pulumi.getter(name="isIsoInserted")
    def is_iso_inserted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_iso_inserted")

    @is_iso_inserted.setter
    def is_iso_inserted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_iso_inserted", value)

    @property
    @pulumi.getter(name="isReachable")
    def is_reachable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_reachable")

    @is_reachable.setter
    def is_reachable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_reachable", value)

    @property
    @pulumi.getter(name="isVmMobilityDriversInstalled")
    def is_vm_mobility_drivers_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vm_mobility_drivers_installed")

    @is_vm_mobility_drivers_installed.setter
    def is_vm_mobility_drivers_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vm_mobility_drivers_installed", value)

    @property
    @pulumi.getter(name="isVssSnapshotCapable")
    def is_vss_snapshot_capable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vss_snapshot_capable")

    @is_vss_snapshot_capable.setter
    def is_vss_snapshot_capable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vss_snapshot_capable", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecHostArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecHostArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicLinkArgsDict']]]]
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicLinkArgs']]]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgs']]]]:
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgsDict(TypedDict):
        is_connected: NotRequired[pulumi.Input[bool]]
        mac_address: NotRequired[pulumi.Input[str]]
        model: NotRequired[pulumi.Input[str]]
        num_queues: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicBackingInfoArgs:
    def __init__(__self__, *,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None):
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgsDict(TypedDict):
        ipv4_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgsDict']]]]
        ipv4_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgsDict']]]]
        network_function_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgsDict']]]]
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        nic_type: NotRequired[pulumi.Input[str]]
        should_allow_unknown_macs: NotRequired[pulumi.Input[bool]]
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgsDict']]]]
        trunked_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        vlan_mode: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoArgs:
    def __init__(__self__, *,
                 ipv4_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgs']]]] = None,
                 ipv4_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgs']]]] = None,
                 network_function_chains: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgs']]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 should_allow_unknown_macs: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgs']]]] = None,
                 trunked_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 vlan_mode: Optional[pulumi.Input[str]] = None):
        if ipv4_configs is not None:
            pulumi.set(__self__, "ipv4_configs", ipv4_configs)
        if ipv4_infos is not None:
            pulumi.set(__self__, "ipv4_infos", ipv4_infos)
        if network_function_chains is not None:
            pulumi.set(__self__, "network_function_chains", network_function_chains)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if should_allow_unknown_macs is not None:
            pulumi.set(__self__, "should_allow_unknown_macs", should_allow_unknown_macs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if trunked_vlans is not None:
            pulumi.set(__self__, "trunked_vlans", trunked_vlans)
        if vlan_mode is not None:
            pulumi.set(__self__, "vlan_mode", vlan_mode)

    @property
    @pulumi.getter(name="ipv4Configs")
    def ipv4_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgs']]]]:
        return pulumi.get(self, "ipv4_configs")

    @ipv4_configs.setter
    def ipv4_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgs']]]]):
        pulumi.set(self, "ipv4_configs", value)

    @property
    @pulumi.getter(name="ipv4Infos")
    def ipv4_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgs']]]]:
        return pulumi.get(self, "ipv4_infos")

    @ipv4_infos.setter
    def ipv4_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgs']]]]):
        pulumi.set(self, "ipv4_infos", value)

    @property
    @pulumi.getter(name="networkFunctionChains")
    def network_function_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgs']]]]:
        return pulumi.get(self, "network_function_chains")

    @network_function_chains.setter
    def network_function_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgs']]]]):
        pulumi.set(self, "network_function_chains", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="shouldAllowUnknownMacs")
    def should_allow_unknown_macs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allow_unknown_macs")

    @should_allow_unknown_macs.setter
    def should_allow_unknown_macs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_unknown_macs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgs']]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="trunkedVlans")
    def trunked_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "trunked_vlans")

    @trunked_vlans.setter
    def trunked_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "trunked_vlans", value)

    @property
    @pulumi.getter(name="vlanMode")
    def vlan_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_mode")

    @vlan_mode.setter
    def vlan_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_mode", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgsDict']]]]
        secondary_ip_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict']]]]
        should_assign_ip: NotRequired[pulumi.Input[bool]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgs']]]] = None,
                 secondary_ip_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]] = None,
                 should_assign_ip: Optional[pulumi.Input[bool]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if secondary_ip_address_lists is not None:
            pulumi.set(__self__, "secondary_ip_address_lists", secondary_ip_address_lists)
        if should_assign_ip is not None:
            pulumi.set(__self__, "should_assign_ip", should_assign_ip)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="secondaryIpAddressLists")
    def secondary_ip_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]:
        return pulumi.get(self, "secondary_ip_address_lists")

    @secondary_ip_address_lists.setter
    def secondary_ip_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]):
        pulumi.set(self, "secondary_ip_address_lists", value)

    @property
    @pulumi.getter(name="shouldAssignIp")
    def should_assign_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_assign_ip")

    @should_assign_ip.setter
    def should_assign_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_assign_ip", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgsDict(TypedDict):
        learned_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoArgs:
    def __init__(__self__, *,
                 learned_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]] = None):
        if learned_ip_addresses is not None:
            pulumi.set(__self__, "learned_ip_addresses", learned_ip_addresses)

    @property
    @pulumi.getter(name="learnedIpAddresses")
    def learned_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]:
        return pulumi.get(self, "learned_ip_addresses")

    @learned_ip_addresses.setter
    def learned_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]):
        pulumi.set(self, "learned_ip_addresses", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoIpv4InfoLearnedIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoNetworkFunctionChainArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecNicNetworkInfoSubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgsDict(TypedDict):
        owners: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecOwnershipInfoArgs:
    def __init__(__self__, *,
                 owners: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgs']]]] = None):
        if owners is not None:
            pulumi.set(__self__, "owners", owners)

    @property
    @pulumi.getter
    def owners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgs']]]]:
        return pulumi.get(self, "owners")

    @owners.setter
    def owners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgs']]]]):
        pulumi.set(self, "owners", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecOwnershipInfoOwnerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceArgsDict(TypedDict):
        assigned_device_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgsDict']]]]
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceArgs:
    def __init__(__self__, *,
                 assigned_device_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgs']]]] = None,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if assigned_device_infos is not None:
            pulumi.set(__self__, "assigned_device_infos", assigned_device_infos)
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="assignedDeviceInfos")
    def assigned_device_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgs']]]]:
        return pulumi.get(self, "assigned_device_infos")

    @assigned_device_infos.setter
    def assigned_device_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgs']]]]):
        pulumi.set(self, "assigned_device_infos", value)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgsDict(TypedDict):
        devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoArgs:
    def __init__(__self__, *,
                 devices: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgs']]]] = None):
        if devices is not None:
            pulumi.set(__self__, "devices", devices)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgs']]]]:
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgs']]]]):
        pulumi.set(self, "devices", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgsDict(TypedDict):
        device_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceAssignedDeviceInfoDeviceArgs:
    def __init__(__self__, *,
                 device_ext_id: Optional[pulumi.Input[str]] = None):
        if device_ext_id is not None:
            pulumi.set(__self__, "device_ext_id", device_ext_id)

    @property
    @pulumi.getter(name="deviceExtId")
    def device_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_ext_id")

    @device_ext_id.setter
    def device_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgsDict(TypedDict):
        pcie_device_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoArgs:
    def __init__(__self__, *,
                 pcie_device_references: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgs']]]] = None):
        if pcie_device_references is not None:
            pulumi.set(__self__, "pcie_device_references", pcie_device_references)

    @property
    @pulumi.getter(name="pcieDeviceReferences")
    def pcie_device_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgs']]]]:
        return pulumi.get(self, "pcie_device_references")

    @pcie_device_references.setter
    def pcie_device_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgs']]]]):
        pulumi.set(self, "pcie_device_references", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgsDict(TypedDict):
        device_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceBackingInfoPcieDeviceReferenceArgs:
    def __init__(__self__, *,
                 device_ext_id: Optional[pulumi.Input[str]] = None):
        if device_ext_id is not None:
            pulumi.set(__self__, "device_ext_id", device_ext_id)

    @property
    @pulumi.getter(name="deviceExtId")
    def device_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "device_ext_id")

    @device_ext_id.setter
    def device_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecPciDeviceLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStateArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgs']]]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecProtectionPolicyStatePolicyArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecSerialPortArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        is_connected: NotRequired[pulumi.Input[bool]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgsDict']]]]
        tenant_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecSerialPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecSerialPortArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecSerialPortLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecSourceArgsDict(TypedDict):
        entity_type: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecSourceArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        qos_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgsDict']]]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None,
                 qos_configs: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgs']]]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)
        if qos_configs is not None:
            pulumi.set(__self__, "qos_configs", qos_configs)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)

    @property
    @pulumi.getter(name="qosConfigs")
    def qos_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgs']]]]:
        return pulumi.get(self, "qos_configs")

    @qos_configs.setter
    def qos_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgs']]]]):
        pulumi.set(self, "qos_configs", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgsDict(TypedDict):
        throttled_iops: NotRequired[pulumi.Input[int]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecStorageConfigQosConfigArgs:
    def __init__(__self__, *,
                 throttled_iops: Optional[pulumi.Input[int]] = None):
        if throttled_iops is not None:
            pulumi.set(__self__, "throttled_iops", throttled_iops)

    @property
    @pulumi.getter(name="throttledIops")
    def throttled_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throttled_iops")

    @throttled_iops.setter
    def throttled_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttled_iops", value)


if not MYPY:
    class TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgsDict(TypedDict):
        is_vtpm_enabled: NotRequired[pulumi.Input[bool]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2TemplateVersionSpecVmSpecVtpmConfigArgs:
    def __init__(__self__, *,
                 is_vtpm_enabled: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        if is_vtpm_enabled is not None:
            pulumi.set(__self__, "is_vtpm_enabled", is_vtpm_enabled)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="isVtpmEnabled")
    def is_vtpm_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vtpm_enabled")

    @is_vtpm_enabled.setter
    def is_vtpm_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vtpm_enabled", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TemplateV2UpdatedByArgsDict(TypedDict):
        user_type: pulumi.Input[str]
        username: pulumi.Input[str]
        additional_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeArgsDict']]]]
        creation_type: NotRequired[pulumi.Input[str]]
        description: NotRequired[pulumi.Input[str]]
        display_name: NotRequired[pulumi.Input[str]]
        email_id: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
        first_name: NotRequired[pulumi.Input[str]]
        idp_id: NotRequired[pulumi.Input[str]]
        is_force_reset_password_enabled: NotRequired[pulumi.Input[bool]]
        last_name: NotRequired[pulumi.Input[str]]
        locale: NotRequired[pulumi.Input[str]]
        middle_initial: NotRequired[pulumi.Input[str]]
        password: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        status: NotRequired[pulumi.Input[str]]
elif False:
    TemplateV2UpdatedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2UpdatedByArgs:
    def __init__(__self__, *,
                 user_type: pulumi.Input[str],
                 username: pulumi.Input[str],
                 additional_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeArgs']]]] = None,
                 creation_type: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 email_id: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 first_name: Optional[pulumi.Input[str]] = None,
                 idp_id: Optional[pulumi.Input[str]] = None,
                 is_force_reset_password_enabled: Optional[pulumi.Input[bool]] = None,
                 last_name: Optional[pulumi.Input[str]] = None,
                 locale: Optional[pulumi.Input[str]] = None,
                 middle_initial: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "user_type", user_type)
        pulumi.set(__self__, "username", username)
        if additional_attributes is not None:
            pulumi.set(__self__, "additional_attributes", additional_attributes)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if email_id is not None:
            pulumi.set(__self__, "email_id", email_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if idp_id is not None:
            pulumi.set(__self__, "idp_id", idp_id)
        if is_force_reset_password_enabled is not None:
            pulumi.set(__self__, "is_force_reset_password_enabled", is_force_reset_password_enabled)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if middle_initial is not None:
            pulumi.set(__self__, "middle_initial", middle_initial)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="userType")
    def user_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user_type")

    @user_type.setter
    def user_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_type", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="additionalAttributes")
    def additional_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeArgs']]]]:
        return pulumi.get(self, "additional_attributes")

    @additional_attributes.setter
    def additional_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeArgs']]]]):
        pulumi.set(self, "additional_attributes", value)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="emailId")
    def email_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "email_id")

    @email_id.setter
    def email_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "first_name")

    @first_name.setter
    def first_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name", value)

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "idp_id")

    @idp_id.setter
    def idp_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idp_id", value)

    @property
    @pulumi.getter(name="isForceResetPasswordEnabled")
    def is_force_reset_password_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_force_reset_password_enabled")

    @is_force_reset_password_enabled.setter
    def is_force_reset_password_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_force_reset_password_enabled", value)

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_name")

    @last_name.setter
    def last_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name", value)

    @property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locale", value)

    @property
    @pulumi.getter(name="middleInitial")
    def middle_initial(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "middle_initial")

    @middle_initial.setter
    def middle_initial(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "middle_initial", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class TemplateV2UpdatedByAdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueArgsDict']]]]
elif False:
    TemplateV2UpdatedByAdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2UpdatedByAdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueArgs']]]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class TemplateV2UpdatedByAdditionalAttributeValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    TemplateV2UpdatedByAdditionalAttributeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2UpdatedByAdditionalAttributeValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateV2UpdatedByAdditionalAttributeValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class UserAccessControlPolicyReferenceListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - the name(Optional).
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    UserAccessControlPolicyReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserAccessControlPolicyReferenceListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name. (Default depends on the resource you are referencing)
        :param pulumi.Input[str] name: - the name(Optional).
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class UserCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - the name(Optional).
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - value of the key.
        """
elif False:
    UserCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - the name(Optional).
        :param pulumi.Input[str] value: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UserDirectoryServiceUserArgsDict(TypedDict):
        directory_service_reference: pulumi.Input['UserDirectoryServiceUserDirectoryServiceReferenceArgsDict']
        """
        - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
        """
        default_user_principal_name: NotRequired[pulumi.Input[str]]
        user_principal_name: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The UserPrincipalName of the user from the directory service.
        """
elif False:
    UserDirectoryServiceUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserDirectoryServiceUserArgs:
    def __init__(__self__, *,
                 directory_service_reference: pulumi.Input['UserDirectoryServiceUserDirectoryServiceReferenceArgs'],
                 default_user_principal_name: Optional[pulumi.Input[str]] = None,
                 user_principal_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['UserDirectoryServiceUserDirectoryServiceReferenceArgs'] directory_service_reference: - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
        :param pulumi.Input[str] user_principal_name: - (Optional) The UserPrincipalName of the user from the directory service.
        """
        pulumi.set(__self__, "directory_service_reference", directory_service_reference)
        if default_user_principal_name is not None:
            pulumi.set(__self__, "default_user_principal_name", default_user_principal_name)
        if user_principal_name is not None:
            pulumi.set(__self__, "user_principal_name", user_principal_name)

    @property
    @pulumi.getter(name="directoryServiceReference")
    def directory_service_reference(self) -> pulumi.Input['UserDirectoryServiceUserDirectoryServiceReferenceArgs']:
        """
        - (Optional) The reference to a directory service. See #reference for to look the supported attributes.
        """
        return pulumi.get(self, "directory_service_reference")

    @directory_service_reference.setter
    def directory_service_reference(self, value: pulumi.Input['UserDirectoryServiceUserDirectoryServiceReferenceArgs']):
        pulumi.set(self, "directory_service_reference", value)

    @property
    @pulumi.getter(name="defaultUserPrincipalName")
    def default_user_principal_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_user_principal_name")

    @default_user_principal_name.setter
    def default_user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_user_principal_name", value)

    @property
    @pulumi.getter(name="userPrincipalName")
    def user_principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The UserPrincipalName of the user from the directory service.
        """
        return pulumi.get(self, "user_principal_name")

    @user_principal_name.setter
    def user_principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_name", value)


if not MYPY:
    class UserDirectoryServiceUserDirectoryServiceReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - the name(Optional).
        """
elif False:
    UserDirectoryServiceUserDirectoryServiceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserDirectoryServiceUserDirectoryServiceReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] kind: - The kind name. (Default depends on the resource you are referencing)
        :param pulumi.Input[str] name: - the name(Optional).
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserGroupsCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - subnet name.
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    UserGroupsCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupsCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - subnet name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - subnet name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UserGroupsDirectoryServiceOusArgsDict(TypedDict):
        distinguished_name: pulumi.Input[str]
        """
        - (Required) The Distinguished name for the user group.
        """
elif False:
    UserGroupsDirectoryServiceOusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupsDirectoryServiceOusArgs:
    def __init__(__self__, *,
                 distinguished_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] distinguished_name: - (Required) The Distinguished name for the user group.
        """
        pulumi.set(__self__, "distinguished_name", distinguished_name)

    @property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> pulumi.Input[str]:
        """
        - (Required) The Distinguished name for the user group.
        """
        return pulumi.get(self, "distinguished_name")

    @distinguished_name.setter
    def distinguished_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "distinguished_name", value)


if not MYPY:
    class UserGroupsDirectoryServiceUserGroupArgsDict(TypedDict):
        distinguished_name: pulumi.Input[str]
        """
        - (Required) The Distinguished name for the user group.
        """
elif False:
    UserGroupsDirectoryServiceUserGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupsDirectoryServiceUserGroupArgs:
    def __init__(__self__, *,
                 distinguished_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] distinguished_name: - (Required) The Distinguished name for the user group.
        """
        pulumi.set(__self__, "distinguished_name", distinguished_name)

    @property
    @pulumi.getter(name="distinguishedName")
    def distinguished_name(self) -> pulumi.Input[str]:
        """
        - (Required) The Distinguished name for the user group.
        """
        return pulumi.get(self, "distinguished_name")

    @distinguished_name.setter
    def distinguished_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "distinguished_name", value)


if not MYPY:
    class UserGroupsSamlUserGroupArgsDict(TypedDict):
        idp_uuid: pulumi.Input[str]
        """
        - (Required) The UUID of the Identity Provider that the group belongs to.
        """
        name: pulumi.Input[str]
        """
        - (Required) The name of the SAML group which the IDP provides.
        """
elif False:
    UserGroupsSamlUserGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupsSamlUserGroupArgs:
    def __init__(__self__, *,
                 idp_uuid: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] idp_uuid: - (Required) The UUID of the Identity Provider that the group belongs to.
        :param pulumi.Input[str] name: - (Required) The name of the SAML group which the IDP provides.
        """
        pulumi.set(__self__, "idp_uuid", idp_uuid)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="idpUuid")
    def idp_uuid(self) -> pulumi.Input[str]:
        """
        - (Required) The UUID of the Identity Provider that the group belongs to.
        """
        return pulumi.get(self, "idp_uuid")

    @idp_uuid.setter
    def idp_uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_uuid", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        - (Required) The name of the SAML group which the IDP provides.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserIdentityProviderUserArgsDict(TypedDict):
        identity_provider_reference: pulumi.Input['UserIdentityProviderUserIdentityProviderReferenceArgsDict']
        """
        - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
        """
        username: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
        """
elif False:
    UserIdentityProviderUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityProviderUserArgs:
    def __init__(__self__, *,
                 identity_provider_reference: pulumi.Input['UserIdentityProviderUserIdentityProviderReferenceArgs'],
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['UserIdentityProviderUserIdentityProviderReferenceArgs'] identity_provider_reference: - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
        :param pulumi.Input[str] username: - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
        """
        pulumi.set(__self__, "identity_provider_reference", identity_provider_reference)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="identityProviderReference")
    def identity_provider_reference(self) -> pulumi.Input['UserIdentityProviderUserIdentityProviderReferenceArgs']:
        """
        - (Optional) The reference to a identity provider. See #reference for to look the supported attributes.
        """
        return pulumi.get(self, "identity_provider_reference")

    @identity_provider_reference.setter
    def identity_provider_reference(self, value: pulumi.Input['UserIdentityProviderUserIdentityProviderReferenceArgs']):
        pulumi.set(self, "identity_provider_reference", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The username from identity provider. Name ID for SAML Identity Provider.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class UserIdentityProviderUserIdentityProviderReferenceArgsDict(TypedDict):
        uuid: pulumi.Input[str]
        """
        - the UUID(Required).
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - the name(Optional).
        """
elif False:
    UserIdentityProviderUserIdentityProviderReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserIdentityProviderUserIdentityProviderReferenceArgs:
    def __init__(__self__, *,
                 uuid: pulumi.Input[str],
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uuid: - the UUID(Required).
        :param pulumi.Input[str] kind: - The kind name. (Default depends on the resource you are referencing)
        :param pulumi.Input[str] name: - the name(Optional).
        """
        pulumi.set(__self__, "uuid", uuid)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def uuid(self) -> pulumi.Input[str]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: pulumi.Input[str]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class UserProjectReferenceListArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - the name(Optional).
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    UserProjectReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProjectReferenceListArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name. (Default depends on the resource you are referencing)
        :param pulumi.Input[str] name: - the name(Optional).
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class UsersV2AdditionalAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        value: NotRequired[pulumi.Input[int]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    UsersV2AdditionalAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsersV2AdditionalAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[int] value: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class UsersV2BucketsAccessKeyArgsDict(TypedDict):
        access_key_name: NotRequired[pulumi.Input[str]]
        """
        - Name of the Bucket Access Key.
        """
        created_time: NotRequired[pulumi.Input[str]]
        """
        - Creation time for the Bucket Access Key.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        - A globally unique identifier of an instance that is suitable for external consumption.
        """
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['UsersV2BucketsAccessKeyLinkArgsDict']]]]
        """
        - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        - Secret Access Key, it will be returned only during Bucket Access Key creation.
        """
        user_id: NotRequired[pulumi.Input[str]]
        """
        - User Identifier who owns the Bucket Access Key.
        """
elif False:
    UsersV2BucketsAccessKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsersV2BucketsAccessKeyArgs:
    def __init__(__self__, *,
                 access_key_name: Optional[pulumi.Input[str]] = None,
                 created_time: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['UsersV2BucketsAccessKeyLinkArgs']]]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None,
                 user_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key_name: - Name of the Bucket Access Key.
        :param pulumi.Input[str] created_time: - Creation time for the Bucket Access Key.
        :param pulumi.Input[str] ext_id: - A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[Sequence[pulumi.Input['UsersV2BucketsAccessKeyLinkArgs']]] links: - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        :param pulumi.Input[str] secret_access_key: - Secret Access Key, it will be returned only during Bucket Access Key creation.
        :param pulumi.Input[str] user_id: - User Identifier who owns the Bucket Access Key.
        """
        if access_key_name is not None:
            pulumi.set(__self__, "access_key_name", access_key_name)
        if created_time is not None:
            pulumi.set(__self__, "created_time", created_time)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="accessKeyName")
    def access_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        - Name of the Bucket Access Key.
        """
        return pulumi.get(self, "access_key_name")

    @access_key_name.setter
    def access_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_name", value)

    @property
    @pulumi.getter(name="createdTime")
    def created_time(self) -> Optional[pulumi.Input[str]]:
        """
        - Creation time for the Bucket Access Key.
        """
        return pulumi.get(self, "created_time")

    @created_time.setter
    def created_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_time", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        - A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UsersV2BucketsAccessKeyLinkArgs']]]]:
        """
        - A HATEOAS style link for the response. Each link contains a user-friendly name identifying the link and an address for retrieving the particular resource.
        """
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UsersV2BucketsAccessKeyLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        - Secret Access Key, it will be returned only during Bucket Access Key creation.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[str]]:
        """
        - User Identifier who owns the Bucket Access Key.
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class UsersV2BucketsAccessKeyLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    UsersV2BucketsAccessKeyLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsersV2BucketsAccessKeyLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class UsersV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        """
        - The URL at which the entity described by the link can be accessed.
        """
        rel: NotRequired[pulumi.Input[str]]
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
elif False:
    UsersV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsersV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] href: - The URL at which the entity described by the link can be accessed.
        :param pulumi.Input[str] rel: - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        """
        - The URL at which the entity described by the link can be accessed.
        """
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        """
        - A name that identifies the relationship of the link to the object that is returned by the URL. The unique value of "self" identifies the URL for the object.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VirtualMachineCategoryArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the vm.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - value of the key.
        """
elif False:
    VirtualMachineCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineCategoryArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: - (Required) The name for the vm.
        :param pulumi.Input[str] value: - value of the key.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the vm.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualMachineDiskListArgsDict(TypedDict):
        data_source_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Reference to a data source.

        The disk_size (the disk size_mib and the disk_size_bytes attributes) is only honored by creating an empty disk. When you are creating from an image, the size is ignored and the disk becomes the size of the image from which it was cloned. In VM creation, you can't set either disk size_mib or disk_size_bytes when you set data_source_reference but, you can update the disk_size after creation (second apply).
        """
        device_properties: NotRequired[pulumi.Input['VirtualMachineDiskListDevicePropertiesArgsDict']]
        """
        Properties to a device.
        """
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        """
        Size of the disk in Bytes.
        """
        disk_size_mib: NotRequired[pulumi.Input[int]]
        """
        Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
        """
        storage_config: NotRequired[pulumi.Input['VirtualMachineDiskListStorageConfigArgsDict']]
        uuid: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The device ID which is used to uniquely identify this particular disk.
        """
        volume_group_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    VirtualMachineDiskListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineDiskListArgs:
    def __init__(__self__, *,
                 data_source_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 device_properties: Optional[pulumi.Input['VirtualMachineDiskListDevicePropertiesArgs']] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 disk_size_mib: Optional[pulumi.Input[int]] = None,
                 storage_config: Optional[pulumi.Input['VirtualMachineDiskListStorageConfigArgs']] = None,
                 uuid: Optional[pulumi.Input[str]] = None,
                 volume_group_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] data_source_reference: Reference to a data source.
               
               The disk_size (the disk size_mib and the disk_size_bytes attributes) is only honored by creating an empty disk. When you are creating from an image, the size is ignored and the disk becomes the size of the image from which it was cloned. In VM creation, you can't set either disk size_mib or disk_size_bytes when you set data_source_reference but, you can update the disk_size after creation (second apply).
        :param pulumi.Input['VirtualMachineDiskListDevicePropertiesArgs'] device_properties: Properties to a device.
        :param pulumi.Input[int] disk_size_bytes: Size of the disk in Bytes.
        :param pulumi.Input[int] disk_size_mib: Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
        :param pulumi.Input[str] uuid: - (Optional) The device ID which is used to uniquely identify this particular disk.
        """
        if data_source_reference is not None:
            pulumi.set(__self__, "data_source_reference", data_source_reference)
        if device_properties is not None:
            pulumi.set(__self__, "device_properties", device_properties)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if disk_size_mib is not None:
            pulumi.set(__self__, "disk_size_mib", disk_size_mib)
        if storage_config is not None:
            pulumi.set(__self__, "storage_config", storage_config)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if volume_group_reference is not None:
            pulumi.set(__self__, "volume_group_reference", volume_group_reference)

    @property
    @pulumi.getter(name="dataSourceReference")
    def data_source_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Reference to a data source.

        The disk_size (the disk size_mib and the disk_size_bytes attributes) is only honored by creating an empty disk. When you are creating from an image, the size is ignored and the disk becomes the size of the image from which it was cloned. In VM creation, you can't set either disk size_mib or disk_size_bytes when you set data_source_reference but, you can update the disk_size after creation (second apply).
        """
        return pulumi.get(self, "data_source_reference")

    @data_source_reference.setter
    def data_source_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "data_source_reference", value)

    @property
    @pulumi.getter(name="deviceProperties")
    def device_properties(self) -> Optional[pulumi.Input['VirtualMachineDiskListDevicePropertiesArgs']]:
        """
        Properties to a device.
        """
        return pulumi.get(self, "device_properties")

    @device_properties.setter
    def device_properties(self, value: Optional[pulumi.Input['VirtualMachineDiskListDevicePropertiesArgs']]):
        pulumi.set(self, "device_properties", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the disk in Bytes.
        """
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="diskSizeMib")
    def disk_size_mib(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the disk in MiB. Must match the size specified in 'disk_size_bytes' - rounded up to the nearest MiB - when that field is present.
        """
        return pulumi.get(self, "disk_size_mib")

    @disk_size_mib.setter
    def disk_size_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_mib", value)

    @property
    @pulumi.getter(name="storageConfig")
    def storage_config(self) -> Optional[pulumi.Input['VirtualMachineDiskListStorageConfigArgs']]:
        return pulumi.get(self, "storage_config")

    @storage_config.setter
    def storage_config(self, value: Optional[pulumi.Input['VirtualMachineDiskListStorageConfigArgs']]):
        pulumi.set(self, "storage_config", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The device ID which is used to uniquely identify this particular disk.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter(name="volumeGroupReference")
    def volume_group_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "volume_group_reference")

    @volume_group_reference.setter
    def volume_group_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "volume_group_reference", value)


if not MYPY:
    class VirtualMachineDiskListDevicePropertiesArgsDict(TypedDict):
        device_type: NotRequired[pulumi.Input[str]]
        """
        - A Disk type (default: DISK).
        """
        disk_address: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        - Address of disk to boot from.
        """
elif False:
    VirtualMachineDiskListDevicePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineDiskListDevicePropertiesArgs:
    def __init__(__self__, *,
                 device_type: Optional[pulumi.Input[str]] = None,
                 disk_address: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] device_type: - A Disk type (default: DISK).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] disk_address: - Address of disk to boot from.
        """
        if device_type is not None:
            pulumi.set(__self__, "device_type", device_type)
        if disk_address is not None:
            pulumi.set(__self__, "disk_address", disk_address)

    @property
    @pulumi.getter(name="deviceType")
    def device_type(self) -> Optional[pulumi.Input[str]]:
        """
        - A Disk type (default: DISK).
        """
        return pulumi.get(self, "device_type")

    @device_type.setter
    def device_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_type", value)

    @property
    @pulumi.getter(name="diskAddress")
    def disk_address(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - Address of disk to boot from.
        """
        return pulumi.get(self, "disk_address")

    @disk_address.setter
    def disk_address(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "disk_address", value)


if not MYPY:
    class VirtualMachineDiskListStorageConfigArgsDict(TypedDict):
        flash_mode: NotRequired[pulumi.Input[str]]
        """
        - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
        """
        storage_container_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineDiskListStorageConfigStorageContainerReferenceArgsDict']]]]
        """
        - Reference to a kind. Either one of (kind, uuid) or url needs to be specified. Requires Prism Central / AOS 5.17+.
        * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
        * `storage_container_reference.#.kind`: - kind of the container reference
        * `storage_container_reference.#.name`: - name of the container reference
        * `storage_container_reference.#.uuid`: - uiid of the container reference
        """
elif False:
    VirtualMachineDiskListStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineDiskListStorageConfigArgs:
    def __init__(__self__, *,
                 flash_mode: Optional[pulumi.Input[str]] = None,
                 storage_container_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs']]]] = None):
        """
        :param pulumi.Input[str] flash_mode: - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs']]] storage_container_references: - Reference to a kind. Either one of (kind, uuid) or url needs to be specified. Requires Prism Central / AOS 5.17+.
               * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
               * `storage_container_reference.#.kind`: - kind of the container reference
               * `storage_container_reference.#.name`: - name of the container reference
               * `storage_container_reference.#.uuid`: - uiid of the container reference
        """
        if flash_mode is not None:
            pulumi.set(__self__, "flash_mode", flash_mode)
        if storage_container_references is not None:
            pulumi.set(__self__, "storage_container_references", storage_container_references)

    @property
    @pulumi.getter(name="flashMode")
    def flash_mode(self) -> Optional[pulumi.Input[str]]:
        """
        - State of the storage policy to pin virtual disks to the hot tier. When specified as a VM attribute, the storage policy applies to all virtual disks of the VM unless overridden by the same attribute specified for a virtual disk.
        """
        return pulumi.get(self, "flash_mode")

    @flash_mode.setter
    def flash_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_mode", value)

    @property
    @pulumi.getter(name="storageContainerReferences")
    def storage_container_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs']]]]:
        """
        - Reference to a kind. Either one of (kind, uuid) or url needs to be specified. Requires Prism Central / AOS 5.17+.
        * `storage_container_reference.#.url`: - GET query on the URL will provide information on the source.
        * `storage_container_reference.#.kind`: - kind of the container reference
        * `storage_container_reference.#.name`: - name of the container reference
        * `storage_container_reference.#.uuid`: - uiid of the container reference
        """
        return pulumi.get(self, "storage_container_references")

    @storage_container_references.setter
    def storage_container_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs']]]]):
        pulumi.set(self, "storage_container_references", value)


if not MYPY:
    class VirtualMachineDiskListStorageConfigStorageContainerReferenceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[str]]
        """
        - The kind name (Default value: project)(Required).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (Required) The name for the vm.
        """
        url: NotRequired[pulumi.Input[str]]
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    VirtualMachineDiskListStorageConfigStorageContainerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineDiskListStorageConfigStorageContainerReferenceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: - The kind name (Default value: project)(Required).
        :param pulumi.Input[str] name: - (Required) The name for the vm.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (Required) The name for the vm.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class VirtualMachineGpuListArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[int]]
        """
        - (Computed) The device ID of the GPU.
        """
        fraction: NotRequired[pulumi.Input[int]]
        """
        Fraction of the physical GPU assigned.
        """
        frame_buffer_size_mib: NotRequired[pulumi.Input[int]]
        """
        - (ReadOnly) GPU frame buffer size in MiB.
        """
        guest_driver_version: NotRequired[pulumi.Input[str]]
        """
        - (ReadOnly) Last determined guest driver version.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The mode of this GPU.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - (ReadOnly) Name of the GPU resource.
        """
        num_virtual_display_heads: NotRequired[pulumi.Input[int]]
        """
        - (ReadOnly) Number of supported virtual display heads.
        """
        pci_address: NotRequired[pulumi.Input[str]]
        """
        GPU {segment:bus:device:function} (sbdf) address if assigned.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - (ReadOnly) UUID of the GPU.
        """
        vendor: NotRequired[pulumi.Input[str]]
        """
        - (Optional) The vendor of the GPU.
        """
elif False:
    VirtualMachineGpuListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineGpuListArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[int]] = None,
                 fraction: Optional[pulumi.Input[int]] = None,
                 frame_buffer_size_mib: Optional[pulumi.Input[int]] = None,
                 guest_driver_version: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_virtual_display_heads: Optional[pulumi.Input[int]] = None,
                 pci_address: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] device_id: - (Computed) The device ID of the GPU.
        :param pulumi.Input[int] fraction: Fraction of the physical GPU assigned.
        :param pulumi.Input[int] frame_buffer_size_mib: - (ReadOnly) GPU frame buffer size in MiB.
        :param pulumi.Input[str] guest_driver_version: - (ReadOnly) Last determined guest driver version.
        :param pulumi.Input[str] mode: - (Optional) The mode of this GPU.
        :param pulumi.Input[str] name: - (ReadOnly) Name of the GPU resource.
        :param pulumi.Input[int] num_virtual_display_heads: - (ReadOnly) Number of supported virtual display heads.
        :param pulumi.Input[str] pci_address: GPU {segment:bus:device:function} (sbdf) address if assigned.
        :param pulumi.Input[str] uuid: - (ReadOnly) UUID of the GPU.
        :param pulumi.Input[str] vendor: - (Optional) The vendor of the GPU.
        """
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if fraction is not None:
            pulumi.set(__self__, "fraction", fraction)
        if frame_buffer_size_mib is not None:
            pulumi.set(__self__, "frame_buffer_size_mib", frame_buffer_size_mib)
        if guest_driver_version is not None:
            pulumi.set(__self__, "guest_driver_version", guest_driver_version)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_virtual_display_heads is not None:
            pulumi.set(__self__, "num_virtual_display_heads", num_virtual_display_heads)
        if pci_address is not None:
            pulumi.set(__self__, "pci_address", pci_address)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[int]]:
        """
        - (Computed) The device ID of the GPU.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter
    def fraction(self) -> Optional[pulumi.Input[int]]:
        """
        Fraction of the physical GPU assigned.
        """
        return pulumi.get(self, "fraction")

    @fraction.setter
    def fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fraction", value)

    @property
    @pulumi.getter(name="frameBufferSizeMib")
    def frame_buffer_size_mib(self) -> Optional[pulumi.Input[int]]:
        """
        - (ReadOnly) GPU frame buffer size in MiB.
        """
        return pulumi.get(self, "frame_buffer_size_mib")

    @frame_buffer_size_mib.setter
    def frame_buffer_size_mib(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frame_buffer_size_mib", value)

    @property
    @pulumi.getter(name="guestDriverVersion")
    def guest_driver_version(self) -> Optional[pulumi.Input[str]]:
        """
        - (ReadOnly) Last determined guest driver version.
        """
        return pulumi.get(self, "guest_driver_version")

    @guest_driver_version.setter
    def guest_driver_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_driver_version", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The mode of this GPU.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - (ReadOnly) Name of the GPU resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numVirtualDisplayHeads")
    def num_virtual_display_heads(self) -> Optional[pulumi.Input[int]]:
        """
        - (ReadOnly) Number of supported virtual display heads.
        """
        return pulumi.get(self, "num_virtual_display_heads")

    @num_virtual_display_heads.setter
    def num_virtual_display_heads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_display_heads", value)

    @property
    @pulumi.getter(name="pciAddress")
    def pci_address(self) -> Optional[pulumi.Input[str]]:
        """
        GPU {segment:bus:device:function} (sbdf) address if assigned.
        """
        return pulumi.get(self, "pci_address")

    @pci_address.setter
    def pci_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pci_address", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - (ReadOnly) UUID of the GPU.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        """
        - (Optional) The vendor of the GPU.
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class VirtualMachineNicListArgsDict(TypedDict):
        ip_endpoint_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListIpEndpointListArgsDict']]]]
        """
        - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        """
        is_connected: NotRequired[pulumi.Input[str]]
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        - The MAC address for the adapter.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        - The model of this NIC. (Options : VIRTIO , E1000).
        """
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        - The reference to a network_function_chain.
        """
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        """
        - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        """
        nic_type: NotRequired[pulumi.Input[str]]
        """
        - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        """
        num_queues: NotRequired[pulumi.Input[int]]
        """
        - The number of tx/rx queue pairs for this NIC.
        """
        subnet_name: NotRequired[pulumi.Input[str]]
        """
        - The name of the subnet reference to.
        """
        subnet_uuid: NotRequired[pulumi.Input[str]]
        """
        - The reference to a subnet.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - The NIC's UUID, which is used to uniquely identify this particular NIC. This UUID may be used to refer to the NIC outside the context of the particular VM it is attached to.
        """
elif False:
    VirtualMachineNicListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineNicListArgs:
    def __init__(__self__, *,
                 ip_endpoint_lists: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListIpEndpointListArgs']]]] = None,
                 is_connected: Optional[pulumi.Input[str]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None,
                 subnet_name: Optional[pulumi.Input[str]] = None,
                 subnet_uuid: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListIpEndpointListArgs']]] ip_endpoint_lists: - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        :param pulumi.Input[str] is_connected: - Indicates whether the serial port connection is connected or not (`true` or `false`).
        :param pulumi.Input[str] mac_address: - The MAC address for the adapter.
        :param pulumi.Input[str] model: - The model of this NIC. (Options : VIRTIO , E1000).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] network_function_chain_reference: - The reference to a network_function_chain.
        :param pulumi.Input[str] network_function_nic_type: - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        :param pulumi.Input[str] nic_type: - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        :param pulumi.Input[int] num_queues: - The number of tx/rx queue pairs for this NIC.
        :param pulumi.Input[str] subnet_name: - The name of the subnet reference to.
        :param pulumi.Input[str] subnet_uuid: - The reference to a subnet.
        :param pulumi.Input[str] uuid: - The NIC's UUID, which is used to uniquely identify this particular NIC. This UUID may be used to refer to the NIC outside the context of the particular VM it is attached to.
        """
        if ip_endpoint_lists is not None:
            pulumi.set(__self__, "ip_endpoint_lists", ip_endpoint_lists)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if subnet_uuid is not None:
            pulumi.set(__self__, "subnet_uuid", subnet_uuid)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="ipEndpointLists")
    def ip_endpoint_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListIpEndpointListArgs']]]]:
        """
        - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        """
        return pulumi.get(self, "ip_endpoint_lists")

    @ip_endpoint_lists.setter
    def ip_endpoint_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListIpEndpointListArgs']]]]):
        pulumi.set(self, "ip_endpoint_lists", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[str]]:
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        - The MAC address for the adapter.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        - The model of this NIC. (Options : VIRTIO , E1000).
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - The reference to a network_function_chain.
        """
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        """
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        """
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        """
        - The number of tx/rx queue pairs for this NIC.
        """
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        - The name of the subnet reference to.
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="subnetUuid")
    def subnet_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - The reference to a subnet.
        """
        return pulumi.get(self, "subnet_uuid")

    @subnet_uuid.setter
    def subnet_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_uuid", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - The NIC's UUID, which is used to uniquely identify this particular NIC. This UUID may be used to refer to the NIC outside the context of the particular VM it is attached to.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class VirtualMachineNicListIpEndpointListArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        """
        - Address string.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
elif False:
    VirtualMachineNicListIpEndpointListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineNicListIpEndpointListArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: - Address string.
        :param pulumi.Input[str] type: - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        - Address string.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VirtualMachineNicListStatusArgsDict(TypedDict):
        floating_ip: NotRequired[pulumi.Input[str]]
        """
        -  The Floating IP associated with the vnic. (Only in `nic_list_status`)
        """
        ip_endpoint_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListStatusIpEndpointListArgsDict']]]]
        """
        - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        """
        is_connected: NotRequired[pulumi.Input[str]]
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        mac_address: NotRequired[pulumi.Input[str]]
        """
        - The MAC address for the adapter.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        - The model of this NIC. (Options : VIRTIO , E1000).
        """
        network_function_chain_reference: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        - The reference to a network_function_chain.
        """
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        """
        - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        """
        nic_type: NotRequired[pulumi.Input[str]]
        """
        - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        """
        num_queues: NotRequired[pulumi.Input[int]]
        """
        - The number of tx/rx queue pairs for this NIC.
        """
        subnet_name: NotRequired[pulumi.Input[str]]
        """
        - The name of the subnet reference to.
        """
        subnet_uuid: NotRequired[pulumi.Input[str]]
        """
        - The reference to a subnet.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        - the UUID(Required).
        """
elif False:
    VirtualMachineNicListStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineNicListStatusArgs:
    def __init__(__self__, *,
                 floating_ip: Optional[pulumi.Input[str]] = None,
                 ip_endpoint_lists: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListStatusIpEndpointListArgs']]]] = None,
                 is_connected: Optional[pulumi.Input[str]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 network_function_chain_reference: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None,
                 subnet_name: Optional[pulumi.Input[str]] = None,
                 subnet_uuid: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] floating_ip: -  The Floating IP associated with the vnic. (Only in `nic_list_status`)
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListStatusIpEndpointListArgs']]] ip_endpoint_lists: - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        :param pulumi.Input[str] is_connected: - Indicates whether the serial port connection is connected or not (`true` or `false`).
        :param pulumi.Input[str] mac_address: - The MAC address for the adapter.
        :param pulumi.Input[str] model: - The model of this NIC. (Options : VIRTIO , E1000).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] network_function_chain_reference: - The reference to a network_function_chain.
        :param pulumi.Input[str] network_function_nic_type: - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        :param pulumi.Input[str] nic_type: - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        :param pulumi.Input[int] num_queues: - The number of tx/rx queue pairs for this NIC.
        :param pulumi.Input[str] subnet_name: - The name of the subnet reference to.
        :param pulumi.Input[str] subnet_uuid: - The reference to a subnet.
        :param pulumi.Input[str] uuid: - the UUID(Required).
        """
        if floating_ip is not None:
            pulumi.set(__self__, "floating_ip", floating_ip)
        if ip_endpoint_lists is not None:
            pulumi.set(__self__, "ip_endpoint_lists", ip_endpoint_lists)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if network_function_chain_reference is not None:
            pulumi.set(__self__, "network_function_chain_reference", network_function_chain_reference)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if subnet_uuid is not None:
            pulumi.set(__self__, "subnet_uuid", subnet_uuid)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter(name="floatingIp")
    def floating_ip(self) -> Optional[pulumi.Input[str]]:
        """
        -  The Floating IP associated with the vnic. (Only in `nic_list_status`)
        """
        return pulumi.get(self, "floating_ip")

    @floating_ip.setter
    def floating_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "floating_ip", value)

    @property
    @pulumi.getter(name="ipEndpointLists")
    def ip_endpoint_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListStatusIpEndpointListArgs']]]]:
        """
        - IP endpoints for the adapter. Currently, IPv4 addresses are supported.
        """
        return pulumi.get(self, "ip_endpoint_lists")

    @ip_endpoint_lists.setter
    def ip_endpoint_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineNicListStatusIpEndpointListArgs']]]]):
        pulumi.set(self, "ip_endpoint_lists", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[str]]:
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        - The MAC address for the adapter.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        - The model of this NIC. (Options : VIRTIO , E1000).
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="networkFunctionChainReference")
    def network_function_chain_reference(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        - The reference to a network_function_chain.
        """
        return pulumi.get(self, "network_function_chain_reference")

    @network_function_chain_reference.setter
    def network_function_chain_reference(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "network_function_chain_reference", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The type of this Network function NIC. Defaults to INGRESS. (Options : INGRESS , EGRESS , TAP).
        """
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The type of this NIC. Defaults to NORMAL_NIC. (Options : NORMAL_NIC , DIRECT_NIC , NETWORK_FUNCTION_NIC).
        """
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        """
        - The number of tx/rx queue pairs for this NIC.
        """
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        - The name of the subnet reference to.
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="subnetUuid")
    def subnet_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - The reference to a subnet.
        """
        return pulumi.get(self, "subnet_uuid")

    @subnet_uuid.setter
    def subnet_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_uuid", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        - the UUID(Required).
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class VirtualMachineNicListStatusIpEndpointListArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        """
        - Address string.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
elif False:
    VirtualMachineNicListStatusIpEndpointListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineNicListStatusIpEndpointListArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: - Address string.
        :param pulumi.Input[str] type: - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        - Address string.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        - Address type. It can only be "ASSIGNED" in the spec. If no type is specified in the spec, the default type is set to "ASSIGNED". (Options : ASSIGNED , LEARNED)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VirtualMachineSerialPortListArgsDict(TypedDict):
        index: NotRequired[pulumi.Input[int]]
        """
        - Index of the serial port (int).
        """
        is_connected: NotRequired[pulumi.Input[bool]]
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
elif False:
    VirtualMachineSerialPortListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineSerialPortListArgs:
    def __init__(__self__, *,
                 index: Optional[pulumi.Input[int]] = None,
                 is_connected: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] index: - Index of the serial port (int).
        :param pulumi.Input[bool] is_connected: - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        - Index of the serial port (int).
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        """
        - Indicates whether the serial port connection is connected or not (`true` or `false`).
        """
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)


if not MYPY:
    class VirtualMachineV2ApcConfigArgsDict(TypedDict):
        cpu_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ApcConfigCpuModelArgsDict']]]]
        """
        CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
        * `cpu_model.name`: (Required) Name of the CPU model associated with the VM.
        """
        is_apc_enabled: NotRequired[pulumi.Input[bool]]
        """
        If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
        """
elif False:
    VirtualMachineV2ApcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2ApcConfigArgs:
    def __init__(__self__, *,
                 cpu_models: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ApcConfigCpuModelArgs']]]] = None,
                 is_apc_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ApcConfigCpuModelArgs']]] cpu_models: CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
               * `cpu_model.name`: (Required) Name of the CPU model associated with the VM.
        :param pulumi.Input[bool] is_apc_enabled: If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
        """
        if cpu_models is not None:
            pulumi.set(__self__, "cpu_models", cpu_models)
        if is_apc_enabled is not None:
            pulumi.set(__self__, "is_apc_enabled", is_apc_enabled)

    @property
    @pulumi.getter(name="cpuModels")
    def cpu_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ApcConfigCpuModelArgs']]]]:
        """
        CPU model associated with the VM if Advanced Processor Compatibility(APC) is enabled. If APC is enabled and no CPU model is explicitly set, a default baseline CPU model is picked by the system. See the APC documentation for more information
        * `cpu_model.name`: (Required) Name of the CPU model associated with the VM.
        """
        return pulumi.get(self, "cpu_models")

    @cpu_models.setter
    def cpu_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ApcConfigCpuModelArgs']]]]):
        pulumi.set(self, "cpu_models", value)

    @property
    @pulumi.getter(name="isApcEnabled")
    def is_apc_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, the selected CPU model will be retained across live and cold migrations of the VM.
        """
        return pulumi.get(self, "is_apc_enabled")

    @is_apc_enabled.setter
    def is_apc_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_apc_enabled", value)


if not MYPY:
    class VirtualMachineV2ApcConfigCpuModelArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        VM name.
        """
elif False:
    VirtualMachineV2ApcConfigCpuModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2ApcConfigCpuModelArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[str] name: VM name.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        VM name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VirtualMachineV2AvailabilityZoneArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2AvailabilityZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2AvailabilityZoneArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2BootConfigArgsDict(TypedDict):
        legacy_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootArgsDict']]]]
        """
        LegacyBoot config Object
        """
        uefi_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootArgsDict']]]]
        """
        UefiBoot config Object
        """
elif False:
    VirtualMachineV2BootConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigArgs:
    def __init__(__self__, *,
                 legacy_boots: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootArgs']]]] = None,
                 uefi_boots: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootArgs']]] legacy_boots: LegacyBoot config Object
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootArgs']]] uefi_boots: UefiBoot config Object
        """
        if legacy_boots is not None:
            pulumi.set(__self__, "legacy_boots", legacy_boots)
        if uefi_boots is not None:
            pulumi.set(__self__, "uefi_boots", uefi_boots)

    @property
    @pulumi.getter(name="legacyBoots")
    def legacy_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootArgs']]]]:
        """
        LegacyBoot config Object
        """
        return pulumi.get(self, "legacy_boots")

    @legacy_boots.setter
    def legacy_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootArgs']]]]):
        pulumi.set(self, "legacy_boots", value)

    @property
    @pulumi.getter(name="uefiBoots")
    def uefi_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootArgs']]]]:
        """
        UefiBoot config Object
        """
        return pulumi.get(self, "uefi_boots")

    @uefi_boots.setter
    def uefi_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootArgs']]]]):
        pulumi.set(self, "uefi_boots", value)


if not MYPY:
    class VirtualMachineV2BootConfigLegacyBootArgsDict(TypedDict):
        boot_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceArgsDict']]]]
        """
        Boot Device object
        * `boot_device.boot_device_disk`: (Optional) Disk address.
        * `boot_device.boot_device_disk.disk_address.bus_type`: (Required) Bus type for the device
        * `boot_device.boot_device_disk.disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.

        * `boot_device.boot_device_nic`: (Optional) Disk Nic address.
        * `boot_device.boot_device_nic.mac_address`: (Required) mac address
        """
        boot_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order. Valid values are 'CDROM', 'DISK', 'NETWORK'.
        """
elif False:
    VirtualMachineV2BootConfigLegacyBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigLegacyBootArgs:
    def __init__(__self__, *,
                 boot_devices: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceArgs']]]] = None,
                 boot_orders: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceArgs']]] boot_devices: Boot Device object
               * `boot_device.boot_device_disk`: (Optional) Disk address.
               * `boot_device.boot_device_disk.disk_address.bus_type`: (Required) Bus type for the device
               * `boot_device.boot_device_disk.disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
               
               * `boot_device.boot_device_nic`: (Optional) Disk Nic address.
               * `boot_device.boot_device_nic.mac_address`: (Required) mac address
        :param pulumi.Input[Sequence[pulumi.Input[str]]] boot_orders: Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order. Valid values are 'CDROM', 'DISK', 'NETWORK'.
        """
        if boot_devices is not None:
            pulumi.set(__self__, "boot_devices", boot_devices)
        if boot_orders is not None:
            pulumi.set(__self__, "boot_orders", boot_orders)

    @property
    @pulumi.getter(name="bootDevices")
    def boot_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceArgs']]]]:
        """
        Boot Device object
        * `boot_device.boot_device_disk`: (Optional) Disk address.
        * `boot_device.boot_device_disk.disk_address.bus_type`: (Required) Bus type for the device
        * `boot_device.boot_device_disk.disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.

        * `boot_device.boot_device_nic`: (Optional) Disk Nic address.
        * `boot_device.boot_device_nic.mac_address`: (Required) mac address
        """
        return pulumi.get(self, "boot_devices")

    @boot_devices.setter
    def boot_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceArgs']]]]):
        pulumi.set(self, "boot_devices", value)

    @property
    @pulumi.getter(name="bootOrders")
    def boot_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Indicates the order of device types in which the VM should try to boot from. If the boot device order is not provided the system will decide an appropriate boot device order. Valid values are 'CDROM', 'DISK', 'NETWORK'.
        """
        return pulumi.get(self, "boot_orders")

    @boot_orders.setter
    def boot_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "boot_orders", value)


if not MYPY:
    class VirtualMachineV2BootConfigLegacyBootBootDeviceArgsDict(TypedDict):
        boot_device_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict']]]]
        boot_device_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict']]]]
elif False:
    VirtualMachineV2BootConfigLegacyBootBootDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigLegacyBootBootDeviceArgs:
    def __init__(__self__, *,
                 boot_device_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]] = None,
                 boot_device_nics: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]] = None):
        if boot_device_disks is not None:
            pulumi.set(__self__, "boot_device_disks", boot_device_disks)
        if boot_device_nics is not None:
            pulumi.set(__self__, "boot_device_nics", boot_device_nics)

    @property
    @pulumi.getter(name="bootDeviceDisks")
    def boot_device_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]:
        return pulumi.get(self, "boot_device_disks")

    @boot_device_disks.setter
    def boot_device_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]):
        pulumi.set(self, "boot_device_disks", value)

    @property
    @pulumi.getter(name="bootDeviceNics")
    def boot_device_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]:
        return pulumi.get(self, "boot_device_nics")

    @boot_device_nics.setter
    def boot_device_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]):
        pulumi.set(self, "boot_device_nics", value)


if not MYPY:
    class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict']]]]
elif False:
    VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)


if not MYPY:
    class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict(TypedDict):
        mac_address: NotRequired[pulumi.Input[str]]
        """
        MAC address of the emulated NIC.
        """
elif False:
    VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs:
    def __init__(__self__, *,
                 mac_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mac_address: MAC address of the emulated NIC.
        """
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        MAC address of the emulated NIC.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootArgsDict(TypedDict):
        is_secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicate whether to enable secure boot or not
        """
        nvram_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceArgsDict']]]]
        """
        Configuration for NVRAM to be presented to the VM.
        * `nvram_device.backing_storage_info`: (Required) Storage provided by Nutanix ADSF
        """
elif False:
    VirtualMachineV2BootConfigUefiBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootArgs:
    def __init__(__self__, *,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 nvram_devices: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_secure_boot_enabled: Indicate whether to enable secure boot or not
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceArgs']]] nvram_devices: Configuration for NVRAM to be presented to the VM.
               * `nvram_device.backing_storage_info`: (Required) Storage provided by Nutanix ADSF
        """
        if is_secure_boot_enabled is not None:
            pulumi.set(__self__, "is_secure_boot_enabled", is_secure_boot_enabled)
        if nvram_devices is not None:
            pulumi.set(__self__, "nvram_devices", nvram_devices)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicate whether to enable secure boot or not
        """
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="nvramDevices")
    def nvram_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceArgs']]]]:
        """
        Configuration for NVRAM to be presented to the VM.
        * `nvram_device.backing_storage_info`: (Required) Storage provided by Nutanix ADSF
        """
        return pulumi.get(self, "nvram_devices")

    @nvram_devices.setter
    def nvram_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceArgs']]]]):
        pulumi.set(self, "nvram_devices", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceArgsDict(TypedDict):
        backing_storage_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict']]]]
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceArgs:
    def __init__(__self__, *,
                 backing_storage_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]] = None):
        if backing_storage_infos is not None:
            pulumi.set(__self__, "backing_storage_infos", backing_storage_infos)

    @property
    @pulumi.getter(name="backingStorageInfos")
    def backing_storage_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]:
        return pulumi.get(self, "backing_storage_infos")

    @backing_storage_infos.setter
    def backing_storage_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]):
        pulumi.set(self, "backing_storage_infos", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict']]]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict']]]]
        """
        Storage configuration for VM.
        """
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict']]]]
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]] storage_configs: Storage configuration for VM.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]:
        """
        Storage configuration for VM.
        """
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict']]]]
        """
        Reference to image or vm disk
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]] references: Reference to image or vm disk
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]:
        """
        Reference to image or vm disk
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict']]]]
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]] image_references: Image Reference
               * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]] vm_disk_references: Vm Disk Reference
               * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
               * `vm_disk_reference.disk_address`: (Optional) Disk address.
               * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]:
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_flash_mode_enabled: Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2CategoryArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2CategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CategoryArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2CdRomArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoArgsDict']]]]
        """
        Storage provided by Nutanix ADSF
        """
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomDiskAddressArgsDict']]]]
        """
        Virtual Machine disk (VM disk).
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        iso_type: NotRequired[pulumi.Input[str]]
        """
        Type of ISO image inserted in CD-ROM. Valid values "OTHER", "GUEST_TOOLS", "GUEST_CUSTOMIZATION" .
        """
elif False:
    VirtualMachineV2CdRomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 iso_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoArgs']]] backing_infos: Storage provided by Nutanix ADSF
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomDiskAddressArgs']]] disk_addresses: Virtual Machine disk (VM disk).
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[str] iso_type: Type of ISO image inserted in CD-ROM. Valid values "OTHER", "GUEST_TOOLS", "GUEST_CUSTOMIZATION" .
        """
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if iso_type is not None:
            pulumi.set(__self__, "iso_type", iso_type)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoArgs']]]]:
        """
        Storage provided by Nutanix ADSF
        """
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomDiskAddressArgs']]]]:
        """
        Virtual Machine disk (VM disk).
        """
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="isoType")
    def iso_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of ISO image inserted in CD-ROM. Valid values "OTHER", "GUEST_TOOLS", "GUEST_CUSTOMIZATION" .
        """
        return pulumi.get(self, "iso_type")

    @iso_type.setter
    def iso_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iso_type", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceArgsDict']]]]
        """
        A reference to a disk or image that contains the contents of a disk.
        """
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        """
        Size of the disk in Bytes
        """
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageConfigArgsDict']]]]
        """
        Storage configuration for VM disks
        * `storage_config.is_flash_mode_enabled`: Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageContainerArgsDict']]]]
        """
        This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageContainerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceArgs']]] data_sources: A reference to a disk or image that contains the contents of a disk.
        :param pulumi.Input[int] disk_size_bytes: Size of the disk in Bytes
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageConfigArgs']]] storage_configs: Storage configuration for VM disks
               * `storage_config.is_flash_mode_enabled`: Indicates whether the virtual disk is pinned to the hot tier or not.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageContainerArgs']]] storage_containers: This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceArgs']]]]:
        """
        A reference to a disk or image that contains the contents of a disk.
        """
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the disk in Bytes
        """
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageConfigArgs']]]]:
        """
        Storage configuration for VM disks
        * `storage_config.is_flash_mode_enabled`: Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageContainerArgs']]]]:
        """
        This reference is for disk level storage container preference. This preference specifies the storage container to which this disk belongs.
        """
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceArgsDict(TypedDict):
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgsDict']]]]
        """
        Reference to image or vm disk
        """
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceArgs:
    def __init__(__self__, *,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs']]] references: Reference to image or vm disk
        """
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs']]]]:
        """
        Reference to image or vm disk
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict']]]]
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]] image_references: Image Reference
               * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]] vm_disk_references: Vm Disk Reference
               * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
               * `vm_disk_reference.disk_address`: (Optional) Disk address.
               * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]:
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_flash_mode_enabled: Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VirtualMachineV2CdRomBackingInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2CdRomBackingInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomBackingInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2CdRomDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2CdRomDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2CdRomDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2ClusterArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2ClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2ClusterArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoArgsDict']]]]
        """
        Supporting storage to create virtual disk on.
        * `backing_info.vm_disk`:(Optional) backing Info for vmDisk
        * `backing_info.adfs_volume_group_reference`: (Required) Volume Group Reference
        * `backing_info.adfs_volume_group_reference.volume_group_ext_id`: (Required) The globally unique identifier of an ADSF volume group. It should be of type UUID.
        """
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskDiskAddressArgsDict']]]]
        """
        Disk address.
        * `disk_address.bus_type`: (Required) Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
        * `disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2DiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoArgs']]] backing_infos: Supporting storage to create virtual disk on.
               * `backing_info.vm_disk`:(Optional) backing Info for vmDisk
               * `backing_info.adfs_volume_group_reference`: (Required) Volume Group Reference
               * `backing_info.adfs_volume_group_reference.volume_group_ext_id`: (Required) The globally unique identifier of an ADSF volume group. It should be of type UUID.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskDiskAddressArgs']]] disk_addresses: Disk address.
               * `disk_address.bus_type`: (Required) Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
               * `disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoArgs']]]]:
        """
        Supporting storage to create virtual disk on.
        * `backing_info.vm_disk`:(Optional) backing Info for vmDisk
        * `backing_info.adfs_volume_group_reference`: (Required) Volume Group Reference
        * `backing_info.adfs_volume_group_reference.volume_group_ext_id`: (Required) The globally unique identifier of an ADSF volume group. It should be of type UUID.
        """
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskDiskAddressArgs']]]]:
        """
        Disk address.
        * `disk_address.bus_type`: (Required) Bus type for the device. The acceptable values are: SCSI, IDE, PCI, SATA, SPAPR (only PPC).
        * `disk_address.index`: (Required) Device index on the bus. This field is ignored unless the bus details are specified.
        """
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoArgsDict(TypedDict):
        adfs_volume_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict']]]]
        vm_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskArgsDict']]]]
elif False:
    VirtualMachineV2DiskBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoArgs:
    def __init__(__self__, *,
                 adfs_volume_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]] = None,
                 vm_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskArgs']]]] = None):
        if adfs_volume_group_references is not None:
            pulumi.set(__self__, "adfs_volume_group_references", adfs_volume_group_references)
        if vm_disks is not None:
            pulumi.set(__self__, "vm_disks", vm_disks)

    @property
    @pulumi.getter(name="adfsVolumeGroupReferences")
    def adfs_volume_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]:
        return pulumi.get(self, "adfs_volume_group_references")

    @adfs_volume_group_references.setter
    def adfs_volume_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]):
        pulumi.set(self, "adfs_volume_group_references", value)

    @property
    @pulumi.getter(name="vmDisks")
    def vm_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskArgs']]]]:
        return pulumi.get(self, "vm_disks")

    @vm_disks.setter
    def vm_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskArgs']]]]):
        pulumi.set(self, "vm_disks", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict(TypedDict):
        volume_group_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoAdfsVolumeGroupReferenceArgs:
    def __init__(__self__, *,
                 volume_group_ext_id: Optional[pulumi.Input[str]] = None):
        if volume_group_ext_id is not None:
            pulumi.set(__self__, "volume_group_ext_id", volume_group_ext_id)

    @property
    @pulumi.getter(name="volumeGroupExtId")
    def volume_group_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_group_ext_id")

    @volume_group_ext_id.setter
    def volume_group_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgsDict']]]]
        """
        Storage configuration for VM.
        """
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgsDict']]]]
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs']]] storage_configs: Storage configuration for VM.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs']]]]:
        """
        Storage configuration for VM.
        """
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict']]]]
        """
        Reference to image or vm disk
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]] references: Reference to image or vm disk
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]]:
        """
        Reference to image or vm disk
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict']]]]
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict']]]]
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]] image_references: Image Reference
               * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]] vm_disk_references: Vm Disk Reference
               * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
               * `vm_disk_reference.disk_address`: (Optional) Disk address.
               * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]:
        """
        Image Reference
        * `image_reference.image_ext_id`: (Required) The globally unique identifier of an image. It should be of type UUID.
        """
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]:
        """
        Vm Disk Reference
        * `vm_disk_reference.disk_ext_id`: (Optional) The globally unique identifier of a VM disk. It should be of type UUID.
        * `vm_disk_reference.disk_address`: (Optional) Disk address.
        * `vm_disk_reference.vm_reference`: (Optional) This is a reference to a VM.
        """
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_flash_mode_enabled: Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskBackingInfoVmDiskStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2DiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
elif False:
    VirtualMachineV2DiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2DiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] index: Index of the serial port.
        """
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VirtualMachineV2GpusArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[int]]
        """
        The device Id of the GPU.
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        fraction: NotRequired[pulumi.Input[int]]
        frame_buffer_size_bytes: NotRequired[pulumi.Input[int]]
        guest_driver_version: NotRequired[pulumi.Input[str]]
        links: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusLinkArgsDict']]]]
        mode: NotRequired[pulumi.Input[str]]
        """
        The mode of this GPU. Valid values "PASSTHROUGH_GRAPHICS", "PASSTHROUGH_COMPUTE", "VIRTUAL" .
        """
        name: NotRequired[pulumi.Input[str]]
        """
        VM name.
        """
        num_virtual_display_heads: NotRequired[pulumi.Input[int]]
        pci_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusPciAddressArgsDict']]]]
        """
        The (S)egment:(B)us:(D)evice.(F)unction hardware address.
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        vendor: NotRequired[pulumi.Input[str]]
        """
        The vendor of the GPU. Valid values "NVIDIA", "AMD", "INTEL" .
        """
elif False:
    VirtualMachineV2GpusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GpusArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[int]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 fraction: Optional[pulumi.Input[int]] = None,
                 frame_buffer_size_bytes: Optional[pulumi.Input[int]] = None,
                 guest_driver_version: Optional[pulumi.Input[str]] = None,
                 links: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusLinkArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_virtual_display_heads: Optional[pulumi.Input[int]] = None,
                 pci_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusPciAddressArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] device_id: The device Id of the GPU.
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[str] mode: The mode of this GPU. Valid values "PASSTHROUGH_GRAPHICS", "PASSTHROUGH_COMPUTE", "VIRTUAL" .
        :param pulumi.Input[str] name: VM name.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusPciAddressArgs']]] pci_addresses: The (S)egment:(B)us:(D)evice.(F)unction hardware address.
        :param pulumi.Input[str] vendor: The vendor of the GPU. Valid values "NVIDIA", "AMD", "INTEL" .
        """
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if fraction is not None:
            pulumi.set(__self__, "fraction", fraction)
        if frame_buffer_size_bytes is not None:
            pulumi.set(__self__, "frame_buffer_size_bytes", frame_buffer_size_bytes)
        if guest_driver_version is not None:
            pulumi.set(__self__, "guest_driver_version", guest_driver_version)
        if links is not None:
            pulumi.set(__self__, "links", links)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_virtual_display_heads is not None:
            pulumi.set(__self__, "num_virtual_display_heads", num_virtual_display_heads)
        if pci_addresses is not None:
            pulumi.set(__self__, "pci_addresses", pci_addresses)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[int]]:
        """
        The device Id of the GPU.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def fraction(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fraction")

    @fraction.setter
    def fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fraction", value)

    @property
    @pulumi.getter(name="frameBufferSizeBytes")
    def frame_buffer_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frame_buffer_size_bytes")

    @frame_buffer_size_bytes.setter
    def frame_buffer_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frame_buffer_size_bytes", value)

    @property
    @pulumi.getter(name="guestDriverVersion")
    def guest_driver_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_driver_version")

    @guest_driver_version.setter
    def guest_driver_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_driver_version", value)

    @property
    @pulumi.getter
    def links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusLinkArgs']]]]:
        return pulumi.get(self, "links")

    @links.setter
    def links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusLinkArgs']]]]):
        pulumi.set(self, "links", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The mode of this GPU. Valid values "PASSTHROUGH_GRAPHICS", "PASSTHROUGH_COMPUTE", "VIRTUAL" .
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        VM name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numVirtualDisplayHeads")
    def num_virtual_display_heads(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_virtual_display_heads")

    @num_virtual_display_heads.setter
    def num_virtual_display_heads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_display_heads", value)

    @property
    @pulumi.getter(name="pciAddresses")
    def pci_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusPciAddressArgs']]]]:
        """
        The (S)egment:(B)us:(D)evice.(F)unction hardware address.
        """
        return pulumi.get(self, "pci_addresses")

    @pci_addresses.setter
    def pci_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GpusPciAddressArgs']]]]):
        pulumi.set(self, "pci_addresses", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        """
        The vendor of the GPU. Valid values "NVIDIA", "AMD", "INTEL" .
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class VirtualMachineV2GpusLinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2GpusLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GpusLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VirtualMachineV2GpusPciAddressArgsDict(TypedDict):
        bus: NotRequired[pulumi.Input[int]]
        device: NotRequired[pulumi.Input[int]]
        func: NotRequired[pulumi.Input[int]]
        segment: NotRequired[pulumi.Input[int]]
elif False:
    VirtualMachineV2GpusPciAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GpusPciAddressArgs:
    def __init__(__self__, *,
                 bus: Optional[pulumi.Input[int]] = None,
                 device: Optional[pulumi.Input[int]] = None,
                 func: Optional[pulumi.Input[int]] = None,
                 segment: Optional[pulumi.Input[int]] = None):
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if func is not None:
            pulumi.set(__self__, "func", func)
        if segment is not None:
            pulumi.set(__self__, "segment", segment)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def func(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "func")

    @func.setter
    def func(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "func", value)

    @property
    @pulumi.getter
    def segment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "segment", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigArgsDict']]]]
        """
        The Nutanix Guest Tools customization settings.

        * `config.sysprep`: (Optional) Sysprep config
        * `config.cloud_init`: (Optional) CloudInit Config
        """
elif False:
    VirtualMachineV2GuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigArgs']]] configs: The Nutanix Guest Tools customization settings.
               
               * `config.sysprep`: (Optional) Sysprep config
               * `config.cloud_init`: (Optional) CloudInit Config
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigArgs']]]]:
        """
        The Nutanix Guest Tools customization settings.

        * `config.sysprep`: (Optional) Sysprep config
        * `config.cloud_init`: (Optional) CloudInit Config
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        """
        The script to use for cloud-init.
        * `cloud_init_script.user_data`: (Optional) user data object
        * `cloud_init_script.custom_keys`: (Optional) The list of the individual KeyValuePair elements.
        """
        datasource_type: NotRequired[pulumi.Input[str]]
        """
        Type of datasource. Default: CONFIG_DRIVE_V2
        """
        metadata: NotRequired[pulumi.Input[str]]
        """
        The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
        """
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]] cloud_init_scripts: The script to use for cloud-init.
               * `cloud_init_script.user_data`: (Optional) user data object
               * `cloud_init_script.custom_keys`: (Optional) The list of the individual KeyValuePair elements.
        :param pulumi.Input[str] datasource_type: Type of datasource. Default: CONFIG_DRIVE_V2
        :param pulumi.Input[str] metadata: The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
        """
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        """
        The script to use for cloud-init.
        * `cloud_init_script.user_data`: (Optional) user data object
        * `cloud_init_script.custom_keys`: (Optional) The list of the individual KeyValuePair elements.
        """
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of datasource. Default: CONFIG_DRIVE_V2
        """
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        """
        The contents of the meta_data configuration for cloud-init. This can be formatted as YAML or JSON. The value must be base64 encoded. Default value is 'CONFIG_DRIVE_V2'.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        VM name.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        """
        :param pulumi.Input[str] name: VM name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        VM name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        """
        Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Values allowed is 'PREPARED', 'FRESH'.
        """
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
        """
        Object either UnattendXml or CustomKeyValues
        * `sysprep_script.unattend_xml`: (Optional) xml object
        * `sysprep_script.custom_key_values`: (Optional) The list of the individual KeyValuePair elements.
        """
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        """
        :param pulumi.Input[str] install_type: Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Values allowed is 'PREPARED', 'FRESH'.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs']]] sysprep_scripts: Object either UnattendXml or CustomKeyValues
               * `sysprep_script.unattend_xml`: (Optional) xml object
               * `sysprep_script.custom_key_values`: (Optional) The list of the individual KeyValuePair elements.
        """
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates whether the guest will be freshly installed using this unattend configuration, or this unattend configuration will be applied to a pre-prepared image. Values allowed is 'PREPARED', 'FRESH'.
        """
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        """
        Object either UnattendXml or CustomKeyValues
        * `sysprep_script.unattend_xml`: (Optional) xml object
        * `sysprep_script.custom_key_values`: (Optional) The list of the individual KeyValuePair elements.
        """
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        VM name.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict']]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]] = None):
        """
        :param pulumi.Input[str] name: VM name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        VM name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict(TypedDict):
        boolean: NotRequired[pulumi.Input[bool]]
        integer: NotRequired[pulumi.Input[int]]
        integer_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        map_of_strings: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict']]]]
        object: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        string: NotRequired[pulumi.Input[str]]
        string_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueArgs:
    def __init__(__self__, *,
                 boolean: Optional[pulumi.Input[bool]] = None,
                 integer: Optional[pulumi.Input[int]] = None,
                 integer_lists: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 map_of_strings: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]] = None,
                 object: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 string: Optional[pulumi.Input[str]] = None,
                 string_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boolean is not None:
            pulumi.set(__self__, "boolean", boolean)
        if integer is not None:
            pulumi.set(__self__, "integer", integer)
        if integer_lists is not None:
            pulumi.set(__self__, "integer_lists", integer_lists)
        if map_of_strings is not None:
            pulumi.set(__self__, "map_of_strings", map_of_strings)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if string is not None:
            pulumi.set(__self__, "string", string)
        if string_lists is not None:
            pulumi.set(__self__, "string_lists", string_lists)

    @property
    @pulumi.getter
    def boolean(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boolean")

    @boolean.setter
    def boolean(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean", value)

    @property
    @pulumi.getter
    def integer(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "integer")

    @integer.setter
    def integer(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer", value)

    @property
    @pulumi.getter(name="integerLists")
    def integer_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "integer_lists")

    @integer_lists.setter
    def integer_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "integer_lists", value)

    @property
    @pulumi.getter(name="mapOfStrings")
    def map_of_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]:
        return pulumi.get(self, "map_of_strings")

    @map_of_strings.setter
    def map_of_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs']]]]):
        pulumi.set(self, "map_of_strings", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)

    @property
    @pulumi.getter(name="stringLists")
    def string_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "string_lists")

    @string_lists.setter
    def string_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "string_lists", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict(TypedDict):
        map: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairValueMapOfStringArgs:
    def __init__(__self__, *,
                 map: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if map is not None:
            pulumi.set(__self__, "map", map)

    @property
    @pulumi.getter
    def map(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "map")

    @map.setter
    def map(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "map", value)


if not MYPY:
    class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualMachineV2GuestToolArgsDict(TypedDict):
        available_version: NotRequired[pulumi.Input[str]]
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of the application names that are enabled on the guest VM.
        """
        guest_os_version: NotRequired[pulumi.Input[str]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether Nutanix Guest Tools is enabled or not.
        """
        is_installed: NotRequired[pulumi.Input[bool]]
        is_iso_inserted: NotRequired[pulumi.Input[bool]]
        is_reachable: NotRequired[pulumi.Input[bool]]
        is_vm_mobility_drivers_installed: NotRequired[pulumi.Input[bool]]
        is_vss_snapshot_capable: NotRequired[pulumi.Input[bool]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2GuestToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2GuestToolArgs:
    def __init__(__self__, *,
                 available_version: Optional[pulumi.Input[str]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 guest_os_version: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_installed: Optional[pulumi.Input[bool]] = None,
                 is_iso_inserted: Optional[pulumi.Input[bool]] = None,
                 is_reachable: Optional[pulumi.Input[bool]] = None,
                 is_vm_mobility_drivers_installed: Optional[pulumi.Input[bool]] = None,
                 is_vss_snapshot_capable: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] capabilities: The list of the application names that are enabled on the guest VM.
        :param pulumi.Input[bool] is_enabled: Indicates whether Nutanix Guest Tools is enabled or not.
        """
        if available_version is not None:
            pulumi.set(__self__, "available_version", available_version)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if guest_os_version is not None:
            pulumi.set(__self__, "guest_os_version", guest_os_version)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if is_iso_inserted is not None:
            pulumi.set(__self__, "is_iso_inserted", is_iso_inserted)
        if is_reachable is not None:
            pulumi.set(__self__, "is_reachable", is_reachable)
        if is_vm_mobility_drivers_installed is not None:
            pulumi.set(__self__, "is_vm_mobility_drivers_installed", is_vm_mobility_drivers_installed)
        if is_vss_snapshot_capable is not None:
            pulumi.set(__self__, "is_vss_snapshot_capable", is_vss_snapshot_capable)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="availableVersion")
    def available_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "available_version")

    @available_version.setter
    def available_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "available_version", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of the application names that are enabled on the guest VM.
        """
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="guestOsVersion")
    def guest_os_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_os_version")

    @guest_os_version.setter
    def guest_os_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_os_version", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Nutanix Guest Tools is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_installed", value)

    @property
    @pulumi.getter(name="isIsoInserted")
    def is_iso_inserted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_iso_inserted")

    @is_iso_inserted.setter
    def is_iso_inserted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_iso_inserted", value)

    @property
    @pulumi.getter(name="isReachable")
    def is_reachable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_reachable")

    @is_reachable.setter
    def is_reachable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_reachable", value)

    @property
    @pulumi.getter(name="isVmMobilityDriversInstalled")
    def is_vm_mobility_drivers_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vm_mobility_drivers_installed")

    @is_vm_mobility_drivers_installed.setter
    def is_vm_mobility_drivers_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vm_mobility_drivers_installed", value)

    @property
    @pulumi.getter(name="isVssSnapshotCapable")
    def is_vss_snapshot_capable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vss_snapshot_capable")

    @is_vss_snapshot_capable.setter
    def is_vss_snapshot_capable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vss_snapshot_capable", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VirtualMachineV2HostArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2HostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2HostArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2NicArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicBackingInfoArgsDict']]]]
        """
        Defines a NIC emulated by the hypervisor
        """
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoArgsDict']]]]
        """
        Network information for a NIC.
        """
elif False:
    VirtualMachineV2NicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicBackingInfoArgs']]] backing_infos: Defines a NIC emulated by the hypervisor
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoArgs']]] network_infos: Network information for a NIC.
        """
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicBackingInfoArgs']]]]:
        """
        Defines a NIC emulated by the hypervisor
        """
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoArgs']]]]:
        """
        Network information for a NIC.
        """
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)


if not MYPY:
    class VirtualMachineV2NicBackingInfoArgsDict(TypedDict):
        is_connected: NotRequired[pulumi.Input[bool]]
        mac_address: NotRequired[pulumi.Input[str]]
        """
        MAC address of the emulated NIC.
        """
        model: NotRequired[pulumi.Input[str]]
        """
        Options for the NIC emulation. Valid values "VIRTIO" , "E1000".
        """
        num_queues: NotRequired[pulumi.Input[int]]
        """
        The number of Tx/Rx queue pairs for this NIC. Default is 1.
        """
elif False:
    VirtualMachineV2NicBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicBackingInfoArgs:
    def __init__(__self__, *,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] mac_address: MAC address of the emulated NIC.
        :param pulumi.Input[str] model: Options for the NIC emulation. Valid values "VIRTIO" , "E1000".
        :param pulumi.Input[int] num_queues: The number of Tx/Rx queue pairs for this NIC. Default is 1.
        """
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        MAC address of the emulated NIC.
        """
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        """
        Options for the NIC emulation. Valid values "VIRTIO" , "E1000".
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Tx/Rx queue pairs for this NIC. Default is 1.
        """
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoArgsDict(TypedDict):
        ipv4_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigArgsDict']]]]
        """
        The IP address configurations.
        """
        ipv4_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoArgsDict']]]]
        network_function_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgsDict']]]]
        """
        The network function chain associates with the NIC. Only valid if nic_type is NORMAL_NIC.
        """
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        """
        The type of this Network function NIC. Defaults to INGRESS.
        """
        nic_type: NotRequired[pulumi.Input[str]]
        """
        NIC type. Valid values "SPAN_DESTINATION_NIC",  "NORMAL_NIC", "DIRECT_NIC", "NETWORK_FUNCTION_NIC" .
        """
        should_allow_unknown_macs: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoSubnetArgsDict']]]]
        """
        Network identifier for this adapter. Only valid if nic_type is NORMAL_NIC or DIRECT_NIC
        """
        trunked_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
        """
        vlan_mode: NotRequired[pulumi.Input[str]]
        """
        all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs.
        """
elif False:
    VirtualMachineV2NicNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoArgs:
    def __init__(__self__, *,
                 ipv4_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigArgs']]]] = None,
                 ipv4_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoArgs']]]] = None,
                 network_function_chains: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs']]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 should_allow_unknown_macs: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoSubnetArgs']]]] = None,
                 trunked_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 vlan_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigArgs']]] ipv4_configs: The IP address configurations.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs']]] network_function_chains: The network function chain associates with the NIC. Only valid if nic_type is NORMAL_NIC.
        :param pulumi.Input[str] network_function_nic_type: The type of this Network function NIC. Defaults to INGRESS.
        :param pulumi.Input[str] nic_type: NIC type. Valid values "SPAN_DESTINATION_NIC",  "NORMAL_NIC", "DIRECT_NIC", "NETWORK_FUNCTION_NIC" .
        :param pulumi.Input[bool] should_allow_unknown_macs: Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoSubnetArgs']]] subnets: Network identifier for this adapter. Only valid if nic_type is NORMAL_NIC or DIRECT_NIC
        :param pulumi.Input[Sequence[pulumi.Input[int]]] trunked_vlans: List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
        :param pulumi.Input[str] vlan_mode: all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs.
        """
        if ipv4_configs is not None:
            pulumi.set(__self__, "ipv4_configs", ipv4_configs)
        if ipv4_infos is not None:
            pulumi.set(__self__, "ipv4_infos", ipv4_infos)
        if network_function_chains is not None:
            pulumi.set(__self__, "network_function_chains", network_function_chains)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if should_allow_unknown_macs is not None:
            pulumi.set(__self__, "should_allow_unknown_macs", should_allow_unknown_macs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if trunked_vlans is not None:
            pulumi.set(__self__, "trunked_vlans", trunked_vlans)
        if vlan_mode is not None:
            pulumi.set(__self__, "vlan_mode", vlan_mode)

    @property
    @pulumi.getter(name="ipv4Configs")
    def ipv4_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigArgs']]]]:
        """
        The IP address configurations.
        """
        return pulumi.get(self, "ipv4_configs")

    @ipv4_configs.setter
    def ipv4_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigArgs']]]]):
        pulumi.set(self, "ipv4_configs", value)

    @property
    @pulumi.getter(name="ipv4Infos")
    def ipv4_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoArgs']]]]:
        return pulumi.get(self, "ipv4_infos")

    @ipv4_infos.setter
    def ipv4_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoArgs']]]]):
        pulumi.set(self, "ipv4_infos", value)

    @property
    @pulumi.getter(name="networkFunctionChains")
    def network_function_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs']]]]:
        """
        The network function chain associates with the NIC. Only valid if nic_type is NORMAL_NIC.
        """
        return pulumi.get(self, "network_function_chains")

    @network_function_chains.setter
    def network_function_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs']]]]):
        pulumi.set(self, "network_function_chains", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of this Network function NIC. Defaults to INGRESS.
        """
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        """
        NIC type. Valid values "SPAN_DESTINATION_NIC",  "NORMAL_NIC", "DIRECT_NIC", "NETWORK_FUNCTION_NIC" .
        """
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="shouldAllowUnknownMacs")
    def should_allow_unknown_macs(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether an unknown unicast traffic is forwarded to this NIC or not. This is applicable only for the NICs on the overlay subnets.
        """
        return pulumi.get(self, "should_allow_unknown_macs")

    @should_allow_unknown_macs.setter
    def should_allow_unknown_macs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_unknown_macs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoSubnetArgs']]]]:
        """
        Network identifier for this adapter. Only valid if nic_type is NORMAL_NIC or DIRECT_NIC
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="trunkedVlans")
    def trunked_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        List of networks to trunk if VLAN mode is marked as TRUNKED. If empty and VLAN mode is set to TRUNKED, all the VLANs are trunked.
        """
        return pulumi.get(self, "trunked_vlans")

    @trunked_vlans.setter
    def trunked_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "trunked_vlans", value)

    @property
    @pulumi.getter(name="vlanMode")
    def vlan_mode(self) -> Optional[pulumi.Input[str]]:
        """
        all the virtual NICs are created in ACCESS mode, which permits only one VLAN per virtual network. TRUNKED mode allows multiple VLANs on a single VM NIC for network-aware user VMs.
        """
        return pulumi.get(self, "vlan_mode")

    @vlan_mode.setter
    def vlan_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_mode", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoIpv4ConfigArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgsDict']]]]
        secondary_ip_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict']]]]
        should_assign_ip: NotRequired[pulumi.Input[bool]]
elif False:
    VirtualMachineV2NicNetworkInfoIpv4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoIpv4ConfigArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]] = None,
                 secondary_ip_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]] = None,
                 should_assign_ip: Optional[pulumi.Input[bool]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if secondary_ip_address_lists is not None:
            pulumi.set(__self__, "secondary_ip_address_lists", secondary_ip_address_lists)
        if should_assign_ip is not None:
            pulumi.set(__self__, "should_assign_ip", should_assign_ip)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="secondaryIpAddressLists")
    def secondary_ip_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]:
        return pulumi.get(self, "secondary_ip_address_lists")

    @secondary_ip_address_lists.setter
    def secondary_ip_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]):
        pulumi.set(self, "secondary_ip_address_lists", value)

    @property
    @pulumi.getter(name="shouldAssignIp")
    def should_assign_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_assign_ip")

    @should_assign_ip.setter
    def should_assign_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_assign_ip", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoIpv4ConfigIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoIpv4InfoArgsDict(TypedDict):
        learned_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgsDict']]]]
elif False:
    VirtualMachineV2NicNetworkInfoIpv4InfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoIpv4InfoArgs:
    def __init__(__self__, *,
                 learned_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]] = None):
        if learned_ip_addresses is not None:
            pulumi.set(__self__, "learned_ip_addresses", learned_ip_addresses)

    @property
    @pulumi.getter(name="learnedIpAddresses")
    def learned_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]:
        return pulumi.get(self, "learned_ip_addresses")

    @learned_ip_addresses.setter
    def learned_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgs']]]]):
        pulumi.set(self, "learned_ip_addresses", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoIpv4InfoLearnedIpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoNetworkFunctionChainArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2NicNetworkInfoSubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2NicNetworkInfoSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2NicNetworkInfoSubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2OwnershipInfoArgsDict(TypedDict):
        owners: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2OwnershipInfoOwnerArgsDict']]]]
elif False:
    VirtualMachineV2OwnershipInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2OwnershipInfoArgs:
    def __init__(__self__, *,
                 owners: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2OwnershipInfoOwnerArgs']]]] = None):
        if owners is not None:
            pulumi.set(__self__, "owners", owners)

    @property
    @pulumi.getter
    def owners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2OwnershipInfoOwnerArgs']]]]:
        return pulumi.get(self, "owners")

    @owners.setter
    def owners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2OwnershipInfoOwnerArgs']]]]):
        pulumi.set(self, "owners", value)


if not MYPY:
    class VirtualMachineV2OwnershipInfoOwnerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2OwnershipInfoOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2OwnershipInfoOwnerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2ProtectionPolicyStateArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ProtectionPolicyStatePolicyArgsDict']]]]
elif False:
    VirtualMachineV2ProtectionPolicyStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2ProtectionPolicyStateArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ProtectionPolicyStatePolicyArgs']]]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ProtectionPolicyStatePolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2ProtectionPolicyStatePolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class VirtualMachineV2ProtectionPolicyStatePolicyArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
elif False:
    VirtualMachineV2ProtectionPolicyStatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2ProtectionPolicyStatePolicyArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VirtualMachineV2SerialPortArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        index: NotRequired[pulumi.Input[int]]
        """
        Index of the serial port.
        """
        is_connected: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the serial port is connected or not.
        """
elif False:
    VirtualMachineV2SerialPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2SerialPortArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 is_connected: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] ext_id: A globally unique identifier of an instance that is suitable for external consumption.
        :param pulumi.Input[int] index: Index of the serial port.
        :param pulumi.Input[bool] is_connected: Indicates whether the serial port is connected or not.
        """
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier of an instance that is suitable for external consumption.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        Index of the serial port.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the serial port is connected or not.
        """
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)


if not MYPY:
    class VirtualMachineV2SourceArgsDict(TypedDict):
        entity_type: NotRequired[pulumi.Input[str]]
elif False:
    VirtualMachineV2SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2SourceArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[str]] = None):
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)


if not MYPY:
    class VirtualMachineV2StorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        qos_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2StorageConfigQosConfigArgsDict']]]]
        """
        QoS parameters to be enforced.
        * `qos_config.throttled_iops`: (Optional) Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
        """
elif False:
    VirtualMachineV2StorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2StorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None,
                 qos_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2StorageConfigQosConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_flash_mode_enabled: Indicates whether the virtual disk is pinned to the hot tier or not.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2StorageConfigQosConfigArgs']]] qos_configs: QoS parameters to be enforced.
               * `qos_config.throttled_iops`: (Optional) Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
        """
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)
        if qos_configs is not None:
            pulumi.set(__self__, "qos_configs", qos_configs)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the virtual disk is pinned to the hot tier or not.
        """
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)

    @property
    @pulumi.getter(name="qosConfigs")
    def qos_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2StorageConfigQosConfigArgs']]]]:
        """
        QoS parameters to be enforced.
        * `qos_config.throttled_iops`: (Optional) Throttled IOPS for the governed entities. The block size for the I/O is 32 kB.
        """
        return pulumi.get(self, "qos_configs")

    @qos_configs.setter
    def qos_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualMachineV2StorageConfigQosConfigArgs']]]]):
        pulumi.set(self, "qos_configs", value)


if not MYPY:
    class VirtualMachineV2StorageConfigQosConfigArgsDict(TypedDict):
        throttled_iops: NotRequired[pulumi.Input[int]]
elif False:
    VirtualMachineV2StorageConfigQosConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2StorageConfigQosConfigArgs:
    def __init__(__self__, *,
                 throttled_iops: Optional[pulumi.Input[int]] = None):
        if throttled_iops is not None:
            pulumi.set(__self__, "throttled_iops", throttled_iops)

    @property
    @pulumi.getter(name="throttledIops")
    def throttled_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throttled_iops")

    @throttled_iops.setter
    def throttled_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttled_iops", value)


if not MYPY:
    class VirtualMachineV2VtpmConfigArgsDict(TypedDict):
        is_vtpm_enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
        """
elif False:
    VirtualMachineV2VtpmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VirtualMachineV2VtpmConfigArgs:
    def __init__(__self__, *,
                 is_vtpm_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_vtpm_enabled: Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
        """
        if is_vtpm_enabled is not None:
            pulumi.set(__self__, "is_vtpm_enabled", is_vtpm_enabled)

    @property
    @pulumi.getter(name="isVtpmEnabled")
    def is_vtpm_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the virtual trusted platform module is enabled for the Guest OS or not.
        """
        return pulumi.get(self, "is_vtpm_enabled")

    @is_vtpm_enabled.setter
    def is_vtpm_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vtpm_enabled", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceArgsDict']]]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageContainerArgsDict']]]]
elif False:
    VmCdromInsertEjectV2BackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceArgs']]]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgsDict']]]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    VmCdromInsertEjectV2BackingInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VmCdromInsertEjectV2BackingInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCdromInsertEjectV2BackingInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCdromInsertEjectV2BackingInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2ApcConfigArgsDict(TypedDict):
        cpu_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ApcConfigCpuModelArgsDict']]]]
        is_apc_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2ApcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2ApcConfigArgs:
    def __init__(__self__, *,
                 cpu_models: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ApcConfigCpuModelArgs']]]] = None,
                 is_apc_enabled: Optional[pulumi.Input[bool]] = None):
        if cpu_models is not None:
            pulumi.set(__self__, "cpu_models", cpu_models)
        if is_apc_enabled is not None:
            pulumi.set(__self__, "is_apc_enabled", is_apc_enabled)

    @property
    @pulumi.getter(name="cpuModels")
    def cpu_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ApcConfigCpuModelArgs']]]]:
        return pulumi.get(self, "cpu_models")

    @cpu_models.setter
    def cpu_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ApcConfigCpuModelArgs']]]]):
        pulumi.set(self, "cpu_models", value)

    @property
    @pulumi.getter(name="isApcEnabled")
    def is_apc_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_apc_enabled")

    @is_apc_enabled.setter
    def is_apc_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_apc_enabled", value)


if not MYPY:
    class VmCloneV2ApcConfigCpuModelArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2ApcConfigCpuModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2ApcConfigCpuModelArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VmCloneV2BootConfigArgsDict(TypedDict):
        legacy_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootArgsDict']]]]
        uefi_boots: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootArgsDict']]]]
elif False:
    VmCloneV2BootConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigArgs:
    def __init__(__self__, *,
                 legacy_boots: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootArgs']]]] = None,
                 uefi_boots: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootArgs']]]] = None):
        if legacy_boots is not None:
            pulumi.set(__self__, "legacy_boots", legacy_boots)
        if uefi_boots is not None:
            pulumi.set(__self__, "uefi_boots", uefi_boots)

    @property
    @pulumi.getter(name="legacyBoots")
    def legacy_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootArgs']]]]:
        return pulumi.get(self, "legacy_boots")

    @legacy_boots.setter
    def legacy_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootArgs']]]]):
        pulumi.set(self, "legacy_boots", value)

    @property
    @pulumi.getter(name="uefiBoots")
    def uefi_boots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootArgs']]]]:
        return pulumi.get(self, "uefi_boots")

    @uefi_boots.setter
    def uefi_boots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootArgs']]]]):
        pulumi.set(self, "uefi_boots", value)


if not MYPY:
    class VmCloneV2BootConfigLegacyBootArgsDict(TypedDict):
        boot_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceArgsDict']]]]
        boot_orders: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    VmCloneV2BootConfigLegacyBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigLegacyBootArgs:
    def __init__(__self__, *,
                 boot_devices: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceArgs']]]] = None,
                 boot_orders: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if boot_devices is not None:
            pulumi.set(__self__, "boot_devices", boot_devices)
        if boot_orders is not None:
            pulumi.set(__self__, "boot_orders", boot_orders)

    @property
    @pulumi.getter(name="bootDevices")
    def boot_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceArgs']]]]:
        return pulumi.get(self, "boot_devices")

    @boot_devices.setter
    def boot_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceArgs']]]]):
        pulumi.set(self, "boot_devices", value)

    @property
    @pulumi.getter(name="bootOrders")
    def boot_orders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "boot_orders")

    @boot_orders.setter
    def boot_orders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "boot_orders", value)


if not MYPY:
    class VmCloneV2BootConfigLegacyBootBootDeviceArgsDict(TypedDict):
        boot_device_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict']]]]
        boot_device_nics: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict']]]]
elif False:
    VmCloneV2BootConfigLegacyBootBootDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigLegacyBootBootDeviceArgs:
    def __init__(__self__, *,
                 boot_device_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]] = None,
                 boot_device_nics: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]] = None):
        if boot_device_disks is not None:
            pulumi.set(__self__, "boot_device_disks", boot_device_disks)
        if boot_device_nics is not None:
            pulumi.set(__self__, "boot_device_nics", boot_device_nics)

    @property
    @pulumi.getter(name="bootDeviceDisks")
    def boot_device_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]:
        return pulumi.get(self, "boot_device_disks")

    @boot_device_disks.setter
    def boot_device_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs']]]]):
        pulumi.set(self, "boot_device_disks", value)

    @property
    @pulumi.getter(name="bootDeviceNics")
    def boot_device_nics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]:
        return pulumi.get(self, "boot_device_nics")

    @boot_device_nics.setter
    def boot_device_nics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs']]]]):
        pulumi.set(self, "boot_device_nics", value)


if not MYPY:
    class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict']]]]
elif False:
    VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)


if not MYPY:
    class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceDiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict(TypedDict):
        mac_address: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigLegacyBootBootDeviceBootDeviceNicArgs:
    def __init__(__self__, *,
                 mac_address: Optional[pulumi.Input[str]] = None):
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootArgsDict(TypedDict):
        is_secure_boot_enabled: NotRequired[pulumi.Input[bool]]
        nvram_devices: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootArgs:
    def __init__(__self__, *,
                 is_secure_boot_enabled: Optional[pulumi.Input[bool]] = None,
                 nvram_devices: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceArgs']]]] = None):
        if is_secure_boot_enabled is not None:
            pulumi.set(__self__, "is_secure_boot_enabled", is_secure_boot_enabled)
        if nvram_devices is not None:
            pulumi.set(__self__, "nvram_devices", nvram_devices)

    @property
    @pulumi.getter(name="isSecureBootEnabled")
    def is_secure_boot_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_secure_boot_enabled")

    @is_secure_boot_enabled.setter
    def is_secure_boot_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure_boot_enabled", value)

    @property
    @pulumi.getter(name="nvramDevices")
    def nvram_devices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceArgs']]]]:
        return pulumi.get(self, "nvram_devices")

    @nvram_devices.setter
    def nvram_devices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceArgs']]]]):
        pulumi.set(self, "nvram_devices", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceArgsDict(TypedDict):
        backing_storage_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceArgs:
    def __init__(__self__, *,
                 backing_storage_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]] = None):
        if backing_storage_infos is not None:
            pulumi.set(__self__, "backing_storage_infos", backing_storage_infos)

    @property
    @pulumi.getter(name="backingStorageInfos")
    def backing_storage_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]:
        return pulumi.get(self, "backing_storage_infos")

    @backing_storage_infos.setter
    def backing_storage_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs']]]]):
        pulumi.set(self, "backing_storage_infos", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict']]]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2BootConfigUefiBootNvramDeviceBackingStorageInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2CategoryArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2CategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CategoryArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2CdRomArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoArgsDict']]]]
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomDiskAddressArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        iso_type: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2CdRomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 iso_type: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if iso_type is not None:
            pulumi.set(__self__, "iso_type", iso_type)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="isoType")
    def iso_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iso_type")

    @iso_type.setter
    def iso_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iso_type", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageContainerArgsDict']]]]
elif False:
    VmCloneV2CdRomBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceArgsDict']]]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2CdRomBackingInfoStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VmCloneV2CdRomBackingInfoStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2CdRomBackingInfoStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomBackingInfoStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2CdRomDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2CdRomDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2CdRomDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2ClusterArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2ClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2ClusterArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2DiskArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoArgsDict']]]]
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskDiskAddressArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2DiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoArgs']]]] = None,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskDiskAddressArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoArgsDict(TypedDict):
        adfs_volume_group_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict']]]]
        vm_disks: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskArgsDict']]]]
elif False:
    VmCloneV2DiskBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoArgs:
    def __init__(__self__, *,
                 adfs_volume_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]] = None,
                 vm_disks: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskArgs']]]] = None):
        if adfs_volume_group_references is not None:
            pulumi.set(__self__, "adfs_volume_group_references", adfs_volume_group_references)
        if vm_disks is not None:
            pulumi.set(__self__, "vm_disks", vm_disks)

    @property
    @pulumi.getter(name="adfsVolumeGroupReferences")
    def adfs_volume_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]:
        return pulumi.get(self, "adfs_volume_group_references")

    @adfs_volume_group_references.setter
    def adfs_volume_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgs']]]]):
        pulumi.set(self, "adfs_volume_group_references", value)

    @property
    @pulumi.getter(name="vmDisks")
    def vm_disks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskArgs']]]]:
        return pulumi.get(self, "vm_disks")

    @vm_disks.setter
    def vm_disks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskArgs']]]]):
        pulumi.set(self, "vm_disks", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict(TypedDict):
        volume_group_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoAdfsVolumeGroupReferenceArgs:
    def __init__(__self__, *,
                 volume_group_ext_id: Optional[pulumi.Input[str]] = None):
        if volume_group_ext_id is not None:
            pulumi.set(__self__, "volume_group_ext_id", volume_group_ext_id)

    @property
    @pulumi.getter(name="volumeGroupExtId")
    def volume_group_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "volume_group_ext_id")

    @volume_group_ext_id.setter
    def volume_group_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_ext_id", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskArgsDict(TypedDict):
        data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        disk_size_bytes: NotRequired[pulumi.Input[int]]
        is_migration_in_progress: NotRequired[pulumi.Input[bool]]
        storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageConfigArgsDict']]]]
        storage_containers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageContainerArgsDict']]]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 disk_size_bytes: Optional[pulumi.Input[int]] = None,
                 is_migration_in_progress: Optional[pulumi.Input[bool]] = None,
                 storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageConfigArgs']]]] = None,
                 storage_containers: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageContainerArgs']]]] = None):
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if disk_size_bytes is not None:
            pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if is_migration_in_progress is not None:
            pulumi.set(__self__, "is_migration_in_progress", is_migration_in_progress)
        if storage_configs is not None:
            pulumi.set(__self__, "storage_configs", storage_configs)
        if storage_containers is not None:
            pulumi.set(__self__, "storage_containers", storage_containers)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter(name="isMigrationInProgress")
    def is_migration_in_progress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_migration_in_progress")

    @is_migration_in_progress.setter
    def is_migration_in_progress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_migration_in_progress", value)

    @property
    @pulumi.getter(name="storageConfigs")
    def storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageConfigArgs']]]]:
        return pulumi.get(self, "storage_configs")

    @storage_configs.setter
    def storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageConfigArgs']]]]):
        pulumi.set(self, "storage_configs", value)

    @property
    @pulumi.getter(name="storageContainers")
    def storage_containers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageContainerArgs']]]]:
        return pulumi.get(self, "storage_containers")

    @storage_containers.setter
    def storage_containers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskStorageContainerArgs']]]]):
        pulumi.set(self, "storage_containers", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict']]]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]] = None):
        if references is not None:
            pulumi.set(__self__, "references", references)

    @property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]]:
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict(TypedDict):
        image_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict']]]]
        vm_disk_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict']]]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceArgs:
    def __init__(__self__, *,
                 image_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]] = None,
                 vm_disk_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]] = None):
        if image_references is not None:
            pulumi.set(__self__, "image_references", image_references)
        if vm_disk_references is not None:
            pulumi.set(__self__, "vm_disk_references", vm_disk_references)

    @property
    @pulumi.getter(name="imageReferences")
    def image_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]:
        return pulumi.get(self, "image_references")

    @image_references.setter
    def image_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs']]]]):
        pulumi.set(self, "image_references", value)

    @property
    @pulumi.getter(name="vmDiskReferences")
    def vm_disk_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]:
        return pulumi.get(self, "vm_disk_references")

    @vm_disk_references.setter
    def vm_disk_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs']]]]):
        pulumi.set(self, "vm_disk_references", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict(TypedDict):
        image_ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceImageReferenceArgs:
    def __init__(__self__, *,
                 image_ext_id: Optional[pulumi.Input[str]] = None):
        if image_ext_id is not None:
            pulumi.set(__self__, "image_ext_id", image_ext_id)

    @property
    @pulumi.getter(name="imageExtId")
    def image_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_ext_id")

    @image_ext_id.setter
    def image_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_ext_id", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict(TypedDict):
        disk_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict']]]]
        disk_ext_id: NotRequired[pulumi.Input[str]]
        vm_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict']]]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceArgs:
    def __init__(__self__, *,
                 disk_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]] = None,
                 disk_ext_id: Optional[pulumi.Input[str]] = None,
                 vm_references: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]] = None):
        if disk_addresses is not None:
            pulumi.set(__self__, "disk_addresses", disk_addresses)
        if disk_ext_id is not None:
            pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        if vm_references is not None:
            pulumi.set(__self__, "vm_references", vm_references)

    @property
    @pulumi.getter(name="diskAddresses")
    def disk_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]:
        return pulumi.get(self, "disk_addresses")

    @disk_addresses.setter
    def disk_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs']]]]):
        pulumi.set(self, "disk_addresses", value)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="vmReferences")
    def vm_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]:
        return pulumi.get(self, "vm_references")

    @vm_references.setter
    def vm_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs']]]]):
        pulumi.set(self, "vm_references", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskDataSourceReferenceVmDiskReferenceVmReferenceArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskStorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskStorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)


if not MYPY:
    class VmCloneV2DiskBackingInfoVmDiskStorageContainerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2DiskBackingInfoVmDiskStorageContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskBackingInfoVmDiskStorageContainerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2DiskDiskAddressArgsDict(TypedDict):
        bus_type: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2DiskDiskAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2DiskDiskAddressArgs:
    def __init__(__self__, *,
                 bus_type: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        if bus_type is not None:
            pulumi.set(__self__, "bus_type", bus_type)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="busType")
    def bus_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bus_type")

    @bus_type.setter
    def bus_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bus_type", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VmCloneV2GpusArgsDict(TypedDict):
        device_id: NotRequired[pulumi.Input[int]]
        ext_id: NotRequired[pulumi.Input[str]]
        fraction: NotRequired[pulumi.Input[int]]
        frame_buffer_size_bytes: NotRequired[pulumi.Input[int]]
        guest_driver_version: NotRequired[pulumi.Input[str]]
        mode: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        num_virtual_display_heads: NotRequired[pulumi.Input[int]]
        pci_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GpusPciAddressArgsDict']]]]
        vendor: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GpusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GpusArgs:
    def __init__(__self__, *,
                 device_id: Optional[pulumi.Input[int]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 fraction: Optional[pulumi.Input[int]] = None,
                 frame_buffer_size_bytes: Optional[pulumi.Input[int]] = None,
                 guest_driver_version: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_virtual_display_heads: Optional[pulumi.Input[int]] = None,
                 pci_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GpusPciAddressArgs']]]] = None,
                 vendor: Optional[pulumi.Input[str]] = None):
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if fraction is not None:
            pulumi.set(__self__, "fraction", fraction)
        if frame_buffer_size_bytes is not None:
            pulumi.set(__self__, "frame_buffer_size_bytes", frame_buffer_size_bytes)
        if guest_driver_version is not None:
            pulumi.set(__self__, "guest_driver_version", guest_driver_version)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_virtual_display_heads is not None:
            pulumi.set(__self__, "num_virtual_display_heads", num_virtual_display_heads)
        if pci_addresses is not None:
            pulumi.set(__self__, "pci_addresses", pci_addresses)
        if vendor is not None:
            pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def fraction(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "fraction")

    @fraction.setter
    def fraction(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "fraction", value)

    @property
    @pulumi.getter(name="frameBufferSizeBytes")
    def frame_buffer_size_bytes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frame_buffer_size_bytes")

    @frame_buffer_size_bytes.setter
    def frame_buffer_size_bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frame_buffer_size_bytes", value)

    @property
    @pulumi.getter(name="guestDriverVersion")
    def guest_driver_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_driver_version")

    @guest_driver_version.setter
    def guest_driver_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_driver_version", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numVirtualDisplayHeads")
    def num_virtual_display_heads(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_virtual_display_heads")

    @num_virtual_display_heads.setter
    def num_virtual_display_heads(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_virtual_display_heads", value)

    @property
    @pulumi.getter(name="pciAddresses")
    def pci_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GpusPciAddressArgs']]]]:
        return pulumi.get(self, "pci_addresses")

    @pci_addresses.setter
    def pci_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GpusPciAddressArgs']]]]):
        pulumi.set(self, "pci_addresses", value)

    @property
    @pulumi.getter
    def vendor(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class VmCloneV2GpusPciAddressArgsDict(TypedDict):
        bus: NotRequired[pulumi.Input[int]]
        device: NotRequired[pulumi.Input[int]]
        func: NotRequired[pulumi.Input[int]]
        segment: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2GpusPciAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GpusPciAddressArgs:
    def __init__(__self__, *,
                 bus: Optional[pulumi.Input[int]] = None,
                 device: Optional[pulumi.Input[int]] = None,
                 func: Optional[pulumi.Input[int]] = None,
                 segment: Optional[pulumi.Input[int]] = None):
        if bus is not None:
            pulumi.set(__self__, "bus", bus)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if func is not None:
            pulumi.set(__self__, "func", func)
        if segment is not None:
            pulumi.set(__self__, "segment", segment)

    @property
    @pulumi.getter
    def bus(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "bus")

    @bus.setter
    def bus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bus", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter
    def func(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "func")

    @func.setter
    def func(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "func", value)

    @property
    @pulumi.getter
    def segment(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "segment")

    @segment.setter
    def segment(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "segment", value)


if not MYPY:
    class VmCloneV2GuestCustomizationArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigArgs']]]] = None):
        if configs is not None:
            pulumi.set(__self__, "configs", configs)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigArgs']]]]:
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigArgs']]]]):
        pulumi.set(self, "configs", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestCustomizationConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgs']]]]:
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestCustomizationConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2GuestToolArgsDict(TypedDict):
        available_version: NotRequired[pulumi.Input[str]]
        capabilities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        guest_os_version: NotRequired[pulumi.Input[str]]
        is_enabled: NotRequired[pulumi.Input[bool]]
        is_installed: NotRequired[pulumi.Input[bool]]
        is_iso_inserted: NotRequired[pulumi.Input[bool]]
        is_reachable: NotRequired[pulumi.Input[bool]]
        is_vm_mobility_drivers_installed: NotRequired[pulumi.Input[bool]]
        is_vss_snapshot_capable: NotRequired[pulumi.Input[bool]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2GuestToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2GuestToolArgs:
    def __init__(__self__, *,
                 available_version: Optional[pulumi.Input[str]] = None,
                 capabilities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 guest_os_version: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_installed: Optional[pulumi.Input[bool]] = None,
                 is_iso_inserted: Optional[pulumi.Input[bool]] = None,
                 is_reachable: Optional[pulumi.Input[bool]] = None,
                 is_vm_mobility_drivers_installed: Optional[pulumi.Input[bool]] = None,
                 is_vss_snapshot_capable: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        if available_version is not None:
            pulumi.set(__self__, "available_version", available_version)
        if capabilities is not None:
            pulumi.set(__self__, "capabilities", capabilities)
        if guest_os_version is not None:
            pulumi.set(__self__, "guest_os_version", guest_os_version)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_installed is not None:
            pulumi.set(__self__, "is_installed", is_installed)
        if is_iso_inserted is not None:
            pulumi.set(__self__, "is_iso_inserted", is_iso_inserted)
        if is_reachable is not None:
            pulumi.set(__self__, "is_reachable", is_reachable)
        if is_vm_mobility_drivers_installed is not None:
            pulumi.set(__self__, "is_vm_mobility_drivers_installed", is_vm_mobility_drivers_installed)
        if is_vss_snapshot_capable is not None:
            pulumi.set(__self__, "is_vss_snapshot_capable", is_vss_snapshot_capable)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="availableVersion")
    def available_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "available_version")

    @available_version.setter
    def available_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "available_version", value)

    @property
    @pulumi.getter
    def capabilities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "capabilities")

    @capabilities.setter
    def capabilities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "capabilities", value)

    @property
    @pulumi.getter(name="guestOsVersion")
    def guest_os_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "guest_os_version")

    @guest_os_version.setter
    def guest_os_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guest_os_version", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isInstalled")
    def is_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_installed")

    @is_installed.setter
    def is_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_installed", value)

    @property
    @pulumi.getter(name="isIsoInserted")
    def is_iso_inserted(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_iso_inserted")

    @is_iso_inserted.setter
    def is_iso_inserted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_iso_inserted", value)

    @property
    @pulumi.getter(name="isReachable")
    def is_reachable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_reachable")

    @is_reachable.setter
    def is_reachable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_reachable", value)

    @property
    @pulumi.getter(name="isVmMobilityDriversInstalled")
    def is_vm_mobility_drivers_installed(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vm_mobility_drivers_installed")

    @is_vm_mobility_drivers_installed.setter
    def is_vm_mobility_drivers_installed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vm_mobility_drivers_installed", value)

    @property
    @pulumi.getter(name="isVssSnapshotCapable")
    def is_vss_snapshot_capable(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vss_snapshot_capable")

    @is_vss_snapshot_capable.setter
    def is_vss_snapshot_capable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vss_snapshot_capable", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VmCloneV2HostArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2HostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2HostArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VmCloneV2NicArgsDict(TypedDict):
        backing_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicBackingInfoArgsDict']]]]
        ext_id: NotRequired[pulumi.Input[str]]
        network_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoArgsDict']]]]
elif False:
    VmCloneV2NicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicArgs:
    def __init__(__self__, *,
                 backing_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicBackingInfoArgs']]]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 network_infos: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoArgs']]]] = None):
        if backing_infos is not None:
            pulumi.set(__self__, "backing_infos", backing_infos)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if network_infos is not None:
            pulumi.set(__self__, "network_infos", network_infos)

    @property
    @pulumi.getter(name="backingInfos")
    def backing_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicBackingInfoArgs']]]]:
        return pulumi.get(self, "backing_infos")

    @backing_infos.setter
    def backing_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicBackingInfoArgs']]]]):
        pulumi.set(self, "backing_infos", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="networkInfos")
    def network_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoArgs']]]]:
        return pulumi.get(self, "network_infos")

    @network_infos.setter
    def network_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoArgs']]]]):
        pulumi.set(self, "network_infos", value)


if not MYPY:
    class VmCloneV2NicBackingInfoArgsDict(TypedDict):
        is_connected: NotRequired[pulumi.Input[bool]]
        mac_address: NotRequired[pulumi.Input[str]]
        model: NotRequired[pulumi.Input[str]]
        num_queues: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2NicBackingInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicBackingInfoArgs:
    def __init__(__self__, *,
                 is_connected: Optional[pulumi.Input[bool]] = None,
                 mac_address: Optional[pulumi.Input[str]] = None,
                 model: Optional[pulumi.Input[str]] = None,
                 num_queues: Optional[pulumi.Input[int]] = None):
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)
        if mac_address is not None:
            pulumi.set(__self__, "mac_address", mac_address)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if num_queues is not None:
            pulumi.set(__self__, "num_queues", num_queues)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model", value)

    @property
    @pulumi.getter(name="numQueues")
    def num_queues(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "num_queues")

    @num_queues.setter
    def num_queues(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_queues", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoArgsDict(TypedDict):
        ipv4_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigArgsDict']]]]
        network_function_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoNetworkFunctionChainArgsDict']]]]
        network_function_nic_type: NotRequired[pulumi.Input[str]]
        nic_type: NotRequired[pulumi.Input[str]]
        should_allow_unknown_macs: NotRequired[pulumi.Input[bool]]
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoSubnetArgsDict']]]]
        trunked_vlans: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        vlan_mode: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2NicNetworkInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoArgs:
    def __init__(__self__, *,
                 ipv4_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigArgs']]]] = None,
                 network_function_chains: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoNetworkFunctionChainArgs']]]] = None,
                 network_function_nic_type: Optional[pulumi.Input[str]] = None,
                 nic_type: Optional[pulumi.Input[str]] = None,
                 should_allow_unknown_macs: Optional[pulumi.Input[bool]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoSubnetArgs']]]] = None,
                 trunked_vlans: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 vlan_mode: Optional[pulumi.Input[str]] = None):
        if ipv4_configs is not None:
            pulumi.set(__self__, "ipv4_configs", ipv4_configs)
        if network_function_chains is not None:
            pulumi.set(__self__, "network_function_chains", network_function_chains)
        if network_function_nic_type is not None:
            pulumi.set(__self__, "network_function_nic_type", network_function_nic_type)
        if nic_type is not None:
            pulumi.set(__self__, "nic_type", nic_type)
        if should_allow_unknown_macs is not None:
            pulumi.set(__self__, "should_allow_unknown_macs", should_allow_unknown_macs)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if trunked_vlans is not None:
            pulumi.set(__self__, "trunked_vlans", trunked_vlans)
        if vlan_mode is not None:
            pulumi.set(__self__, "vlan_mode", vlan_mode)

    @property
    @pulumi.getter(name="ipv4Configs")
    def ipv4_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigArgs']]]]:
        return pulumi.get(self, "ipv4_configs")

    @ipv4_configs.setter
    def ipv4_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigArgs']]]]):
        pulumi.set(self, "ipv4_configs", value)

    @property
    @pulumi.getter(name="networkFunctionChains")
    def network_function_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoNetworkFunctionChainArgs']]]]:
        return pulumi.get(self, "network_function_chains")

    @network_function_chains.setter
    def network_function_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoNetworkFunctionChainArgs']]]]):
        pulumi.set(self, "network_function_chains", value)

    @property
    @pulumi.getter(name="networkFunctionNicType")
    def network_function_nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_function_nic_type")

    @network_function_nic_type.setter
    def network_function_nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_function_nic_type", value)

    @property
    @pulumi.getter(name="nicType")
    def nic_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "nic_type")

    @nic_type.setter
    def nic_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nic_type", value)

    @property
    @pulumi.getter(name="shouldAllowUnknownMacs")
    def should_allow_unknown_macs(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_allow_unknown_macs")

    @should_allow_unknown_macs.setter
    def should_allow_unknown_macs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_allow_unknown_macs", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoSubnetArgs']]]]:
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoSubnetArgs']]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="trunkedVlans")
    def trunked_vlans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "trunked_vlans")

    @trunked_vlans.setter
    def trunked_vlans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "trunked_vlans", value)

    @property
    @pulumi.getter(name="vlanMode")
    def vlan_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vlan_mode")

    @vlan_mode.setter
    def vlan_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_mode", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoIpv4ConfigArgsDict(TypedDict):
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgsDict']]]]
        secondary_ip_address_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict']]]]
        should_assign_ip: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2NicNetworkInfoIpv4ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoIpv4ConfigArgs:
    def __init__(__self__, *,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]] = None,
                 secondary_ip_address_lists: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]] = None,
                 should_assign_ip: Optional[pulumi.Input[bool]] = None):
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if secondary_ip_address_lists is not None:
            pulumi.set(__self__, "secondary_ip_address_lists", secondary_ip_address_lists)
        if should_assign_ip is not None:
            pulumi.set(__self__, "should_assign_ip", should_assign_ip)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="secondaryIpAddressLists")
    def secondary_ip_address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]:
        return pulumi.get(self, "secondary_ip_address_lists")

    @secondary_ip_address_lists.setter
    def secondary_ip_address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs']]]]):
        pulumi.set(self, "secondary_ip_address_lists", value)

    @property
    @pulumi.getter(name="shouldAssignIp")
    def should_assign_ip(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "should_assign_ip")

    @should_assign_ip.setter
    def should_assign_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_assign_ip", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoIpv4ConfigIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoIpv4ConfigSecondaryIpAddressListArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoNetworkFunctionChainArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2NicNetworkInfoNetworkFunctionChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoNetworkFunctionChainArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2NicNetworkInfoSubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2NicNetworkInfoSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2NicNetworkInfoSubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2OwnershipInfoArgsDict(TypedDict):
        owners: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2OwnershipInfoOwnerArgsDict']]]]
elif False:
    VmCloneV2OwnershipInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2OwnershipInfoArgs:
    def __init__(__self__, *,
                 owners: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2OwnershipInfoOwnerArgs']]]] = None):
        if owners is not None:
            pulumi.set(__self__, "owners", owners)

    @property
    @pulumi.getter
    def owners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2OwnershipInfoOwnerArgs']]]]:
        return pulumi.get(self, "owners")

    @owners.setter
    def owners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2OwnershipInfoOwnerArgs']]]]):
        pulumi.set(self, "owners", value)


if not MYPY:
    class VmCloneV2OwnershipInfoOwnerArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2OwnershipInfoOwnerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2OwnershipInfoOwnerArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2ProtectionPolicyStateArgsDict(TypedDict):
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ProtectionPolicyStatePolicyArgsDict']]]]
elif False:
    VmCloneV2ProtectionPolicyStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2ProtectionPolicyStateArgs:
    def __init__(__self__, *,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ProtectionPolicyStatePolicyArgs']]]] = None):
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ProtectionPolicyStatePolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2ProtectionPolicyStatePolicyArgs']]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class VmCloneV2ProtectionPolicyStatePolicyArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2ProtectionPolicyStatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2ProtectionPolicyStatePolicyArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2SerialPortArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
        index: NotRequired[pulumi.Input[int]]
        is_connected: NotRequired[pulumi.Input[bool]]
elif False:
    VmCloneV2SerialPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2SerialPortArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None,
                 index: Optional[pulumi.Input[int]] = None,
                 is_connected: Optional[pulumi.Input[bool]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)
        if index is not None:
            pulumi.set(__self__, "index", index)
        if is_connected is not None:
            pulumi.set(__self__, "is_connected", is_connected)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="isConnected")
    def is_connected(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_connected")

    @is_connected.setter
    def is_connected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_connected", value)


if not MYPY:
    class VmCloneV2SourceArgsDict(TypedDict):
        entity_type: NotRequired[pulumi.Input[str]]
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2SourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2SourceArgs:
    def __init__(__self__, *,
                 entity_type: Optional[pulumi.Input[str]] = None,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmCloneV2StorageConfigArgsDict(TypedDict):
        is_flash_mode_enabled: NotRequired[pulumi.Input[bool]]
        qos_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmCloneV2StorageConfigQosConfigArgsDict']]]]
elif False:
    VmCloneV2StorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2StorageConfigArgs:
    def __init__(__self__, *,
                 is_flash_mode_enabled: Optional[pulumi.Input[bool]] = None,
                 qos_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2StorageConfigQosConfigArgs']]]] = None):
        if is_flash_mode_enabled is not None:
            pulumi.set(__self__, "is_flash_mode_enabled", is_flash_mode_enabled)
        if qos_configs is not None:
            pulumi.set(__self__, "qos_configs", qos_configs)

    @property
    @pulumi.getter(name="isFlashModeEnabled")
    def is_flash_mode_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_flash_mode_enabled")

    @is_flash_mode_enabled.setter
    def is_flash_mode_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_flash_mode_enabled", value)

    @property
    @pulumi.getter(name="qosConfigs")
    def qos_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2StorageConfigQosConfigArgs']]]]:
        return pulumi.get(self, "qos_configs")

    @qos_configs.setter
    def qos_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmCloneV2StorageConfigQosConfigArgs']]]]):
        pulumi.set(self, "qos_configs", value)


if not MYPY:
    class VmCloneV2StorageConfigQosConfigArgsDict(TypedDict):
        throttled_iops: NotRequired[pulumi.Input[int]]
elif False:
    VmCloneV2StorageConfigQosConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2StorageConfigQosConfigArgs:
    def __init__(__self__, *,
                 throttled_iops: Optional[pulumi.Input[int]] = None):
        if throttled_iops is not None:
            pulumi.set(__self__, "throttled_iops", throttled_iops)

    @property
    @pulumi.getter(name="throttledIops")
    def throttled_iops(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "throttled_iops")

    @throttled_iops.setter
    def throttled_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "throttled_iops", value)


if not MYPY:
    class VmCloneV2VtpmConfigArgsDict(TypedDict):
        is_vtpm_enabled: NotRequired[pulumi.Input[bool]]
        version: NotRequired[pulumi.Input[str]]
elif False:
    VmCloneV2VtpmConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmCloneV2VtpmConfigArgs:
    def __init__(__self__, *,
                 is_vtpm_enabled: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        if is_vtpm_enabled is not None:
            pulumi.set(__self__, "is_vtpm_enabled", is_vtpm_enabled)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="isVtpmEnabled")
    def is_vtpm_enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_vtpm_enabled")

    @is_vtpm_enabled.setter
    def is_vtpm_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_vtpm_enabled", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VmGcUpdateV2ConfigArgsDict(TypedDict):
        cloud_inits: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitArgsDict']]]]
        syspreps: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigArgs:
    def __init__(__self__, *,
                 cloud_inits: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitArgs']]]] = None,
                 syspreps: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepArgs']]]] = None):
        if cloud_inits is not None:
            pulumi.set(__self__, "cloud_inits", cloud_inits)
        if syspreps is not None:
            pulumi.set(__self__, "syspreps", syspreps)

    @property
    @pulumi.getter(name="cloudInits")
    def cloud_inits(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitArgs']]]]:
        return pulumi.get(self, "cloud_inits")

    @cloud_inits.setter
    def cloud_inits(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitArgs']]]]):
        pulumi.set(self, "cloud_inits", value)

    @property
    @pulumi.getter
    def syspreps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepArgs']]]]:
        return pulumi.get(self, "syspreps")

    @syspreps.setter
    def syspreps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepArgs']]]]):
        pulumi.set(self, "syspreps", value)


if not MYPY:
    class VmGcUpdateV2ConfigCloudInitArgsDict(TypedDict):
        cloud_init_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptArgsDict']]]]
        datasource_type: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[str]]
elif False:
    VmGcUpdateV2ConfigCloudInitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigCloudInitArgs:
    def __init__(__self__, *,
                 cloud_init_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptArgs']]]] = None,
                 datasource_type: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[str]] = None):
        if cloud_init_scripts is not None:
            pulumi.set(__self__, "cloud_init_scripts", cloud_init_scripts)
        if datasource_type is not None:
            pulumi.set(__self__, "datasource_type", datasource_type)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @property
    @pulumi.getter(name="cloudInitScripts")
    def cloud_init_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptArgs']]]]:
        return pulumi.get(self, "cloud_init_scripts")

    @cloud_init_scripts.setter
    def cloud_init_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptArgs']]]]):
        pulumi.set(self, "cloud_init_scripts", value)

    @property
    @pulumi.getter(name="datasourceType")
    def datasource_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datasource_type")

    @datasource_type.setter
    def datasource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasource_type", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class VmGcUpdateV2ConfigCloudInitCloudInitScriptArgsDict(TypedDict):
        custom_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgsDict']]]]
        user_datas: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigCloudInitCloudInitScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigCloudInitCloudInitScriptArgs:
    def __init__(__self__, *,
                 custom_keys: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgs']]]] = None,
                 user_datas: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgs']]]] = None):
        if custom_keys is not None:
            pulumi.set(__self__, "custom_keys", custom_keys)
        if user_datas is not None:
            pulumi.set(__self__, "user_datas", user_datas)

    @property
    @pulumi.getter(name="customKeys")
    def custom_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgs']]]]:
        return pulumi.get(self, "custom_keys")

    @custom_keys.setter
    def custom_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgs']]]]):
        pulumi.set(self, "custom_keys", value)

    @property
    @pulumi.getter(name="userDatas")
    def user_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgs']]]]:
        return pulumi.get(self, "user_datas")

    @user_datas.setter
    def user_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgs']]]]):
        pulumi.set(self, "user_datas", value)


if not MYPY:
    class VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigCloudInitCloudInitScriptCustomKeyKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigCloudInitCloudInitScriptUserDataArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmGcUpdateV2ConfigSysprepArgsDict(TypedDict):
        install_type: NotRequired[pulumi.Input[str]]
        sysprep_scripts: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigSysprepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigSysprepArgs:
    def __init__(__self__, *,
                 install_type: Optional[pulumi.Input[str]] = None,
                 sysprep_scripts: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptArgs']]]] = None):
        if install_type is not None:
            pulumi.set(__self__, "install_type", install_type)
        if sysprep_scripts is not None:
            pulumi.set(__self__, "sysprep_scripts", sysprep_scripts)

    @property
    @pulumi.getter(name="installType")
    def install_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_type")

    @install_type.setter
    def install_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_type", value)

    @property
    @pulumi.getter(name="sysprepScripts")
    def sysprep_scripts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptArgs']]]]:
        return pulumi.get(self, "sysprep_scripts")

    @sysprep_scripts.setter
    def sysprep_scripts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptArgs']]]]):
        pulumi.set(self, "sysprep_scripts", value)


if not MYPY:
    class VmGcUpdateV2ConfigSysprepSysprepScriptArgsDict(TypedDict):
        custom_key_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgsDict']]]]
        unattend_xmls: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigSysprepSysprepScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigSysprepSysprepScriptArgs:
    def __init__(__self__, *,
                 custom_key_values: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgs']]]] = None,
                 unattend_xmls: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgs']]]] = None):
        if custom_key_values is not None:
            pulumi.set(__self__, "custom_key_values", custom_key_values)
        if unattend_xmls is not None:
            pulumi.set(__self__, "unattend_xmls", unattend_xmls)

    @property
    @pulumi.getter(name="customKeyValues")
    def custom_key_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgs']]]]:
        return pulumi.get(self, "custom_key_values")

    @custom_key_values.setter
    def custom_key_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgs']]]]):
        pulumi.set(self, "custom_key_values", value)

    @property
    @pulumi.getter(name="unattendXmls")
    def unattend_xmls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgs']]]]:
        return pulumi.get(self, "unattend_xmls")

    @unattend_xmls.setter
    def unattend_xmls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgs']]]]):
        pulumi.set(self, "unattend_xmls", value)


if not MYPY:
    class VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgsDict(TypedDict):
        key_value_pairs: NotRequired[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict']]]]
elif False:
    VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueArgs:
    def __init__(__self__, *,
                 key_value_pairs: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]] = None):
        if key_value_pairs is not None:
            pulumi.set(__self__, "key_value_pairs", key_value_pairs)

    @property
    @pulumi.getter(name="keyValuePairs")
    def key_value_pairs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]:
        return pulumi.get(self, "key_value_pairs")

    @key_value_pairs.setter
    def key_value_pairs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs']]]]):
        pulumi.set(self, "key_value_pairs", value)


if not MYPY:
    class VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigSysprepSysprepScriptCustomKeyValueKeyValuePairArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmGcUpdateV2ConfigSysprepSysprepScriptUnattendXmlArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VmNetworkDeviceAssignIpV2IpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    VmNetworkDeviceAssignIpV2IpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNetworkDeviceAssignIpV2IpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class VmNetworkDeviceMigrateV2IpAddressArgsDict(TypedDict):
        value: pulumi.Input[str]
        prefix_length: NotRequired[pulumi.Input[int]]
elif False:
    VmNetworkDeviceMigrateV2IpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNetworkDeviceMigrateV2IpAddressArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 prefix_length: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "value", value)
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class VmNetworkDeviceMigrateV2SubnetArgsDict(TypedDict):
        ext_id: NotRequired[pulumi.Input[str]]
elif False:
    VmNetworkDeviceMigrateV2SubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmNetworkDeviceMigrateV2SubnetArgs:
    def __init__(__self__, *,
                 ext_id: Optional[pulumi.Input[str]] = None):
        if ext_id is not None:
            pulumi.set(__self__, "ext_id", ext_id)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ext_id", value)


if not MYPY:
    class VmShutdownActionV2GuestPowerStateTransitionConfigArgsDict(TypedDict):
        should_enable_script_exec: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to run the set script before the VM shutdowns/restarts.
        """
        should_fail_on_script_failure: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to abort VM shutdown/restart if the script fails.


        See detailed information in [Nutanix VMs Power Action V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0).
        """
elif False:
    VmShutdownActionV2GuestPowerStateTransitionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VmShutdownActionV2GuestPowerStateTransitionConfigArgs:
    def __init__(__self__, *,
                 should_enable_script_exec: Optional[pulumi.Input[bool]] = None,
                 should_fail_on_script_failure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] should_enable_script_exec: Indicates whether to run the set script before the VM shutdowns/restarts.
        :param pulumi.Input[bool] should_fail_on_script_failure: Indicates whether to abort VM shutdown/restart if the script fails.
               
               
               See detailed information in [Nutanix VMs Power Action V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0).
        """
        if should_enable_script_exec is not None:
            pulumi.set(__self__, "should_enable_script_exec", should_enable_script_exec)
        if should_fail_on_script_failure is not None:
            pulumi.set(__self__, "should_fail_on_script_failure", should_fail_on_script_failure)

    @property
    @pulumi.getter(name="shouldEnableScriptExec")
    def should_enable_script_exec(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to run the set script before the VM shutdowns/restarts.
        """
        return pulumi.get(self, "should_enable_script_exec")

    @should_enable_script_exec.setter
    def should_enable_script_exec(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_enable_script_exec", value)

    @property
    @pulumi.getter(name="shouldFailOnScriptFailure")
    def should_fail_on_script_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to abort VM shutdown/restart if the script fails.


        See detailed information in [Nutanix VMs Power Action V4](https://developers.nutanix.com/api-reference?namespace=vmm&version=v4.0).
        """
        return pulumi.get(self, "should_fail_on_script_failure")

    @should_fail_on_script_failure.setter
    def should_fail_on_script_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_fail_on_script_failure", value)


if not MYPY:
    class VolumeGroupDiskV2DiskDataSourceReferenceArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
        """
        - The external identifier of the Data Source Reference.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        - The Entity Type of the Data Source Reference.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - The name of the Data Source Reference.bled for the Volume Group.
        """
        uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - The uri list of the Data Source Reference.
        """
elif False:
    VolumeGroupDiskV2DiskDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupDiskV2DiskDataSourceReferenceArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str],
                 entity_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] ext_id: - The external identifier of the Data Source Reference.
        :param pulumi.Input[str] entity_type: - The Entity Type of the Data Source Reference.
        :param pulumi.Input[str] name: - The name of the Data Source Reference.bled for the Volume Group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uris: - The uri list of the Data Source Reference.
        """
        pulumi.set(__self__, "ext_id", ext_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uris is not None:
            pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        """
        - The external identifier of the Data Source Reference.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The Entity Type of the Data Source Reference.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - The name of the Data Source Reference.bled for the Volume Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - The uri list of the Data Source Reference.
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uris", value)


if not MYPY:
    class VolumeGroupDiskV2DiskStorageFeatureArgsDict(TypedDict):
        flash_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupDiskV2DiskStorageFeatureFlashModeArgsDict']]]]
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
elif False:
    VolumeGroupDiskV2DiskStorageFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupDiskV2DiskStorageFeatureArgs:
    def __init__(__self__, *,
                 flash_modes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs']]] flash_modes: - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        if flash_modes is not None:
            pulumi.set(__self__, "flash_modes", flash_modes)

    @property
    @pulumi.getter(name="flashModes")
    def flash_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs']]]]:
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        return pulumi.get(self, "flash_modes")

    @flash_modes.setter
    def flash_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs']]]]):
        pulumi.set(self, "flash_modes", value)


if not MYPY:
    class VolumeGroupDiskV2DiskStorageFeatureFlashModeArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
elif False:
    VolumeGroupDiskV2DiskStorageFeatureFlashModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupDiskV2DiskStorageFeatureFlashModeArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: - Indicates whether the flash mode is enabled for the Volume Group Disk.
               
               See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdArgsDict(TypedDict):
        fqdns: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict']]]]
        """
        A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict']]]]
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdArgs:
    def __init__(__self__, *,
                 fqdns: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']]]] = None,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']]] fqdns: A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']]] ipv4s: An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']]] ipv6s: An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if fqdns is not None:
            pulumi.set(__self__, "fqdns", fqdns)
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']]]]:
        """
        A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']]]]):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']]]]:
        """
        An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        - The fully qualified domain name.


        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
elif False:
    VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: - The fully qualified domain name.
               
               
               See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - The fully qualified domain name.


        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv4 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
elif False:
    VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv4 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupIscsiClientV2IscsiInitiatorNetworkIdIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] prefix_length: - The prefix length of the network to which this host IPv6 address belongs.
        :param pulumi.Input[str] value: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VolumeGroupV2DiskArgsDict(TypedDict):
        disk_data_source_references: pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskDataSourceReferenceArgsDict']]]
        """
        -(Required) Disk Data Source Reference.
        """
        disk_size_bytes: pulumi.Input[int]
        """
        - ize of the disk in bytes. This field is mandatory during Volume Group creation if a new disk is being created on the storage container.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        - Volume Disk description.
        """
        disk_storage_features: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureArgsDict']]]]
        """
        - Storage optimization features which must be enabled on the Volume Disks. This is an optional field. If omitted, the disks will honor the Volume Group specific storage features setting.
        """
        index: NotRequired[pulumi.Input[int]]
        """
        - Index of the disk in a Volume Group. This field is optional and immutable.
        """
elif False:
    VolumeGroupV2DiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2DiskArgs:
    def __init__(__self__, *,
                 disk_data_source_references: pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskDataSourceReferenceArgs']]],
                 disk_size_bytes: pulumi.Input[int],
                 description: Optional[pulumi.Input[str]] = None,
                 disk_storage_features: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureArgs']]]] = None,
                 index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskDataSourceReferenceArgs']]] disk_data_source_references: -(Required) Disk Data Source Reference.
        :param pulumi.Input[int] disk_size_bytes: - ize of the disk in bytes. This field is mandatory during Volume Group creation if a new disk is being created on the storage container.
        :param pulumi.Input[str] description: - Volume Disk description.
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureArgs']]] disk_storage_features: - Storage optimization features which must be enabled on the Volume Disks. This is an optional field. If omitted, the disks will honor the Volume Group specific storage features setting.
        :param pulumi.Input[int] index: - Index of the disk in a Volume Group. This field is optional and immutable.
        """
        pulumi.set(__self__, "disk_data_source_references", disk_data_source_references)
        pulumi.set(__self__, "disk_size_bytes", disk_size_bytes)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk_storage_features is not None:
            pulumi.set(__self__, "disk_storage_features", disk_storage_features)
        if index is not None:
            pulumi.set(__self__, "index", index)

    @property
    @pulumi.getter(name="diskDataSourceReferences")
    def disk_data_source_references(self) -> pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskDataSourceReferenceArgs']]]:
        """
        -(Required) Disk Data Source Reference.
        """
        return pulumi.get(self, "disk_data_source_references")

    @disk_data_source_references.setter
    def disk_data_source_references(self, value: pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskDataSourceReferenceArgs']]]):
        pulumi.set(self, "disk_data_source_references", value)

    @property
    @pulumi.getter(name="diskSizeBytes")
    def disk_size_bytes(self) -> pulumi.Input[int]:
        """
        - ize of the disk in bytes. This field is mandatory during Volume Group creation if a new disk is being created on the storage container.
        """
        return pulumi.get(self, "disk_size_bytes")

    @disk_size_bytes.setter
    def disk_size_bytes(self, value: pulumi.Input[int]):
        pulumi.set(self, "disk_size_bytes", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        - Volume Disk description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="diskStorageFeatures")
    def disk_storage_features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureArgs']]]]:
        """
        - Storage optimization features which must be enabled on the Volume Disks. This is an optional field. If omitted, the disks will honor the Volume Group specific storage features setting.
        """
        return pulumi.get(self, "disk_storage_features")

    @disk_storage_features.setter
    def disk_storage_features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureArgs']]]]):
        pulumi.set(self, "disk_storage_features", value)

    @property
    @pulumi.getter
    def index(self) -> Optional[pulumi.Input[int]]:
        """
        - Index of the disk in a Volume Group. This field is optional and immutable.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "index", value)


if not MYPY:
    class VolumeGroupV2DiskDiskDataSourceReferenceArgsDict(TypedDict):
        ext_id: pulumi.Input[str]
        """
        - The external identifier of the Data Source Reference.
        """
        entity_type: NotRequired[pulumi.Input[str]]
        """
        - The Entity Type of the Data Source Reference.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        - The name of the Data Source Reference.bled for the Volume Group.
        """
        uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        - The uri list of the Data Source Reference.
        """
elif False:
    VolumeGroupV2DiskDiskDataSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2DiskDiskDataSourceReferenceArgs:
    def __init__(__self__, *,
                 ext_id: pulumi.Input[str],
                 entity_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] ext_id: - The external identifier of the Data Source Reference.
        :param pulumi.Input[str] entity_type: - The Entity Type of the Data Source Reference.
        :param pulumi.Input[str] name: - The name of the Data Source Reference.bled for the Volume Group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] uris: - The uri list of the Data Source Reference.
        """
        pulumi.set(__self__, "ext_id", ext_id)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uris is not None:
            pulumi.set(__self__, "uris", uris)

    @property
    @pulumi.getter(name="extId")
    def ext_id(self) -> pulumi.Input[str]:
        """
        - The external identifier of the Data Source Reference.
        """
        return pulumi.get(self, "ext_id")

    @ext_id.setter
    def ext_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "ext_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[str]]:
        """
        - The Entity Type of the Data Source Reference.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        - The name of the Data Source Reference.bled for the Volume Group.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        - The uri list of the Data Source Reference.
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "uris", value)


if not MYPY:
    class VolumeGroupV2DiskDiskStorageFeatureArgsDict(TypedDict):
        flash_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureFlashModeArgsDict']]]]
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
elif False:
    VolumeGroupV2DiskDiskStorageFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2DiskDiskStorageFeatureArgs:
    def __init__(__self__, *,
                 flash_modes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs']]] flash_modes: - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        if flash_modes is not None:
            pulumi.set(__self__, "flash_modes", flash_modes)

    @property
    @pulumi.getter(name="flashModes")
    def flash_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs']]]]:
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        return pulumi.get(self, "flash_modes")

    @flash_modes.setter
    def flash_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs']]]]):
        pulumi.set(self, "flash_modes", value)


if not MYPY:
    class VolumeGroupV2DiskDiskStorageFeatureFlashModeArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
elif False:
    VolumeGroupV2DiskDiskStorageFeatureFlashModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2DiskDiskStorageFeatureFlashModeArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: - Indicates whether the flash mode is enabled for the Volume Group Disk.
               
               See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class VolumeGroupV2IscsiFeatureArgsDict(TypedDict):
        enabled_authentications: NotRequired[pulumi.Input[str]]
        """
        - The authentication type enabled for the Volume Group.
        """
        target_secret: NotRequired[pulumi.Input[str]]
        """
        Target secret in case of a CHAP authentication. This field must only be provided in case the authentication type is not set to CHAP. This is an optional field and it cannot be retrieved once configured.
        """
elif False:
    VolumeGroupV2IscsiFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2IscsiFeatureArgs:
    def __init__(__self__, *,
                 enabled_authentications: Optional[pulumi.Input[str]] = None,
                 target_secret: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] enabled_authentications: - The authentication type enabled for the Volume Group.
        :param pulumi.Input[str] target_secret: Target secret in case of a CHAP authentication. This field must only be provided in case the authentication type is not set to CHAP. This is an optional field and it cannot be retrieved once configured.
        """
        if enabled_authentications is not None:
            pulumi.set(__self__, "enabled_authentications", enabled_authentications)
        if target_secret is not None:
            pulumi.set(__self__, "target_secret", target_secret)

    @property
    @pulumi.getter(name="enabledAuthentications")
    def enabled_authentications(self) -> Optional[pulumi.Input[str]]:
        """
        - The authentication type enabled for the Volume Group.
        """
        return pulumi.get(self, "enabled_authentications")

    @enabled_authentications.setter
    def enabled_authentications(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_authentications", value)

    @property
    @pulumi.getter(name="targetSecret")
    def target_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Target secret in case of a CHAP authentication. This field must only be provided in case the authentication type is not set to CHAP. This is an optional field and it cannot be retrieved once configured.
        """
        return pulumi.get(self, "target_secret")

    @target_secret.setter
    def target_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_secret", value)


if not MYPY:
    class VolumeGroupV2StorageFeatureArgsDict(TypedDict):
        flash_modes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2StorageFeatureFlashModeArgsDict']]]]
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
elif False:
    VolumeGroupV2StorageFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2StorageFeatureArgs:
    def __init__(__self__, *,
                 flash_modes: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2StorageFeatureFlashModeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2StorageFeatureFlashModeArgs']]] flash_modes: - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        if flash_modes is not None:
            pulumi.set(__self__, "flash_modes", flash_modes)

    @property
    @pulumi.getter(name="flashModes")
    def flash_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2StorageFeatureFlashModeArgs']]]]:
        """
        - this field will avoid down migration of data from the hot tier unless the overrides field is specified for the virtual disks.
        """
        return pulumi.get(self, "flash_modes")

    @flash_modes.setter
    def flash_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VolumeGroupV2StorageFeatureFlashModeArgs']]]]):
        pulumi.set(self, "flash_modes", value)


if not MYPY:
    class VolumeGroupV2StorageFeatureFlashModeArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
elif False:
    VolumeGroupV2StorageFeatureFlashModeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeGroupV2StorageFeatureFlashModeArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: - Indicates whether the flash mode is enabled for the Volume Group Disk.
               
               See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        - Indicates whether the flash mode is enabled for the Volume Group Disk.

        See detailed information in [Nutanix Volumes V4](https://developers.nutanix.com/api-reference?namespace=volumes&version=v4.0#tag/VolumeGroups/operation/createVolumeGroup).
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class VpcCommonDomainNameServerIpListArgsDict(TypedDict):
        ip: NotRequired[pulumi.Input[str]]
        """
        ip address.
        """
elif False:
    VpcCommonDomainNameServerIpListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcCommonDomainNameServerIpListArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: ip address.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        ip address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


if not MYPY:
    class VpcExternalSubnetListStatusArgsDict(TypedDict):
        external_subnet_reference: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        active_gateway_node: NotRequired[pulumi.Input['VpcExternalSubnetListStatusActiveGatewayNodeArgsDict']]
        external_ip_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    VpcExternalSubnetListStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcExternalSubnetListStatusArgs:
    def __init__(__self__, *,
                 external_subnet_reference: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 active_gateway_node: Optional[pulumi.Input['VpcExternalSubnetListStatusActiveGatewayNodeArgs']] = None,
                 external_ip_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "external_subnet_reference", external_subnet_reference)
        if active_gateway_node is not None:
            pulumi.set(__self__, "active_gateway_node", active_gateway_node)
        if external_ip_lists is not None:
            pulumi.set(__self__, "external_ip_lists", external_ip_lists)

    @property
    @pulumi.getter(name="externalSubnetReference")
    def external_subnet_reference(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        return pulumi.get(self, "external_subnet_reference")

    @external_subnet_reference.setter
    def external_subnet_reference(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "external_subnet_reference", value)

    @property
    @pulumi.getter(name="activeGatewayNode")
    def active_gateway_node(self) -> Optional[pulumi.Input['VpcExternalSubnetListStatusActiveGatewayNodeArgs']]:
        return pulumi.get(self, "active_gateway_node")

    @active_gateway_node.setter
    def active_gateway_node(self, value: Optional[pulumi.Input['VpcExternalSubnetListStatusActiveGatewayNodeArgs']]):
        pulumi.set(self, "active_gateway_node", value)

    @property
    @pulumi.getter(name="externalIpLists")
    def external_ip_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "external_ip_lists")

    @external_ip_lists.setter
    def external_ip_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_ip_lists", value)


if not MYPY:
    class VpcExternalSubnetListStatusActiveGatewayNodeArgsDict(TypedDict):
        host_reference: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        ip_address: NotRequired[pulumi.Input[str]]
elif False:
    VpcExternalSubnetListStatusActiveGatewayNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcExternalSubnetListStatusActiveGatewayNodeArgs:
    def __init__(__self__, *,
                 host_reference: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 ip_address: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "host_reference", host_reference)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="hostReference")
    def host_reference(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        return pulumi.get(self, "host_reference")

    @host_reference.setter
    def host_reference(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "host_reference", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)


if not MYPY:
    class VpcExternallyRoutablePrefixListArgsDict(TypedDict):
        ip: pulumi.Input[str]
        """
        ip address.
        """
        prefix_length: pulumi.Input[int]
        """
        prefix length.
        """
elif False:
    VpcExternallyRoutablePrefixListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcExternallyRoutablePrefixListArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 prefix_length: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: ip address.
        :param pulumi.Input[int] prefix_length: prefix length.
        """
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "prefix_length", prefix_length)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        ip address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        """
        prefix length.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)


if not MYPY:
    class VpcV2CommonDhcpOptionArgsDict(TypedDict):
        domain_name_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerArgsDict']]]]
        """
        List of Domain Name Server addresses
        - `domain_name_servers.ipv4`:(Optional) Reference to address configuration
        - `domain_name_servers.ipv6`: (Optional) Reference to address configuration
        """
elif False:
    VpcV2CommonDhcpOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2CommonDhcpOptionArgs:
    def __init__(__self__, *,
                 domain_name_servers: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerArgs']]] domain_name_servers: List of Domain Name Server addresses
               - `domain_name_servers.ipv4`:(Optional) Reference to address configuration
               - `domain_name_servers.ipv6`: (Optional) Reference to address configuration
        """
        if domain_name_servers is not None:
            pulumi.set(__self__, "domain_name_servers", domain_name_servers)

    @property
    @pulumi.getter(name="domainNameServers")
    def domain_name_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerArgs']]]]:
        """
        List of Domain Name Server addresses
        - `domain_name_servers.ipv4`:(Optional) Reference to address configuration
        - `domain_name_servers.ipv6`: (Optional) Reference to address configuration
        """
        return pulumi.get(self, "domain_name_servers")

    @domain_name_servers.setter
    def domain_name_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerArgs']]]]):
        pulumi.set(self, "domain_name_servers", value)


if not MYPY:
    class VpcV2CommonDhcpOptionDomainNameServerArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv6ArgsDict']]]]
elif False:
    VpcV2CommonDhcpOptionDomainNameServerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2CommonDhcpOptionDomainNameServerArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2CommonDhcpOptionDomainNameServerIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VpcV2CommonDhcpOptionDomainNameServerIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2CommonDhcpOptionDomainNameServerIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2CommonDhcpOptionDomainNameServerIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2CommonDhcpOptionDomainNameServerIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2CommonDhcpOptionDomainNameServerIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2CommonDhcpOptionDomainNameServerIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternalSubnetArgsDict(TypedDict):
        subnet_reference: pulumi.Input[str]
        """
        External subnet reference.
        """
        active_gateway_count: NotRequired[pulumi.Input[int]]
        active_gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeArgsDict']]]]
        external_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpArgsDict']]]]
        """
        List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
        """
        gateway_nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    VpcV2ExternalSubnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetArgs:
    def __init__(__self__, *,
                 subnet_reference: pulumi.Input[str],
                 active_gateway_count: Optional[pulumi.Input[int]] = None,
                 active_gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeArgs']]]] = None,
                 external_ips: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpArgs']]]] = None,
                 gateway_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] subnet_reference: External subnet reference.
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpArgs']]] external_ips: List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
        """
        pulumi.set(__self__, "subnet_reference", subnet_reference)
        if active_gateway_count is not None:
            pulumi.set(__self__, "active_gateway_count", active_gateway_count)
        if active_gateway_nodes is not None:
            pulumi.set(__self__, "active_gateway_nodes", active_gateway_nodes)
        if external_ips is not None:
            pulumi.set(__self__, "external_ips", external_ips)
        if gateway_nodes is not None:
            pulumi.set(__self__, "gateway_nodes", gateway_nodes)

    @property
    @pulumi.getter(name="subnetReference")
    def subnet_reference(self) -> pulumi.Input[str]:
        """
        External subnet reference.
        """
        return pulumi.get(self, "subnet_reference")

    @subnet_reference.setter
    def subnet_reference(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_reference", value)

    @property
    @pulumi.getter(name="activeGatewayCount")
    def active_gateway_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "active_gateway_count")

    @active_gateway_count.setter
    def active_gateway_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_gateway_count", value)

    @property
    @pulumi.getter(name="activeGatewayNodes")
    def active_gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeArgs']]]]:
        return pulumi.get(self, "active_gateway_nodes")

    @active_gateway_nodes.setter
    def active_gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeArgs']]]]):
        pulumi.set(self, "active_gateway_nodes", value)

    @property
    @pulumi.getter(name="externalIps")
    def external_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpArgs']]]]:
        """
        List of IP Addresses used for SNAT, if NAT is enabled on the external subnet. If NAT is not enabled, this specifies the IP address of the VPC port connected to the external gateway.
        """
        return pulumi.get(self, "external_ips")

    @external_ips.setter
    def external_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpArgs']]]]):
        pulumi.set(self, "external_ips", value)

    @property
    @pulumi.getter(name="gatewayNodes")
    def gateway_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "gateway_nodes")

    @gateway_nodes.setter
    def gateway_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateway_nodes", value)


if not MYPY:
    class VpcV2ExternalSubnetActiveGatewayNodeArgsDict(TypedDict):
        node_id: NotRequired[pulumi.Input[str]]
        node_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict']]]]
elif False:
    VpcV2ExternalSubnetActiveGatewayNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetActiveGatewayNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 node_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]] = None):
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if node_ip_addresses is not None:
            pulumi.set(__self__, "node_ip_addresses", node_ip_addresses)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter(name="nodeIpAddresses")
    def node_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]:
        return pulumi.get(self, "node_ip_addresses")

    @node_ip_addresses.setter
    def node_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgs']]]]):
        pulumi.set(self, "node_ip_addresses", value)


if not MYPY:
    class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict']]]]
elif False:
    VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetActiveGatewayNodeNodeIpAddressIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternalSubnetExternalIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv4ArgsDict']]]]
        """
        Reference to address configuration
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv6ArgsDict']]]]
        """
        Reference to address configuration
        """
elif False:
    VpcV2ExternalSubnetExternalIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetExternalIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv4Args']]] ipv4s: Reference to address configuration
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv6Args']]] ipv6s: Reference to address configuration
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv4Args']]]]:
        """
        Reference to address configuration
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv6Args']]]]:
        """
        Reference to address configuration
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternalSubnetExternalIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VpcV2ExternalSubnetExternalIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternalSubnetExternalIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetExternalIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternalSubnetExternalIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternalSubnetExternalIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternalSubnetExternalIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternallyRoutablePrefixArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4ArgsDict']]]]
        """
        IP V4 Configuration
        - `ipv4.ip`: (Required) Reference to address configuration
        - `ipv4.prefix_length`: (Required) The prefix length of the network
        """
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6ArgsDict']]]]
        """
        IP V6 Configuration
        - `ipv6.ip`: (Required) Reference to address configuration
        - `ipv6.prefix_length`: (Required) The prefix length of the network
        """
elif False:
    VpcV2ExternallyRoutablePrefixArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternallyRoutablePrefixArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6Args']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4Args']]] ipv4s: IP V4 Configuration
               - `ipv4.ip`: (Required) Reference to address configuration
               - `ipv4.prefix_length`: (Required) The prefix length of the network
        :param pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6Args']]] ipv6s: IP V6 Configuration
               - `ipv6.ip`: (Required) Reference to address configuration
               - `ipv6.prefix_length`: (Required) The prefix length of the network
        """
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4Args']]]]:
        """
        IP V4 Configuration
        - `ipv4.ip`: (Required) Reference to address configuration
        - `ipv4.prefix_length`: (Required) The prefix length of the network
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6Args']]]]:
        """
        IP V6 Configuration
        - `ipv6.ip`: (Required) Reference to address configuration
        - `ipv6.prefix_length`: (Required) The prefix length of the network
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VpcV2ExternallyRoutablePrefixIpv4ArgsDict(TypedDict):
        prefix_length: pulumi.Input[int]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4IpArgsDict']]]]
elif False:
    VpcV2ExternallyRoutablePrefixIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternallyRoutablePrefixIpv4Args:
    def __init__(__self__, *,
                 prefix_length: pulumi.Input[int],
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4IpArgs']]]] = None):
        pulumi.set(__self__, "prefix_length", prefix_length)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv4IpArgs']]]]):
        pulumi.set(self, "ips", value)


if not MYPY:
    class VpcV2ExternallyRoutablePrefixIpv4IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternallyRoutablePrefixIpv4IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternallyRoutablePrefixIpv4IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2ExternallyRoutablePrefixIpv6ArgsDict(TypedDict):
        prefix_length: pulumi.Input[int]
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6IpArgsDict']]]]
elif False:
    VpcV2ExternallyRoutablePrefixIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternallyRoutablePrefixIpv6Args:
    def __init__(__self__, *,
                 prefix_length: pulumi.Input[int],
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6IpArgs']]]] = None):
        pulumi.set(__self__, "prefix_length", prefix_length)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> pulumi.Input[int]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: pulumi.Input[int]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6IpArgs']]]]:
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2ExternallyRoutablePrefixIpv6IpArgs']]]]):
        pulumi.set(self, "ips", value)


if not MYPY:
    class VpcV2ExternallyRoutablePrefixIpv6IpArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2ExternallyRoutablePrefixIpv6IpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2ExternallyRoutablePrefixIpv6IpArgs:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2LinkArgsDict(TypedDict):
        href: NotRequired[pulumi.Input[str]]
        rel: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2LinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2LinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


if not MYPY:
    class VpcV2MetadataArgsDict(TypedDict):
        category_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]
        owner_reference_id: NotRequired[pulumi.Input[str]]
        owner_user_name: NotRequired[pulumi.Input[str]]
        project_name: NotRequired[pulumi.Input[str]]
        project_reference_id: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2MetadataArgs:
    def __init__(__self__, *,
                 category_ids: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]] = None,
                 owner_reference_id: Optional[pulumi.Input[str]] = None,
                 owner_user_name: Optional[pulumi.Input[str]] = None,
                 project_name: Optional[pulumi.Input[str]] = None,
                 project_reference_id: Optional[pulumi.Input[str]] = None):
        if category_ids is not None:
            pulumi.set(__self__, "category_ids", category_ids)
        if owner_reference_id is not None:
            pulumi.set(__self__, "owner_reference_id", owner_reference_id)
        if owner_user_name is not None:
            pulumi.set(__self__, "owner_user_name", owner_user_name)
        if project_name is not None:
            pulumi.set(__self__, "project_name", project_name)
        if project_reference_id is not None:
            pulumi.set(__self__, "project_reference_id", project_reference_id)

    @property
    @pulumi.getter(name="categoryIds")
    def category_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]:
        return pulumi.get(self, "category_ids")

    @category_ids.setter
    def category_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Sequence[Any]]]]]):
        pulumi.set(self, "category_ids", value)

    @property
    @pulumi.getter(name="ownerReferenceId")
    def owner_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_reference_id")

    @owner_reference_id.setter
    def owner_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_reference_id", value)

    @property
    @pulumi.getter(name="ownerUserName")
    def owner_user_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "owner_user_name")

    @owner_user_name.setter
    def owner_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner_user_name", value)

    @property
    @pulumi.getter(name="projectName")
    def project_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_name")

    @project_name.setter
    def project_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_name", value)

    @property
    @pulumi.getter(name="projectReferenceId")
    def project_reference_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_reference_id")

    @project_reference_id.setter
    def project_reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_reference_id", value)


if not MYPY:
    class VpcV2SnatIpArgsDict(TypedDict):
        ipv4s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv4ArgsDict']]]]
        ipv6s: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv6ArgsDict']]]]
elif False:
    VpcV2SnatIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2SnatIpArgs:
    def __init__(__self__, *,
                 ipv4s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv4Args']]]] = None,
                 ipv6s: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv6Args']]]] = None):
        if ipv4s is not None:
            pulumi.set(__self__, "ipv4s", ipv4s)
        if ipv6s is not None:
            pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def ipv4s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv4Args']]]]:
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv4Args']]]]):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv6Args']]]]:
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcV2SnatIpIpv6Args']]]]):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class VpcV2SnatIpIpv4ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2SnatIpIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2SnatIpIpv4Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpcV2SnatIpIpv6ArgsDict(TypedDict):
        prefix_length: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    VpcV2SnatIpIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcV2SnatIpIpv6Args:
    def __init__(__self__, *,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        if prefix_length is not None:
            pulumi.set(__self__, "prefix_length", prefix_length)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAccessControlPoliciesMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name (Default value: project)(Required).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetAccessControlPoliciesMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessControlPoliciesMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str kind: - The kind name (Default value: project)(Required).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetAccessControlPolicyCategoryArgsDict(TypedDict):
        name: str
        """
        - the name(Optional).
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetAccessControlPolicyCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAccessControlPolicyCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name(Optional).
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAddressGroupV2Ipv4AddressArgsDict(TypedDict):
        prefix_length: int
        """
        The prefix length of the network to which this host IPv4 address belongs.
        """
        value: str
        """
        ip of address
        """
elif False:
    GetAddressGroupV2Ipv4AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAddressGroupV2Ipv4AddressArgs:
    def __init__(__self__, *,
                 prefix_length: int,
                 value: str):
        """
        :param int prefix_length: The prefix length of the network to which this host IPv4 address belongs.
        :param str value: ip of address
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        The prefix length of the network to which this host IPv4 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: int):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        ip of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetAddressGroupsMetadataArgsDict(TypedDict):
        filter: str
        """
        (Optional) Filter in FIQL Syntax
        """
        kind: str
        length: int
        """
        (Optional) Integer
        """
        offset: int
        """
        (Optional) Integer
        """
        sort_attribute: str
        """
        (Optional) attribute to sort
        """
        sort_order: str
        """
        (Optional) order of sorting
        """
elif False:
    GetAddressGroupsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAddressGroupsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str filter: (Optional) Filter in FIQL Syntax
        :param int length: (Optional) Integer
        :param int offset: (Optional) Integer
        :param str sort_attribute: (Optional) attribute to sort
        :param str sort_order: (Optional) order of sorting
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        (Optional) Filter in FIQL Syntax
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        (Optional) Integer
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        (Optional) Integer
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        """
        (Optional) attribute to sort
        """
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        """
        (Optional) order of sorting
        """
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetAssertHelperCheckArgsDict(TypedDict):
        condition: bool
        error_message: str
elif False:
    GetAssertHelperCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAssertHelperCheckArgs:
    def __init__(__self__, *,
                 condition: bool,
                 error_message: str):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def condition(self) -> bool:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: bool):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: str):
        pulumi.set(self, "error_message", value)


if not MYPY:
    class GetClusterCategoryArgsDict(TypedDict):
        name: str
        """
        - the key name.
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetClusterCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetClusterCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the key name.
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetFloatingIpsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name (Default value: project).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
        total_matches: int
elif False:
    GetFloatingIpsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFloatingIpsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str,
                 total_matches: int):
        """
        :param str kind: - The kind name (Default value: project).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)
        pulumi.set(__self__, "total_matches", total_matches)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name (Default value: project).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)

    @property
    @pulumi.getter(name="totalMatches")
    def total_matches(self) -> int:
        return pulumi.get(self, "total_matches")

    @total_matches.setter
    def total_matches(self, value: int):
        pulumi.set(self, "total_matches", value)


if not MYPY:
    class GetFoundationCentralClusterDetailsClusterStatusArgsDict(TypedDict):
        aggregate_percent_complete: float
        """
        Overall progress percentage including imaging and cluster creation.
        """
        cluster_creation_started: bool
        """
        Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
        """
        cluster_progress_details: Sequence['GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgsDict']
        """
        Denotes the progress status of cluster creation.
        """
        current_foundation_ip: str
        """
        Current IP address of the coordinating foundation node.
        """
        foundation_session_id: str
        """
        Foundation session id for cluster creation.
        """
        imaging_stopped: bool
        """
        Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        """
        intent_picked_up: bool
        """
        Denotes whether the remote nodes has picked up the cluster creation intent.
        """
        node_progress_details: Sequence['GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgsDict']
        """
        List of progress details of each node.
        """
elif False:
    GetFoundationCentralClusterDetailsClusterStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralClusterDetailsClusterStatusArgs:
    def __init__(__self__, *,
                 aggregate_percent_complete: float,
                 cluster_creation_started: bool,
                 cluster_progress_details: Sequence['GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs'],
                 current_foundation_ip: str,
                 foundation_session_id: str,
                 imaging_stopped: bool,
                 intent_picked_up: bool,
                 node_progress_details: Sequence['GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs']):
        """
        :param float aggregate_percent_complete: Overall progress percentage including imaging and cluster creation.
        :param bool cluster_creation_started: Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
        :param Sequence['GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs'] cluster_progress_details: Denotes the progress status of cluster creation.
        :param str current_foundation_ip: Current IP address of the coordinating foundation node.
        :param str foundation_session_id: Foundation session id for cluster creation.
        :param bool imaging_stopped: Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        :param bool intent_picked_up: Denotes whether the remote nodes has picked up the cluster creation intent.
        :param Sequence['GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs'] node_progress_details: List of progress details of each node.
        """
        pulumi.set(__self__, "aggregate_percent_complete", aggregate_percent_complete)
        pulumi.set(__self__, "cluster_creation_started", cluster_creation_started)
        pulumi.set(__self__, "cluster_progress_details", cluster_progress_details)
        pulumi.set(__self__, "current_foundation_ip", current_foundation_ip)
        pulumi.set(__self__, "foundation_session_id", foundation_session_id)
        pulumi.set(__self__, "imaging_stopped", imaging_stopped)
        pulumi.set(__self__, "intent_picked_up", intent_picked_up)
        pulumi.set(__self__, "node_progress_details", node_progress_details)

    @property
    @pulumi.getter(name="aggregatePercentComplete")
    def aggregate_percent_complete(self) -> float:
        """
        Overall progress percentage including imaging and cluster creation.
        """
        return pulumi.get(self, "aggregate_percent_complete")

    @aggregate_percent_complete.setter
    def aggregate_percent_complete(self, value: float):
        pulumi.set(self, "aggregate_percent_complete", value)

    @property
    @pulumi.getter(name="clusterCreationStarted")
    def cluster_creation_started(self) -> bool:
        """
        Denotes whether cluster creation has started in a phoenix workflow. For foundation workflows, this field will be same as intent_picked_up.
        """
        return pulumi.get(self, "cluster_creation_started")

    @cluster_creation_started.setter
    def cluster_creation_started(self, value: bool):
        pulumi.set(self, "cluster_creation_started", value)

    @property
    @pulumi.getter(name="clusterProgressDetails")
    def cluster_progress_details(self) -> Sequence['GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs']:
        """
        Denotes the progress status of cluster creation.
        """
        return pulumi.get(self, "cluster_progress_details")

    @cluster_progress_details.setter
    def cluster_progress_details(self, value: Sequence['GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs']):
        pulumi.set(self, "cluster_progress_details", value)

    @property
    @pulumi.getter(name="currentFoundationIp")
    def current_foundation_ip(self) -> str:
        """
        Current IP address of the coordinating foundation node.
        """
        return pulumi.get(self, "current_foundation_ip")

    @current_foundation_ip.setter
    def current_foundation_ip(self, value: str):
        pulumi.set(self, "current_foundation_ip", value)

    @property
    @pulumi.getter(name="foundationSessionId")
    def foundation_session_id(self) -> str:
        """
        Foundation session id for cluster creation.
        """
        return pulumi.get(self, "foundation_session_id")

    @foundation_session_id.setter
    def foundation_session_id(self, value: str):
        pulumi.set(self, "foundation_session_id", value)

    @property
    @pulumi.getter(name="imagingStopped")
    def imaging_stopped(self) -> bool:
        """
        Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        """
        return pulumi.get(self, "imaging_stopped")

    @imaging_stopped.setter
    def imaging_stopped(self, value: bool):
        pulumi.set(self, "imaging_stopped", value)

    @property
    @pulumi.getter(name="intentPickedUp")
    def intent_picked_up(self) -> bool:
        """
        Denotes whether the remote nodes has picked up the cluster creation intent.
        """
        return pulumi.get(self, "intent_picked_up")

    @intent_picked_up.setter
    def intent_picked_up(self, value: bool):
        pulumi.set(self, "intent_picked_up", value)

    @property
    @pulumi.getter(name="nodeProgressDetails")
    def node_progress_details(self) -> Sequence['GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs']:
        """
        List of progress details of each node.
        """
        return pulumi.get(self, "node_progress_details")

    @node_progress_details.setter
    def node_progress_details(self, value: Sequence['GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs']):
        pulumi.set(self, "node_progress_details", value)


if not MYPY:
    class GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgsDict(TypedDict):
        cluster_name: str
        """
        Cluster name.
        """
        message_lists: Sequence[str]
        """
        List of messages for the client based on process state.
        """
        percent_complete: float
        """
        Percent completion of cluster creation process.
        """
        status: str
        """
        Current status of cluster creation process.
        """
elif False:
    GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralClusterDetailsClusterStatusClusterProgressDetailArgs:
    def __init__(__self__, *,
                 cluster_name: str,
                 message_lists: Sequence[str],
                 percent_complete: float,
                 status: str):
        """
        :param str cluster_name: Cluster name.
        :param Sequence[str] message_lists: List of messages for the client based on process state.
        :param float percent_complete: Percent completion of cluster creation process.
        :param str status: Current status of cluster creation process.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "message_lists", message_lists)
        pulumi.set(__self__, "percent_complete", percent_complete)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: str):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="messageLists")
    def message_lists(self) -> Sequence[str]:
        """
        List of messages for the client based on process state.
        """
        return pulumi.get(self, "message_lists")

    @message_lists.setter
    def message_lists(self, value: Sequence[str]):
        pulumi.set(self, "message_lists", value)

    @property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> float:
        """
        Percent completion of cluster creation process.
        """
        return pulumi.get(self, "percent_complete")

    @percent_complete.setter
    def percent_complete(self, value: float):
        pulumi.set(self, "percent_complete", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of cluster creation process.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgsDict(TypedDict):
        imaged_node_uuid: str
        """
        UUID of the node.
        """
        imaging_stopped: bool
        """
        Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        """
        intent_picked_up: bool
        """
        Denotes whether the remote nodes has picked up the cluster creation intent.
        """
        message_lists: Sequence[str]
        """
        List of messages for the client based on process state.
        """
        percent_complete: float
        """
        Percent completion of cluster creation process.
        """
        status: str
        """
        Current status of cluster creation process.
        """
elif False:
    GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralClusterDetailsClusterStatusNodeProgressDetailArgs:
    def __init__(__self__, *,
                 imaged_node_uuid: str,
                 imaging_stopped: bool,
                 intent_picked_up: bool,
                 message_lists: Sequence[str],
                 percent_complete: float,
                 status: str):
        """
        :param str imaged_node_uuid: UUID of the node.
        :param bool imaging_stopped: Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        :param bool intent_picked_up: Denotes whether the remote nodes has picked up the cluster creation intent.
        :param Sequence[str] message_lists: List of messages for the client based on process state.
        :param float percent_complete: Percent completion of cluster creation process.
        :param str status: Current status of cluster creation process.
        """
        pulumi.set(__self__, "imaged_node_uuid", imaged_node_uuid)
        pulumi.set(__self__, "imaging_stopped", imaging_stopped)
        pulumi.set(__self__, "intent_picked_up", intent_picked_up)
        pulumi.set(__self__, "message_lists", message_lists)
        pulumi.set(__self__, "percent_complete", percent_complete)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="imagedNodeUuid")
    def imaged_node_uuid(self) -> str:
        """
        UUID of the node.
        """
        return pulumi.get(self, "imaged_node_uuid")

    @imaged_node_uuid.setter
    def imaged_node_uuid(self, value: str):
        pulumi.set(self, "imaged_node_uuid", value)

    @property
    @pulumi.getter(name="imagingStopped")
    def imaging_stopped(self) -> bool:
        """
        Describes whether imaging has stopped. True indicates that process has stopped. False indicates that process is still going on. This field will only be used by phoenix nodes to update FC.
        """
        return pulumi.get(self, "imaging_stopped")

    @imaging_stopped.setter
    def imaging_stopped(self, value: bool):
        pulumi.set(self, "imaging_stopped", value)

    @property
    @pulumi.getter(name="intentPickedUp")
    def intent_picked_up(self) -> bool:
        """
        Denotes whether the remote nodes has picked up the cluster creation intent.
        """
        return pulumi.get(self, "intent_picked_up")

    @intent_picked_up.setter
    def intent_picked_up(self, value: bool):
        pulumi.set(self, "intent_picked_up", value)

    @property
    @pulumi.getter(name="messageLists")
    def message_lists(self) -> Sequence[str]:
        """
        List of messages for the client based on process state.
        """
        return pulumi.get(self, "message_lists")

    @message_lists.setter
    def message_lists(self, value: Sequence[str]):
        pulumi.set(self, "message_lists", value)

    @property
    @pulumi.getter(name="percentComplete")
    def percent_complete(self) -> float:
        """
        Percent completion of cluster creation process.
        """
        return pulumi.get(self, "percent_complete")

    @percent_complete.setter
    def percent_complete(self, value: float):
        pulumi.set(self, "percent_complete", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of cluster creation process.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetFoundationCentralClusterDetailsCommonNetworkSettingsArgsDict(TypedDict):
        cvm_dns_servers: Sequence[str]
        """
        List of dns servers for the cvms in the cluster.
        """
        cvm_ntp_servers: Sequence[str]
        """
        List of ntp servers for the cvms in the cluster.
        """
        hypervisor_dns_servers: Sequence[str]
        """
        List of dns servers for the hypervisors in the cluster.
        """
        hypervisor_ntp_servers: Sequence[str]
        """
        List of ntp servers for the hypervisors in the cluster.
        """
elif False:
    GetFoundationCentralClusterDetailsCommonNetworkSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralClusterDetailsCommonNetworkSettingsArgs:
    def __init__(__self__, *,
                 cvm_dns_servers: Sequence[str],
                 cvm_ntp_servers: Sequence[str],
                 hypervisor_dns_servers: Sequence[str],
                 hypervisor_ntp_servers: Sequence[str]):
        """
        :param Sequence[str] cvm_dns_servers: List of dns servers for the cvms in the cluster.
        :param Sequence[str] cvm_ntp_servers: List of ntp servers for the cvms in the cluster.
        :param Sequence[str] hypervisor_dns_servers: List of dns servers for the hypervisors in the cluster.
        :param Sequence[str] hypervisor_ntp_servers: List of ntp servers for the hypervisors in the cluster.
        """
        pulumi.set(__self__, "cvm_dns_servers", cvm_dns_servers)
        pulumi.set(__self__, "cvm_ntp_servers", cvm_ntp_servers)
        pulumi.set(__self__, "hypervisor_dns_servers", hypervisor_dns_servers)
        pulumi.set(__self__, "hypervisor_ntp_servers", hypervisor_ntp_servers)

    @property
    @pulumi.getter(name="cvmDnsServers")
    def cvm_dns_servers(self) -> Sequence[str]:
        """
        List of dns servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_dns_servers")

    @cvm_dns_servers.setter
    def cvm_dns_servers(self, value: Sequence[str]):
        pulumi.set(self, "cvm_dns_servers", value)

    @property
    @pulumi.getter(name="cvmNtpServers")
    def cvm_ntp_servers(self) -> Sequence[str]:
        """
        List of ntp servers for the cvms in the cluster.
        """
        return pulumi.get(self, "cvm_ntp_servers")

    @cvm_ntp_servers.setter
    def cvm_ntp_servers(self, value: Sequence[str]):
        pulumi.set(self, "cvm_ntp_servers", value)

    @property
    @pulumi.getter(name="hypervisorDnsServers")
    def hypervisor_dns_servers(self) -> Sequence[str]:
        """
        List of dns servers for the hypervisors in the cluster.
        """
        return pulumi.get(self, "hypervisor_dns_servers")

    @hypervisor_dns_servers.setter
    def hypervisor_dns_servers(self, value: Sequence[str]):
        pulumi.set(self, "hypervisor_dns_servers", value)

    @property
    @pulumi.getter(name="hypervisorNtpServers")
    def hypervisor_ntp_servers(self) -> Sequence[str]:
        """
        List of ntp servers for the hypervisors in the cluster.
        """
        return pulumi.get(self, "hypervisor_ntp_servers")

    @hypervisor_ntp_servers.setter
    def hypervisor_ntp_servers(self, value: Sequence[str]):
        pulumi.set(self, "hypervisor_ntp_servers", value)


if not MYPY:
    class GetFoundationCentralImagedClustersListFiltersArgsDict(TypedDict):
        archived: NotRequired[bool]
        """
        True if the cluster creation request is archived, False otherwise
        """
elif False:
    GetFoundationCentralImagedClustersListFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralImagedClustersListFiltersArgs:
    def __init__(__self__, *,
                 archived: Optional[bool] = None):
        """
        :param bool archived: True if the cluster creation request is archived, False otherwise
        """
        if archived is not None:
            pulumi.set(__self__, "archived", archived)

    @property
    @pulumi.getter
    def archived(self) -> Optional[bool]:
        """
        True if the cluster creation request is archived, False otherwise
        """
        return pulumi.get(self, "archived")

    @archived.setter
    def archived(self, value: Optional[bool]):
        pulumi.set(self, "archived", value)


if not MYPY:
    class GetFoundationCentralImagedNodesListFiltersArgsDict(TypedDict):
        node_state: NotRequired[str]
        """
        Specifies whether the node is discovering, available or unavailable for cluster creation.
        """
elif False:
    GetFoundationCentralImagedNodesListFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralImagedNodesListFiltersArgs:
    def __init__(__self__, *,
                 node_state: Optional[str] = None):
        """
        :param str node_state: Specifies whether the node is discovering, available or unavailable for cluster creation.
        """
        if node_state is not None:
            pulumi.set(__self__, "node_state", node_state)

    @property
    @pulumi.getter(name="nodeState")
    def node_state(self) -> Optional[str]:
        """
        Specifies whether the node is discovering, available or unavailable for cluster creation.
        """
        return pulumi.get(self, "node_state")

    @node_state.setter
    def node_state(self, value: Optional[str]):
        pulumi.set(self, "node_state", value)


if not MYPY:
    class GetFoundationCentralListApiKeysMetadataArgsDict(TypedDict):
        length: int
        """
        The number of records retrieved.
        """
        offset: int
        """
        Offset from the start of the object list.
        """
        total_matches: int
        """
        Total matches found.
        """
elif False:
    GetFoundationCentralListApiKeysMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFoundationCentralListApiKeysMetadataArgs:
    def __init__(__self__, *,
                 length: int,
                 offset: int,
                 total_matches: int):
        """
        :param int length: The number of records retrieved.
        :param int offset: Offset from the start of the object list.
        :param int total_matches: Total matches found.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "total_matches", total_matches)

    @property
    @pulumi.getter
    def length(self) -> int:
        """
        The number of records retrieved.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        """
        Offset from the start of the object list.
        """
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="totalMatches")
    def total_matches(self) -> int:
        """
        Total matches found.
        """
        return pulumi.get(self, "total_matches")

    @total_matches.setter
    def total_matches(self, value: int):
        pulumi.set(self, "total_matches", value)


if not MYPY:
    class GetHostCategoryArgsDict(TypedDict):
        name: str
        """
        - the key name.
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetHostCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHostCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the key name.
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the key name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetImageCategoryArgsDict(TypedDict):
        name: str
        """
        - the name.
        """
        value: str
elif False:
    GetImageCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImageCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbCloneFilterArgsDict(TypedDict):
        any_status: NotRequired[str]
        """
        Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        """
        detailed: NotRequired[str]
        """
        Load entities with complete details. Default is false
        """
        load_dbserver_cluster: NotRequired[str]
        """
        Load cluster info. Default is false
        """
        timezone: NotRequired[str]
        """
        Default is UTC
        """
elif False:
    GetNdbCloneFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbCloneFilterArgs:
    def __init__(__self__, *,
                 any_status: Optional[str] = None,
                 detailed: Optional[str] = None,
                 load_dbserver_cluster: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str any_status: Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        :param str detailed: Load entities with complete details. Default is false
        :param str load_dbserver_cluster: Load cluster info. Default is false
        :param str timezone: Default is UTC
        """
        if any_status is not None:
            pulumi.set(__self__, "any_status", any_status)
        if detailed is not None:
            pulumi.set(__self__, "detailed", detailed)
        if load_dbserver_cluster is not None:
            pulumi.set(__self__, "load_dbserver_cluster", load_dbserver_cluster)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="anyStatus")
    def any_status(self) -> Optional[str]:
        """
        Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        """
        return pulumi.get(self, "any_status")

    @any_status.setter
    def any_status(self, value: Optional[str]):
        pulumi.set(self, "any_status", value)

    @property
    @pulumi.getter
    def detailed(self) -> Optional[str]:
        """
        Load entities with complete details. Default is false
        """
        return pulumi.get(self, "detailed")

    @detailed.setter
    def detailed(self, value: Optional[str]):
        pulumi.set(self, "detailed", value)

    @property
    @pulumi.getter(name="loadDbserverCluster")
    def load_dbserver_cluster(self) -> Optional[str]:
        """
        Load cluster info. Default is false
        """
        return pulumi.get(self, "load_dbserver_cluster")

    @load_dbserver_cluster.setter
    def load_dbserver_cluster(self, value: Optional[str]):
        pulumi.set(self, "load_dbserver_cluster", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Default is UTC
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[str]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class GetNdbCloneTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbCloneTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbCloneTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbClonesFilterArgsDict(TypedDict):
        any_status: NotRequired[str]
        """
        Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        """
        detailed: NotRequired[str]
        """
        Load entities with complete details. Default is false
        """
        load_dbserver_cluster: NotRequired[str]
        """
        Load cluster info. Default is false
        """
        order_by_dbserver_cluster: NotRequired[str]
        """
        Sorted by dbserver cluster. Default is false
        """
        order_by_dbserver_logical_cluster: NotRequired[str]
        """
        Sorted by dbserver logical cluster.  Default is false
        """
        timezone: NotRequired[str]
        """
        Default is UTC
        """
elif False:
    GetNdbClonesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbClonesFilterArgs:
    def __init__(__self__, *,
                 any_status: Optional[str] = None,
                 detailed: Optional[str] = None,
                 load_dbserver_cluster: Optional[str] = None,
                 order_by_dbserver_cluster: Optional[str] = None,
                 order_by_dbserver_logical_cluster: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str any_status: Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        :param str detailed: Load entities with complete details. Default is false
        :param str load_dbserver_cluster: Load cluster info. Default is false
        :param str order_by_dbserver_cluster: Sorted by dbserver cluster. Default is false
        :param str order_by_dbserver_logical_cluster: Sorted by dbserver logical cluster.  Default is false
        :param str timezone: Default is UTC
        """
        if any_status is not None:
            pulumi.set(__self__, "any_status", any_status)
        if detailed is not None:
            pulumi.set(__self__, "detailed", detailed)
        if load_dbserver_cluster is not None:
            pulumi.set(__self__, "load_dbserver_cluster", load_dbserver_cluster)
        if order_by_dbserver_cluster is not None:
            pulumi.set(__self__, "order_by_dbserver_cluster", order_by_dbserver_cluster)
        if order_by_dbserver_logical_cluster is not None:
            pulumi.set(__self__, "order_by_dbserver_logical_cluster", order_by_dbserver_logical_cluster)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="anyStatus")
    def any_status(self) -> Optional[str]:
        """
        Get entity(s) if it satisfies query criteria irrespective of status (retrieve even deleted). Default is false
        """
        return pulumi.get(self, "any_status")

    @any_status.setter
    def any_status(self, value: Optional[str]):
        pulumi.set(self, "any_status", value)

    @property
    @pulumi.getter
    def detailed(self) -> Optional[str]:
        """
        Load entities with complete details. Default is false
        """
        return pulumi.get(self, "detailed")

    @detailed.setter
    def detailed(self, value: Optional[str]):
        pulumi.set(self, "detailed", value)

    @property
    @pulumi.getter(name="loadDbserverCluster")
    def load_dbserver_cluster(self) -> Optional[str]:
        """
        Load cluster info. Default is false
        """
        return pulumi.get(self, "load_dbserver_cluster")

    @load_dbserver_cluster.setter
    def load_dbserver_cluster(self, value: Optional[str]):
        pulumi.set(self, "load_dbserver_cluster", value)

    @property
    @pulumi.getter(name="orderByDbserverCluster")
    def order_by_dbserver_cluster(self) -> Optional[str]:
        """
        Sorted by dbserver cluster. Default is false
        """
        return pulumi.get(self, "order_by_dbserver_cluster")

    @order_by_dbserver_cluster.setter
    def order_by_dbserver_cluster(self, value: Optional[str]):
        pulumi.set(self, "order_by_dbserver_cluster", value)

    @property
    @pulumi.getter(name="orderByDbserverLogicalCluster")
    def order_by_dbserver_logical_cluster(self) -> Optional[str]:
        """
        Sorted by dbserver logical cluster.  Default is false
        """
        return pulumi.get(self, "order_by_dbserver_logical_cluster")

    @order_by_dbserver_logical_cluster.setter
    def order_by_dbserver_logical_cluster(self, value: Optional[str]):
        pulumi.set(self, "order_by_dbserver_logical_cluster", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Default is UTC
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[str]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class GetNdbDatabaseTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbDatabaseTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbDatabaseTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbDbserverTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbDbserverTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbDbserverTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbMaintenanceWindowTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbMaintenanceWindowTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbMaintenanceWindowTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbSnapshotFilterArgsDict(TypedDict):
        load_replicated_child_snapshots: NotRequired[str]
        """
        load child snapshots. Default is false
        """
        timezone: NotRequired[str]
        """
        Default is UTC
        """
elif False:
    GetNdbSnapshotFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbSnapshotFilterArgs:
    def __init__(__self__, *,
                 load_replicated_child_snapshots: Optional[str] = None,
                 timezone: Optional[str] = None):
        """
        :param str load_replicated_child_snapshots: load child snapshots. Default is false
        :param str timezone: Default is UTC
        """
        if load_replicated_child_snapshots is not None:
            pulumi.set(__self__, "load_replicated_child_snapshots", load_replicated_child_snapshots)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="loadReplicatedChildSnapshots")
    def load_replicated_child_snapshots(self) -> Optional[str]:
        """
        load child snapshots. Default is false
        """
        return pulumi.get(self, "load_replicated_child_snapshots")

    @load_replicated_child_snapshots.setter
    def load_replicated_child_snapshots(self, value: Optional[str]):
        pulumi.set(self, "load_replicated_child_snapshots", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Default is UTC
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[str]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class GetNdbSnapshotTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbSnapshotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbSnapshotTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNdbSnapshotsFilterArgsDict(TypedDict):
        time_machine_id: NotRequired[str]
        """
        Fetches all the snapshots for a given time machine
        """
elif False:
    GetNdbSnapshotsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbSnapshotsFilterArgs:
    def __init__(__self__, *,
                 time_machine_id: Optional[str] = None):
        """
        :param str time_machine_id: Fetches all the snapshots for a given time machine
        """
        if time_machine_id is not None:
            pulumi.set(__self__, "time_machine_id", time_machine_id)

    @property
    @pulumi.getter(name="timeMachineId")
    def time_machine_id(self) -> Optional[str]:
        """
        Fetches all the snapshots for a given time machine
        """
        return pulumi.get(self, "time_machine_id")

    @time_machine_id.setter
    def time_machine_id(self, value: Optional[str]):
        pulumi.set(self, "time_machine_id", value)


if not MYPY:
    class GetNdbTimeMachineTagArgsDict(TypedDict):
        entity_id: str
        entity_type: str
        tag_id: str
        tag_name: str
        value: str
elif False:
    GetNdbTimeMachineTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNdbTimeMachineTagArgs:
    def __init__(__self__, *,
                 entity_id: str,
                 entity_type: str,
                 tag_id: str,
                 tag_name: str,
                 value: str):
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "tag_id", tag_id)
        pulumi.set(__self__, "tag_name", tag_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> str:
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: str):
        pulumi.set(self, "entity_id", value)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: str):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="tagId")
    def tag_id(self) -> str:
        return pulumi.get(self, "tag_id")

    @tag_id.setter
    def tag_id(self, value: str):
        pulumi.set(self, "tag_id", value)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        return pulumi.get(self, "tag_name")

    @tag_name.setter
    def tag_name(self, value: str):
        pulumi.set(self, "tag_name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetNetworkSecurityRuleCategoryArgsDict(TypedDict):
        name: str
        """
        - the name.
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetNetworkSecurityRuleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetNetworkSecurityRuleCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name.
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetPbrsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name (Default value: project).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
        total_matches: int
elif False:
    GetPbrsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPbrsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str,
                 total_matches: int):
        """
        :param str kind: - The kind name (Default value: project).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)
        pulumi.set(__self__, "total_matches", total_matches)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name (Default value: project).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)

    @property
    @pulumi.getter(name="totalMatches")
    def total_matches(self) -> int:
        return pulumi.get(self, "total_matches")

    @total_matches.setter
    def total_matches(self, value: int):
        pulumi.set(self, "total_matches", value)


if not MYPY:
    class GetPermissionCategoryArgsDict(TypedDict):
        name: str
        """
        the name.
        """
        value: str
        """
        value of the key.
        """
elif False:
    GetPermissionCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: the name.
        :param str value: value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetPermissionsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        (Required) The kind name (Default value: `project`).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetPermissionsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPermissionsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str kind: (Required) The kind name (Default value: `project`).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetProjectCategoryArgsDict(TypedDict):
        name: str
        """
        the name.
        """
        value: str
        """
        value of the key.
        """
elif False:
    GetProjectCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: the name.
        :param str value: value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetProjectExternalUserGroupReferenceListArgsDict(TypedDict):
        kind: str
        """
        (Required) The kind name (Default value: `project`).
        """
        name: str
        """
        the name.
        """
        uuid: str
        """
        (Required) the UUID.
        """
elif False:
    GetProjectExternalUserGroupReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectExternalUserGroupReferenceListArgs:
    def __init__(__self__, *,
                 kind: str,
                 name: str,
                 uuid: str):
        """
        :param str kind: (Required) The kind name (Default value: `project`).
        :param str name: the name.
        :param str uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: str):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetProjectSubnetReferenceListArgsDict(TypedDict):
        kind: str
        """
        (Required) The kind name (Default value: `project`).
        """
        name: str
        """
        the name.
        """
        uuid: str
        """
        (Required) the UUID.
        """
elif False:
    GetProjectSubnetReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectSubnetReferenceListArgs:
    def __init__(__self__, *,
                 kind: str,
                 name: str,
                 uuid: str):
        """
        :param str kind: (Required) The kind name (Default value: `project`).
        :param str name: the name.
        :param str uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: str):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetProjectUserReferenceListArgsDict(TypedDict):
        kind: str
        """
        (Required) The kind name (Default value: `project`).
        """
        name: str
        """
        the name.
        """
        uuid: str
        """
        (Required) the UUID.
        """
elif False:
    GetProjectUserReferenceListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectUserReferenceListArgs:
    def __init__(__self__, *,
                 kind: str,
                 name: str,
                 uuid: str):
        """
        :param str kind: (Required) The kind name (Default value: `project`).
        :param str name: the name.
        :param str uuid: (Required) the UUID.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        (Required) The kind name (Default value: `project`).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uuid(self) -> str:
        """
        (Required) the UUID.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: str):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetProtectionRuleCategoryArgsDict(TypedDict):
        name: str
        """
        (Optional) the name.
        """
        value: str
        """
        value of the key.
        """
elif False:
    GetProtectionRuleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProtectionRuleCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: (Optional) the name.
        :param str value: value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Optional) the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRecoveryPlanCategoryArgsDict(TypedDict):
        name: str
        """
        (Optional) the name.
        """
        value: str
        """
        value of the key.
        """
elif False:
    GetRecoveryPlanCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecoveryPlanCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: (Optional) the name.
        :param str value: value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Optional) the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRoleCategoryArgsDict(TypedDict):
        name: str
        """
        - the name(Optional).
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetRoleCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRoleCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name(Optional).
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRolesMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name (Default value: project)(Required).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetRolesMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRolesMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str kind: - The kind name (Default value: project)(Required).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name (Default value: project)(Required).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetServiceGroupsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetServiceGroupsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceGroupsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetSubnetAdditionalFilterArgsDict(TypedDict):
        name: str
        """
        - the name(Optional).
        """
        values: Sequence[str]
elif False:
    GetSubnetAdditionalFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetAdditionalFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        :param str name: - the name(Optional).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSubnetCategoryArgsDict(TypedDict):
        name: str
        """
        - the name(Optional).
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetSubnetCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name(Optional).
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSubnetV2ReservedIpAddressArgsDict(TypedDict):
        prefix_length: int
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        value: str
        """
        value of address
        """
elif False:
    GetSubnetV2ReservedIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetV2ReservedIpAddressArgs:
    def __init__(__self__, *,
                 prefix_length: int,
                 value: str):
        """
        :param int prefix_length: The prefix length of the network to which this host IPv4/IPv6 address belongs.
        :param str value: value of address
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        The prefix length of the network to which this host IPv4/IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: int):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value of address
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSubnetsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        The kind name (Default value: project.
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetSubnetsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSubnetsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str kind: The kind name (Default value: project.
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        The kind name (Default value: project.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetUserCategoryArgsDict(TypedDict):
        name: str
        """
        - (Optional) The name for the user
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetUserCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - (Optional) The name for the user
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - (Optional) The name for the user
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetUserGroupCategoryArgsDict(TypedDict):
        name: str
        """
        - the name(Optional).
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetUserGroupCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserGroupCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name(Optional).
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name(Optional).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetUserGroupsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetUserGroupsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUserGroupsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetUsersMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
elif False:
    GetUsersMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsersMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str):
        """
        :param str kind: - The kind name. (Default depends on the resource you are referencing)
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name. (Default depends on the resource you are referencing)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)


if not MYPY:
    class GetVirtualMachineCategoryArgsDict(TypedDict):
        name: str
        """
        - the name.
        """
        value: str
        """
        - value of the key.
        """
elif False:
    GetVirtualMachineCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVirtualMachineCategoryArgs:
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: - the name.
        :param str value: - value of the key.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        - the name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - value of the key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetVmRecoveryPointInfoV2DiskRecoveryPointArgsDict(TypedDict):
        disk_ext_id: str
        """
        External identifier of the disk.
        """
        disk_recovery_point_ext_id: str
        """
        External identifier of the disk recovery point.
        """
elif False:
    GetVmRecoveryPointInfoV2DiskRecoveryPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVmRecoveryPointInfoV2DiskRecoveryPointArgs:
    def __init__(__self__, *,
                 disk_ext_id: str,
                 disk_recovery_point_ext_id: str):
        """
        :param str disk_ext_id: External identifier of the disk.
        :param str disk_recovery_point_ext_id: External identifier of the disk recovery point.
        """
        pulumi.set(__self__, "disk_ext_id", disk_ext_id)
        pulumi.set(__self__, "disk_recovery_point_ext_id", disk_recovery_point_ext_id)

    @property
    @pulumi.getter(name="diskExtId")
    def disk_ext_id(self) -> str:
        """
        External identifier of the disk.
        """
        return pulumi.get(self, "disk_ext_id")

    @disk_ext_id.setter
    def disk_ext_id(self, value: str):
        pulumi.set(self, "disk_ext_id", value)

    @property
    @pulumi.getter(name="diskRecoveryPointExtId")
    def disk_recovery_point_ext_id(self) -> str:
        """
        External identifier of the disk recovery point.
        """
        return pulumi.get(self, "disk_recovery_point_ext_id")

    @disk_recovery_point_ext_id.setter
    def disk_recovery_point_ext_id(self, value: str):
        pulumi.set(self, "disk_recovery_point_ext_id", value)


if not MYPY:
    class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdArgsDict(TypedDict):
        fqdns: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict']
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        ipv4s: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict']
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        ipv6s: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict']
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
elif False:
    GetVolumeIscsiClientV2IscsiInitiatorNetworkIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdArgs:
    def __init__(__self__, *,
                 fqdns: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs'],
                 ipv4s: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args'],
                 ipv6s: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']):
        """
        :param Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs'] fqdns: - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        :param Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args'] ipv4s: - An unique address that identifies a device on the internet or a local network in IPv4 format.
        :param Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args'] ipv6s: - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        pulumi.set(__self__, "fqdns", fqdns)
        pulumi.set(__self__, "ipv4s", ipv4s)
        pulumi.set(__self__, "ipv6s", ipv6s)

    @property
    @pulumi.getter
    def fqdns(self) -> Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']:
        """
        - A fully qualified domain name that specifies its exact location in the tree hierarchy of the Domain Name System.
        """
        return pulumi.get(self, "fqdns")

    @fqdns.setter
    def fqdns(self, value: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs']):
        pulumi.set(self, "fqdns", value)

    @property
    @pulumi.getter
    def ipv4s(self) -> Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']:
        """
        - An unique address that identifies a device on the internet or a local network in IPv4 format.
        """
        return pulumi.get(self, "ipv4s")

    @ipv4s.setter
    def ipv4s(self, value: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args']):
        pulumi.set(self, "ipv4s", value)

    @property
    @pulumi.getter
    def ipv6s(self) -> Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']:
        """
        - An unique address that identifies a device on the internet or a local network in IPv6 format.
        """
        return pulumi.get(self, "ipv6s")

    @ipv6s.setter
    def ipv6s(self, value: Sequence['GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args']):
        pulumi.set(self, "ipv6s", value)


if not MYPY:
    class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict(TypedDict):
        value: str
        """
        - The fully qualified domain name.
        """
elif False:
    GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdFqdnArgs:
    def __init__(__self__, *,
                 value: str):
        """
        :param str value: - The fully qualified domain name.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - The fully qualified domain name.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict(TypedDict):
        prefix_length: int
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        value: str
        """
        - The fully qualified domain name.
        """
elif False:
    GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv4Args:
    def __init__(__self__, *,
                 prefix_length: int,
                 value: str):
        """
        :param int prefix_length: - The prefix length of the network to which this host IPv6 address belongs.
        :param str value: - The fully qualified domain name.
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: int):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - The fully qualified domain name.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict(TypedDict):
        prefix_length: int
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        value: str
        """
        - The fully qualified domain name.
        """
elif False:
    GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVolumeIscsiClientV2IscsiInitiatorNetworkIdIpv6Args:
    def __init__(__self__, *,
                 prefix_length: int,
                 value: str):
        """
        :param int prefix_length: - The prefix length of the network to which this host IPv6 address belongs.
        :param str value: - The fully qualified domain name.
        """
        pulumi.set(__self__, "prefix_length", prefix_length)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        """
        - The prefix length of the network to which this host IPv6 address belongs.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: int):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        - The fully qualified domain name.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetVpcsMetadataArgsDict(TypedDict):
        filter: str
        kind: str
        """
        - The kind name (Default value: project).
        """
        length: int
        offset: int
        sort_attribute: str
        sort_order: str
        total_matches: int
elif False:
    GetVpcsMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetVpcsMetadataArgs:
    def __init__(__self__, *,
                 filter: str,
                 kind: str,
                 length: int,
                 offset: int,
                 sort_attribute: str,
                 sort_order: str,
                 total_matches: int):
        """
        :param str kind: - The kind name (Default value: project).
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "offset", offset)
        pulumi.set(__self__, "sort_attribute", sort_attribute)
        pulumi.set(__self__, "sort_order", sort_order)
        pulumi.set(__self__, "total_matches", total_matches)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: str):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        - The kind name (Default value: project).
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: str):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: int):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def offset(self) -> int:
        return pulumi.get(self, "offset")

    @offset.setter
    def offset(self, value: int):
        pulumi.set(self, "offset", value)

    @property
    @pulumi.getter(name="sortAttribute")
    def sort_attribute(self) -> str:
        return pulumi.get(self, "sort_attribute")

    @sort_attribute.setter
    def sort_attribute(self, value: str):
        pulumi.set(self, "sort_attribute", value)

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> str:
        return pulumi.get(self, "sort_order")

    @sort_order.setter
    def sort_order(self, value: str):
        pulumi.set(self, "sort_order", value)

    @property
    @pulumi.getter(name="totalMatches")
    def total_matches(self) -> int:
        return pulumi.get(self, "total_matches")

    @total_matches.setter
    def total_matches(self, value: int):
        pulumi.set(self, "total_matches", value)


