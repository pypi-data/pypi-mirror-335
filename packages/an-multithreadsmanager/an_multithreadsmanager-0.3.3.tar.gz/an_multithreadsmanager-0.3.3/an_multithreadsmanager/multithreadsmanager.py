# -*- coding: utf-8 -*-
"""MTHM_20250321_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13ZfW1QU7ZBEXAqvEEWXO8ArnyHQlldQs

# MultiThreadsManager
ä¸¦åˆ—å‡¦ç†ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã‚¯ãƒ©ã‚¹


```
2025/03/12 0.1.0å®Œæˆã€‚mtcopyå®Ÿè£…ã€‚ä¸¦åˆ—å‡¦ç†ã§ã‚³ãƒ”ãƒ¼ã‚’ã‚¹ãƒ”ãƒ¼ãƒ‰å‡¦ç†ã™ã‚‹ã€‚
2025/03/14 0.2.0 mtcopyã§ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚‚ã‚³ãƒ”ãƒ¼ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã€‚
2025/03/20 0.3.0 mtcopy_with_symlinksã§ã€ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’å«ã‚ã¦ã‚³ãƒ”ãƒ¼ã§ãã‚‹ã‚ˆã†ã«ã—ãŸ
2025/03/20 0.3.1 ãƒŸã‚¹
2025/03/21 0.3.2 ãƒã‚°ä¿®æ­£
2025/03/22 0.3.3 ãƒã‚°ä¿®æ­£
```

# MultiThreadsManager

## 1. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©
"""

# @title a. MultiThreadsManager å®šç¾©
import os
import shutil
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper


class MultiThreadsManager:
    def __init__(self):
        """
        ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿: ã‚¹ãƒ¬ãƒƒãƒ‰æ•°ä¸Šé™ã‚’æŒ‡å®šå¯èƒ½ã€‚
        max_workersã‚’æŒ‡å®šã—ãªã„å ´åˆã€ThreadPoolExecutorã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ãŒä½¿ç”¨ã•ã‚Œã‚‹ã€‚
        """
        self.debug = DebugHelper(instance_name="MultiThreadsManager")
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()


    def mtcopy(self, src_dir: str, dst_dir: str, desc="Copying", max_workers = None):
        """
        src_dir å†…ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆå†å¸°çš„ã«æ¤œç´¢ï¼‰ã‚’ã€dst_dir ã«ä¸¦åˆ—ã‚³ãƒ”ãƒ¼ã™ã‚‹ã€‚
        ãƒ•ã‚¡ã‚¤ãƒ«ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’ä¿æŒã—ã¦ã€ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚‚å«ã‚ã¦ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
        ã‚³ãƒ”ãƒ¼ä¸­ã«å¤±æ•—ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Œã°ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚
        """
        # find ã‚³ãƒžãƒ³ãƒ‰ã§ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã‚’å–å¾—
        try:
            result = subprocess.run(
                ["find", src_dir, "-type", "f"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            file_paths = result.stdout.strip().splitlines()
        except Exception as e:
            raise RuntimeError(f"ã‚³ãƒ”ãƒ¼å…ƒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")

        total_files = len(file_paths)
        if total_files == 0:
            print("ã‚³ãƒ”ãƒ¼ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
            return

        with tqdm(total=total_files, desc=desc, unit="files") as pbar:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = []
                for f in file_paths:
                    # f ã¯çµ¶å¯¾ãƒ‘ã‚¹ã€‚src_dir ã«å¯¾ã™ã‚‹ç›¸å¯¾ãƒ‘ã‚¹ã‚’æ±‚ã‚ã‚‹
                    rel_path = os.path.relpath(f, src_dir)
                    dst_path = os.path.join(dst_dir, rel_path)
                    # ã‚³ãƒ”ãƒ¼å…ˆã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
                    os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                    if os.path.islink(f):
                        target = os.readlink(f)
                        # os.symlink ã‚’é–¢æ•°ã¨ã—ã¦æ¸¡ã—ã€target ã¨ dst_path ã‚’å¼•æ•°ã¨ã—ã¦ä¸Žãˆã‚‹
                        futures.append(executor.submit(os.symlink, target, dst_path))
                    else:
                        futures.append(executor.submit(shutil.copy2, f, dst_path))
                for future in as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        tqdm.write(f"ã‚³ãƒ”ãƒ¼å¤±æ•—: {e}")
                    finally:
                        pbar.update(1)



    def mtcopy_with_symlinks( self, src_dir, dst_dir, max_workers=None, desc="Copying"):
        """
        src_dir å†…ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†å¸°çš„ã«æ¤œç´¢ã—ã€ä¸¦åˆ—ã« dst_dir ã¸ã‚³ãƒ”ãƒ¼ã—ã¾ã™ã€‚
        ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆã€ãƒªãƒ³ã‚¯å…ˆãŒ src_dir å†…ãªã‚‰ã°ã€dst_dir å†…ã®å¯¾å¿œãƒ‘ã‚¹ã‚’æŒ‡ã™
        ç›¸å¯¾ãƒ‘ã‚¹ã®ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã¾ã™ã€‚
        """
        self.debug.log_step( "ã‚³ãƒ”ãƒ¼ã‚’é–‹å§‹ã—ã¾ã™", char = "ðŸŽ")
        src_dir = os.path.abspath(src_dir)
        dst_dir = os.path.abspath(dst_dir)

        # ã¾ãšã€src_dir å†…ã®ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«ã®çµ¶å¯¾ãƒ‘ã‚¹ã¨ã€å¯¾å¿œã™ã‚‹ dst_dir ä¸Šã®ãƒ‘ã‚¹ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
        file_list = []
        for root, dirs, files in os.walk(src_dir):
            rel_root = os.path.relpath(root, src_dir)
            dst_root = os.path.join(dst_dir, rel_root)
            # ã‚³ãƒ”ãƒ¼å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ä½œæˆ
            os.makedirs(dst_root, exist_ok=True)
            for file in files:
                src_path = os.path.join(root, file)
                dst_path = os.path.join(dst_root, file)
                file_list.append((src_path, dst_path))

        total_files = len(file_list)

        # å„ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚³ãƒ”ãƒ¼å‡¦ç†ã‚’å®šç¾©
        def process_file(src_path, dst_path):
            if os.path.islink(src_path):
                # ã‚·ãƒ³ãƒœãƒªãƒƒã‚¯ãƒªãƒ³ã‚¯ã®å ´åˆ
                link_target = os.readlink(src_path)
                # ç›¸å¯¾ãƒ‘ã‚¹ã®å ´åˆã¯çµ¶å¯¾ãƒ‘ã‚¹ã«å¤‰æ›
                if not os.path.isabs(link_target):
                    abs_link_target = os.path.abspath(os.path.join(os.path.dirname(src_path), link_target))
                else:
                    abs_link_target = link_target
                if abs_link_target.startswith(src_dir):
                    # ã‚³ãƒ”ãƒ¼å…ƒå†…ã®ãƒªãƒ³ã‚¯ãªã‚‰ã€ã‚³ãƒ”ãƒ¼å…ˆã®å¯¾å¿œãƒ‘ã‚¹ã‚’è¨ˆç®—
                    rel_target = os.path.relpath(abs_link_target, src_dir)
                    new_target = os.path.join(dst_dir, rel_target)
                    # dst_path ã®ã‚ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‹ã‚‰ new_target ã¸ã®ç›¸å¯¾ãƒ‘ã‚¹ã‚’æ±‚ã‚ã‚‹
                    new_target_rel = os.path.relpath(new_target, os.path.dirname(dst_path))
                    os.symlink(new_target_rel, dst_path)
                else:
                    # ã‚³ãƒ”ãƒ¼å…ƒå¤–ã®å ´åˆã¯ãƒªãƒ³ã‚¯å…ˆã‚’ãã®ã¾ã¾å†ç¾
                    os.symlink(link_target, dst_path)
            else:
                # é€šå¸¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã¯ã‚³ãƒ”ãƒ¼
                shutil.copy2(src_path, dst_path)

        # ä¸¦åˆ—å‡¦ç†ã§ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # futures = {executor.submit(process_file, src, dst): (src, dst) for src, dst in file_list}
            futures = {
                executor.submit(process_file, str(src), str(dst)): (str(src), str(dst))
                for src, dst in file_list
            }
            for future in tqdm(as_completed(futures), total=total_files, desc=desc, unit="files"):
                try:
                    future.result()
                except Exception as e:
                    src, dst = futures[future]
                    tqdm.write(f"Error copying {src} -> {dst}: {e}")

        self.debug.log_step( "ã‚³ãƒ”ãƒ¼ã‚’çµ‚äº†ã—ã¾ã™", char = "ðŸ´")
        return total_files

# # ä½¿ç”¨ä¾‹
# if __name__ == "__main__":
#     src_directory = "/path/to/source_dir"
#     dst_directory = "/path/to/destination_dir"
#     result_list = mtcopy_with_symlinks(src_directory, dst_directory, max_workers=8)
#     for res in result_list:
#         print(res)

"""## 2. ãƒ†ã‚¹ãƒˆ"""

# @title a. MultiThreadsManager å®Ÿè¡Œ
if __name__ == '__main__':
    import shutil
    from pathlib import Path
    from google.colab import drive
    drive.mount('/content/drive')

    get_ipython().system( "pip install an_DebugHelper" )
    from an_debughelper import DebugHelper
    get_ipython().system( "pip install an_EnvManager" )
    from an_envmanager import EnvManager
    # get_ipython().system("pip install an_MultiThreadsManager")
    # from an_multithreadsmanager import MultiThreadsManager
    class MainLoop():
        def __init__(self):
            self.debug = DebugHelper(instance_name="MainLoop")
            self.debug.enable_log_to_file_stdout()
            self.debug.enable_log_to_file_stderr()
            self.debug.enable_timestamp()

            self.envmanager = EnvManager( env_files = [ "settings_ven.env" ] )
            self.venv_name = "kohya_env"
            self.venv_folder = self.envmanager.get_env_var( "Ven_venv_folder" )
            self.venv_contents_folder = self.envmanager.get_env_var( "Ven_venv_contents_folder" )
            self.local_venv_folder = self.envmanager.get_env_var( "Ven_local_venv_folder" )

            self.venv_path = Path( self.venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )
            self.local_venv_path = Path( self.local_venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )

            self.debug.log_step( f"venv_path       :{ self.venv_path }" )
            self.debug.log_step( f"local_venv_path :{ self.local_venv_path }")

        def copy_mt(self):
            shutil.rmtree( self.local_venv_folder , ignore_errors = True )
            mtmanager = MultiThreadsManager()
            # mtmanager.mtcopy( self.venv_path, self.local_venv_path, desc = "venv")
            mtmanager.mtcopy_with_symlinks( self.venv_path, self.local_venv_path, desc = "venv", max_workers = 32)

    main = MainLoop()
    # get_ipython().system( "sudo sh -c 'sync; echo 3 > /proc/sys/vm/drop_caches'" )
    main.copy_mt()

    # shutil.rmtree( base_dst_dir, ignore_errors = True )
    # # os.makedirs( dst_dir, exist_ok = True )
    # mtmanager = MultiThreadsManager( max_workers = 16 )
    # mtmanager.mtcopy( venv_src_dir, venv_dst_dir, desc = "venv")
#    mtmanager.mtcopy( kohya_src_dir, kohya_dst_dir, desc = "kohya" )
#    shutil.rmtree( "/content/cEnv/venv/kohya_env3", ignore_errors = True )
#    os.makedirs( "/content/cEnv/venv/kohya_env3", exist_ok = True )
#    !rsync -a --info=progress2 /content/drive/MyDrive/cEnv/venv/kohya_env/ /content/cEnv/venv/kohya_env3/

# !ls -l /content/drive/MyDrive/cEnv/venv/kohya_env/contents/bin/python*