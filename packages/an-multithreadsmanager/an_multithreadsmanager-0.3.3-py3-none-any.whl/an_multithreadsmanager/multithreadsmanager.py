# -*- coding: utf-8 -*-
"""MTHM_20250321_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13ZfW1QU7ZBEXAqvEEWXO8ArnyHQlldQs

# MultiThreadsManager
並列処理をサポートするクラス


```
2025/03/12 0.1.0完成。mtcopy実装。並列処理でコピーをスピード処理する。
2025/03/14 0.2.0 mtcopyでサブフォルダもコピーできるようにした。
2025/03/20 0.3.0 mtcopy_with_symlinksで、シンボリックリンクを含めてコピーできるようにした
2025/03/20 0.3.1 ミス
2025/03/21 0.3.2 バグ修正
2025/03/22 0.3.3 バグ修正
```

# MultiThreadsManager

## 1. モジュール定義
"""

# @title a. MultiThreadsManager 定義
import os
import shutil
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper


class MultiThreadsManager:
    def __init__(self):
        """
        コンストラクタ: スレッド数上限を指定可能。
        max_workersを指定しない場合、ThreadPoolExecutorのデフォルト値が使用される。
        """
        self.debug = DebugHelper(instance_name="MultiThreadsManager")
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()


    def mtcopy(self, src_dir: str, dst_dir: str, desc="Copying", max_workers = None):
        """
        src_dir 内の全ファイル（再帰的に検索）を、dst_dir に並列コピーする。
        ファイルの相対パスを保持して、サブフォルダも含めてコピーします。
        コピー中に失敗したファイルがあればエラーメッセージを表示します。
        """
        # find コマンドでファイル一覧を取得
        try:
            result = subprocess.run(
                ["find", src_dir, "-type", "f"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            file_paths = result.stdout.strip().splitlines()
        except Exception as e:
            raise RuntimeError(f"コピー元ディレクトリのファイル一覧取得に失敗しました: {e}")

        total_files = len(file_paths)
        if total_files == 0:
            print("コピーするファイルがありません。")
            return

        with tqdm(total=total_files, desc=desc, unit="files") as pbar:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = []
                for f in file_paths:
                    # f は絶対パス。src_dir に対する相対パスを求める
                    rel_path = os.path.relpath(f, src_dir)
                    dst_path = os.path.join(dst_dir, rel_path)
                    # コピー先のディレクトリが存在しない場合は作成
                    os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                    if os.path.islink(f):
                        target = os.readlink(f)
                        # os.symlink を関数として渡し、target と dst_path を引数として与える
                        futures.append(executor.submit(os.symlink, target, dst_path))
                    else:
                        futures.append(executor.submit(shutil.copy2, f, dst_path))
                for future in as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        tqdm.write(f"コピー失敗: {e}")
                    finally:
                        pbar.update(1)



    def mtcopy_with_symlinks( self, src_dir, dst_dir, max_workers=None, desc="Copying"):
        """
        src_dir 内の全ファイルを再帰的に検索し、並列に dst_dir へコピーします。
        シンボリックリンクの場合、リンク先が src_dir 内ならば、dst_dir 内の対応パスを指す
        相対パスのシンボリックリンクを作成します。
        """
        self.debug.log_step( "コピーを開始します", char = "🐎")
        src_dir = os.path.abspath(src_dir)
        dst_dir = os.path.abspath(dst_dir)

        # まず、src_dir 内のすべてのファイルの絶対パスと、対応する dst_dir 上のパスをリストアップ
        file_list = []
        for root, dirs, files in os.walk(src_dir):
            rel_root = os.path.relpath(root, src_dir)
            dst_root = os.path.join(dst_dir, rel_root)
            # コピー先ディレクトリが存在しなければ作成
            os.makedirs(dst_root, exist_ok=True)
            for file in files:
                src_path = os.path.join(root, file)
                dst_path = os.path.join(dst_root, file)
                file_list.append((src_path, dst_path))

        total_files = len(file_list)

        # 各ファイルのコピー処理を定義
        def process_file(src_path, dst_path):
            if os.path.islink(src_path):
                # シンボリックリンクの場合
                link_target = os.readlink(src_path)
                # 相対パスの場合は絶対パスに変換
                if not os.path.isabs(link_target):
                    abs_link_target = os.path.abspath(os.path.join(os.path.dirname(src_path), link_target))
                else:
                    abs_link_target = link_target
                if abs_link_target.startswith(src_dir):
                    # コピー元内のリンクなら、コピー先の対応パスを計算
                    rel_target = os.path.relpath(abs_link_target, src_dir)
                    new_target = os.path.join(dst_dir, rel_target)
                    # dst_path のあるディレクトリから new_target への相対パスを求める
                    new_target_rel = os.path.relpath(new_target, os.path.dirname(dst_path))
                    os.symlink(new_target_rel, dst_path)
                else:
                    # コピー元外の場合はリンク先をそのまま再現
                    os.symlink(link_target, dst_path)
            else:
                # 通常ファイルの場合はコピー
                shutil.copy2(src_path, dst_path)

        # 並列処理でファイルをコピー
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # futures = {executor.submit(process_file, src, dst): (src, dst) for src, dst in file_list}
            futures = {
                executor.submit(process_file, str(src), str(dst)): (str(src), str(dst))
                for src, dst in file_list
            }
            for future in tqdm(as_completed(futures), total=total_files, desc=desc, unit="files"):
                try:
                    future.result()
                except Exception as e:
                    src, dst = futures[future]
                    tqdm.write(f"Error copying {src} -> {dst}: {e}")

        self.debug.log_step( "コピーを終了します", char = "🏴")
        return total_files

# # 使用例
# if __name__ == "__main__":
#     src_directory = "/path/to/source_dir"
#     dst_directory = "/path/to/destination_dir"
#     result_list = mtcopy_with_symlinks(src_directory, dst_directory, max_workers=8)
#     for res in result_list:
#         print(res)

"""## 2. テスト"""

# @title a. MultiThreadsManager 実行
if __name__ == '__main__':
    import shutil
    from pathlib import Path
    from google.colab import drive
    drive.mount('/content/drive')

    get_ipython().system( "pip install an_DebugHelper" )
    from an_debughelper import DebugHelper
    get_ipython().system( "pip install an_EnvManager" )
    from an_envmanager import EnvManager
    # get_ipython().system("pip install an_MultiThreadsManager")
    # from an_multithreadsmanager import MultiThreadsManager
    class MainLoop():
        def __init__(self):
            self.debug = DebugHelper(instance_name="MainLoop")
            self.debug.enable_log_to_file_stdout()
            self.debug.enable_log_to_file_stderr()
            self.debug.enable_timestamp()

            self.envmanager = EnvManager( env_files = [ "settings_ven.env" ] )
            self.venv_name = "kohya_env"
            self.venv_folder = self.envmanager.get_env_var( "Ven_venv_folder" )
            self.venv_contents_folder = self.envmanager.get_env_var( "Ven_venv_contents_folder" )
            self.local_venv_folder = self.envmanager.get_env_var( "Ven_local_venv_folder" )

            self.venv_path = Path( self.venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )
            self.local_venv_path = Path( self.local_venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )

            self.debug.log_step( f"venv_path       :{ self.venv_path }" )
            self.debug.log_step( f"local_venv_path :{ self.local_venv_path }")

        def copy_mt(self):
            shutil.rmtree( self.local_venv_folder , ignore_errors = True )
            mtmanager = MultiThreadsManager()
            # mtmanager.mtcopy( self.venv_path, self.local_venv_path, desc = "venv")
            mtmanager.mtcopy_with_symlinks( self.venv_path, self.local_venv_path, desc = "venv", max_workers = 32)

    main = MainLoop()
    # get_ipython().system( "sudo sh -c 'sync; echo 3 > /proc/sys/vm/drop_caches'" )
    main.copy_mt()

    # shutil.rmtree( base_dst_dir, ignore_errors = True )
    # # os.makedirs( dst_dir, exist_ok = True )
    # mtmanager = MultiThreadsManager( max_workers = 16 )
    # mtmanager.mtcopy( venv_src_dir, venv_dst_dir, desc = "venv")
#    mtmanager.mtcopy( kohya_src_dir, kohya_dst_dir, desc = "kohya" )
#    shutil.rmtree( "/content/cEnv/venv/kohya_env3", ignore_errors = True )
#    os.makedirs( "/content/cEnv/venv/kohya_env3", exist_ok = True )
#    !rsync -a --info=progress2 /content/drive/MyDrive/cEnv/venv/kohya_env/ /content/cEnv/venv/kohya_env3/

# !ls -l /content/drive/MyDrive/cEnv/venv/kohya_env/contents/bin/python*