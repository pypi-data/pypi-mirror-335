# -*- coding: utf-8 -*-
"""MTHM_20250320_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rwB9i0V5WZPBtyUUWDn8BAx8OW0R-1Y1

# MultiThreadsManager
並列処理をサポートするクラス


```
2025/03/12 0.1.0完成。mtcopy実装。並列処理でコピーをスピード処理する。
2025/03/14 0.2.0 mtcopyでサブフォルダもコピーできるようにした。
2025/03/20 0.3.0 mtcopy_with_symlinksで、シンボリックリンクを含めてコピーできるようにした
2025/03/21 0.3.1 ミス
```

# MultiThreadsManager

## 1. モジュール定義
"""

# @title a. MultiThreadsManager 定義
import os
import shutil
import subprocess
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

class MultiThreadsManager:
    def __init__(self, max_workers=None):
        """
        コンストラクタ: スレッド数上限を指定可能。
        max_workersを指定しない場合、ThreadPoolExecutorのデフォルト値が使用される。
        """
        self.max_workers = max_workers

    def mtcopy(self, src_dir: str, dst_dir: str, desc="Copying"):
        """
        src_dir 内の全ファイル（再帰的に検索）を、dst_dir に並列コピーする。
        ファイルの相対パスを保持して、サブフォルダも含めてコピーします。
        コピー中に失敗したファイルがあればエラーメッセージを表示します。
        """
        # find コマンドでファイル一覧を取得
        try:
            result = subprocess.run(
                ["find", src_dir, "-type", "f"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=True,
            )
            file_paths = result.stdout.strip().splitlines()
        except Exception as e:
            raise RuntimeError(f"コピー元ディレクトリのファイル一覧取得に失敗しました: {e}")

        total_files = len(file_paths)
        if total_files == 0:
            print("コピーするファイルがありません。")
            return

        with tqdm(total=total_files, desc=desc, unit="files") as pbar:
            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                futures = []
                for f in file_paths:
                    # f は絶対パス。src_dir に対する相対パスを求める
                    rel_path = os.path.relpath(f, src_dir)
                    dst_path = os.path.join(dst_dir, rel_path)
                    # コピー先のディレクトリが存在しない場合は作成
                    os.makedirs(os.path.dirname(dst_path), exist_ok=True)
                    if os.path.islink(f):
                        target = os.readlink(f)
                        # os.symlink を関数として渡し、target と dst_path を引数として与える
                        futures.append(executor.submit(os.symlink, target, dst_path))
                    else:
                        futures.append(executor.submit(shutil.copy2, f, dst_path))
                for future in as_completed(futures):
                    try:
                        future.result()
                    except Exception as e:
                        tqdm.write(f"コピー失敗: {e}")
                    finally:
                        pbar.update(1)


    def mtcopy_with_symlinks( self, src_dir, dst_dir, desc, max_workers=None ):
        """
        src_dir 内の全ファイルとシンボリックリンクを、dst_dir に並列コピーします。
        シンボリックリンクの場合は、リンク先を再現します。
        """
        src_dir = Path(src_dir)
        dst_dir = Path(dst_dir)
        dst_dir.mkdir(parents=True, exist_ok=True)

        # src_dir 内の全エントリ（ファイル・ディレクトリ・シンボリックリンク）を再帰的に取得
        all_items = list(src_dir.rglob("*"))
        total_items = len(all_items)

        def copy_item(item):
            rel_path = item.relative_to(src_dir)
            dst_item = dst_dir.joinpath(rel_path)
            if item.is_dir():
                dst_item.mkdir(parents=True, exist_ok=True)
                return f"Directory created: {dst_item}"
            if item.is_symlink():
                target = os.readlink(item)
                # 相対パスの場合、コピー先に合わせて再計算
                if not os.path.isabs(target):
                    absolute_target = (item.parent / target).resolve()
                    new_target = os.path.relpath(absolute_target, dst_item.parent)
                else:
                    new_target = target
                os.symlink(new_target, dst_item)
                return f"Symlink created: {dst_item} -> {new_target}"
            else:
                dst_item.parent.mkdir(parents=True, exist_ok=True)
                shutil.copy2(item, dst_item)
                return f"File copied: {dst_item}"

        results = []
        with tqdm(total=total_items, desc=desc, unit="item") as pbar:
            with ThreadPoolExecutor(max_workers=max_workers) as executor:
                futures = {executor.submit(copy_item, item): item for item in all_items}
                for future in as_completed(futures):
                    try:
                        result = future.result()
                        results.append(result)
                    except Exception as e:
                        results.append(f"Error copying {futures[future]}: {e}")
                    pbar.update(1)

        return results

# # 使用例
# if __name__ == "__main__":
#     src_directory = "/path/to/source_dir"
#     dst_directory = "/path/to/destination_dir"
#     result_list = mtcopy_with_symlinks(src_directory, dst_directory, max_workers=8)
#     for res in result_list:
#         print(res)

"""## 2. テスト"""

# @title a. MultiThreadsManager 実行
import shutil
from pathlib import Path
from google.colab import drive
drive.mount('/content/drive')

get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper
get_ipython().system( "pip install an_EnvManager" )
from an_envmanager import EnvManager

class MainLoop():
    def __init__(self):
        self.debug = DebugHelper(instance_name="MainLoop")
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        self.envmanager = EnvManager( env_files = [ "settings_ven.env" ] )
        self.venv_name = "kohya_env"
        self.venv_folder = self.envmanager.get_env_var( "Ven_venv_folder" )
        self.venv_contents_folder = self.envmanager.get_env_var( "Ven_venv_contents_folder" )
        self.local_venv_folder = self.envmanager.get_env_var( "Ven_local_venv_folder" )

        self.venv_path = Path( self.venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )
        self.local_venv_path = Path( self.local_venv_folder ).joinpath( self.venv_name, self.venv_contents_folder )

        self.debug.log_step( f"venv_path       :{ self.venv_path }" )
        self.debug.log_step( f"local_venv_path :{ self.local_venv_path }")

    def copy_mt(self):
        shutil.rmtree( self.local_venv_folder , ignore_errors = True )
        mtmanager = MultiThreadsManager( max_workers = 32 )
        # mtmanager.mtcopy( self.venv_path, self.local_venv_path, desc = "venv")
        mtmanager.mtcopy_with_symlinks( self.venv_path, self.local_venv_path, desc = "venv")

if __name__ == '__main__':
    main = MainLoop()
    get_ipython().system( "sudo sh -c 'sync; echo 3 > /proc/sys/vm/drop_caches'" )
    main.copy_mt()

    # shutil.rmtree( base_dst_dir, ignore_errors = True )
    # # os.makedirs( dst_dir, exist_ok = True )
    # mtmanager = MultiThreadsManager( max_workers = 16 )
    # mtmanager.mtcopy( venv_src_dir, venv_dst_dir, desc = "venv")
#    mtmanager.mtcopy( kohya_src_dir, kohya_dst_dir, desc = "kohya" )
#    shutil.rmtree( "/content/cEnv/venv/kohya_env3", ignore_errors = True )
#    os.makedirs( "/content/cEnv/venv/kohya_env3", exist_ok = True )
#    !rsync -a --info=progress2 /content/drive/MyDrive/cEnv/venv/kohya_env/ /content/cEnv/venv/kohya_env3/

# !ls -l /content/drive/MyDrive/cEnv/venv/kohya_env/contents/bin/python*