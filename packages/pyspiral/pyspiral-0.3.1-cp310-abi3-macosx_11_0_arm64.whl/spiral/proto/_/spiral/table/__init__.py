# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: spiral/table/common.proto, spiral/table/metadata.proto, spiral/table/statistics.proto, spiral/table/wal.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    List,
    Optional,
)

import betterproto


class FileFormat(betterproto.Enum):
    UNSPECIFIED = 0
    PARQUET = 1
    PROTOBUF = 2
    BINARY_ARRAY = 3
    VORTEX = 4


class Level(betterproto.Enum):
    UNSPECIFIED = 0
    L0 = 1
    L1 = 2


@dataclass(eq=False, repr=False)
class ApproximateSetMembership(betterproto.Message):
    bloom_filter: "BloomFilter" = betterproto.message_field(
        2, group="membership_strategy"
    )


@dataclass(eq=False, repr=False)
class BloomFilter(betterproto.Message):
    bit_vec: bytes = betterproto.bytes_field(1)
    bitmap_bits: int = betterproto.uint64_field(2)
    k_num: int = betterproto.uint32_field(3)


@dataclass(eq=False, repr=False)
class Schema(betterproto.Message):
    arrow: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ColumnGroup(betterproto.Message):
    parts: List[str] = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class KeySpan(betterproto.Message):
    """/ Span of keys defined as indices into a key space (exclusive end)."""

    begin: int = betterproto.uint64_field(1)
    end: int = betterproto.uint64_field(2)


@dataclass(eq=False, repr=False)
class KeyExtent(betterproto.Message):
    """/ Extent of keys in terms of min and max (an inclusive range)."""

    min: bytes = betterproto.bytes_field(1)
    max: bytes = betterproto.bytes_field(2)


@dataclass(eq=False, repr=False)
class KeyMap(betterproto.Message):
    """/ Displacement map."""

    bitmap: bytes = betterproto.bytes_field(1)


@dataclass(eq=False, repr=False)
class ManifestHandle(betterproto.Message):
    """
    / Handle to a manifest file, with additional metadata to accelerate reads.
    """

    id: str = betterproto.string_field(1)
    format: "FileFormat" = betterproto.enum_field(2)
    file_size: int = betterproto.uint64_field(3)
    spfs_format_metadata: Optional[bytes] = betterproto.bytes_field(4, optional=True)


@dataclass(eq=False, repr=False)
class VersionedSchema(betterproto.Message):
    """/ Timestamped schema."""

    ts: int = betterproto.uint64_field(1)
    schema: "Schema" = betterproto.message_field(2)
    column_ids: List[str] = betterproto.string_field(3)
    """
    List of column IDs, in the same order as columns in the schema.
     Must have the same length as the number of columns in the schema.
    """


@dataclass(eq=False, repr=False)
class WriteAheadLog(betterproto.Message):
    """
    / Table's Write Ahead Log stores sequence of operations and table metadata.
    """

    entries: List["LogEntry"] = betterproto.message_field(1)
    truncated_up_to: int = betterproto.uint64_field(3)
    """
    Timestamp of the latest entry that has been removed from the log.
     Entries with ts <= truncated_up_to are NOT present in the log.
    """

    ks_manifest_handle: Optional["ManifestHandle"] = betterproto.message_field(
        2, optional=True
    )
    """An absent manifest means that one has not yet been written."""


@dataclass(eq=False, repr=False)
class LogEntry(betterproto.Message):
    ts: int = betterproto.uint64_field(1)
    key_space_write: "KeySpaceWriteOp" = betterproto.message_field(2, group="operation")
    fragment_set_write: "FragmentSetWriteOp" = betterproto.message_field(
        3, group="operation"
    )
    configuration: "ConfigurationOp" = betterproto.message_field(4, group="operation")
    schema_evolution: "SchemaEvolutionOp" = betterproto.message_field(
        5, group="operation"
    )
    schema_break: "SchemaBreakOp" = betterproto.message_field(6, group="operation")
    compact_key_space: "CompactKeySpaceOp" = betterproto.message_field(
        7, group="operation"
    )
    compact_column_group: "CompactColumnGroupOp" = betterproto.message_field(
        8, group="operation"
    )


@dataclass(eq=False, repr=False)
class KeySpaceWriteOp(betterproto.Message):
    ks_id: str = betterproto.string_field(1)
    manifest_handle: "ManifestHandle" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class FragmentSetWriteOp(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    fs_id: str = betterproto.string_field(2)
    fs_level: "Level" = betterproto.enum_field(3)
    manifest_handle: "ManifestHandle" = betterproto.message_field(4)
    key_span: "KeySpan" = betterproto.message_field(5)
    key_extent: "KeyExtent" = betterproto.message_field(6)
    column_ids: List[str] = betterproto.string_field(7)
    data_ts: Optional[int] = betterproto.uint64_field(8, optional=True)
    """
    Timestamp of the data in the fragments.
     Used as committed_ts for files in the manifest.
     If not present, timestamp of the operation is used.
    """


@dataclass(eq=False, repr=False)
class ConfigurationOp(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    immutable_schema: Optional[bool] = betterproto.bool_field(2, optional=True)
    """All column group configuration is stored in column group metadata."""


@dataclass(eq=False, repr=False)
class SchemaEvolutionOp(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    new_schema: "VersionedSchema" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class SchemaBreakOp(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    removed_column_names: List[str] = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class CompactKeySpaceOp(betterproto.Message):
    results: List["CompactKeySpaceResult"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class CompactKeySpaceResult(betterproto.Message):
    """
    TODO(marko): Do we really need to know all of this? UpdateKeySpaceOp?
    """

    ks_id: str = betterproto.string_field(1)
    compacted: "CompactKeySpaceResultCompacted" = betterproto.message_field(
        2, group="action"
    )
    """Key space has been compacted."""

    created: "CompactKeySpaceResultCreated" = betterproto.message_field(
        3, group="action"
    )
    """New output key space has been created."""

    moved: "CompactKeySpaceResultMoved" = betterproto.message_field(4, group="action")
    """Key space has been promoted to L1."""

    extended: "CompactKeySpaceResultExtended" = betterproto.message_field(
        5, group="action"
    )
    """Key space has been extended with new key files."""


@dataclass(eq=False, repr=False)
class CompactKeySpaceResultCompacted(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CompactKeySpaceResultCreated(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CompactKeySpaceResultMoved(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CompactKeySpaceResultExtended(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CompactColumnGroupOp(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    from_fragment_ids: List[str] = betterproto.string_field(2)
    """
    NOTE: While key space compaction always compacts a full key space,
     column group compaction can compact only a subset of the fragment set,
     therefore the event specifies the fragment ids.
    """

    into_fs_ids: List[str] = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class ColumnGroupMetadata(betterproto.Message):
    column_group: "ColumnGroup" = betterproto.message_field(1)
    manifest_handle: Optional["ManifestHandle"] = betterproto.message_field(
        2, optional=True
    )
    """An absent manifest means that one has not yet been written."""

    last_modified_at: int = betterproto.uint64_field(3)
    """Timestamp of the last WAL entry that modified this metadata."""

    schema_versions: List["VersionedSchema"] = betterproto.message_field(4)
    """
    TODO(marko): Add config that truncates this list and breaks time travel.
     Versions of the schema. Higher index is more recent, last element is latest
     schema. Stored to support time travel through the schema, e.g. reading
     deleted column.
    """

    immutable_schema: bool = betterproto.bool_field(5)
    """
    True if schema can NOT be evolved on write.
     An explicit schema evolution is required.
    """

    schema_salt: int = betterproto.int32_field(6)
    """
    Schema salt is used to compute column IDs. It is modified on breaking
     change, e.g. column deletion. This ensures that if the previously existing
     column is added again, it will have a different ID.
    """
